#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Path/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PATH_TINY';
  use 5.008001;
  use strict;
  use warnings;
  
  package Path::Tiny;
  # ABSTRACT: File path utility
  
  our $VERSION = '0.124';
  
  # Dependencies
  use Config;
  use Exporter 5.57   (qw/import/);
  use File::Spec 0.86 ();          # shipped with 5.8.1
  use Carp ();
  
  our @EXPORT    = qw/path/;
  our @EXPORT_OK = qw/cwd rootdir tempfile tempdir/;
  
  use constant {
      PATH     => 0,
      CANON    => 1,
      VOL      => 2,
      DIR      => 3,
      FILE     => 4,
      TEMP     => 5,
      IS_WIN32 => ( $^O eq 'MSWin32' ),
  };
  
  use overload (
      q{""}    => sub    { $_[0]->[PATH] },
      bool     => sub () { 1 },
      fallback => 1,
  );
  
  # FREEZE/THAW per Sereal/CBOR/Types::Serialiser protocol
  sub FREEZE { return $_[0]->[PATH] }
  sub THAW   { return path( $_[2] ) }
  { no warnings 'once'; *TO_JSON = *FREEZE };
  
  my $HAS_UU; # has Unicode::UTF8; lazily populated
  
  sub _check_UU {
      local $SIG{__DIE__}; # prevent outer handler from being called
      !!eval {
          require Unicode::UTF8;
          Unicode::UTF8->VERSION(0.58);
          1;
      };
  }
  
  my $HAS_PU;              # has PerlIO::utf8_strict; lazily populated
  
  sub _check_PU {
      local $SIG{__DIE__}; # prevent outer handler from being called
      !!eval {
          # MUST preload Encode or $SIG{__DIE__} localization fails
          # on some Perl 5.8.8 (maybe other 5.8.*) compiled with -O2.
          require Encode;
          require PerlIO::utf8_strict;
          PerlIO::utf8_strict->VERSION(0.003);
          1;
      };
  }
  
  my $HAS_FLOCK = $Config{d_flock} || $Config{d_fcntl_can_lock} || $Config{d_lockf};
  
  # notions of "root" directories differ on Win32: \\server\dir\ or C:\ or \
  my $SLASH      = qr{[\\/]};
  my $NOTSLASH   = qr{[^\\/]};
  my $DRV_VOL    = qr{[a-z]:}i;
  my $UNC_VOL    = qr{$SLASH $SLASH $NOTSLASH+ $SLASH $NOTSLASH+}x;
  my $WIN32_ROOT = qr{(?: $UNC_VOL $SLASH | $DRV_VOL $SLASH | $SLASH )}x;
  
  sub _win32_vol {
      my ( $path, $drv ) = @_;
      require Cwd;
      my $dcwd = eval { Cwd::getdcwd($drv) }; # C: -> C:\some\cwd
      # getdcwd on non-existent drive returns empty string
      # so just use the original drive Z: -> Z:
      $dcwd = "$drv" unless defined $dcwd && length $dcwd;
      # normalize dwcd to end with a slash: might be C:\some\cwd or D:\ or Z:
      $dcwd =~ s{$SLASH?\z}{/};
      # make the path absolute with dcwd
      $path =~ s{^$DRV_VOL}{$dcwd};
      return $path;
  }
  
  # This is a string test for before we have the object; see is_rootdir for well-formed
  # object test
  sub _is_root {
      return IS_WIN32() ? ( $_[0] =~ /^$WIN32_ROOT\z/ ) : ( $_[0] eq '/' );
  }
  
  BEGIN {
      *_same = IS_WIN32() ? sub { lc( $_[0] ) eq lc( $_[1] ) } : sub { $_[0] eq $_[1] };
  }
  
  # mode bits encoded for chmod in symbolic mode
  my %MODEBITS = ( om => 0007, gm => 0070, um => 0700 ); ## no critic
  { my $m = 0; $MODEBITS{$_} = ( 1 << $m++ ) for qw/ox ow or gx gw gr ux uw ur/ };
  
  sub _symbolic_chmod {
      my ( $mode, $symbolic ) = @_;
      for my $clause ( split /,\s*/, $symbolic ) {
          if ( $clause =~ m{\A([augo]+)([=+-])([rwx]+)\z} ) {
              my ( $who, $action, $perms ) = ( $1, $2, $3 );
              $who =~ s/a/ugo/g;
              for my $w ( split //, $who ) {
                  my $p = 0;
                  $p |= $MODEBITS{"$w$_"} for split //, $perms;
                  if ( $action eq '=' ) {
                      $mode = ( $mode & ~$MODEBITS{"${w}m"} ) | $p;
                  }
                  else {
                      $mode = $action eq "+" ? ( $mode | $p ) : ( $mode & ~$p );
                  }
              }
          }
          else {
              Carp::croak("Invalid mode clause '$clause' for chmod()");
          }
      }
      return $mode;
  }
  
  # flock doesn't work on NFS on BSD or on some filesystems like lustre.
  # Since program authors often can't control or detect that, we warn once
  # instead of being fatal if we can detect it and people who need it strict
  # can fatalize the 'flock' category
  
  #<<< No perltidy
  { package flock; use warnings::register }
  #>>>
  
  my $WARNED_NO_FLOCK = 0;
  
  sub _throw {
      my ( $self, $function, $file, $msg ) = @_;
      if (   $function =~ /^flock/
          && $! =~ /operation not supported|function not implemented/i
          && !warnings::fatal_enabled('flock') )
      {
          if ( !$WARNED_NO_FLOCK ) {
              warnings::warn( flock => "Flock not available: '$!': continuing in unsafe mode" );
              $WARNED_NO_FLOCK++;
          }
      }
      else {
          $msg = $! unless defined $msg;
          Path::Tiny::Error->throw( $function, ( defined $file ? $file : $self->[PATH] ),
              $msg );
      }
      return;
  }
  
  # cheapo option validation
  sub _get_args {
      my ( $raw, @valid ) = @_;
      if ( defined($raw) && ref($raw) ne 'HASH' ) {
          my ( undef, undef, undef, $called_as ) = caller(1);
          $called_as =~ s{^.*::}{};
          Carp::croak("Options for $called_as must be a hash reference");
      }
      my $cooked = {};
      for my $k (@valid) {
          $cooked->{$k} = delete $raw->{$k} if exists $raw->{$k};
      }
      if ( keys %$raw ) {
          my ( undef, undef, undef, $called_as ) = caller(1);
          $called_as =~ s{^.*::}{};
          Carp::croak( "Invalid option(s) for $called_as: " . join( ", ", keys %$raw ) );
      }
      return $cooked;
  }
  
  #--------------------------------------------------------------------------#
  # Constructors
  #--------------------------------------------------------------------------#
  
  #pod =construct path
  #pod
  #pod     $path = path("foo/bar");
  #pod     $path = path("/tmp", "file.txt"); # list
  #pod     $path = path(".");                # cwd
  #pod     $path = path("~user/file.txt");   # tilde processing
  #pod
  #pod Constructs a C<Path::Tiny> object.  It doesn't matter if you give a file or
  #pod directory path.  It's still up to you to call directory-like methods only on
  #pod directories and file-like methods only on files.  This function is exported
  #pod automatically by default.
  #pod
  #pod The first argument must be defined and have non-zero length or an exception
  #pod will be thrown.  This prevents subtle, dangerous errors with code like
  #pod C<< path( maybe_undef() )->remove_tree >>.
  #pod
  #pod If the first component of the path is a tilde ('~') then the component will be
  #pod replaced with the output of C<glob('~')>.  If the first component of the path
  #pod is a tilde followed by a user name then the component will be replaced with
  #pod output of C<glob('~username')>.  Behaviour for non-existent users depends on
  #pod the output of C<glob> on the system.
  #pod
  #pod On Windows, if the path consists of a drive identifier without a path component
  #pod (C<C:> or C<D:>), it will be expanded to the absolute path of the current
  #pod directory on that volume using C<Cwd::getdcwd()>.
  #pod
  #pod If called with a single C<Path::Tiny> argument, the original is returned unless
  #pod the original is holding a temporary file or directory reference in which case a
  #pod stringified copy is made.
  #pod
  #pod     $path = path("foo/bar");
  #pod     $temp = Path::Tiny->tempfile;
  #pod
  #pod     $p2 = path($path); # like $p2 = $path
  #pod     $t2 = path($temp); # like $t2 = path( "$temp" )
  #pod
  #pod This optimizes copies without proliferating references unexpectedly if a copy is
  #pod made by code outside your control.
  #pod
  #pod Current API available since 0.017.
  #pod
  #pod =cut
  
  sub path {
      my $path = shift;
      Carp::croak("Path::Tiny paths require defined, positive-length parts")
        unless 1 + @_ == grep { defined && length } $path, @_;
  
      # non-temp Path::Tiny objects are effectively immutable and can be reused
      if ( !@_ && ref($path) eq __PACKAGE__ && !$path->[TEMP] ) {
          return $path;
      }
  
      # stringify objects
      $path = "$path";
  
      # expand relative volume paths on windows; put trailing slash on UNC root
      if ( IS_WIN32() ) {
          $path = _win32_vol( $path, $1 ) if $path =~ m{^($DRV_VOL)(?:$NOTSLASH|\z)};
          $path .= "/" if $path =~ m{^$UNC_VOL\z};
      }
  
      # concatenations stringifies objects, too
      if (@_) {
          $path .= ( _is_root($path) ? "" : "/" ) . join( "/", @_ );
      }
  
      # canonicalize, but with unix slashes and put back trailing volume slash
      my $cpath = $path = File::Spec->canonpath($path);
      $path =~ tr[\\][/] if IS_WIN32();
      $path = "/" if $path eq '/..'; # for old File::Spec
      $path .= "/" if IS_WIN32() && $path =~ m{^$UNC_VOL\z};
  
      # root paths must always have a trailing slash, but other paths must not
      if ( _is_root($path) ) {
          $path =~ s{/?\z}{/};
      }
      else {
          $path =~ s{/\z}{};
      }
  
      # do any tilde expansions
      if ( $path =~ m{^(~[^/]*).*} ) {
          require File::Glob;
          my ($homedir) = File::Glob::bsd_glob($1);
          $homedir =~ tr[\\][/] if IS_WIN32();
          $path =~ s{^(~[^/]*)}{$homedir};
      }
  
      bless [ $path, $cpath ], __PACKAGE__;
  }
  
  #pod =construct new
  #pod
  #pod     $path = Path::Tiny->new("foo/bar");
  #pod
  #pod This is just like C<path>, but with method call overhead.  (Why would you
  #pod do that?)
  #pod
  #pod Current API available since 0.001.
  #pod
  #pod =cut
  
  sub new { shift; path(@_) }
  
  #pod =construct cwd
  #pod
  #pod     $path = Path::Tiny->cwd; # path( Cwd::getcwd )
  #pod     $path = cwd; # optional export
  #pod
  #pod Gives you the absolute path to the current directory as a C<Path::Tiny> object.
  #pod This is slightly faster than C<< path(".")->absolute >>.
  #pod
  #pod C<cwd> may be exported on request and used as a function instead of as a
  #pod method.
  #pod
  #pod Current API available since 0.018.
  #pod
  #pod =cut
  
  sub cwd {
      require Cwd;
      return path( Cwd::getcwd() );
  }
  
  #pod =construct rootdir
  #pod
  #pod     $path = Path::Tiny->rootdir; # /
  #pod     $path = rootdir;             # optional export 
  #pod
  #pod Gives you C<< File::Spec->rootdir >> as a C<Path::Tiny> object if you're too
  #pod picky for C<path("/")>.
  #pod
  #pod C<rootdir> may be exported on request and used as a function instead of as a
  #pod method.
  #pod
  #pod Current API available since 0.018.
  #pod
  #pod =cut
  
  sub rootdir { path( File::Spec->rootdir ) }
  
  #pod =construct tempfile, tempdir
  #pod
  #pod     $temp = Path::Tiny->tempfile( @options );
  #pod     $temp = Path::Tiny->tempdir( @options );
  #pod     $temp = $dirpath->tempfile( @options );
  #pod     $temp = $dirpath->tempdir( @options );
  #pod     $temp = tempfile( @options ); # optional export
  #pod     $temp = tempdir( @options );  # optional export
  #pod
  #pod C<tempfile> passes the options to C<< File::Temp->new >> and returns a C<Path::Tiny>
  #pod object with the file name.  The C<TMPDIR> option is enabled by default.
  #pod
  #pod The resulting C<File::Temp> object is cached. When the C<Path::Tiny> object is
  #pod destroyed, the C<File::Temp> object will be as well.
  #pod
  #pod C<File::Temp> annoyingly requires you to specify a custom template in slightly
  #pod different ways depending on which function or method you call, but
  #pod C<Path::Tiny> lets you ignore that and can take either a leading template or a
  #pod C<TEMPLATE> option and does the right thing.
  #pod
  #pod     $temp = Path::Tiny->tempfile( "customXXXXXXXX" );             # ok
  #pod     $temp = Path::Tiny->tempfile( TEMPLATE => "customXXXXXXXX" ); # ok
  #pod
  #pod The tempfile path object will be normalized to have an absolute path, even if
  #pod created in a relative directory using C<DIR>.  If you want it to have
  #pod the C<realpath> instead, pass a leading options hash like this:
  #pod
  #pod     $real_temp = tempfile({realpath => 1}, @options);
  #pod
  #pod C<tempdir> is just like C<tempfile>, except it calls
  #pod C<< File::Temp->newdir >> instead.
  #pod
  #pod Both C<tempfile> and C<tempdir> may be exported on request and used as
  #pod functions instead of as methods.
  #pod
  #pod The methods can be called on an instances representing a
  #pod directory. In this case, the directory is used as the base to create the
  #pod temporary file/directory, setting the C<DIR> option in File::Temp.
  #pod
  #pod     my $target_dir = path('/to/destination');
  #pod     my $tempfile = $target_dir->tempfile('foobarXXXXXX');
  #pod     $tempfile->spew('A lot of data...');  # not atomic
  #pod     $tempfile->move($target_dir->child('foobar')); # hopefully atomic
  #pod
  #pod In this case, any value set for option C<DIR> is ignored.
  #pod
  #pod B<Note>: for tempfiles, the filehandles from File::Temp are closed and not
  #pod reused.  This is not as secure as using File::Temp handles directly, but is
  #pod less prone to deadlocks or access problems on some platforms.  Think of what
  #pod C<Path::Tiny> gives you to be just a temporary file B<name> that gets cleaned
  #pod up.
  #pod
  #pod B<Note 2>: if you don't want these cleaned up automatically when the object
  #pod is destroyed, File::Temp requires different options for directories and
  #pod files.  Use C<< CLEANUP => 0 >> for directories and C<< UNLINK => 0 >> for
  #pod files.
  #pod
  #pod B<Note 3>: Don't lose the temporary object by chaining a method call instead
  #pod of storing it:
  #pod
  #pod     my $lost = tempdir()->child("foo"); # tempdir cleaned up right away
  #pod
  #pod B<Note 4>: The cached object may be accessed with the L</cached_temp> method.
  #pod Keeping a reference to, or modifying the cached object may break the
  #pod behavior documented above and is not supported.  Use at your own risk.
  #pod
  #pod Current API available since 0.119.
  #pod
  #pod =cut
  
  sub tempfile {
      my ( $opts, $maybe_template, $args )
          = _parse_file_temp_args(tempfile => @_);
  
      # File::Temp->new demands TEMPLATE
      $args->{TEMPLATE} = $maybe_template->[0] if @$maybe_template;
  
      require File::Temp;
      my $temp = File::Temp->new( TMPDIR => 1, %$args );
      close $temp;
      my $self = $opts->{realpath} ? path($temp)->realpath : path($temp)->absolute;
      $self->[TEMP] = $temp;                # keep object alive while we are
      return $self;
  }
  
  sub tempdir {
      my ( $opts, $maybe_template, $args )
          = _parse_file_temp_args(tempdir => @_);
  
      require File::Temp;
      my $temp = File::Temp->newdir( @$maybe_template, TMPDIR => 1, %$args );
      my $self = $opts->{realpath} ? path($temp)->realpath : path($temp)->absolute;
      $self->[TEMP] = $temp;                # keep object alive while we are
      # Some ActiveState Perls for Windows break Cwd in ways that lead
      # File::Temp to get confused about what path to remove; this
      # monkey-patches the object with our own view of the absolute path
      $temp->{REALNAME} = $self->[CANON] if IS_WIN32;
      return $self;
  }
  
  # normalize the various ways File::Temp does templates
  sub _parse_file_temp_args {
      my $called_as = shift;
      if ( @_ && $_[0] eq 'Path::Tiny' ) { shift } # class method
      elsif ( @_ && eval{$_[0]->isa('Path::Tiny')} ) {
          my $dir = shift;
          if (! $dir->is_dir) {
              $dir->_throw( $called_as, $dir, "is not a directory object" );
          }
          push @_, DIR => $dir->stringify; # no overriding
      }
      my $opts = ( @_ && ref $_[0] eq 'HASH' ) ? shift @_ : {};
      $opts = _get_args( $opts, qw/realpath/ );
  
      my $leading_template = ( scalar(@_) % 2 == 1 ? shift(@_) : '' );
      my %args = @_;
      %args = map { uc($_), $args{$_} } keys %args;
      my @template = (
            exists $args{TEMPLATE} ? delete $args{TEMPLATE}
          : $leading_template      ? $leading_template
          :                          ()
      );
  
      return ( $opts, \@template, \%args );
  }
  
  #--------------------------------------------------------------------------#
  # Private methods
  #--------------------------------------------------------------------------#
  
  sub _splitpath {
      my ($self) = @_;
      @{$self}[ VOL, DIR, FILE ] = File::Spec->splitpath( $self->[PATH] );
  }
  
  sub _resolve_symlinks {
      my ($self) = @_;
      my $new = $self;
      my ( $count, %seen ) = 0;
      while ( -l $new->[PATH] ) {
          if ( $seen{ $new->[PATH] }++ ) {
              $self->_throw( 'readlink', $self->[PATH], "symlink loop detected" );
          }
          if ( ++$count > 100 ) {
              $self->_throw( 'readlink', $self->[PATH], "maximum symlink depth exceeded" );
          }
          my $resolved = readlink $new->[PATH] or $new->_throw( 'readlink', $new->[PATH] );
          $resolved = path($resolved);
          $new = $resolved->is_absolute ? $resolved : $new->sibling($resolved);
      }
      return $new;
  }
  
  #--------------------------------------------------------------------------#
  # Public methods
  #--------------------------------------------------------------------------#
  
  #pod =method absolute
  #pod
  #pod     $abs = path("foo/bar")->absolute;
  #pod     $abs = path("foo/bar")->absolute("/tmp");
  #pod
  #pod Returns a new C<Path::Tiny> object with an absolute path (or itself if already
  #pod absolute).  If no argument is given, the current directory is used as the
  #pod absolute base path.  If an argument is given, it will be converted to an
  #pod absolute path (if it is not already) and used as the absolute base path.
  #pod
  #pod This will not resolve upward directories ("foo/../bar") unless C<canonpath>
  #pod in L<File::Spec> would normally do so on your platform.  If you need them
  #pod resolved, you must call the more expensive C<realpath> method instead.
  #pod
  #pod On Windows, an absolute path without a volume component will have it added
  #pod based on the current drive.
  #pod
  #pod Current API available since 0.101.
  #pod
  #pod =cut
  
  sub absolute {
      my ( $self, $base ) = @_;
  
      # absolute paths handled differently by OS
      if (IS_WIN32) {
          return $self if length $self->volume;
          # add missing volume
          if ( $self->is_absolute ) {
              require Cwd;
              # use Win32::GetCwd not Cwd::getdcwd because we're sure
              # to have the former but not necessarily the latter
              my ($drv) = Win32::GetCwd() =~ /^($DRV_VOL | $UNC_VOL)/x;
              return path( $drv . $self->[PATH] );
          }
      }
      else {
          return $self if $self->is_absolute;
      }
  
      # no base means use current directory as base
      require Cwd;
      return path( Cwd::getcwd(), $_[0]->[PATH] ) unless defined $base;
  
      # relative base should be made absolute; we check is_absolute rather
      # than unconditionally make base absolute so that "/foo" doesn't become
      # "C:/foo" on Windows.
      $base = path($base);
      return path( ( $base->is_absolute ? $base : $base->absolute ), $_[0]->[PATH] );
  }
  
  #pod =method append, append_raw, append_utf8
  #pod
  #pod     path("foo.txt")->append(@data);
  #pod     path("foo.txt")->append(\@data);
  #pod     path("foo.txt")->append({binmode => ":raw"}, @data);
  #pod     path("foo.txt")->append_raw(@data);
  #pod     path("foo.txt")->append_utf8(@data);
  #pod
  #pod Appends data to a file.  The file is locked with C<flock> prior to writing
  #pod and closed afterwards.  An optional hash reference may be used to pass
  #pod options.  Valid options are:
  #pod
  #pod =for :list
  #pod * C<binmode>: passed to C<binmode()> on the handle used for writing.
  #pod * C<truncate>: truncates the file after locking and before appending
  #pod
  #pod The C<truncate> option is a way to replace the contents of a file
  #pod B<in place>, unlike L</spew> which writes to a temporary file and then
  #pod replaces the original (if it exists).
  #pod
  #pod C<append_raw> is like C<append> with a C<binmode> of C<:unix> for fast,
  #pod unbuffered, raw write.
  #pod
  #pod C<append_utf8> is like C<append> with a C<binmode> of
  #pod C<:unix:encoding(UTF-8)> (or L<PerlIO::utf8_strict>).  If L<Unicode::UTF8>
  #pod 0.58+ is installed, a raw append will be done instead on the data encoded
  #pod with C<Unicode::UTF8>.
  #pod
  #pod Current API available since 0.060.
  #pod
  #pod =cut
  
  sub append {
      my ( $self, @data ) = @_;
      my $args = ( @data && ref $data[0] eq 'HASH' ) ? shift @data : {};
      $args = _get_args( $args, qw/binmode truncate/ );
      my $binmode = $args->{binmode};
      $binmode = ( ( caller(0) )[10] || {} )->{'open>'} unless defined $binmode;
      my $mode = $args->{truncate} ? ">" : ">>";
      my $fh = $self->filehandle( { locked => 1 }, $mode, $binmode );
      print {$fh} map { ref eq 'ARRAY' ? @$_ : $_ } @data;
      close $fh or $self->_throw('close');
  }
  
  sub append_raw {
      my ( $self, @data ) = @_;
      my $args = ( @data && ref $data[0] eq 'HASH' ) ? shift @data : {};
      $args = _get_args( $args, qw/binmode truncate/ );
      $args->{binmode} = ':unix';
      append( $self, $args, @data );
  }
  
  sub append_utf8 {
      my ( $self, @data ) = @_;
      my $args = ( @data && ref $data[0] eq 'HASH' ) ? shift @data : {};
      $args = _get_args( $args, qw/binmode truncate/ );
      if ( defined($HAS_UU) ? $HAS_UU : ( $HAS_UU = _check_UU() ) ) {
          $args->{binmode} = ":unix";
          append( $self, $args, map { Unicode::UTF8::encode_utf8($_) } @data );
      }
      elsif ( defined($HAS_PU) ? $HAS_PU : ( $HAS_PU = _check_PU() ) ) {
          $args->{binmode} = ":unix:utf8_strict";
          append( $self, $args, @data );
      }
      else {
          $args->{binmode} = ":unix:encoding(UTF-8)";
          append( $self, $args, @data );
      }
  }
  
  #pod =method assert
  #pod
  #pod     $path = path("foo.txt")->assert( sub { $_->exists } );
  #pod
  #pod Returns the invocant after asserting that a code reference argument returns
  #pod true.  When the assertion code reference runs, it will have the invocant
  #pod object in the C<$_> variable.  If it returns false, an exception will be
  #pod thrown.  The assertion code reference may also throw its own exception.
  #pod
  #pod If no assertion is provided, the invocant is returned without error.
  #pod
  #pod Current API available since 0.062.
  #pod
  #pod =cut
  
  sub assert {
      my ( $self, $assertion ) = @_;
      return $self unless $assertion;
      if ( ref $assertion eq 'CODE' ) {
          local $_ = $self;
          $assertion->()
            or Path::Tiny::Error->throw( "assert", $self->[PATH], "failed assertion" );
      }
      else {
          Carp::croak("argument to assert must be a code reference argument");
      }
      return $self;
  }
  
  #pod =method basename
  #pod
  #pod     $name = path("foo/bar.txt")->basename;        # bar.txt
  #pod     $name = path("foo.txt")->basename('.txt');    # foo
  #pod     $name = path("foo.txt")->basename(qr/.txt/);  # foo
  #pod     $name = path("foo.txt")->basename(@suffixes);
  #pod
  #pod Returns the file portion or last directory portion of a path.
  #pod
  #pod Given a list of suffixes as strings or regular expressions, any that match at
  #pod the end of the file portion or last directory portion will be removed before
  #pod the result is returned.
  #pod
  #pod Current API available since 0.054.
  #pod
  #pod =cut
  
  sub basename {
      my ( $self, @suffixes ) = @_;
      $self->_splitpath unless defined $self->[FILE];
      my $file = $self->[FILE];
      for my $s (@suffixes) {
          my $re = ref($s) eq 'Regexp' ? qr/$s\z/ : qr/\Q$s\E\z/;
          last if $file =~ s/$re//;
      }
      return $file;
  }
  
  #pod =method canonpath
  #pod
  #pod     $canonical = path("foo/bar")->canonpath; # foo\bar on Windows
  #pod
  #pod Returns a string with the canonical format of the path name for
  #pod the platform.  In particular, this means directory separators
  #pod will be C<\> on Windows.
  #pod
  #pod Current API available since 0.001.
  #pod
  #pod =cut
  
  sub canonpath { $_[0]->[CANON] }
  
  #pod =method cached_temp
  #pod
  #pod Returns the cached C<File::Temp> or C<File::Temp::Dir> object if the
  #pod C<Path::Tiny> object was created with C</tempfile> or C</tempdir>.
  #pod If there is no such object, this method throws.
  #pod
  #pod B<WARNING>: Keeping a reference to, or modifying the cached object may
  #pod break the behavior documented for temporary files and directories created
  #pod with C<Path::Tiny> and is not supported.  Use at your own risk.
  #pod
  #pod Current API available since 0.101.
  #pod
  #pod =cut
  
  sub cached_temp {
      my $self = shift;
      $self->_throw( "cached_temp", $self, "has no cached File::Temp object" )
        unless defined $self->[TEMP];
      return $self->[TEMP];
  }
  
  #pod =method child
  #pod
  #pod     $file = path("/tmp")->child("foo.txt"); # "/tmp/foo.txt"
  #pod     $file = path("/tmp")->child(@parts);
  #pod
  #pod Returns a new C<Path::Tiny> object relative to the original.  Works
  #pod like C<catfile> or C<catdir> from File::Spec, but without caring about
  #pod file or directories.
  #pod
  #pod B<WARNING>: because the argument could contain C<..> or refer to symlinks,
  #pod there is no guarantee that the new path refers to an actual descendent of
  #pod the original.  If this is important to you, transform parent and child with
  #pod L</realpath> and check them with L</subsumes>.
  #pod
  #pod Current API available since 0.001.
  #pod
  #pod =cut
  
  sub child {
      my ( $self, @parts ) = @_;
      return path( $self->[PATH], @parts );
  }
  
  #pod =method children
  #pod
  #pod     @paths = path("/tmp")->children;
  #pod     @paths = path("/tmp")->children( qr/\.txt\z/ );
  #pod
  #pod Returns a list of C<Path::Tiny> objects for all files and directories
  #pod within a directory.  Excludes "." and ".." automatically.
  #pod
  #pod If an optional C<qr//> argument is provided, it only returns objects for child
  #pod names that match the given regular expression.  Only the base name is used
  #pod for matching:
  #pod
  #pod     @paths = path("/tmp")->children( qr/^foo/ );
  #pod     # matches children like the glob foo*
  #pod
  #pod Current API available since 0.028.
  #pod
  #pod =cut
  
  sub children {
      my ( $self, $filter ) = @_;
      my $dh;
      opendir $dh, $self->[PATH] or $self->_throw('opendir');
      my @children = readdir $dh;
      closedir $dh or $self->_throw('closedir');
  
      if ( not defined $filter ) {
          @children = grep { $_ ne '.' && $_ ne '..' } @children;
      }
      elsif ( $filter && ref($filter) eq 'Regexp' ) {
          @children = grep { $_ ne '.' && $_ ne '..' && $_ =~ $filter } @children;
      }
      else {
          Carp::croak("Invalid argument '$filter' for children()");
      }
  
      return map { path( $self->[PATH], $_ ) } @children;
  }
  
  #pod =method chmod
  #pod
  #pod     path("foo.txt")->chmod(0777);
  #pod     path("foo.txt")->chmod("0755");
  #pod     path("foo.txt")->chmod("go-w");
  #pod     path("foo.txt")->chmod("a=r,u+wx");
  #pod
  #pod Sets file or directory permissions.  The argument can be a numeric mode, a
  #pod octal string beginning with a "0" or a limited subset of the symbolic mode use
  #pod by F</bin/chmod>.
  #pod
  #pod The symbolic mode must be a comma-delimited list of mode clauses.  Clauses must
  #pod match C<< qr/\A([augo]+)([=+-])([rwx]+)\z/ >>, which defines "who", "op" and
  #pod "perms" parameters for each clause.  Unlike F</bin/chmod>, all three parameters
  #pod are required for each clause, multiple ops are not allowed and permissions
  #pod C<stugoX> are not supported.  (See L<File::chmod> for more complex needs.)
  #pod
  #pod Current API available since 0.053.
  #pod
  #pod =cut
  
  sub chmod {
      my ( $self, $new_mode ) = @_;
  
      my $mode;
      if ( $new_mode =~ /\d/ ) {
          $mode = ( $new_mode =~ /^0/ ? oct($new_mode) : $new_mode );
      }
      elsif ( $new_mode =~ /[=+-]/ ) {
          $mode = _symbolic_chmod( $self->stat->mode & 07777, $new_mode ); ## no critic
      }
      else {
          Carp::croak("Invalid mode argument '$new_mode' for chmod()");
      }
  
      CORE::chmod( $mode, $self->[PATH] ) or $self->_throw("chmod");
  
      return 1;
  }
  
  #pod =method copy
  #pod
  #pod     path("/tmp/foo.txt")->copy("/tmp/bar.txt");
  #pod
  #pod Copies the current path to the given destination using L<File::Copy>'s
  #pod C<copy> function. Upon success, returns the C<Path::Tiny> object for the
  #pod newly copied file.
  #pod
  #pod Current API available since 0.070.
  #pod
  #pod =cut
  
  # XXX do recursively for directories?
  sub copy {
      my ( $self, $dest ) = @_;
      require File::Copy;
      File::Copy::copy( $self->[PATH], $dest )
        or Carp::croak("copy failed for $self to $dest: $!");
  
      return -d $dest ? path( $dest, $self->basename ) : path($dest);
  }
  
  #pod =method digest
  #pod
  #pod     $obj = path("/tmp/foo.txt")->digest;        # SHA-256
  #pod     $obj = path("/tmp/foo.txt")->digest("MD5"); # user-selected
  #pod     $obj = path("/tmp/foo.txt")->digest( { chunk_size => 1e6 }, "MD5" );
  #pod
  #pod Returns a hexadecimal digest for a file.  An optional hash reference of options may
  #pod be given.  The only option is C<chunk_size>.  If C<chunk_size> is given, that many
  #pod bytes will be read at a time.  If not provided, the entire file will be slurped
  #pod into memory to compute the digest.
  #pod
  #pod Any subsequent arguments are passed to the constructor for L<Digest> to select
  #pod an algorithm.  If no arguments are given, the default is SHA-256.
  #pod
  #pod Current API available since 0.056.
  #pod
  #pod =cut
  
  sub digest {
      my ( $self, @opts ) = @_;
      my $args = ( @opts && ref $opts[0] eq 'HASH' ) ? shift @opts : {};
      $args = _get_args( $args, qw/chunk_size/ );
      unshift @opts, 'SHA-256' unless @opts;
      require Digest;
      my $digest = Digest->new(@opts);
      if ( $args->{chunk_size} ) {
          my $fh = $self->filehandle( { locked => 1 }, "<", ":unix" );
          my $buf;
          $digest->add($buf) while read $fh, $buf, $args->{chunk_size};
      }
      else {
          $digest->add( $self->slurp_raw );
      }
      return $digest->hexdigest;
  }
  
  #pod =method dirname (deprecated)
  #pod
  #pod     $name = path("/tmp/foo.txt")->dirname; # "/tmp/"
  #pod
  #pod Returns the directory portion you would get from calling
  #pod C<< File::Spec->splitpath( $path->stringify ) >> or C<"."> for a path without a
  #pod parent directory portion.  Because L<File::Spec> is inconsistent, the result
  #pod might or might not have a trailing slash.  Because of this, this method is
  #pod B<deprecated>.
  #pod
  #pod A better, more consistently approach is likely C<< $path->parent->stringify >>,
  #pod which will not have a trailing slash except for a root directory.
  #pod
  #pod Deprecated in 0.056.
  #pod
  #pod =cut
  
  sub dirname {
      my ($self) = @_;
      $self->_splitpath unless defined $self->[DIR];
      return length $self->[DIR] ? $self->[DIR] : ".";
  }
  
  #pod =method edit, edit_raw, edit_utf8
  #pod
  #pod     path("foo.txt")->edit( \&callback, $options );
  #pod     path("foo.txt")->edit_utf8( \&callback );
  #pod     path("foo.txt")->edit_raw( \&callback );
  #pod
  #pod These are convenience methods that allow "editing" a file using a single
  #pod callback argument. They slurp the file using C<slurp>, place the contents
  #pod inside a localized C<$_> variable, call the callback function (without
  #pod arguments), and then write C<$_> (presumably mutated) back to the
  #pod file with C<spew>.
  #pod
  #pod An optional hash reference may be used to pass options.  The only option is
  #pod C<binmode>, which is passed to C<slurp> and C<spew>.
  #pod
  #pod C<edit_utf8> and C<edit_raw> act like their respective C<slurp_*> and
  #pod C<spew_*> methods.
  #pod
  #pod Current API available since 0.077.
  #pod
  #pod =cut
  
  sub edit {
      my $self = shift;
      my $cb   = shift;
      my $args = _get_args( shift, qw/binmode/ );
      Carp::croak("Callback for edit() must be a code reference")
        unless defined($cb) && ref($cb) eq 'CODE';
  
      local $_ =
        $self->slurp( exists( $args->{binmode} ) ? { binmode => $args->{binmode} } : () );
      $cb->();
      $self->spew( $args, $_ );
  
      return;
  }
  
  # this is done long-hand to benefit from slurp_utf8 optimizations
  sub edit_utf8 {
      my ( $self, $cb ) = @_;
      Carp::croak("Callback for edit_utf8() must be a code reference")
        unless defined($cb) && ref($cb) eq 'CODE';
  
      local $_ = $self->slurp_utf8;
      $cb->();
      $self->spew_utf8($_);
  
      return;
  }
  
  sub edit_raw { $_[2] = { binmode => ":unix" }; goto &edit }
  
  #pod =method edit_lines, edit_lines_utf8, edit_lines_raw
  #pod
  #pod     path("foo.txt")->edit_lines( \&callback, $options );
  #pod     path("foo.txt")->edit_lines_utf8( \&callback );
  #pod     path("foo.txt")->edit_lines_raw( \&callback );
  #pod
  #pod These are convenience methods that allow "editing" a file's lines using a
  #pod single callback argument.  They iterate over the file: for each line, the
  #pod line is put into a localized C<$_> variable, the callback function is
  #pod executed (without arguments) and then C<$_> is written to a temporary file.
  #pod When iteration is finished, the temporary file is atomically renamed over
  #pod the original.
  #pod
  #pod An optional hash reference may be used to pass options.  The only option is
  #pod C<binmode>, which is passed to the method that open handles for reading and
  #pod writing.
  #pod
  #pod C<edit_lines_utf8> and C<edit_lines_raw> act like their respective
  #pod C<slurp_*> and C<spew_*> methods.
  #pod
  #pod Current API available since 0.077.
  #pod
  #pod =cut
  
  sub edit_lines {
      my $self = shift;
      my $cb   = shift;
      my $args = _get_args( shift, qw/binmode/ );
      Carp::croak("Callback for edit_lines() must be a code reference")
        unless defined($cb) && ref($cb) eq 'CODE';
  
      my $binmode = $args->{binmode};
      # get default binmode from caller's lexical scope (see "perldoc open")
      $binmode = ( ( caller(0) )[10] || {} )->{'open>'} unless defined $binmode;
  
      # writing need to follow the link and create the tempfile in the same
      # dir for later atomic rename
      my $resolved_path = $self->_resolve_symlinks;
      my $temp          = path( $resolved_path . $$ . int( rand( 2**31 ) ) );
  
      my $temp_fh = $temp->filehandle( { exclusive => 1, locked => 1 }, ">", $binmode );
      my $in_fh = $self->filehandle( { locked => 1 }, '<', $binmode );
  
      local $_;
      while (<$in_fh>) {
          $cb->();
          $temp_fh->print($_);
      }
  
      close $temp_fh or $self->_throw( 'close', $temp );
      close $in_fh or $self->_throw('close');
  
      return $temp->move($resolved_path);
  }
  
  sub edit_lines_raw { $_[2] = { binmode => ":unix" }; goto &edit_lines }
  
  sub edit_lines_utf8 {
      $_[2] = { binmode => ":raw:encoding(UTF-8)" };
      goto &edit_lines;
  }
  
  #pod =method exists, is_file, is_dir
  #pod
  #pod     if ( path("/tmp")->exists ) { ... }     # -e
  #pod     if ( path("/tmp")->is_dir ) { ... }     # -d
  #pod     if ( path("/tmp")->is_file ) { ... }    # -e && ! -d
  #pod
  #pod Implements file test operations, this means the file or directory actually has
  #pod to exist on the filesystem.  Until then, it's just a path.
  #pod
  #pod B<Note>: C<is_file> is not C<-f> because C<-f> is not the opposite of C<-d>.
  #pod C<-f> means "plain file", excluding symlinks, devices, etc. that often can be
  #pod read just like files.
  #pod
  #pod Use C<-f> instead if you really mean to check for a plain file.
  #pod
  #pod Current API available since 0.053.
  #pod
  #pod =cut
  
  sub exists { -e $_[0]->[PATH] }
  
  sub is_file { -e $_[0]->[PATH] && !-d _ }
  
  sub is_dir { -d $_[0]->[PATH] }
  
  #pod =method filehandle
  #pod
  #pod     $fh = path("/tmp/foo.txt")->filehandle($mode, $binmode);
  #pod     $fh = path("/tmp/foo.txt")->filehandle({ locked => 1 }, $mode, $binmode);
  #pod     $fh = path("/tmp/foo.txt")->filehandle({ exclusive => 1  }, $mode, $binmode);
  #pod
  #pod Returns an open file handle.  The C<$mode> argument must be a Perl-style
  #pod read/write mode string ("<" ,">", ">>", etc.).  If a C<$binmode>
  #pod is given, it is set during the C<open> call.
  #pod
  #pod An optional hash reference may be used to pass options.
  #pod
  #pod The C<locked> option governs file locking; if true, handles opened for writing,
  #pod appending or read-write are locked with C<LOCK_EX>; otherwise, they are
  #pod locked with C<LOCK_SH>.  When using C<locked>, ">" or "+>" modes will delay
  #pod truncation until after the lock is acquired.
  #pod
  #pod The C<exclusive> option causes the open() call to fail if the file already
  #pod exists.  This corresponds to the O_EXCL flag to sysopen / open(2).
  #pod C<exclusive> implies C<locked> and will set it for you if you forget it.
  #pod
  #pod See C<openr>, C<openw>, C<openrw>, and C<opena> for sugar.
  #pod
  #pod Current API available since 0.066.
  #pod
  #pod =cut
  
  # Note: must put binmode on open line, not subsequent binmode() call, so things
  # like ":unix" actually stop perlio/crlf from being added
  
  sub filehandle {
      my ( $self, @args ) = @_;
      my $args = ( @args && ref $args[0] eq 'HASH' ) ? shift @args : {};
      $args = _get_args( $args, qw/locked exclusive/ );
      $args->{locked} = 1 if $args->{exclusive};
      my ( $opentype, $binmode ) = @args;
  
      $opentype = "<" unless defined $opentype;
      Carp::croak("Invalid file mode '$opentype'")
        unless grep { $opentype eq $_ } qw/< +< > +> >> +>>/;
  
      $binmode = ( ( caller(0) )[10] || {} )->{ 'open' . substr( $opentype, -1, 1 ) }
        unless defined $binmode;
      $binmode = "" unless defined $binmode;
  
      my ( $fh, $lock, $trunc );
      if ( $HAS_FLOCK && $args->{locked} && !$ENV{PERL_PATH_TINY_NO_FLOCK} ) {
          require Fcntl;
          # truncating file modes shouldn't truncate until lock acquired
          if ( grep { $opentype eq $_ } qw( > +> ) ) {
              # sysopen in write mode without truncation
              my $flags = $opentype eq ">" ? Fcntl::O_WRONLY() : Fcntl::O_RDWR();
              $flags |= Fcntl::O_CREAT();
              $flags |= Fcntl::O_EXCL() if $args->{exclusive};
              sysopen( $fh, $self->[PATH], $flags ) or $self->_throw("sysopen");
  
              # fix up the binmode since sysopen() can't specify layers like
              # open() and binmode() can't start with just :unix like open()
              if ( $binmode =~ s/^:unix// ) {
                  # eliminate pseudo-layers
                  binmode( $fh, ":raw" ) or $self->_throw("binmode (:raw)");
                  # strip off real layers until only :unix is left
                  while ( 1 < ( my $layers =()= PerlIO::get_layers( $fh, output => 1 ) ) ) {
                      binmode( $fh, ":pop" ) or $self->_throw("binmode (:pop)");
                  }
              }
  
              # apply any remaining binmode layers
              if ( length $binmode ) {
                  binmode( $fh, $binmode ) or $self->_throw("binmode ($binmode)");
              }
  
              # ask for lock and truncation
              $lock  = Fcntl::LOCK_EX();
              $trunc = 1;
          }
          elsif ( $^O eq 'aix' && $opentype eq "<" ) {
              # AIX can only lock write handles, so upgrade to RW and LOCK_EX if
              # the file is writable; otherwise give up on locking.  N.B.
              # checking -w before open to determine the open mode is an
              # unavoidable race condition
              if ( -w $self->[PATH] ) {
                  $opentype = "+<";
                  $lock     = Fcntl::LOCK_EX();
              }
          }
          else {
              $lock = $opentype eq "<" ? Fcntl::LOCK_SH() : Fcntl::LOCK_EX();
          }
      }
  
      unless ($fh) {
          my $mode = $opentype . $binmode;
          open $fh, $mode, $self->[PATH] or $self->_throw("open ($mode)");
      }
  
      do { flock( $fh, $lock ) or $self->_throw("flock ($lock)") } if $lock;
      do { truncate( $fh, 0 ) or $self->_throw("truncate") } if $trunc;
  
      return $fh;
  }
  
  #pod =method is_absolute, is_relative
  #pod
  #pod     if ( path("/tmp")->is_absolute ) { ... }
  #pod     if ( path("/tmp")->is_relative ) { ... }
  #pod
  #pod Booleans for whether the path appears absolute or relative.
  #pod
  #pod Current API available since 0.001.
  #pod
  #pod =cut
  
  sub is_absolute { substr( $_[0]->dirname, 0, 1 ) eq '/' }
  
  sub is_relative { substr( $_[0]->dirname, 0, 1 ) ne '/' }
  
  #pod =method is_rootdir
  #pod
  #pod     while ( ! $path->is_rootdir ) {
  #pod         $path = $path->parent;
  #pod         ...
  #pod     }
  #pod
  #pod Boolean for whether the path is the root directory of the volume.  I.e. the
  #pod C<dirname> is C<q[/]> and the C<basename> is C<q[]>.
  #pod
  #pod This works even on C<MSWin32> with drives and UNC volumes:
  #pod
  #pod     path("C:/")->is_rootdir;             # true
  #pod     path("//server/share/")->is_rootdir; #true
  #pod
  #pod Current API available since 0.038.
  #pod
  #pod =cut
  
  sub is_rootdir {
      my ($self) = @_;
      $self->_splitpath unless defined $self->[DIR];
      return $self->[DIR] eq '/' && $self->[FILE] eq '';
  }
  
  #pod =method iterator
  #pod
  #pod     $iter = path("/tmp")->iterator( \%options );
  #pod
  #pod Returns a code reference that walks a directory lazily.  Each invocation
  #pod returns a C<Path::Tiny> object or undef when the iterator is exhausted.
  #pod
  #pod     $iter = path("/tmp")->iterator;
  #pod     while ( $path = $iter->() ) {
  #pod         ...
  #pod     }
  #pod
  #pod The current and parent directory entries ("." and "..") will not
  #pod be included.
  #pod
  #pod If the C<recurse> option is true, the iterator will walk the directory
  #pod recursively, breadth-first.  If the C<follow_symlinks> option is also true,
  #pod directory links will be followed recursively.  There is no protection against
  #pod loops when following links. If a directory is not readable, it will not be
  #pod followed.
  #pod
  #pod The default is the same as:
  #pod
  #pod     $iter = path("/tmp")->iterator( {
  #pod         recurse         => 0,
  #pod         follow_symlinks => 0,
  #pod     } );
  #pod
  #pod For a more powerful, recursive iterator with built-in loop avoidance, see
  #pod L<Path::Iterator::Rule>.
  #pod
  #pod See also L</visit>.
  #pod
  #pod Current API available since 0.016.
  #pod
  #pod =cut
  
  sub iterator {
      my $self = shift;
      my $args = _get_args( shift, qw/recurse follow_symlinks/ );
      my @dirs = $self;
      my $current;
      return sub {
          my $next;
          while (@dirs) {
              if ( ref $dirs[0] eq 'Path::Tiny' ) {
                  if ( !-r $dirs[0] ) {
                      # Directory is missing or not readable, so skip it.  There
                      # is still a race condition possible between the check and
                      # the opendir, but we can't easily differentiate between
                      # error cases that are OK to skip and those that we want
                      # to be exceptions, so we live with the race and let opendir
                      # be fatal.
                      shift @dirs and next;
                  }
                  $current = $dirs[0];
                  my $dh;
                  opendir( $dh, $current->[PATH] )
                    or $self->_throw( 'opendir', $current->[PATH] );
                  $dirs[0] = $dh;
                  if ( -l $current->[PATH] && !$args->{follow_symlinks} ) {
                      # Symlink attack! It was a real dir, but is now a symlink!
                      # N.B. we check *after* opendir so the attacker has to win
                      # two races: replace dir with symlink before opendir and
                      # replace symlink with dir before -l check above
                      shift @dirs and next;
                  }
              }
              while ( defined( $next = readdir $dirs[0] ) ) {
                  next if $next eq '.' || $next eq '..';
                  my $path = $current->child($next);
                  push @dirs, $path
                    if $args->{recurse} && -d $path && !( !$args->{follow_symlinks} && -l $path );
                  return $path;
              }
              shift @dirs;
          }
          return;
      };
  }
  
  #pod =method lines, lines_raw, lines_utf8
  #pod
  #pod     @contents = path("/tmp/foo.txt")->lines;
  #pod     @contents = path("/tmp/foo.txt")->lines(\%options);
  #pod     @contents = path("/tmp/foo.txt")->lines_raw;
  #pod     @contents = path("/tmp/foo.txt")->lines_utf8;
  #pod
  #pod     @contents = path("/tmp/foo.txt")->lines( { chomp => 1, count => 4 } );
  #pod
  #pod Returns a list of lines from a file.  Optionally takes a hash-reference of
  #pod options.  Valid options are C<binmode>, C<count> and C<chomp>.
  #pod
  #pod If C<binmode> is provided, it will be set on the handle prior to reading.
  #pod
  #pod If a positive C<count> is provided, that many lines will be returned from the
  #pod start of the file.  If a negative C<count> is provided, the entire file will be
  #pod read, but only C<abs(count)> will be kept and returned.  If C<abs(count)>
  #pod exceeds the number of lines in the file, all lines will be returned.
  #pod
  #pod If C<chomp> is set, any end-of-line character sequences (C<CR>, C<CRLF>, or
  #pod C<LF>) will be removed from the lines returned.
  #pod
  #pod Because the return is a list, C<lines> in scalar context will return the number
  #pod of lines (and throw away the data).
  #pod
  #pod     $number_of_lines = path("/tmp/foo.txt")->lines;
  #pod
  #pod C<lines_raw> is like C<lines> with a C<binmode> of C<:raw>.  We use C<:raw>
  #pod instead of C<:unix> so PerlIO buffering can manage reading by line.
  #pod
  #pod C<lines_utf8> is like C<lines> with a C<binmode> of C<:raw:encoding(UTF-8)>
  #pod (or L<PerlIO::utf8_strict>).  If L<Unicode::UTF8> 0.58+ is installed, a raw
  #pod UTF-8 slurp will be done and then the lines will be split.  This is
  #pod actually faster than relying on C<:encoding(UTF-8)>, though a bit memory
  #pod intensive.  If memory use is a concern, consider C<openr_utf8> and
  #pod iterating directly on the handle.
  #pod
  #pod Current API available since 0.065.
  #pod
  #pod =cut
  
  sub lines {
      my $self    = shift;
      my $args    = _get_args( shift, qw/binmode chomp count/ );
      my $binmode = $args->{binmode};
      $binmode = ( ( caller(0) )[10] || {} )->{'open<'} unless defined $binmode;
      my $fh = $self->filehandle( { locked => 1 }, "<", $binmode );
      my $chomp = $args->{chomp};
      # XXX more efficient to read @lines then chomp(@lines) vs map?
      if ( $args->{count} ) {
          my ( $counter, $mod, @result ) = ( 0, abs( $args->{count} ) );
          while ( my $line = <$fh> ) {
              $line =~ s/(?:\x{0d}?\x{0a}|\x{0d})\z// if $chomp;
              $result[ $counter++ ] = $line;
              # for positive count, terminate after right number of lines
              last if $counter == $args->{count};
              # for negative count, eventually wrap around in the result array
              $counter %= $mod;
          }
          # reorder results if full and wrapped somewhere in the middle
          splice( @result, 0, 0, splice( @result, $counter ) )
            if @result == $mod && $counter % $mod;
          return @result;
      }
      elsif ($chomp) {
          return map { s/(?:\x{0d}?\x{0a}|\x{0d})\z//; $_ } <$fh>; ## no critic
      }
      else {
          return wantarray ? <$fh> : ( my $count =()= <$fh> );
      }
  }
  
  sub lines_raw {
      my $self = shift;
      my $args = _get_args( shift, qw/binmode chomp count/ );
      if ( $args->{chomp} && !$args->{count} ) {
          return split /\n/, slurp_raw($self);                    ## no critic
      }
      else {
          $args->{binmode} = ":raw";
          return lines( $self, $args );
      }
  }
  
  my $CRLF = qr/(?:\x{0d}?\x{0a}|\x{0d})/;
  
  sub lines_utf8 {
      my $self = shift;
      my $args = _get_args( shift, qw/binmode chomp count/ );
      if (   ( defined($HAS_UU) ? $HAS_UU : ( $HAS_UU = _check_UU() ) )
          && $args->{chomp}
          && !$args->{count} )
      {
          my $slurp = slurp_utf8($self);
          $slurp =~ s/$CRLF\z//; # like chomp, but full CR?LF|CR
          return split $CRLF, $slurp, -1; ## no critic
      }
      elsif ( defined($HAS_PU) ? $HAS_PU : ( $HAS_PU = _check_PU() ) ) {
          $args->{binmode} = ":unix:utf8_strict";
          return lines( $self, $args );
      }
      else {
          $args->{binmode} = ":raw:encoding(UTF-8)";
          return lines( $self, $args );
      }
  }
  
  #pod =method mkpath
  #pod
  #pod     path("foo/bar/baz")->mkpath;
  #pod     path("foo/bar/baz")->mkpath( \%options );
  #pod
  #pod Like calling C<make_path> from L<File::Path>.  An optional hash reference
  #pod is passed through to C<make_path>.  Errors will be trapped and an exception
  #pod thrown.  Returns the list of directories created or an empty list if
  #pod the directories already exist, just like C<make_path>.
  #pod
  #pod See also L</touchpath> as a chainable alternative to create a writeable file path
  #pod (though without options).
  #pod
  #pod Current API available since 0.001.
  #pod
  #pod =cut
  
  sub mkpath {
      my ( $self, $args ) = @_;
      $args = {} unless ref $args eq 'HASH';
      my $err;
      $args->{error} = \$err unless defined $args->{error};
      require File::Path;
      my @dirs = File::Path::make_path( $self->[PATH], $args );
      if ( $err && @$err ) {
          my ( $file, $message ) = %{ $err->[0] };
          Carp::croak("mkpath failed for $file: $message");
      }
      return @dirs;
  }
  
  #pod =method move
  #pod
  #pod     path("foo.txt")->move("bar.txt");
  #pod
  #pod Move the current path to the given destination path using Perl's
  #pod built-in L<rename|perlfunc/rename> function. Returns the result
  #pod of the C<rename> function (except it throws an exception if it fails).
  #pod
  #pod Current API available since 0.001.
  #pod
  #pod =cut
  
  sub move {
      my ( $self, $dst ) = @_;
  
      return rename( $self->[PATH], $dst )
        || $self->_throw( 'rename', $self->[PATH] . "' -> '$dst" );
  }
  
  #pod =method openr, openw, openrw, opena
  #pod
  #pod     $fh = path("foo.txt")->openr($binmode);  # read
  #pod     $fh = path("foo.txt")->openr_raw;
  #pod     $fh = path("foo.txt")->openr_utf8;
  #pod
  #pod     $fh = path("foo.txt")->openw($binmode);  # write
  #pod     $fh = path("foo.txt")->openw_raw;
  #pod     $fh = path("foo.txt")->openw_utf8;
  #pod
  #pod     $fh = path("foo.txt")->opena($binmode);  # append
  #pod     $fh = path("foo.txt")->opena_raw;
  #pod     $fh = path("foo.txt")->opena_utf8;
  #pod
  #pod     $fh = path("foo.txt")->openrw($binmode); # read/write
  #pod     $fh = path("foo.txt")->openrw_raw;
  #pod     $fh = path("foo.txt")->openrw_utf8;
  #pod
  #pod Returns a file handle opened in the specified mode.  The C<openr> style methods
  #pod take a single C<binmode> argument.  All of the C<open*> methods have
  #pod C<open*_raw> and C<open*_utf8> equivalents that use C<:raw> and
  #pod C<:raw:encoding(UTF-8)>, respectively.
  #pod
  #pod An optional hash reference may be used to pass options.  The only option is
  #pod C<locked>.  If true, handles opened for writing, appending or read-write are
  #pod locked with C<LOCK_EX>; otherwise, they are locked for C<LOCK_SH>.
  #pod
  #pod     $fh = path("foo.txt")->openrw_utf8( { locked => 1 } );
  #pod
  #pod See L</filehandle> for more on locking.
  #pod
  #pod Current API available since 0.011.
  #pod
  #pod =cut
  
  # map method names to corresponding open mode
  my %opens = (
      opena  => ">>",
      openr  => "<",
      openw  => ">",
      openrw => "+<"
  );
  
  while ( my ( $k, $v ) = each %opens ) {
      no strict 'refs';
      # must check for lexical IO mode hint
      *{$k} = sub {
          my ( $self, @args ) = @_;
          my $args = ( @args && ref $args[0] eq 'HASH' ) ? shift @args : {};
          $args = _get_args( $args, qw/locked/ );
          my ($binmode) = @args;
          $binmode = ( ( caller(0) )[10] || {} )->{ 'open' . substr( $v, -1, 1 ) }
            unless defined $binmode;
          $self->filehandle( $args, $v, $binmode );
      };
      *{ $k . "_raw" } = sub {
          my ( $self, @args ) = @_;
          my $args = ( @args && ref $args[0] eq 'HASH' ) ? shift @args : {};
          $args = _get_args( $args, qw/locked/ );
          $self->filehandle( $args, $v, ":raw" );
      };
      *{ $k . "_utf8" } = sub {
          my ( $self, @args ) = @_;
          my $args = ( @args && ref $args[0] eq 'HASH' ) ? shift @args : {};
          $args = _get_args( $args, qw/locked/ );
          $self->filehandle( $args, $v, ":raw:encoding(UTF-8)" );
      };
  }
  
  #pod =method parent
  #pod
  #pod     $parent = path("foo/bar/baz")->parent; # foo/bar
  #pod     $parent = path("foo/wibble.txt")->parent; # foo
  #pod
  #pod     $parent = path("foo/bar/baz")->parent(2); # foo
  #pod
  #pod Returns a C<Path::Tiny> object corresponding to the parent directory of the
  #pod original directory or file. An optional positive integer argument is the number
  #pod of parent directories upwards to return.  C<parent> by itself is equivalent to
  #pod C<parent(1)>.
  #pod
  #pod Current API available since 0.014.
  #pod
  #pod =cut
  
  # XXX this is ugly and coverage is incomplete.  I think it's there for windows
  # so need to check coverage there and compare
  sub parent {
      my ( $self, $level ) = @_;
      $level = 1 unless defined $level && $level > 0;
      $self->_splitpath unless defined $self->[FILE];
      my $parent;
      if ( length $self->[FILE] ) {
          if ( $self->[FILE] eq '.' || $self->[FILE] eq ".." ) {
              $parent = path( $self->[PATH] . "/.." );
          }
          else {
              $parent = path( _non_empty( $self->[VOL] . $self->[DIR] ) );
          }
      }
      elsif ( length $self->[DIR] ) {
          # because of symlinks, any internal updir requires us to
          # just add more updirs at the end
          if ( $self->[DIR] =~ m{(?:^\.\./|/\.\./|/\.\.\z)} ) {
              $parent = path( $self->[VOL] . $self->[DIR] . "/.." );
          }
          else {
              ( my $dir = $self->[DIR] ) =~ s{/[^\/]+/\z}{/};
              $parent = path( $self->[VOL] . $dir );
          }
      }
      else {
          $parent = path( _non_empty( $self->[VOL] ) );
      }
      return $level == 1 ? $parent : $parent->parent( $level - 1 );
  }
  
  sub _non_empty {
      my ($string) = shift;
      return ( ( defined($string) && length($string) ) ? $string : "." );
  }
  
  #pod =method realpath
  #pod
  #pod     $real = path("/baz/foo/../bar")->realpath;
  #pod     $real = path("foo/../bar")->realpath;
  #pod
  #pod Returns a new C<Path::Tiny> object with all symbolic links and upward directory
  #pod parts resolved using L<Cwd>'s C<realpath>.  Compared to C<absolute>, this is
  #pod more expensive as it must actually consult the filesystem.
  #pod
  #pod If the parent path can't be resolved (e.g. if it includes directories that
  #pod don't exist), an exception will be thrown:
  #pod
  #pod     $real = path("doesnt_exist/foo")->realpath; # dies
  #pod
  #pod However, if the parent path exists and only the last component (e.g. filename)
  #pod doesn't exist, the realpath will be the realpath of the parent plus the
  #pod non-existent last component:
  #pod
  #pod     $real = path("./aasdlfasdlf")->realpath; # works
  #pod
  #pod The underlying L<Cwd> module usually worked this way on Unix, but died on
  #pod Windows (and some Unixes) if the full path didn't exist.  As of version 0.064,
  #pod it's safe to use anywhere.
  #pod
  #pod Current API available since 0.001.
  #pod
  #pod =cut
  
  # Win32 and some Unixes need parent path resolved separately so realpath
  # doesn't throw an error resolving non-existent basename
  sub realpath {
      my $self = shift;
      $self = $self->_resolve_symlinks;
      require Cwd;
      $self->_splitpath if !defined $self->[FILE];
      my $check_parent =
        length $self->[FILE] && $self->[FILE] ne '.' && $self->[FILE] ne '..';
      my $realpath = eval {
          # pure-perl Cwd can carp
          local $SIG{__WARN__} = sub { };
          Cwd::realpath( $check_parent ? $self->parent->[PATH] : $self->[PATH] );
      };
      # parent realpath must exist; not all Cwd::realpath will error if it doesn't
      $self->_throw("resolving realpath")
        unless defined $realpath && length $realpath && -e $realpath;
      return ( $check_parent ? path( $realpath, $self->[FILE] ) : path($realpath) );
  }
  
  #pod =method relative
  #pod
  #pod     $rel = path("/tmp/foo/bar")->relative("/tmp"); # foo/bar
  #pod
  #pod Returns a C<Path::Tiny> object with a path relative to a new base path
  #pod given as an argument.  If no argument is given, the current directory will
  #pod be used as the new base path.
  #pod
  #pod If either path is already relative, it will be made absolute based on the
  #pod current directly before determining the new relative path.
  #pod
  #pod The algorithm is roughly as follows:
  #pod
  #pod =for :list
  #pod * If the original and new base path are on different volumes, an exception
  #pod   will be thrown.
  #pod * If the original and new base are identical, the relative path is C<".">.
  #pod * If the new base subsumes the original, the relative path is the original
  #pod   path with the new base chopped off the front
  #pod * If the new base does not subsume the original, a common prefix path is
  #pod   determined (possibly the root directory) and the relative path will
  #pod   consist of updirs (C<"..">) to reach the common prefix, followed by the
  #pod   original path less the common prefix.
  #pod
  #pod Unlike C<File::Spec::abs2rel>, in the last case above, the calculation based
  #pod on a common prefix takes into account symlinks that could affect the updir
  #pod process.  Given an original path "/A/B" and a new base "/A/C",
  #pod (where "A", "B" and "C" could each have multiple path components):
  #pod
  #pod =for :list
  #pod * Symlinks in "A" don't change the result unless the last component of A is
  #pod   a symlink and the first component of "C" is an updir.
  #pod * Symlinks in "B" don't change the result and will exist in the result as
  #pod   given.
  #pod * Symlinks and updirs in "C" must be resolved to actual paths, taking into
  #pod   account the possibility that not all path components might exist on the
  #pod   filesystem.
  #pod
  #pod Current API available since 0.001.  New algorithm (that accounts for
  #pod symlinks) available since 0.079.
  #pod
  #pod =cut
  
  sub relative {
      my ( $self, $base ) = @_;
      $base = path( defined $base && length $base ? $base : '.' );
  
      # relative paths must be converted to absolute first
      $self = $self->absolute if $self->is_relative;
      $base = $base->absolute if $base->is_relative;
  
      # normalize volumes if they exist
      $self = $self->absolute if !length $self->volume && length $base->volume;
      $base = $base->absolute if length $self->volume  && !length $base->volume;
  
      # can't make paths relative across volumes
      if ( !_same( $self->volume, $base->volume ) ) {
          Carp::croak("relative() can't cross volumes: '$self' vs '$base'");
      }
  
      # if same absolute path, relative is current directory
      return path(".") if _same( $self->[PATH], $base->[PATH] );
  
      # if base is a prefix of self, chop prefix off self
      if ( $base->subsumes($self) ) {
          $base = "" if $base->is_rootdir;
          my $relative = "$self";
          $relative =~ s{\A\Q$base/}{};
          return path($relative);
      }
  
      # base is not a prefix, so must find a common prefix (even if root)
      my ( @common, @self_parts, @base_parts );
      @base_parts = split /\//, $base->_just_filepath;
  
      # if self is rootdir, then common directory is root (shown as empty
      # string for later joins); otherwise, must be computed from path parts.
      if ( $self->is_rootdir ) {
          @common = ("");
          shift @base_parts;
      }
      else {
          @self_parts = split /\//, $self->_just_filepath;
  
          while ( @self_parts && @base_parts && _same( $self_parts[0], $base_parts[0] ) ) {
              push @common, shift @base_parts;
              shift @self_parts;
          }
      }
  
      # if there are any symlinks from common to base, we have a problem, as
      # you can't guarantee that updir from base reaches the common prefix;
      # we must resolve symlinks and try again; likewise, any updirs are
      # a problem as it throws off calculation of updirs needed to get from
      # self's path to the common prefix.
      if ( my $new_base = $self->_resolve_between( \@common, \@base_parts ) ) {
          return $self->relative($new_base);
      }
  
      # otherwise, symlinks in common or from common to A don't matter as
      # those don't involve updirs
      my @new_path = ( ("..") x ( 0+ @base_parts ), @self_parts );
      return path(@new_path);
  }
  
  sub _just_filepath {
      my $self     = shift;
      my $self_vol = $self->volume;
      return "$self" if !length $self_vol;
  
      ( my $self_path = "$self" ) =~ s{\A\Q$self_vol}{};
  
      return $self_path;
  }
  
  sub _resolve_between {
      my ( $self, $common, $base ) = @_;
      my $path = $self->volume . join( "/", @$common );
      my $changed = 0;
      for my $p (@$base) {
          $path .= "/$p";
          if ( $p eq '..' ) {
              $changed = 1;
              if ( -e $path ) {
                  $path = path($path)->realpath->[PATH];
              }
              else {
                  $path =~ s{/[^/]+/..\z}{/};
              }
          }
          if ( -l $path ) {
              $changed = 1;
              $path    = path($path)->realpath->[PATH];
          }
      }
      return $changed ? path($path) : undef;
  }
  
  #pod =method remove
  #pod
  #pod     path("foo.txt")->remove;
  #pod
  #pod This is just like C<unlink>, except for its error handling: if the path does
  #pod not exist, it returns false; if deleting the file fails, it throws an
  #pod exception.
  #pod
  #pod Current API available since 0.012.
  #pod
  #pod =cut
  
  sub remove {
      my $self = shift;
  
      return 0 if !-e $self->[PATH] && !-l $self->[PATH];
  
      return unlink( $self->[PATH] ) || $self->_throw('unlink');
  }
  
  #pod =method remove_tree
  #pod
  #pod     # directory
  #pod     path("foo/bar/baz")->remove_tree;
  #pod     path("foo/bar/baz")->remove_tree( \%options );
  #pod     path("foo/bar/baz")->remove_tree( { safe => 0 } ); # force remove
  #pod
  #pod Like calling C<remove_tree> from L<File::Path>, but defaults to C<safe> mode.
  #pod An optional hash reference is passed through to C<remove_tree>.  Errors will be
  #pod trapped and an exception thrown.  Returns the number of directories deleted,
  #pod just like C<remove_tree>.
  #pod
  #pod If you want to remove a directory only if it is empty, use the built-in
  #pod C<rmdir> function instead.
  #pod
  #pod     rmdir path("foo/bar/baz/");
  #pod
  #pod Current API available since 0.013.
  #pod
  #pod =cut
  
  sub remove_tree {
      my ( $self, $args ) = @_;
      return 0 if !-e $self->[PATH] && !-l $self->[PATH];
      $args = {} unless ref $args eq 'HASH';
      my $err;
      $args->{error} = \$err unless defined $args->{error};
      $args->{safe}  = 1     unless defined $args->{safe};
      require File::Path;
      my $count = File::Path::remove_tree( $self->[PATH], $args );
  
      if ( $err && @$err ) {
          my ( $file, $message ) = %{ $err->[0] };
          Carp::croak("remove_tree failed for $file: $message");
      }
      return $count;
  }
  
  #pod =method sibling
  #pod
  #pod     $foo = path("/tmp/foo.txt");
  #pod     $sib = $foo->sibling("bar.txt");        # /tmp/bar.txt
  #pod     $sib = $foo->sibling("baz", "bam.txt"); # /tmp/baz/bam.txt
  #pod
  #pod Returns a new C<Path::Tiny> object relative to the parent of the original.
  #pod This is slightly more efficient than C<< $path->parent->child(...) >>.
  #pod
  #pod Current API available since 0.058.
  #pod
  #pod =cut
  
  sub sibling {
      my $self = shift;
      return path( $self->parent->[PATH], @_ );
  }
  
  #pod =method size, size_human
  #pod
  #pod     my $p = path("foo"); # with size 1025 bytes
  #pod
  #pod     $p->size;                            # "1025"
  #pod     $p->size_human;                      # "1.1 K"
  #pod     $p->size_human( {format => "iec"} ); # "1.1 KiB"
  #pod
  #pod Returns the size of a file.  The C<size> method is just a wrapper around C<-s>.
  #pod
  #pod The C<size_human> method provides a human-readable string similar to
  #pod C<ls -lh>.  Like C<ls>, it rounds upwards and provides one decimal place for
  #pod single-digit sizes and no decimal places for larger sizes.  The only available
  #pod option is C<format>, which has three valid values:
  #pod
  #pod =for :list
  #pod * 'ls' (the default): base-2 sizes, with C<ls> style single-letter suffixes (K, M, etc.)
  #pod * 'iec': base-2 sizes, with IEC binary suffixes (KiB, MiB, etc.)
  #pod * 'si': base-10 sizes, with SI decimal suffixes (kB, MB, etc.)
  #pod
  #pod If C<-s> would return C<undef>, C<size_human> returns the empty string.
  #pod
  #pod Current API available since 0.122.
  #pod
  #pod =cut
  
  sub size { -s $_[0]->[PATH] }
  
  my %formats = (
      'ls'  => [ 1024, log(1024), [ "", map { " $_" } qw/K M G T/ ] ],
      'iec' => [ 1024, log(1024), [ "", map { " $_" } qw/KiB MiB GiB TiB/ ] ],
      'si'  => [ 1000, log(1000), [ "", map { " $_" } qw/kB MB GB TB/ ] ],
  );
  
  sub _formats { return $formats{$_[0]} }
  
  sub size_human {
      my $self     = shift;
      my $args     = _get_args( shift, qw/format/ );
      my $format   = defined $args->{format} ? $args->{format} : "ls";
      my $fmt_opts = $formats{$format}
        or Carp::croak("Invalid format '$format' for size_human()");
      my $size = -s $self->[PATH];
      return defined $size ? _human_size( $size, @$fmt_opts ) : "";
  }
  
  sub _ceil {
      return $_[0] == int($_[0]) ? $_[0] : int($_[0]+1);
  }
  
  sub _human_size {
      my ( $size, $base, $log_base, $suffixes ) = @_;
      return "0" if $size == 0;
  
      my $mag = int( log($size) / $log_base );
      $size /= $base**$mag;
      $size =
          $mag == 0               ? $size
        : length( int($size) ) == 1 ? _ceil( $size * 10 ) / 10
        :                             _ceil($size);
      if ( $size >= $base ) {
          $size /= $base;
          $mag++;
      }
  
      my $fmt = ( $mag == 0 || length( int($size) ) > 1 ) ? "%.0f%s" : "%.1f%s";
      return sprintf( $fmt, $size, $suffixes->[$mag] );
  }
  
  #pod =method slurp, slurp_raw, slurp_utf8
  #pod
  #pod     $data = path("foo.txt")->slurp;
  #pod     $data = path("foo.txt")->slurp( {binmode => ":raw"} );
  #pod     $data = path("foo.txt")->slurp_raw;
  #pod     $data = path("foo.txt")->slurp_utf8;
  #pod
  #pod Reads file contents into a scalar.  Takes an optional hash reference which may
  #pod be used to pass options.  The only available option is C<binmode>, which is
  #pod passed to C<binmode()> on the handle used for reading.
  #pod
  #pod C<slurp_raw> is like C<slurp> with a C<binmode> of C<:unix> for
  #pod a fast, unbuffered, raw read.
  #pod
  #pod C<slurp_utf8> is like C<slurp> with a C<binmode> of
  #pod C<:unix:encoding(UTF-8)> (or L<PerlIO::utf8_strict>).  If L<Unicode::UTF8>
  #pod 0.58+ is installed, a raw slurp will be done instead and the result decoded
  #pod with C<Unicode::UTF8>.  This is just as strict and is roughly an order of
  #pod magnitude faster than using C<:encoding(UTF-8)>.
  #pod
  #pod B<Note>: C<slurp> and friends lock the filehandle before slurping.  If
  #pod you plan to slurp from a file created with L<File::Temp>, be sure to
  #pod close other handles or open without locking to avoid a deadlock:
  #pod
  #pod     my $tempfile = File::Temp->new(EXLOCK => 0);
  #pod     my $guts = path($tempfile)->slurp;
  #pod
  #pod Current API available since 0.004.
  #pod
  #pod =cut
  
  sub slurp {
      my $self    = shift;
      my $args    = _get_args( shift, qw/binmode/ );
      my $binmode = $args->{binmode};
      $binmode = ( ( caller(0) )[10] || {} )->{'open<'} unless defined $binmode;
      my $fh = $self->filehandle( { locked => 1 }, "<", $binmode );
      if ( ( defined($binmode) ? $binmode : "" ) eq ":unix"
          and my $size = -s $fh )
      {
          my $buf;
          read $fh, $buf, $size; # File::Slurp in a nutshell
          return $buf;
      }
      else {
          local $/;
          return scalar <$fh>;
      }
  }
  
  sub slurp_raw { $_[1] = { binmode => ":unix" }; goto &slurp }
  
  sub slurp_utf8 {
      if ( defined($HAS_UU) ? $HAS_UU : ( $HAS_UU = _check_UU() ) ) {
          return Unicode::UTF8::decode_utf8( slurp( $_[0], { binmode => ":unix" } ) );
      }
      elsif ( defined($HAS_PU) ? $HAS_PU : ( $HAS_PU = _check_PU() ) ) {
          $_[1] = { binmode => ":unix:utf8_strict" };
          goto &slurp;
      }
      else {
          $_[1] = { binmode => ":raw:encoding(UTF-8)" };
          goto &slurp;
      }
  }
  
  #pod =method spew, spew_raw, spew_utf8
  #pod
  #pod     path("foo.txt")->spew(@data);
  #pod     path("foo.txt")->spew(\@data);
  #pod     path("foo.txt")->spew({binmode => ":raw"}, @data);
  #pod     path("foo.txt")->spew_raw(@data);
  #pod     path("foo.txt")->spew_utf8(@data);
  #pod
  #pod Writes data to a file atomically.  The file is written to a temporary file in
  #pod the same directory, then renamed over the original.  An optional hash reference
  #pod may be used to pass options.  The only option is C<binmode>, which is passed to
  #pod C<binmode()> on the handle used for writing.
  #pod
  #pod C<spew_raw> is like C<spew> with a C<binmode> of C<:unix> for a fast,
  #pod unbuffered, raw write.
  #pod
  #pod C<spew_utf8> is like C<spew> with a C<binmode> of C<:unix:encoding(UTF-8)>
  #pod (or L<PerlIO::utf8_strict>).  If L<Unicode::UTF8> 0.58+ is installed, a raw
  #pod spew will be done instead on the data encoded with C<Unicode::UTF8>.
  #pod
  #pod B<NOTE>: because the file is written to a temporary file and then renamed, the
  #pod new file will wind up with permissions based on your current umask.  This is a
  #pod feature to protect you from a race condition that would otherwise give
  #pod different permissions than you might expect.  If you really want to keep the
  #pod original mode flags, use L</append> with the C<truncate> option.
  #pod
  #pod Current API available since 0.011.
  #pod
  #pod =cut
  
  # XXX add "unsafe" option to disable flocking and atomic?  Check benchmarks on append() first.
  sub spew {
      my ( $self, @data ) = @_;
      my $args = ( @data && ref $data[0] eq 'HASH' ) ? shift @data : {};
      $args = _get_args( $args, qw/binmode/ );
      my $binmode = $args->{binmode};
      # get default binmode from caller's lexical scope (see "perldoc open")
      $binmode = ( ( caller(0) )[10] || {} )->{'open>'} unless defined $binmode;
  
      # spewing need to follow the link
      # and create the tempfile in the same dir
      my $resolved_path = $self->_resolve_symlinks;
  
      my $temp = path( $resolved_path . $$ . int( rand( 2**31 ) ) );
      my $fh = $temp->filehandle( { exclusive => 1, locked => 1 }, ">", $binmode );
      print {$fh} map { ref eq 'ARRAY' ? @$_ : $_ } @data;
      close $fh or $self->_throw( 'close', $temp->[PATH] );
  
      return $temp->move($resolved_path);
  }
  
  sub spew_raw { splice @_, 1, 0, { binmode => ":unix" }; goto &spew }
  
  sub spew_utf8 {
      if ( defined($HAS_UU) ? $HAS_UU : ( $HAS_UU = _check_UU() ) ) {
          my $self = shift;
          spew(
              $self,
              { binmode => ":unix" },
              map { Unicode::UTF8::encode_utf8($_) } map { ref eq 'ARRAY' ? @$_ : $_ } @_
          );
      }
      elsif ( defined($HAS_PU) ? $HAS_PU : ( $HAS_PU = _check_PU() ) ) {
          splice @_, 1, 0, { binmode => ":unix:utf8_strict" };
          goto &spew;
      }
      else {
          splice @_, 1, 0, { binmode => ":unix:encoding(UTF-8)" };
          goto &spew;
      }
  }
  
  #pod =method stat, lstat
  #pod
  #pod     $stat = path("foo.txt")->stat;
  #pod     $stat = path("/some/symlink")->lstat;
  #pod
  #pod Like calling C<stat> or C<lstat> from L<File::stat>.
  #pod
  #pod Current API available since 0.001.
  #pod
  #pod =cut
  
  # XXX break out individual stat() components as subs?
  sub stat {
      my $self = shift;
      require File::stat;
      return File::stat::stat( $self->[PATH] ) || $self->_throw('stat');
  }
  
  sub lstat {
      my $self = shift;
      require File::stat;
      return File::stat::lstat( $self->[PATH] ) || $self->_throw('lstat');
  }
  
  #pod =method stringify
  #pod
  #pod     $path = path("foo.txt");
  #pod     say $path->stringify; # same as "$path"
  #pod
  #pod Returns a string representation of the path.  Unlike C<canonpath>, this method
  #pod returns the path standardized with Unix-style C</> directory separators.
  #pod
  #pod Current API available since 0.001.
  #pod
  #pod =cut
  
  sub stringify { $_[0]->[PATH] }
  
  #pod =method subsumes
  #pod
  #pod     path("foo/bar")->subsumes("foo/bar/baz"); # true
  #pod     path("/foo/bar")->subsumes("/foo/baz");   # false
  #pod
  #pod Returns true if the first path is a prefix of the second path at a directory
  #pod boundary.
  #pod
  #pod This B<does not> resolve parent directory entries (C<..>) or symlinks:
  #pod
  #pod     path("foo/bar")->subsumes("foo/bar/../baz"); # true
  #pod
  #pod If such things are important to you, ensure that both paths are resolved to
  #pod the filesystem with C<realpath>:
  #pod
  #pod     my $p1 = path("foo/bar")->realpath;
  #pod     my $p2 = path("foo/bar/../baz")->realpath;
  #pod     if ( $p1->subsumes($p2) ) { ... }
  #pod
  #pod Current API available since 0.048.
  #pod
  #pod =cut
  
  sub subsumes {
      my $self = shift;
      Carp::croak("subsumes() requires a defined, positive-length argument")
        unless defined $_[0];
      my $other = path(shift);
  
      # normalize absolute vs relative
      if ( $self->is_absolute && !$other->is_absolute ) {
          $other = $other->absolute;
      }
      elsif ( $other->is_absolute && !$self->is_absolute ) {
          $self = $self->absolute;
      }
  
      # normalize volume vs non-volume; do this after absolute path
      # adjustments above since that might add volumes already
      if ( length $self->volume && !length $other->volume ) {
          $other = $other->absolute;
      }
      elsif ( length $other->volume && !length $self->volume ) {
          $self = $self->absolute;
      }
  
      if ( $self->[PATH] eq '.' ) {
          return !!1; # cwd subsumes everything relative
      }
      elsif ( $self->is_rootdir ) {
          # a root directory ("/", "c:/") already ends with a separator
          return $other->[PATH] =~ m{^\Q$self->[PATH]\E};
      }
      else {
          # exact match or prefix breaking at a separator
          return $other->[PATH] =~ m{^\Q$self->[PATH]\E(?:/|\z)};
      }
  }
  
  #pod =method touch
  #pod
  #pod     path("foo.txt")->touch;
  #pod     path("foo.txt")->touch($epoch_secs);
  #pod
  #pod Like the Unix C<touch> utility.  Creates the file if it doesn't exist, or else
  #pod changes the modification and access times to the current time.  If the first
  #pod argument is the epoch seconds then it will be used.
  #pod
  #pod Returns the path object so it can be easily chained with other methods:
  #pod
  #pod     # won't die if foo.txt doesn't exist
  #pod     $content = path("foo.txt")->touch->slurp;
  #pod
  #pod Current API available since 0.015.
  #pod
  #pod =cut
  
  sub touch {
      my ( $self, $epoch ) = @_;
      if ( !-e $self->[PATH] ) {
          my $fh = $self->openw;
          close $fh or $self->_throw('close');
      }
      if ( defined $epoch ) {
          utime $epoch, $epoch, $self->[PATH]
            or $self->_throw("utime ($epoch)");
      }
      else {
          # literal undef prevents warnings :-(
          utime undef, undef, $self->[PATH]
            or $self->_throw("utime ()");
      }
      return $self;
  }
  
  #pod =method touchpath
  #pod
  #pod     path("bar/baz/foo.txt")->touchpath;
  #pod
  #pod Combines C<mkpath> and C<touch>.  Creates the parent directory if it doesn't exist,
  #pod before touching the file.  Returns the path object like C<touch> does.
  #pod
  #pod Current API available since 0.022.
  #pod
  #pod =cut
  
  sub touchpath {
      my ($self) = @_;
      my $parent = $self->parent;
      $parent->mkpath unless $parent->exists;
      $self->touch;
  }
  
  #pod =method visit
  #pod
  #pod     path("/tmp")->visit( \&callback, \%options );
  #pod
  #pod Executes a callback for each child of a directory.  It returns a hash
  #pod reference with any state accumulated during iteration.
  #pod
  #pod The options are the same as for L</iterator> (which it uses internally):
  #pod C<recurse> and C<follow_symlinks>.  Both default to false.
  #pod
  #pod The callback function will receive a C<Path::Tiny> object as the first argument
  #pod and a hash reference to accumulate state as the second argument.  For example:
  #pod
  #pod     # collect files sizes
  #pod     my $sizes = path("/tmp")->visit(
  #pod         sub {
  #pod             my ($path, $state) = @_;
  #pod             return if $path->is_dir;
  #pod             $state->{$path} = -s $path;
  #pod         },
  #pod         { recurse => 1 }
  #pod     );
  #pod
  #pod For convenience, the C<Path::Tiny> object will also be locally aliased as the
  #pod C<$_> global variable:
  #pod
  #pod     # print paths matching /foo/
  #pod     path("/tmp")->visit( sub { say if /foo/ }, { recurse => 1} );
  #pod
  #pod If the callback returns a B<reference> to a false scalar value, iteration will
  #pod terminate.  This is not the same as "pruning" a directory search; this just
  #pod stops all iteration and returns the state hash reference.
  #pod
  #pod     # find up to 10 files larger than 100K
  #pod     my $files = path("/tmp")->visit(
  #pod         sub {
  #pod             my ($path, $state) = @_;
  #pod             $state->{$path}++ if -s $path > 102400
  #pod             return \0 if keys %$state == 10;
  #pod         },
  #pod         { recurse => 1 }
  #pod     );
  #pod
  #pod If you want more flexible iteration, use a module like L<Path::Iterator::Rule>.
  #pod
  #pod Current API available since 0.062.
  #pod
  #pod =cut
  
  sub visit {
      my $self = shift;
      my $cb   = shift;
      my $args = _get_args( shift, qw/recurse follow_symlinks/ );
      Carp::croak("Callback for visit() must be a code reference")
        unless defined($cb) && ref($cb) eq 'CODE';
      my $next  = $self->iterator($args);
      my $state = {};
      while ( my $file = $next->() ) {
          local $_ = $file;
          my $r = $cb->( $file, $state );
          last if ref($r) eq 'SCALAR' && !$$r;
      }
      return $state;
  }
  
  #pod =method volume
  #pod
  #pod     $vol = path("/tmp/foo.txt")->volume;   # ""
  #pod     $vol = path("C:/tmp/foo.txt")->volume; # "C:"
  #pod
  #pod Returns the volume portion of the path.  This is equivalent
  #pod to what L<File::Spec> would give from C<splitpath> and thus
  #pod usually is the empty string on Unix-like operating systems or the
  #pod drive letter for an absolute path on C<MSWin32>.
  #pod
  #pod Current API available since 0.001.
  #pod
  #pod =cut
  
  sub volume {
      my ($self) = @_;
      $self->_splitpath unless defined $self->[VOL];
      return $self->[VOL];
  }
  
  package Path::Tiny::Error;
  
  our @CARP_NOT = qw/Path::Tiny/;
  
  use overload ( q{""} => sub { (shift)->{msg} }, fallback => 1 );
  
  sub throw {
      my ( $class, $op, $file, $err ) = @_;
      chomp( my $trace = Carp::shortmess );
      my $msg = "Error $op on '$file': $err$trace\n";
      die bless { op => $op, file => $file, err => $err, msg => $msg }, $class;
  }
  
  1;
  
  
  # vim: ts=4 sts=4 sw=4 et:
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Path::Tiny - File path utility
  
  =head1 VERSION
  
  version 0.124
  
  =head1 SYNOPSIS
  
    use Path::Tiny;
  
    # creating Path::Tiny objects
  
    $dir = path("/tmp");
    $foo = path("foo.txt");
  
    $subdir = $dir->child("foo");
    $bar = $subdir->child("bar.txt");
  
    # stringifies as cleaned up path
  
    $file = path("./foo.txt");
    print $file; # "foo.txt"
  
    # reading files
  
    $guts = $file->slurp;
    $guts = $file->slurp_utf8;
  
    @lines = $file->lines;
    @lines = $file->lines_utf8;
  
    ($head) = $file->lines( {count => 1} );
    ($tail) = $file->lines( {count => -1} );
  
    # writing files
  
    $bar->spew( @data );
    $bar->spew_utf8( @data );
  
    # reading directories
  
    for ( $dir->children ) { ... }
  
    $iter = $dir->iterator;
    while ( my $next = $iter->() ) { ... }
  
  =head1 DESCRIPTION
  
  This module provides a small, fast utility for working with file paths.  It is
  friendlier to use than L<File::Spec> and provides easy access to functions from
  several other core file handling modules.  It aims to be smaller and faster
  than many alternatives on CPAN, while helping people do many common things in
  consistent and less error-prone ways.
  
  Path::Tiny does not try to work for anything except Unix-like and Win32
  platforms.  Even then, it might break if you try something particularly obscure
  or tortuous.  (Quick!  What does this mean:
  C<< ///../../..//./././a//b/.././c/././ >>?  And how does it differ on Win32?)
  
  All paths are forced to have Unix-style forward slashes.  Stringifying
  the object gives you back the path (after some clean up).
  
  File input/output methods C<flock> handles before reading or writing,
  as appropriate (if supported by the platform and/or filesystem).
  
  The C<*_utf8> methods (C<slurp_utf8>, C<lines_utf8>, etc.) operate in raw
  mode.  On Windows, that means they will not have CRLF translation from the
  C<:crlf> IO layer.  Installing L<Unicode::UTF8> 0.58 or later will speed up
  C<*_utf8> situations in many cases and is highly recommended.
  Alternatively, installing L<PerlIO::utf8_strict> 0.003 or later will be
  used in place of the default C<:encoding(UTF-8)>.
  
  This module depends heavily on PerlIO layers for correct operation and thus
  requires Perl 5.008001 or later.
  
  =head1 CONSTRUCTORS
  
  =head2 path
  
      $path = path("foo/bar");
      $path = path("/tmp", "file.txt"); # list
      $path = path(".");                # cwd
      $path = path("~user/file.txt");   # tilde processing
  
  Constructs a C<Path::Tiny> object.  It doesn't matter if you give a file or
  directory path.  It's still up to you to call directory-like methods only on
  directories and file-like methods only on files.  This function is exported
  automatically by default.
  
  The first argument must be defined and have non-zero length or an exception
  will be thrown.  This prevents subtle, dangerous errors with code like
  C<< path( maybe_undef() )->remove_tree >>.
  
  If the first component of the path is a tilde ('~') then the component will be
  replaced with the output of C<glob('~')>.  If the first component of the path
  is a tilde followed by a user name then the component will be replaced with
  output of C<glob('~username')>.  Behaviour for non-existent users depends on
  the output of C<glob> on the system.
  
  On Windows, if the path consists of a drive identifier without a path component
  (C<C:> or C<D:>), it will be expanded to the absolute path of the current
  directory on that volume using C<Cwd::getdcwd()>.
  
  If called with a single C<Path::Tiny> argument, the original is returned unless
  the original is holding a temporary file or directory reference in which case a
  stringified copy is made.
  
      $path = path("foo/bar");
      $temp = Path::Tiny->tempfile;
  
      $p2 = path($path); # like $p2 = $path
      $t2 = path($temp); # like $t2 = path( "$temp" )
  
  This optimizes copies without proliferating references unexpectedly if a copy is
  made by code outside your control.
  
  Current API available since 0.017.
  
  =head2 new
  
      $path = Path::Tiny->new("foo/bar");
  
  This is just like C<path>, but with method call overhead.  (Why would you
  do that?)
  
  Current API available since 0.001.
  
  =head2 cwd
  
      $path = Path::Tiny->cwd; # path( Cwd::getcwd )
      $path = cwd; # optional export
  
  Gives you the absolute path to the current directory as a C<Path::Tiny> object.
  This is slightly faster than C<< path(".")->absolute >>.
  
  C<cwd> may be exported on request and used as a function instead of as a
  method.
  
  Current API available since 0.018.
  
  =head2 rootdir
  
      $path = Path::Tiny->rootdir; # /
      $path = rootdir;             # optional export 
  
  Gives you C<< File::Spec->rootdir >> as a C<Path::Tiny> object if you're too
  picky for C<path("/")>.
  
  C<rootdir> may be exported on request and used as a function instead of as a
  method.
  
  Current API available since 0.018.
  
  =head2 tempfile, tempdir
  
      $temp = Path::Tiny->tempfile( @options );
      $temp = Path::Tiny->tempdir( @options );
      $temp = $dirpath->tempfile( @options );
      $temp = $dirpath->tempdir( @options );
      $temp = tempfile( @options ); # optional export
      $temp = tempdir( @options );  # optional export
  
  C<tempfile> passes the options to C<< File::Temp->new >> and returns a C<Path::Tiny>
  object with the file name.  The C<TMPDIR> option is enabled by default.
  
  The resulting C<File::Temp> object is cached. When the C<Path::Tiny> object is
  destroyed, the C<File::Temp> object will be as well.
  
  C<File::Temp> annoyingly requires you to specify a custom template in slightly
  different ways depending on which function or method you call, but
  C<Path::Tiny> lets you ignore that and can take either a leading template or a
  C<TEMPLATE> option and does the right thing.
  
      $temp = Path::Tiny->tempfile( "customXXXXXXXX" );             # ok
      $temp = Path::Tiny->tempfile( TEMPLATE => "customXXXXXXXX" ); # ok
  
  The tempfile path object will be normalized to have an absolute path, even if
  created in a relative directory using C<DIR>.  If you want it to have
  the C<realpath> instead, pass a leading options hash like this:
  
      $real_temp = tempfile({realpath => 1}, @options);
  
  C<tempdir> is just like C<tempfile>, except it calls
  C<< File::Temp->newdir >> instead.
  
  Both C<tempfile> and C<tempdir> may be exported on request and used as
  functions instead of as methods.
  
  The methods can be called on an instances representing a
  directory. In this case, the directory is used as the base to create the
  temporary file/directory, setting the C<DIR> option in File::Temp.
  
      my $target_dir = path('/to/destination');
      my $tempfile = $target_dir->tempfile('foobarXXXXXX');
      $tempfile->spew('A lot of data...');  # not atomic
      $tempfile->move($target_dir->child('foobar')); # hopefully atomic
  
  In this case, any value set for option C<DIR> is ignored.
  
  B<Note>: for tempfiles, the filehandles from File::Temp are closed and not
  reused.  This is not as secure as using File::Temp handles directly, but is
  less prone to deadlocks or access problems on some platforms.  Think of what
  C<Path::Tiny> gives you to be just a temporary file B<name> that gets cleaned
  up.
  
  B<Note 2>: if you don't want these cleaned up automatically when the object
  is destroyed, File::Temp requires different options for directories and
  files.  Use C<< CLEANUP => 0 >> for directories and C<< UNLINK => 0 >> for
  files.
  
  B<Note 3>: Don't lose the temporary object by chaining a method call instead
  of storing it:
  
      my $lost = tempdir()->child("foo"); # tempdir cleaned up right away
  
  B<Note 4>: The cached object may be accessed with the L</cached_temp> method.
  Keeping a reference to, or modifying the cached object may break the
  behavior documented above and is not supported.  Use at your own risk.
  
  Current API available since 0.119.
  
  =head1 METHODS
  
  =head2 absolute
  
      $abs = path("foo/bar")->absolute;
      $abs = path("foo/bar")->absolute("/tmp");
  
  Returns a new C<Path::Tiny> object with an absolute path (or itself if already
  absolute).  If no argument is given, the current directory is used as the
  absolute base path.  If an argument is given, it will be converted to an
  absolute path (if it is not already) and used as the absolute base path.
  
  This will not resolve upward directories ("foo/../bar") unless C<canonpath>
  in L<File::Spec> would normally do so on your platform.  If you need them
  resolved, you must call the more expensive C<realpath> method instead.
  
  On Windows, an absolute path without a volume component will have it added
  based on the current drive.
  
  Current API available since 0.101.
  
  =head2 append, append_raw, append_utf8
  
      path("foo.txt")->append(@data);
      path("foo.txt")->append(\@data);
      path("foo.txt")->append({binmode => ":raw"}, @data);
      path("foo.txt")->append_raw(@data);
      path("foo.txt")->append_utf8(@data);
  
  Appends data to a file.  The file is locked with C<flock> prior to writing
  and closed afterwards.  An optional hash reference may be used to pass
  options.  Valid options are:
  
  =over 4
  
  =item *
  
  C<binmode>: passed to C<binmode()> on the handle used for writing.
  
  =item *
  
  C<truncate>: truncates the file after locking and before appending
  
  =back
  
  The C<truncate> option is a way to replace the contents of a file
  B<in place>, unlike L</spew> which writes to a temporary file and then
  replaces the original (if it exists).
  
  C<append_raw> is like C<append> with a C<binmode> of C<:unix> for fast,
  unbuffered, raw write.
  
  C<append_utf8> is like C<append> with a C<binmode> of
  C<:unix:encoding(UTF-8)> (or L<PerlIO::utf8_strict>).  If L<Unicode::UTF8>
  0.58+ is installed, a raw append will be done instead on the data encoded
  with C<Unicode::UTF8>.
  
  Current API available since 0.060.
  
  =head2 assert
  
      $path = path("foo.txt")->assert( sub { $_->exists } );
  
  Returns the invocant after asserting that a code reference argument returns
  true.  When the assertion code reference runs, it will have the invocant
  object in the C<$_> variable.  If it returns false, an exception will be
  thrown.  The assertion code reference may also throw its own exception.
  
  If no assertion is provided, the invocant is returned without error.
  
  Current API available since 0.062.
  
  =head2 basename
  
      $name = path("foo/bar.txt")->basename;        # bar.txt
      $name = path("foo.txt")->basename('.txt');    # foo
      $name = path("foo.txt")->basename(qr/.txt/);  # foo
      $name = path("foo.txt")->basename(@suffixes);
  
  Returns the file portion or last directory portion of a path.
  
  Given a list of suffixes as strings or regular expressions, any that match at
  the end of the file portion or last directory portion will be removed before
  the result is returned.
  
  Current API available since 0.054.
  
  =head2 canonpath
  
      $canonical = path("foo/bar")->canonpath; # foo\bar on Windows
  
  Returns a string with the canonical format of the path name for
  the platform.  In particular, this means directory separators
  will be C<\> on Windows.
  
  Current API available since 0.001.
  
  =head2 cached_temp
  
  Returns the cached C<File::Temp> or C<File::Temp::Dir> object if the
  C<Path::Tiny> object was created with C</tempfile> or C</tempdir>.
  If there is no such object, this method throws.
  
  B<WARNING>: Keeping a reference to, or modifying the cached object may
  break the behavior documented for temporary files and directories created
  with C<Path::Tiny> and is not supported.  Use at your own risk.
  
  Current API available since 0.101.
  
  =head2 child
  
      $file = path("/tmp")->child("foo.txt"); # "/tmp/foo.txt"
      $file = path("/tmp")->child(@parts);
  
  Returns a new C<Path::Tiny> object relative to the original.  Works
  like C<catfile> or C<catdir> from File::Spec, but without caring about
  file or directories.
  
  B<WARNING>: because the argument could contain C<..> or refer to symlinks,
  there is no guarantee that the new path refers to an actual descendent of
  the original.  If this is important to you, transform parent and child with
  L</realpath> and check them with L</subsumes>.
  
  Current API available since 0.001.
  
  =head2 children
  
      @paths = path("/tmp")->children;
      @paths = path("/tmp")->children( qr/\.txt\z/ );
  
  Returns a list of C<Path::Tiny> objects for all files and directories
  within a directory.  Excludes "." and ".." automatically.
  
  If an optional C<qr//> argument is provided, it only returns objects for child
  names that match the given regular expression.  Only the base name is used
  for matching:
  
      @paths = path("/tmp")->children( qr/^foo/ );
      # matches children like the glob foo*
  
  Current API available since 0.028.
  
  =head2 chmod
  
      path("foo.txt")->chmod(0777);
      path("foo.txt")->chmod("0755");
      path("foo.txt")->chmod("go-w");
      path("foo.txt")->chmod("a=r,u+wx");
  
  Sets file or directory permissions.  The argument can be a numeric mode, a
  octal string beginning with a "0" or a limited subset of the symbolic mode use
  by F</bin/chmod>.
  
  The symbolic mode must be a comma-delimited list of mode clauses.  Clauses must
  match C<< qr/\A([augo]+)([=+-])([rwx]+)\z/ >>, which defines "who", "op" and
  "perms" parameters for each clause.  Unlike F</bin/chmod>, all three parameters
  are required for each clause, multiple ops are not allowed and permissions
  C<stugoX> are not supported.  (See L<File::chmod> for more complex needs.)
  
  Current API available since 0.053.
  
  =head2 copy
  
      path("/tmp/foo.txt")->copy("/tmp/bar.txt");
  
  Copies the current path to the given destination using L<File::Copy>'s
  C<copy> function. Upon success, returns the C<Path::Tiny> object for the
  newly copied file.
  
  Current API available since 0.070.
  
  =head2 digest
  
      $obj = path("/tmp/foo.txt")->digest;        # SHA-256
      $obj = path("/tmp/foo.txt")->digest("MD5"); # user-selected
      $obj = path("/tmp/foo.txt")->digest( { chunk_size => 1e6 }, "MD5" );
  
  Returns a hexadecimal digest for a file.  An optional hash reference of options may
  be given.  The only option is C<chunk_size>.  If C<chunk_size> is given, that many
  bytes will be read at a time.  If not provided, the entire file will be slurped
  into memory to compute the digest.
  
  Any subsequent arguments are passed to the constructor for L<Digest> to select
  an algorithm.  If no arguments are given, the default is SHA-256.
  
  Current API available since 0.056.
  
  =head2 dirname (deprecated)
  
      $name = path("/tmp/foo.txt")->dirname; # "/tmp/"
  
  Returns the directory portion you would get from calling
  C<< File::Spec->splitpath( $path->stringify ) >> or C<"."> for a path without a
  parent directory portion.  Because L<File::Spec> is inconsistent, the result
  might or might not have a trailing slash.  Because of this, this method is
  B<deprecated>.
  
  A better, more consistently approach is likely C<< $path->parent->stringify >>,
  which will not have a trailing slash except for a root directory.
  
  Deprecated in 0.056.
  
  =head2 edit, edit_raw, edit_utf8
  
      path("foo.txt")->edit( \&callback, $options );
      path("foo.txt")->edit_utf8( \&callback );
      path("foo.txt")->edit_raw( \&callback );
  
  These are convenience methods that allow "editing" a file using a single
  callback argument. They slurp the file using C<slurp>, place the contents
  inside a localized C<$_> variable, call the callback function (without
  arguments), and then write C<$_> (presumably mutated) back to the
  file with C<spew>.
  
  An optional hash reference may be used to pass options.  The only option is
  C<binmode>, which is passed to C<slurp> and C<spew>.
  
  C<edit_utf8> and C<edit_raw> act like their respective C<slurp_*> and
  C<spew_*> methods.
  
  Current API available since 0.077.
  
  =head2 edit_lines, edit_lines_utf8, edit_lines_raw
  
      path("foo.txt")->edit_lines( \&callback, $options );
      path("foo.txt")->edit_lines_utf8( \&callback );
      path("foo.txt")->edit_lines_raw( \&callback );
  
  These are convenience methods that allow "editing" a file's lines using a
  single callback argument.  They iterate over the file: for each line, the
  line is put into a localized C<$_> variable, the callback function is
  executed (without arguments) and then C<$_> is written to a temporary file.
  When iteration is finished, the temporary file is atomically renamed over
  the original.
  
  An optional hash reference may be used to pass options.  The only option is
  C<binmode>, which is passed to the method that open handles for reading and
  writing.
  
  C<edit_lines_utf8> and C<edit_lines_raw> act like their respective
  C<slurp_*> and C<spew_*> methods.
  
  Current API available since 0.077.
  
  =head2 exists, is_file, is_dir
  
      if ( path("/tmp")->exists ) { ... }     # -e
      if ( path("/tmp")->is_dir ) { ... }     # -d
      if ( path("/tmp")->is_file ) { ... }    # -e && ! -d
  
  Implements file test operations, this means the file or directory actually has
  to exist on the filesystem.  Until then, it's just a path.
  
  B<Note>: C<is_file> is not C<-f> because C<-f> is not the opposite of C<-d>.
  C<-f> means "plain file", excluding symlinks, devices, etc. that often can be
  read just like files.
  
  Use C<-f> instead if you really mean to check for a plain file.
  
  Current API available since 0.053.
  
  =head2 filehandle
  
      $fh = path("/tmp/foo.txt")->filehandle($mode, $binmode);
      $fh = path("/tmp/foo.txt")->filehandle({ locked => 1 }, $mode, $binmode);
      $fh = path("/tmp/foo.txt")->filehandle({ exclusive => 1  }, $mode, $binmode);
  
  Returns an open file handle.  The C<$mode> argument must be a Perl-style
  read/write mode string ("<" ,">", ">>", etc.).  If a C<$binmode>
  is given, it is set during the C<open> call.
  
  An optional hash reference may be used to pass options.
  
  The C<locked> option governs file locking; if true, handles opened for writing,
  appending or read-write are locked with C<LOCK_EX>; otherwise, they are
  locked with C<LOCK_SH>.  When using C<locked>, ">" or "+>" modes will delay
  truncation until after the lock is acquired.
  
  The C<exclusive> option causes the open() call to fail if the file already
  exists.  This corresponds to the O_EXCL flag to sysopen / open(2).
  C<exclusive> implies C<locked> and will set it for you if you forget it.
  
  See C<openr>, C<openw>, C<openrw>, and C<opena> for sugar.
  
  Current API available since 0.066.
  
  =head2 is_absolute, is_relative
  
      if ( path("/tmp")->is_absolute ) { ... }
      if ( path("/tmp")->is_relative ) { ... }
  
  Booleans for whether the path appears absolute or relative.
  
  Current API available since 0.001.
  
  =head2 is_rootdir
  
      while ( ! $path->is_rootdir ) {
          $path = $path->parent;
          ...
      }
  
  Boolean for whether the path is the root directory of the volume.  I.e. the
  C<dirname> is C<q[/]> and the C<basename> is C<q[]>.
  
  This works even on C<MSWin32> with drives and UNC volumes:
  
      path("C:/")->is_rootdir;             # true
      path("//server/share/")->is_rootdir; #true
  
  Current API available since 0.038.
  
  =head2 iterator
  
      $iter = path("/tmp")->iterator( \%options );
  
  Returns a code reference that walks a directory lazily.  Each invocation
  returns a C<Path::Tiny> object or undef when the iterator is exhausted.
  
      $iter = path("/tmp")->iterator;
      while ( $path = $iter->() ) {
          ...
      }
  
  The current and parent directory entries ("." and "..") will not
  be included.
  
  If the C<recurse> option is true, the iterator will walk the directory
  recursively, breadth-first.  If the C<follow_symlinks> option is also true,
  directory links will be followed recursively.  There is no protection against
  loops when following links. If a directory is not readable, it will not be
  followed.
  
  The default is the same as:
  
      $iter = path("/tmp")->iterator( {
          recurse         => 0,
          follow_symlinks => 0,
      } );
  
  For a more powerful, recursive iterator with built-in loop avoidance, see
  L<Path::Iterator::Rule>.
  
  See also L</visit>.
  
  Current API available since 0.016.
  
  =head2 lines, lines_raw, lines_utf8
  
      @contents = path("/tmp/foo.txt")->lines;
      @contents = path("/tmp/foo.txt")->lines(\%options);
      @contents = path("/tmp/foo.txt")->lines_raw;
      @contents = path("/tmp/foo.txt")->lines_utf8;
  
      @contents = path("/tmp/foo.txt")->lines( { chomp => 1, count => 4 } );
  
  Returns a list of lines from a file.  Optionally takes a hash-reference of
  options.  Valid options are C<binmode>, C<count> and C<chomp>.
  
  If C<binmode> is provided, it will be set on the handle prior to reading.
  
  If a positive C<count> is provided, that many lines will be returned from the
  start of the file.  If a negative C<count> is provided, the entire file will be
  read, but only C<abs(count)> will be kept and returned.  If C<abs(count)>
  exceeds the number of lines in the file, all lines will be returned.
  
  If C<chomp> is set, any end-of-line character sequences (C<CR>, C<CRLF>, or
  C<LF>) will be removed from the lines returned.
  
  Because the return is a list, C<lines> in scalar context will return the number
  of lines (and throw away the data).
  
      $number_of_lines = path("/tmp/foo.txt")->lines;
  
  C<lines_raw> is like C<lines> with a C<binmode> of C<:raw>.  We use C<:raw>
  instead of C<:unix> so PerlIO buffering can manage reading by line.
  
  C<lines_utf8> is like C<lines> with a C<binmode> of C<:raw:encoding(UTF-8)>
  (or L<PerlIO::utf8_strict>).  If L<Unicode::UTF8> 0.58+ is installed, a raw
  UTF-8 slurp will be done and then the lines will be split.  This is
  actually faster than relying on C<:encoding(UTF-8)>, though a bit memory
  intensive.  If memory use is a concern, consider C<openr_utf8> and
  iterating directly on the handle.
  
  Current API available since 0.065.
  
  =head2 mkpath
  
      path("foo/bar/baz")->mkpath;
      path("foo/bar/baz")->mkpath( \%options );
  
  Like calling C<make_path> from L<File::Path>.  An optional hash reference
  is passed through to C<make_path>.  Errors will be trapped and an exception
  thrown.  Returns the list of directories created or an empty list if
  the directories already exist, just like C<make_path>.
  
  See also L</touchpath> as a chainable alternative to create a writeable file path
  (though without options).
  
  Current API available since 0.001.
  
  =head2 move
  
      path("foo.txt")->move("bar.txt");
  
  Move the current path to the given destination path using Perl's
  built-in L<rename|perlfunc/rename> function. Returns the result
  of the C<rename> function (except it throws an exception if it fails).
  
  Current API available since 0.001.
  
  =head2 openr, openw, openrw, opena
  
      $fh = path("foo.txt")->openr($binmode);  # read
      $fh = path("foo.txt")->openr_raw;
      $fh = path("foo.txt")->openr_utf8;
  
      $fh = path("foo.txt")->openw($binmode);  # write
      $fh = path("foo.txt")->openw_raw;
      $fh = path("foo.txt")->openw_utf8;
  
      $fh = path("foo.txt")->opena($binmode);  # append
      $fh = path("foo.txt")->opena_raw;
      $fh = path("foo.txt")->opena_utf8;
  
      $fh = path("foo.txt")->openrw($binmode); # read/write
      $fh = path("foo.txt")->openrw_raw;
      $fh = path("foo.txt")->openrw_utf8;
  
  Returns a file handle opened in the specified mode.  The C<openr> style methods
  take a single C<binmode> argument.  All of the C<open*> methods have
  C<open*_raw> and C<open*_utf8> equivalents that use C<:raw> and
  C<:raw:encoding(UTF-8)>, respectively.
  
  An optional hash reference may be used to pass options.  The only option is
  C<locked>.  If true, handles opened for writing, appending or read-write are
  locked with C<LOCK_EX>; otherwise, they are locked for C<LOCK_SH>.
  
      $fh = path("foo.txt")->openrw_utf8( { locked => 1 } );
  
  See L</filehandle> for more on locking.
  
  Current API available since 0.011.
  
  =head2 parent
  
      $parent = path("foo/bar/baz")->parent; # foo/bar
      $parent = path("foo/wibble.txt")->parent; # foo
  
      $parent = path("foo/bar/baz")->parent(2); # foo
  
  Returns a C<Path::Tiny> object corresponding to the parent directory of the
  original directory or file. An optional positive integer argument is the number
  of parent directories upwards to return.  C<parent> by itself is equivalent to
  C<parent(1)>.
  
  Current API available since 0.014.
  
  =head2 realpath
  
      $real = path("/baz/foo/../bar")->realpath;
      $real = path("foo/../bar")->realpath;
  
  Returns a new C<Path::Tiny> object with all symbolic links and upward directory
  parts resolved using L<Cwd>'s C<realpath>.  Compared to C<absolute>, this is
  more expensive as it must actually consult the filesystem.
  
  If the parent path can't be resolved (e.g. if it includes directories that
  don't exist), an exception will be thrown:
  
      $real = path("doesnt_exist/foo")->realpath; # dies
  
  However, if the parent path exists and only the last component (e.g. filename)
  doesn't exist, the realpath will be the realpath of the parent plus the
  non-existent last component:
  
      $real = path("./aasdlfasdlf")->realpath; # works
  
  The underlying L<Cwd> module usually worked this way on Unix, but died on
  Windows (and some Unixes) if the full path didn't exist.  As of version 0.064,
  it's safe to use anywhere.
  
  Current API available since 0.001.
  
  =head2 relative
  
      $rel = path("/tmp/foo/bar")->relative("/tmp"); # foo/bar
  
  Returns a C<Path::Tiny> object with a path relative to a new base path
  given as an argument.  If no argument is given, the current directory will
  be used as the new base path.
  
  If either path is already relative, it will be made absolute based on the
  current directly before determining the new relative path.
  
  The algorithm is roughly as follows:
  
  =over 4
  
  =item *
  
  If the original and new base path are on different volumes, an exception will be thrown.
  
  =item *
  
  If the original and new base are identical, the relative path is C<".">.
  
  =item *
  
  If the new base subsumes the original, the relative path is the original path with the new base chopped off the front
  
  =item *
  
  If the new base does not subsume the original, a common prefix path is determined (possibly the root directory) and the relative path will consist of updirs (C<"..">) to reach the common prefix, followed by the original path less the common prefix.
  
  =back
  
  Unlike C<File::Spec::abs2rel>, in the last case above, the calculation based
  on a common prefix takes into account symlinks that could affect the updir
  process.  Given an original path "/A/B" and a new base "/A/C",
  (where "A", "B" and "C" could each have multiple path components):
  
  =over 4
  
  =item *
  
  Symlinks in "A" don't change the result unless the last component of A is a symlink and the first component of "C" is an updir.
  
  =item *
  
  Symlinks in "B" don't change the result and will exist in the result as given.
  
  =item *
  
  Symlinks and updirs in "C" must be resolved to actual paths, taking into account the possibility that not all path components might exist on the filesystem.
  
  =back
  
  Current API available since 0.001.  New algorithm (that accounts for
  symlinks) available since 0.079.
  
  =head2 remove
  
      path("foo.txt")->remove;
  
  This is just like C<unlink>, except for its error handling: if the path does
  not exist, it returns false; if deleting the file fails, it throws an
  exception.
  
  Current API available since 0.012.
  
  =head2 remove_tree
  
      # directory
      path("foo/bar/baz")->remove_tree;
      path("foo/bar/baz")->remove_tree( \%options );
      path("foo/bar/baz")->remove_tree( { safe => 0 } ); # force remove
  
  Like calling C<remove_tree> from L<File::Path>, but defaults to C<safe> mode.
  An optional hash reference is passed through to C<remove_tree>.  Errors will be
  trapped and an exception thrown.  Returns the number of directories deleted,
  just like C<remove_tree>.
  
  If you want to remove a directory only if it is empty, use the built-in
  C<rmdir> function instead.
  
      rmdir path("foo/bar/baz/");
  
  Current API available since 0.013.
  
  =head2 sibling
  
      $foo = path("/tmp/foo.txt");
      $sib = $foo->sibling("bar.txt");        # /tmp/bar.txt
      $sib = $foo->sibling("baz", "bam.txt"); # /tmp/baz/bam.txt
  
  Returns a new C<Path::Tiny> object relative to the parent of the original.
  This is slightly more efficient than C<< $path->parent->child(...) >>.
  
  Current API available since 0.058.
  
  =head2 size, size_human
  
      my $p = path("foo"); # with size 1025 bytes
  
      $p->size;                            # "1025"
      $p->size_human;                      # "1.1 K"
      $p->size_human( {format => "iec"} ); # "1.1 KiB"
  
  Returns the size of a file.  The C<size> method is just a wrapper around C<-s>.
  
  The C<size_human> method provides a human-readable string similar to
  C<ls -lh>.  Like C<ls>, it rounds upwards and provides one decimal place for
  single-digit sizes and no decimal places for larger sizes.  The only available
  option is C<format>, which has three valid values:
  
  =over 4
  
  =item *
  
  'ls' (the default): base-2 sizes, with C<ls> style single-letter suffixes (K, M, etc.)
  
  =item *
  
  'iec': base-2 sizes, with IEC binary suffixes (KiB, MiB, etc.)
  
  =item *
  
  'si': base-10 sizes, with SI decimal suffixes (kB, MB, etc.)
  
  =back
  
  If C<-s> would return C<undef>, C<size_human> returns the empty string.
  
  Current API available since 0.122.
  
  =head2 slurp, slurp_raw, slurp_utf8
  
      $data = path("foo.txt")->slurp;
      $data = path("foo.txt")->slurp( {binmode => ":raw"} );
      $data = path("foo.txt")->slurp_raw;
      $data = path("foo.txt")->slurp_utf8;
  
  Reads file contents into a scalar.  Takes an optional hash reference which may
  be used to pass options.  The only available option is C<binmode>, which is
  passed to C<binmode()> on the handle used for reading.
  
  C<slurp_raw> is like C<slurp> with a C<binmode> of C<:unix> for
  a fast, unbuffered, raw read.
  
  C<slurp_utf8> is like C<slurp> with a C<binmode> of
  C<:unix:encoding(UTF-8)> (or L<PerlIO::utf8_strict>).  If L<Unicode::UTF8>
  0.58+ is installed, a raw slurp will be done instead and the result decoded
  with C<Unicode::UTF8>.  This is just as strict and is roughly an order of
  magnitude faster than using C<:encoding(UTF-8)>.
  
  B<Note>: C<slurp> and friends lock the filehandle before slurping.  If
  you plan to slurp from a file created with L<File::Temp>, be sure to
  close other handles or open without locking to avoid a deadlock:
  
      my $tempfile = File::Temp->new(EXLOCK => 0);
      my $guts = path($tempfile)->slurp;
  
  Current API available since 0.004.
  
  =head2 spew, spew_raw, spew_utf8
  
      path("foo.txt")->spew(@data);
      path("foo.txt")->spew(\@data);
      path("foo.txt")->spew({binmode => ":raw"}, @data);
      path("foo.txt")->spew_raw(@data);
      path("foo.txt")->spew_utf8(@data);
  
  Writes data to a file atomically.  The file is written to a temporary file in
  the same directory, then renamed over the original.  An optional hash reference
  may be used to pass options.  The only option is C<binmode>, which is passed to
  C<binmode()> on the handle used for writing.
  
  C<spew_raw> is like C<spew> with a C<binmode> of C<:unix> for a fast,
  unbuffered, raw write.
  
  C<spew_utf8> is like C<spew> with a C<binmode> of C<:unix:encoding(UTF-8)>
  (or L<PerlIO::utf8_strict>).  If L<Unicode::UTF8> 0.58+ is installed, a raw
  spew will be done instead on the data encoded with C<Unicode::UTF8>.
  
  B<NOTE>: because the file is written to a temporary file and then renamed, the
  new file will wind up with permissions based on your current umask.  This is a
  feature to protect you from a race condition that would otherwise give
  different permissions than you might expect.  If you really want to keep the
  original mode flags, use L</append> with the C<truncate> option.
  
  Current API available since 0.011.
  
  =head2 stat, lstat
  
      $stat = path("foo.txt")->stat;
      $stat = path("/some/symlink")->lstat;
  
  Like calling C<stat> or C<lstat> from L<File::stat>.
  
  Current API available since 0.001.
  
  =head2 stringify
  
      $path = path("foo.txt");
      say $path->stringify; # same as "$path"
  
  Returns a string representation of the path.  Unlike C<canonpath>, this method
  returns the path standardized with Unix-style C</> directory separators.
  
  Current API available since 0.001.
  
  =head2 subsumes
  
      path("foo/bar")->subsumes("foo/bar/baz"); # true
      path("/foo/bar")->subsumes("/foo/baz");   # false
  
  Returns true if the first path is a prefix of the second path at a directory
  boundary.
  
  This B<does not> resolve parent directory entries (C<..>) or symlinks:
  
      path("foo/bar")->subsumes("foo/bar/../baz"); # true
  
  If such things are important to you, ensure that both paths are resolved to
  the filesystem with C<realpath>:
  
      my $p1 = path("foo/bar")->realpath;
      my $p2 = path("foo/bar/../baz")->realpath;
      if ( $p1->subsumes($p2) ) { ... }
  
  Current API available since 0.048.
  
  =head2 touch
  
      path("foo.txt")->touch;
      path("foo.txt")->touch($epoch_secs);
  
  Like the Unix C<touch> utility.  Creates the file if it doesn't exist, or else
  changes the modification and access times to the current time.  If the first
  argument is the epoch seconds then it will be used.
  
  Returns the path object so it can be easily chained with other methods:
  
      # won't die if foo.txt doesn't exist
      $content = path("foo.txt")->touch->slurp;
  
  Current API available since 0.015.
  
  =head2 touchpath
  
      path("bar/baz/foo.txt")->touchpath;
  
  Combines C<mkpath> and C<touch>.  Creates the parent directory if it doesn't exist,
  before touching the file.  Returns the path object like C<touch> does.
  
  Current API available since 0.022.
  
  =head2 visit
  
      path("/tmp")->visit( \&callback, \%options );
  
  Executes a callback for each child of a directory.  It returns a hash
  reference with any state accumulated during iteration.
  
  The options are the same as for L</iterator> (which it uses internally):
  C<recurse> and C<follow_symlinks>.  Both default to false.
  
  The callback function will receive a C<Path::Tiny> object as the first argument
  and a hash reference to accumulate state as the second argument.  For example:
  
      # collect files sizes
      my $sizes = path("/tmp")->visit(
          sub {
              my ($path, $state) = @_;
              return if $path->is_dir;
              $state->{$path} = -s $path;
          },
          { recurse => 1 }
      );
  
  For convenience, the C<Path::Tiny> object will also be locally aliased as the
  C<$_> global variable:
  
      # print paths matching /foo/
      path("/tmp")->visit( sub { say if /foo/ }, { recurse => 1} );
  
  If the callback returns a B<reference> to a false scalar value, iteration will
  terminate.  This is not the same as "pruning" a directory search; this just
  stops all iteration and returns the state hash reference.
  
      # find up to 10 files larger than 100K
      my $files = path("/tmp")->visit(
          sub {
              my ($path, $state) = @_;
              $state->{$path}++ if -s $path > 102400
              return \0 if keys %$state == 10;
          },
          { recurse => 1 }
      );
  
  If you want more flexible iteration, use a module like L<Path::Iterator::Rule>.
  
  Current API available since 0.062.
  
  =head2 volume
  
      $vol = path("/tmp/foo.txt")->volume;   # ""
      $vol = path("C:/tmp/foo.txt")->volume; # "C:"
  
  Returns the volume portion of the path.  This is equivalent
  to what L<File::Spec> would give from C<splitpath> and thus
  usually is the empty string on Unix-like operating systems or the
  drive letter for an absolute path on C<MSWin32>.
  
  Current API available since 0.001.
  
  =for Pod::Coverage openr_utf8 opena_utf8 openw_utf8 openrw_utf8
  openr_raw opena_raw openw_raw openrw_raw
  IS_WIN32 FREEZE THAW TO_JSON abs2rel
  
  =head1 EXCEPTION HANDLING
  
  Simple usage errors will generally croak.  Failures of underlying Perl
  functions will be thrown as exceptions in the class
  C<Path::Tiny::Error>.
  
  A C<Path::Tiny::Error> object will be a hash reference with the following fields:
  
  =over 4
  
  =item *
  
  C<op>  a description of the operation, usually function call and any extra info
  
  =item *
  
  C<file>  the file or directory relating to the error
  
  =item *
  
  C<err>  hold C<$!> at the time the error was thrown
  
  =item *
  
  C<msg>  a string combining the above data and a Carp-like short stack trace
  
  =back
  
  Exception objects will stringify as the C<msg> field.
  
  =head1 ENVIRONMENT
  
  =head2 PERL_PATH_TINY_NO_FLOCK
  
  If the environment variable C<PERL_PATH_TINY_NO_FLOCK> is set to a true
  value then flock will NOT be used when accessing files (this is not
  recommended).
  
  =head1 CAVEATS
  
  =head2 Subclassing not supported
  
  For speed, this class is implemented as an array based object and uses many
  direct function calls internally.  You must not subclass it and expect
  things to work properly.
  
  =head2 File locking
  
  If flock is not supported on a platform, it will not be used, even if
  locking is requested.
  
  In situations where a platform normally would support locking, but the
  flock fails due to a filesystem limitation, Path::Tiny has some heuristics
  to detect this and will warn once and continue in an unsafe mode.  If you
  want this failure to be fatal, you can fatalize the 'flock' warnings
  category:
  
      use warnings FATAL => 'flock';
  
  See additional caveats below.
  
  =head3 NFS and BSD
  
  On BSD, Perl's flock implementation may not work to lock files on an
  NFS filesystem.  If detected, this situation will warn once, as described
  above.
  
  =head3 Lustre
  
  The Lustre filesystem does not support flock.  If detected, this situation
  will warn once, as described above.
  
  =head3 AIX and locking
  
  AIX requires a write handle for locking.  Therefore, calls that normally
  open a read handle and take a shared lock instead will open a read-write
  handle and take an exclusive lock.  If the user does not have write
  permission, no lock will be used.
  
  =head2 utf8 vs UTF-8
  
  All the C<*_utf8> methods by default use C<:encoding(UTF-8)> -- either as
  C<:unix:encoding(UTF-8)> (unbuffered) or C<:raw:encoding(UTF-8)> (buffered) --
  which is strict against the Unicode spec and disallows illegal Unicode
  codepoints or UTF-8 sequences.
  
  Unfortunately, C<:encoding(UTF-8)> is very, very slow.  If you install
  L<Unicode::UTF8> 0.58 or later, that module will be used by some C<*_utf8>
  methods to encode or decode data after a raw, binary input/output operation,
  which is much faster.  Alternatively, if you install L<PerlIO::utf8_strict>,
  that will be used instead of C<:encoding(UTF-8)> and is also very fast.
  
  If you need the performance and can accept the security risk,
  C<< slurp({binmode => ":unix:utf8"}) >> will be faster than C<:unix:encoding(UTF-8)>
  (but not as fast as C<Unicode::UTF8>).
  
  Note that the C<*_utf8> methods read in B<raw> mode.  There is no CRLF
  translation on Windows.  If you must have CRLF translation, use the regular
  input/output methods with an appropriate binmode:
  
    $path->spew_utf8($data);                            # raw
    $path->spew({binmode => ":encoding(UTF-8)"}, $data; # LF -> CRLF
  
  =head2 Default IO layers and the open pragma
  
  If you have Perl 5.10 or later, file input/output methods (C<slurp>, C<spew>,
  etc.) and high-level handle opening methods ( C<filehandle>, C<openr>,
  C<openw>, etc. ) respect default encodings set by the C<-C> switch or lexical
  L<open> settings of the caller.  For UTF-8, this is almost certainly slower
  than using the dedicated C<_utf8> methods if you have L<Unicode::UTF8>.
  
  =head1 TYPE CONSTRAINTS AND COERCION
  
  A standard L<MooseX::Types> library is available at
  L<MooseX::Types::Path::Tiny>.  A L<Type::Tiny> equivalent is available as
  L<Types::Path::Tiny>.
  
  =head1 SEE ALSO
  
  These are other file/path utilities, which may offer a different feature
  set than C<Path::Tiny>.
  
  =over 4
  
  =item *
  
  L<File::chmod>
  
  =item *
  
  L<File::Fu>
  
  =item *
  
  L<IO::All>
  
  =item *
  
  L<Path::Class>
  
  =back
  
  These iterators may be slightly faster than the recursive iterator in
  C<Path::Tiny>:
  
  =over 4
  
  =item *
  
  L<Path::Iterator::Rule>
  
  =item *
  
  L<File::Next>
  
  =back
  
  There are probably comparable, non-Tiny tools.  Let me know if you want me to
  add a module to the list.
  
  This module was featured in the L<2013 Perl Advent Calendar|http://www.perladvent.org/2013/2013-12-18.html>.
  
  =for :stopwords cpan testmatrix url bugtracker rt cpants kwalitee diff irc mailto metadata placeholders metacpan
  
  =head1 SUPPORT
  
  =head2 Bugs / Feature Requests
  
  Please report any bugs or feature requests through the issue tracker
  at L<https://github.com/dagolden/Path-Tiny/issues>.
  You will be notified automatically of any progress on your issue.
  
  =head2 Source Code
  
  This is open source software.  The code repository is available for
  public review and contribution under the terms of the license.
  
  L<https://github.com/dagolden/Path-Tiny>
  
    git clone https://github.com/dagolden/Path-Tiny.git
  
  =head1 AUTHOR
  
  David Golden <dagolden@cpan.org>
  
  =head1 CONTRIBUTORS
  
  =for stopwords Alex Efros Aristotle Pagaltzis Chris Williams Dan Book Dave Rolsky David Steinbrunner Doug Bell Flavio Poletti Gabor Szabo Gabriel Andrade George Hartzell Geraud Continsouzas Goro Fuji Graham Knop Ollis Ian Sillitoe James Hunt John Karr Karen Etheridge Mark Ellis Martin H. Sluka Kjeldsen Michael G. Schwern Nigel Gregoire Philippe Bruhat (BooK) regina-verbae Roy Ivy III Shlomi Fish Smylers Tatsuhiko Miyagawa Toby Inkster Yanick Champoux  - Keedi Kim
  
  =over 4
  
  =item *
  
  Alex Efros <powerman@powerman.name>
  
  =item *
  
  Aristotle Pagaltzis <pagaltzis@gmx.de>
  
  =item *
  
  Chris Williams <bingos@cpan.org>
  
  =item *
  
  Dan Book <grinnz@grinnz.com>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  David Steinbrunner <dsteinbrunner@pobox.com>
  
  =item *
  
  Doug Bell <madcityzen@gmail.com>
  
  =item *
  
  Flavio Poletti <flavio@polettix.it>
  
  =item *
  
  Gabor Szabo <szabgab@cpan.org>
  
  =item *
  
  Gabriel Andrade <gabiruh@gmail.com>
  
  =item *
  
  George Hartzell <hartzell@cpan.org>
  
  =item *
  
  Geraud Continsouzas <geraud@scsi.nc>
  
  =item *
  
  Goro Fuji <gfuji@cpan.org>
  
  =item *
  
  Graham Knop <haarg@haarg.org>
  
  =item *
  
  Graham Ollis <plicease@cpan.org>
  
  =item *
  
  Ian Sillitoe <ian@sillit.com>
  
  =item *
  
  James Hunt <james@niftylogic.com>
  
  =item *
  
  John Karr <brainbuz@brainbuz.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Mark Ellis <mark.ellis@cartridgesave.co.uk>
  
  =item *
  
  Martin H. Sluka <fany@cpan.org>
  
  =item *
  
  Martin Kjeldsen <mk@bluepipe.dk>
  
  =item *
  
  Michael G. Schwern <mschwern@cpan.org>
  
  =item *
  
  Nigel Gregoire <nigelgregoire@gmail.com>
  
  =item *
  
  Philippe Bruhat (BooK) <book@cpan.org>
  
  =item *
  
  regina-verbae <regina-verbae@users.noreply.github.com>
  
  =item *
  
  Roy Ivy III <rivy@cpan.org>
  
  =item *
  
  Shlomi Fish <shlomif@shlomifish.org>
  
  =item *
  
  Smylers <Smylers@stripey.com>
  
  =item *
  
  Tatsuhiko Miyagawa <miyagawa@bulknews.net>
  
  =item *
  
  Toby Inkster <tobyink@cpan.org>
  
  =item *
  
  Yanick Champoux <yanick@babyl.dyndns.org>
  
  =item *
  
   - Keedi Kim <keedi@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2014 by David Golden.
  
  This is free software, licensed under:
  
    The Apache License, Version 2.0, January 2004
  
  =cut
PATH_TINY

$fatpacked{"Web/DOM/Attr.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WEB_DOM_ATTR';
  package Web::DOM::Attr;
  use strict;
  use warnings;
  our $VERSION = '3.0';
  use Web::DOM::Node;
  push our @ISA, qw(Web::DOM::Node);
  use Web::DOM::TypeError;
  
  our @EXPORT;
  
  *node_name = \&name;
  *manakai_name = \&name;
  
  sub name ($) {
    if (${$_[0]}->[2]->{prefix}) {
      return ${${$_[0]}->[2]->{prefix}} . ':' . ${${$_[0]}->[2]->{local_name}};
    } else {
      return ${${$_[0]}->[2]->{local_name}};
    }
  } # name
  
  sub is_id ($) {
    return (not ${$_[0]}->[2]->{namespace_uri} and
            ${${$_[0]}->[2]->{local_name}} eq 'id');
  } # is_id
  
  sub value ($;$) {
    if (@_ > 1) {
      # XXX mutation?
  
      # IndexedString
      ${$_[0]}->[2]->{data} = [[defined $_[1] ? ''.$_[1] : '', -1, 0]];
      ## |textContent| and |nodeValue| do not have
      ## [TreatNullAs=EmptyString], while |value| does not.
  
      if (my $oe = $_[0]->owner_element) {
        $oe->_attribute_is
            (${$_[0]}->[2]->{namespace_uri}, ${$_[0]}->[2]->{local_name},
             set => 1, changed => 1);
      }
    }
    return join '', map { $_->[0] } @{${$_[0]}->[2]->{data}}; # IndexedString
  } # value
  
  *node_value = \&value;
  *text_content = \&value;
  
  sub manakai_get_indexed_string ($) {
    return [map {
      [$_->[0], $_->[1], $_->[2]]; # string copy
    } @{${$_[0]}->[2]->{data}}]; # IndexedString
  } # manakai_get_indexed_string
  
  sub manakai_append_text ($$) {
    # XXX mutation?
  
    # IndexedStringSegment
    my $segment = [ref $_[1] eq 'SCALAR' ? ${$_[1]} : $_[1], -1, 0];
    $segment->[0] = ''.$segment->[0] if ref $_[1];
  
    push @{${$_[0]}->[2]->{data}}, $segment;
  
    if (my $oe = $_[0]->owner_element) {
      $oe->_attribute_is
          (${$_[0]}->[2]->{namespace_uri}, ${$_[0]}->[2]->{local_name},
           set => 1, changed => 1);
    }
    return $_[0];
  } # manakai_append_text
  
  sub manakai_append_indexed_string ($$) {
    # XXX mutation?
  
    # IndexedString
    _throw Web::DOM::TypeError 'The argument is not an IndexedString'
        if not ref $_[1] eq 'ARRAY' or
           grep { not ref $_ eq 'ARRAY' } @{$_[1]};
  
    push @{${$_[0]}->[2]->{data}}, map {
      [''.$_->[0], 0+$_->[1], 0+$_->[2]]; # string copy
    } @{$_[1]};
  
    if (my $oe = $_[0]->owner_element) {
      $oe->_attribute_is
          (${$_[0]}->[2]->{namespace_uri}, ${$_[0]}->[2]->{local_name},
           set => 1, changed => 1);
    }
  
    return;
  } # manakai_append_indexed_string
  
  sub specified ($) { 1 }
  
  sub owner_element ($) {
    if (my $id = ${$_[0]}->[2]->{owner}) {
      return ${$_[0]}->[0]->node ($id);
    } else {
      return undef;
    }
  } # owner_element
  
  ## |DeclaredValueType|
  sub NO_TYPE_ATTR () { 0 }
  sub CDATA_ATTR () { 1 }
  sub ID_ATTR () { 2 }
  sub IDREF_ATTR () { 3 }
  sub IDREFS_ATTR () { 4 }
  sub ENTITY_ATTR () { 5 }
  sub ENTITIES_ATTR () { 6 }
  sub NMTOKEN_ATTR () { 7 }
  sub NMTOKENS_ATTR () { 8 }
  sub NOTATION_ATTR () { 9 }
  sub ENUMERATION_ATTR () { 10 }
  sub UNKNOWN_ATTR () { 11 }
  
  push @EXPORT, qw(
    NO_TYPE_ATTR CDATA_ATTR ID_ATTR IDREF_ATTR IDREFS_ATTR ENTITY_ATTR
    ENTITIES_ATTR NMTOKEN_ATTR NMTOKENS_ATTR NOTATION_ATTR ENUMERATION_ATTR
    UNKNOWN_ATTR
  );
  
  sub manakai_attribute_type ($;$) {
    if (@_ > 1) {
      ${$_[0]}->[2]->{attribute_type} = $_[1] % 2**16;
    }
    return ${$_[0]}->[2]->{attribute_type} || 0;
  } # manakai_attribute_type
  
  1;
  
  =head1 LICENSE
  
  Copyright 2012-2015 Wakaba <wakaba@suikawiki.org>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
WEB_DOM_ATTR

$fatpacked{"Web/DOM/CharacterData.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WEB_DOM_CHARACTERDATA';
  package Web::DOM::CharacterData;
  use strict;
  use warnings;
  no warnings 'utf8';
  our $VERSION = '3.0';
  use Web::DOM::Internal;
  use Web::DOM::Node;
  use Web::DOM::ChildNode;
  push our @ISA, qw(Web::DOM::Node Web::DOM::ChildNode);
  use Web::DOM::TypeError;
  
  *node_value = \&data;
  *text_content = \&data;
  
  sub data ($;$) {
    if (@_ > 1) {
      ## "Replace data" steps (simplified)
      # XXX mutation record
      @{${$_[0]}->[2]->{data}} = ([defined $_[1] ? ''.$_[1] : '', -1, 0]); # WebIDL; IndexedStringSegment
      # XXX range
    }
    return join '', map { $_->[0] } @{${$_[0]}->[2]->{data}}; # IndexedString
  } # data
  
  sub manakai_get_indexed_string ($) {
    return [map {
      [$_->[0], $_->[1], $_->[2]]; # string copy
    } @{${$_[0]}->[2]->{data}}]; # IndexedString
  } # manakai_get_indexed_string
  
  sub length ($) {
    my $data = $_[0]->data;
    my $length = CORE::length $data;
    if ($data =~ /[\x{10000}-\x{10FFFF}]/) {
      $length += $data =~ tr/\x{10000}-\x{10FFFF}/\x{10000}-\x{10FFFF}/;
    }
    return $length;
  } # length
  
  sub append_data ($$) {
    push @{${$_[0]}->[2]->{data}}, [''.$_[1], -1, 0]; # IndexedStringSegment
    return;
  } # append_data
  
  sub manakai_append_text ($$) {
    ## See also ParentNode::manakai_append_text
  
    # IndexedStringSegment
    my $segment = [ref $_[1] eq 'SCALAR' ? ${$_[1]} : $_[1], -1, 0];
    $segment->[0] = ''.$segment->[0] if ref $_[1];
  
    push @{${$_[0]}->[2]->{data}}, $segment;
  
    return $_[0];
  } # manakai_append_text
  
  sub manakai_append_indexed_string ($$) {
    # IndexedStringSegment
    _throw Web::DOM::TypeError 'The argument is not an IndexedString'
        if not ref $_[1] eq 'ARRAY' or
           grep { not ref $_ eq 'ARRAY' } @{$_[1]};
  
    push @{${$_[0]}->[2]->{data}}, map {
      [''.$_->[0], 0+$_->[1], 0+$_->[2]]; # string copy
    } @{$_[1]};
  
    return;
  } # manakai_append_indexed_string
  
  sub substring_data ($$$) {
    my $offset = _idl_unsigned_long $_[1];
    my $count = _idl_unsigned_long $_[2];
  
    # Substring data
    my $data = $_[0]->data;
    if ($data =~ /[\x{10000}-\x{10FFFF}]/ or
        $offset >= 2**31 or $count >= 2**31) {
      # 1.-4.
      my @data = split //, $data;
      my @result;
      my $i = 0;
      for (@data) {
        last if $i >= $offset + $count;
        if (/[\x{10000}-\x{10FFFF}]/) {
          if ($offset == $i + 1) {
            push @result, chr ((((ord $_) - 0x10000) % 0x400) + 0xDC00);
          } elsif ($offset + $count == $i + 1) {
            push @result, chr ((((ord $_) - 0x10000) / 0x400) + 0xD800);
          } elsif ($offset <= $i) {
            push @result, $_;
          }
          $i += 2;
        } else {
          if ($offset <= $i) {
            push @result, $_;
          }
          $i++;
        }
      }
      if ($offset > $i) {
        _throw Web::DOM::Exception 'IndexSizeError',
            'Offset is greater than the length';
      }
      return join '', @result;
    } else {
      # 1.-2.
      if ($offset > CORE::length $data) {
        _throw Web::DOM::Exception 'IndexSizeError',
            'Offset is greater than the length';
      }
  
      # 3.-4.
      return substr $data, $offset, $count;
    }
  } # substring_data
  
  sub insert_data ($$$) {
    return $_[0]->replace_data ($_[1], 0, $_[2]);
  } # insert_data
  
  sub delete_data ($$$) {
    return $_[0]->replace_data ($_[1], $_[2], '');
  } # delete_data
  
  sub replace_data ($$$$) {
    my $offset = _idl_unsigned_long $_[1];
    my $count = _idl_unsigned_long $_[2];
    my $s = ''.$_[3];
  
    # IndexedString
    if (@{${$_[0]}->[2]->{data}} != 1) {
      @{${$_[0]}->[2]->{data}} = ([$_[0]->data, -1, 0]);
    } else {
      ${$_[0]}->[2]->{data}->[0]->[1] = -1;
      ${$_[0]}->[2]->{data}->[0]->[2] = 0;
    }
  
    # Replace data
    if (${$_[0]}->[2]->{data}->[0]->[0] =~ /[\x{D800}-\x{DFFF}\x{10000}-\x{10FFFF}]/ or # IndexedString
        $s =~ /[\x{D800}-\x{DFFF}]/ or
        $offset >= 2**31 or $count >= 2**31) {
      # XXX 4. mutation
  
      # 1.-3., 5.
      my @data = split //, ${$_[0]}->[2]->{data}->[0]->[0]; # IndexedString
      my @before;
      my @after;
      my $i = 0;
      for (@data) {
        if (/[\x{10000}-\x{10FFFF}]/) {
          if ($offset == $i + 1) {
            push @before, chr ((((ord $_) - 0x10000) / 0x400) + 0xD800);
          } elsif ($offset + $count == $i + 1) {
            push @after, chr ((((ord $_) - 0x10000) % 0x400) + 0xDC00);
          } elsif ($offset + $count <= $i) {
            push @after, $_;
          } elsif ($i < $offset) {
            push @before, $_;
          } # $offset <= $i
          $i += 2;
        } else {
          if ($offset + $count <= $i) {
            push @after, $_;
          } elsif ($i < $offset) {
            push @before, $_;
          }
          $i++;
        }
      }
      if ($offset > $i) {
        _throw Web::DOM::Exception 'IndexSizeError',
            'Offset is greater than the length';
      }
      ${$_[0]}->[2]->{data}->[0]->[0] = join '', @before, $s, @after; # IndexedString
    } else {
      # 1.-2.
      if ($offset > CORE::length ${$_[0]}->[2]->{data}->[0]->[0]) { # IndexedString
        _throw Web::DOM::Exception 'IndexSizeError',
            'Offset is greater than the length';
      }
  
      # XXX 4. mutation
  
      # 3., 5.
      substr (${$_[0]}->[2]->{data}->[0]->[0], $offset, $count) = $s; # IndexedString
    }
  
    # XXX 6.-11. range
    return;
  } # replace_data
  
  1;
  
  =head1 LICENSE
  
  Copyright 2012-2016 Wakaba <wakaba@suikawiki.org>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
WEB_DOM_CHARACTERDATA

$fatpacked{"Web/DOM/ChildNode.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WEB_DOM_CHILDNODE';
  package Web::DOM::ChildNode;
  use strict;
  use warnings;
  our $VERSION = '1.0';
  use Web::DOM::Node;
  
  sub previous_element_sibling ($) {
    my $self = shift;
    my $parent_id = $$self->[2]->{parent_node};
    return undef unless defined $parent_id;
    my $self_id = $$self->[1];
    my $children = $$self->[0]->{data}->[$parent_id]->{child_nodes};
    my $found;
    for (reverse 0..$#$children) {
      if ($children->[$_] == $self_id) {
        $found = 1;
      } elsif ($found and 
               $$self->[0]->{data}->[$children->[$_]]->{node_type} == ELEMENT_NODE) {
        return $$self->[0]->node ($children->[$_]);
      }
    }
    return undef;
  } # previous_element_sibling
  
  sub next_element_sibling ($) {
    my $self = shift;
    my $parent_id = $$self->[2]->{parent_node};
    return undef unless defined $parent_id;
    my $self_id = $$self->[1];
    my $children = $$self->[0]->{data}->[$parent_id]->{child_nodes};
    my $found;
    for (0..$#$children) {
      if ($children->[$_] == $self_id) {
        $found = 1;
      } elsif ($found and 
               $$self->[0]->{data}->[$children->[$_]]->{node_type} == ELEMENT_NODE) {
        return $$self->[0]->node ($children->[$_]);
      }
    }
    return undef;
  } # next_element_sibling
  
  # XXX before after replace remove
  
  1;
  
  =head1 LICENSE
  
  Copyright 2012 Wakaba <wakaba@suikawiki.org>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
WEB_DOM_CHILDNODE

$fatpacked{"Web/DOM/Collection.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WEB_DOM_COLLECTION';
  package Web::DOM::Collection;
  use strict;
  use warnings;
  our $VERSION = '4.0';
  use Carp;
  use Web::DOM::Internal;
  
  ## Collection - superclass of |Web::DOM::NodeList|,
  ## |Web::DOM::NamedNodeMap|, |Web::DOM::HTMLCollection|, and
  ## |Web::DOM::CSSRuleList|.
  
  use overload
      '@{}' => sub {
        if (defined ${$_[0]}->[2] and
            ${${$_[0]}->[0]}->[0]->{revision} == ${$_[0]}->[5]) {
          return ${$_[0]}->[2];
        } else {
          return ${$_[0]}->[2] = do {
            my $list = $_[0]->to_a;
            Internals::SvREADONLY (@$list, 1);
            Internals::SvREADONLY ($_, 1) for @$list;
            delete ${$_[0]}->[4];
            ${$_[0]}->[5] = ${${$_[0]}->[0]}->[0]->{revision};
            $list;
          };
        }
        ## Strictly speaking, $obj->[$index]'s $index has to be
        ## converted to IDL |unsigned long| value before actual |getter|
        ## processing (or the |FETCH| method in Perl |tie| terminology).
        ## However, Perl's builtin convertion of array index, which
        ## clamps the value within the range of 32-bit signed long
        ## <http://qiita.com/items/f479744bed8633338fb5>, makes
        ## WebIDL-specific processing redundant.  (Also note that Perl
        ## can't handle array with length greater than or equal to
        ## 2^31.)
      },
      '""' => sub {
        return ref ($_[0]) . '=DOM(' . ${$_[0]}->[0] . ',' . (join $;, map {
          defined $_ ? do {
            s/($;|\x00)/\x00$1/g;
            $_;
          } : '';
        } @{ref ${$_[0]}->[3] ? ${$_[0]}->[3] : [${$_[0]}->[3]]}) . ')';
      },
      bool => sub { 1 },
      cmp => sub {
        carp "Use of uninitialized value in string comparison (cmp)"
            unless defined $_[1];
        overload::StrVal ($_[0]) cmp overload::StrVal ($_[1])
      },
      fallback => 1;
  
  sub item ($$) {
    my $n = _idl_unsigned_long $_[1];
    return undef if $n >= 2**31; # perl array
    return $_[0]->[$n]; # or undef
  } # item
  
  sub length ($) {
    return 0+@{$_[0]};
  } # length
  
  sub to_a ($) {
    return [$_[0]->to_list];
  } # to_a
  
  sub as_list ($) {
    return $_[0]->to_a;
  } # as_list
  
  # XXX Should the result of this method cached?
  sub to_list ($) {
    my $node = ${$_[0]}->[0];
    my $int = $$node->[0];
    return (map { $int->node ($_) } (${$_[0]}->[1]->($node)));
  } # to_list
  
  1;
  
  =head1 LICENSE
  
  Copyright 2012-2016 Wakaba <wakaba@suikawiki.org>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
WEB_DOM_COLLECTION

$fatpacked{"Web/DOM/Comment.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WEB_DOM_COMMENT';
  package Web::DOM::Comment;
  use strict;
  use warnings;
  our $VERSION = '1.0';
  use Web::DOM::CharacterData;
  push our @ISA, qw(Web::DOM::CharacterData);
  
  # XXX constructor
  
  sub node_name ($) {
    return '#comment';
  } # node_name
  
  1;
  
  =head1 LICENSE
  
  Copyright 2012 Wakaba <wakaba@suikawiki.org>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
WEB_DOM_COMMENT

$fatpacked{"Web/DOM/Document.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WEB_DOM_DOCUMENT';
  package Web::DOM::Document;
  use strict;
  use warnings;
  no warnings 'utf8';
  our $VERSION = '6.0';
  use Web::DOM::Node;
  use Web::DOM::ParentNode;
  use Web::DOM::XPathEvaluator;
  push our @ISA, qw(Web::DOM::ParentNode Web::DOM::XPathEvaluator
                    Web::DOM::Node);
  use Web::DOM::Internal;
  use Web::DOM::TypeError;
  use Web::DOM::Exception;
  # XXX EventHandlers DocumentOrShadowRoot
  
  sub new ($) {
    my $data = {node_type => DOCUMENT_NODE};
    my $objs = Web::DOM::Internal::Objects->new;
    my $id = $objs->add_data ($data);
    $objs->{rc}->[$id]++;
    # XXX origin
    return $objs->node ($id);
  } # new
  
  ## ------ Basic node properties ------
  
  sub node_name ($) {
    return '#document';
  } # node_name
  
  sub owner_document ($) {
    return undef;
  } # owner_document
  
  ## ------ Document properties ------
  
  sub content_type ($) {
    return ${$_[0]}->[2]->{content_type} || 'application/xml';
  } # content_type
  
  ## Internal method.
  ##
  ## Set the content type of the document.  It must be a lowercase
  ## canonical valid MIME type without parameters.  It can be
  ## "text/html" iff it is an HTML document.  This method must be
  ## invoked after |manakai_is_html| method as that method mutates the
  ## content type of the document.
  sub _set_content_type ($$) {
    ${$_[0]}->[2]->{content_type} = $_[1];
  } # _set_content_type
  
  sub manakai_is_html ($;$) {
    my $self = $_[0];
    if (@_ > 1) {
      if ($_[1]) {
        $$self->[2]->{is_html} = 1;
        $$self->[2]->{content_type} = 'text/html';
      } else {
        delete $$self->[2]->{is_html};
        delete $$self->[2]->{compat_mode};
        delete $$self->[2]->{content_type};
      }
      for my $cols (@{$$self->[0]->{cols} or []}) {
        next unless $cols;
        for my $key (keys %$cols) {
          next unless $cols->{$key};
          delete ${$cols->{$key}}->[2];
          delete ${$cols->{$key}}->[4];
        }
      }
    }
    return $$self->[2]->{is_html};
  } # manakai_is_html
  
  sub compat_mode ($) {
    my $self = $_[0];
    if ($$self->[2]->{is_html}) {
      if (defined $$self->[2]->{compat_mode} and
          $$self->[2]->{compat_mode} eq 'quirks') {
        return 'BackCompat';
      }
    }
    return 'CSS1Compat';
  } # compat_mode
  
  sub manakai_compat_mode ($;$) {
    my $self = $_[0];
    if ($$self->[2]->{is_html}) {
      if (@_ > 1 and defined $_[1] and
          {'no quirks' => 1, 'limited quirks' => 1, 'quirks' => 1}->{$_[1]}) {
        $$self->[2]->{compat_mode} = $_[1];
        for my $cols (@{$$self->[0]->{cols} or []}) {
          next unless $cols;
          for my $key (keys %$cols) {
            next unless $cols->{$key};
            delete ${$cols->{$key}}->[2];
            delete ${$cols->{$key}}->[4];
          }
        }
      }
      return $$self->[2]->{compat_mode} || 'no quirks';
    } else {
      return 'no quirks';
    }
  } # manakai_compat_mode
  
  sub manakai_is_srcdoc ($;$) {
    if (@_ > 1) {
      if ($_[1]) {
        ${$_[0]}->[2]->{is_srcdoc} = 1;
      } else {
        delete ${$_[0]}->[2]->{is_srcdoc};
      }
      delete ${$_[0]}->[0]->{document_base_url};
      delete ${$_[0]}->[0]->{document_base_url_revision};
    }
    return ${$_[0]}->[2]->{is_srcdoc};
  } # manakai_is_srcdoc
  
  sub character_set ($) {
    require Web::Encoding;
    return Web::Encoding::encoding_name_to_compat_name
        (${$_[0]}->[2]->{encoding} || 'utf-8');
  } # character_set
  
  *charset = \&character_set;
  
  sub input_encoding ($;$) {
    if (@_ > 1) {
      require Web::Encoding;
      my $name = Web::Encoding::encoding_label_to_name (''.$_[1]);
      ${$_[0]}->[2]->{encoding} = $name
          if Web::Encoding::is_encoding_label ($name);
    }
    return $_[0]->character_set;
  } # input_encoding
  
  sub manakai_charset ($;$) {
    if (@_ > 1) {
      if (defined $_[1]) {
        ${$_[0]}->[2]->{manakai_charset} = ''.$_[1];
      } else {
        delete ${$_[0]}->[2]->{manakai_charset};
      }
    }
    return ${$_[0]}->[2]->{manakai_charset};
  } # manakai_charset
  
  sub manakai_has_bom ($;$) {
    if (@_ > 1) {
      if ($_[1]) {
        ${$_[0]}->[2]->{manakai_has_bom} = 1;
      } else {
        delete ${$_[0]}->[2]->{manakai_has_bom};
      }
    }
    return ${$_[0]}->[2]->{manakai_has_bom};
  } # manakai_has_bom
  
  sub url ($) {
    return defined ${$_[0]}->[2]->{url}
        ? ${$_[0]}->[2]->{url} : 'about:blank';
  } # url
  
  *document_uri = \&url;
  
  sub manakai_set_url ($$) {
    # 1.
    my $url = _resolve_url ''.$_[1], 'about:blank';
  
    # 2.
    if (not defined $url) {
      _throw Web::DOM::Exception 'SyntaxError',
          'Cannot resolve the specified URL';
    }
  
    # 3.
    ${$_[0]}->[2]->{url} = $url;
    delete ${$_[0]}->[0]->{document_base_url};
    delete ${$_[0]}->[0]->{document_base_url_revision};
    return;
  } # manakai_set_url
  
  # XXX origin
  
  # XXX location
  
  # XXX domain
  
  sub manakai_entity_base_uri ($;$) {
    if (@_ > 1) {
      if (not defined $_[1]) {
        # 1.
        delete ${$_[0]}->[2]->{manakai_entity_base_uri};
      } else {
        # 2.
        ${$_[0]}->[2]->{manakai_entity_base_uri}
            = Web::DOM::Internal->text (_resolve_url ''.$_[1], $_[0]->url);
      }
    }
  
    # 1.
    return ${${$_[0]}->[2]->{manakai_entity_base_uri}}
        if ${$_[0]}->[2]->{manakai_entity_base_uri};
  
    # 2.
    return $_[0]->url;
  } # manakai_entity_base_uri
  
  # XXX referrer cookie lastModified
  
  sub xml_version ($;$) {
    if (@_ > 1) {
      my $version = ''.$_[1];
      if ($version eq '1.0' or $version eq '1.1' or
          ${$_[0]}->[2]->{no_strict_error_checking}) {
        ${$_[0]}->[2]->{xml_version} = $version;
      } else {
        _throw Web::DOM::Exception 'NotSupportedError',
            'Specified XML version is not supported';
      }
    }
    return defined ${$_[0]}->[2]->{xml_version}
        ? ${$_[0]}->[2]->{xml_version} : '1.0';
  } # xml_version
  
  sub xml_encoding ($;$) {
    if (@_ > 1) {
      if (defined $_[1]) {
        ${$_[0]}->[2]->{xml_encoding} = ''.$_[1];
      } else {
        delete ${$_[0]}->[2]->{xml_encoding};
      }
    }
    return ${$_[0]}->[2]->{xml_encoding};
  } # xml_encoding
  
  sub xml_standalone ($;$) {
    if (@_ > 1) {
      if ($_[1]) {
        ${$_[0]}->[2]->{xml_standalone} = 1;
      } else {
        delete ${$_[0]}->[2]->{xml_standalone};
      }
    }
    return ${$_[0]}->[2]->{xml_standalone};
  } # xml_standalone
  
  sub all_declarations_processed ($;$) {
    if (@_ > 1) {
      if ($_[1]) {
        ${$_[0]}->[2]->{all_declarations_processed} = 1;
      } else {
        delete ${$_[0]}->[2]->{all_declarations_processed};
      }
    }
    return ${$_[0]}->[2]->{all_declarations_processed};
  } # all_declarations_processed
  
  ## ------ Document configuration ------
  
  sub implementation ($) {
    return ${$_[0]}->[0]->impl;
  } # implementation
  
  sub dom_config ($) {
    return ${$_[0]}->[0]->config;
  } # dom_config
  
  sub strict_error_checking ($;$) {
    if (@_ > 1) {
      if ($_[1]) {
        delete ${$_[0]}->[2]->{no_strict_error_checking};
      } else {
        ${$_[0]}->[2]->{no_strict_error_checking} = 1;
      }
    }
    return not ${$_[0]}->[2]->{no_strict_error_checking};
  } # strict_error_checking
  
  ## ------ Attributes ------
  
  sub dir ($;$) {
    my $de = shift->manakai_html;
    if (defined $de) {
      return $de->dir (@_);
    } else {
      return '';
    }
  } # dir
  
  # XXX *color
  
  ## ------ Content ------
  
  sub text_content ($;$) {
    if (${$_[0]}->[0]->{config}->{not_manakai_strict_document_children}) {
      return shift->SUPER::text_content (@_);
    } else {
      return undef;
    }
  } # text_content
  
  sub manakai_append_text ($$) {
    if (${$_[0]}->[0]->{config}->{not_manakai_strict_document_children}) {
      $_[0]->SUPER::manakai_append_text ($_[1]);
    }
    return $_[0];
  } # manakai_append_text
  
  sub manakai_append_indexed_string ($$) {
    if (${$_[0]}->[0]->{config}->{not_manakai_strict_document_children}) {
      $_[0]->SUPER::manakai_append_indexed_string ($_[1]);
    }
    return undef;
  } # manakai_append_indexed_string
  
  sub doctype ($) {
    for ($_[0]->child_nodes->to_list) {
      if ($_->node_type == DOCUMENT_TYPE_NODE) {
        return $_;
      }
    }
    return undef;
  } # doctype
  
  sub document_element ($) {
    for ($_[0]->child_nodes->to_list) {
      if ($_->node_type == ELEMENT_NODE) {
        return $_;
      }
    }
    return undef;
  } # document_element
  
  sub manakai_html ($) {
    my $html = $_[0]->document_element or return undef;
    return $html if $html->manakai_element_type_match (HTML_NS, 'html');
    return undef;
  } # manakai_html
  
  sub atom_feed_element ($) {
    my $el = $_[0]->document_element or return undef;
    return $el if $el->manakai_element_type_match (ATOM_NS, 'feed');
    return undef;
  } # atom_feed_element
  
  sub head ($) {
    my $html = $_[0]->manakai_html or return undef;
    for ($html->child_nodes->to_list) {
      if ($_->manakai_element_type_match (HTML_NS, 'head')) {
        return $_;
      }
    }
    return undef;
  } # head
  
  *manakai_head = \&head;
  
  sub title ($;$) {
    my $self = $_[0];
  
    my $title_el;
    my $re = $self->document_element;
    if (defined $re) {
      if ($re->manakai_element_type_match (SVG_NS, 'svg')) {
        for ($re->children->to_list) {
          if ($_->manakai_element_type_match (SVG_NS, 'title')) {
            if (@_ > 1) {
              $_->text_content ($_[1]);
            }
            $title_el = $_;
            last;
          }
        }
  
        if (@_ > 1) {
          $title_el = $self->create_element_ns (SVG_NS, 'title');
          $re->append_child ($title_el);
          $title_el->text_content ($_[1]);
        }
      } elsif (($re->namespace_uri || '') eq HTML_NS) {
        $title_el = $self->get_elements_by_tag_name ('title')->[0];
        if (defined $title_el) {
          if (@_ > 1) {
            $title_el->text_content ($_[1]);
          }
        } else {
          my $head = $self->head;
          if (defined $head) {
            $title_el = $self->create_element_ns (HTML_NS, 'title');
            if (@_ > 1) {
              $head->append_child ($title_el);
              $title_el->text_content ($_[1]);
            }
          }
        }
      } else {
        return unless defined wantarray;
        $title_el = $self->get_elements_by_tag_name ('title')->[0];
      }
    } else {
      return unless defined wantarray;
      $title_el = $self->get_elements_by_tag_name ('title')->[0];
    }
    return unless defined wantarray;
  
    my $value = '';
    if (defined $title_el) {
      $value = join '', map { $_->data }
          grep { $_->node_type == TEXT_NODE } $title_el->child_nodes->to_list;
    }
    $value =~ s/[\x09\x0A\x0C\x0D\x20]+/ /g;
    $value =~ s/\A //;
    $value =~ s/ \z//;
    return $value;
  } # title
  
  sub body ($;$) {
    my $self = $_[0];
    if (@_ > 1) {
      # WebIDL
      if (defined $_[1] and
          not UNIVERSAL::isa ($_[1], 'Web::DOM::HTMLElement')) {
        _throw Web::DOM::TypeError 'The argument is not an HTMLElement';
      }
  
      # 1.
      if (not defined $_[1] or
          not HTML_NS eq ($_[1]->namespace_uri || '') or
          not ($_[1]->local_name eq 'body' or $_[1]->local_name eq 'frameset')) {
        _throw Web::DOM::Exception 'HierarchyRequestError',
            'The specified value cannot be used as the body element';
      }
  
      my $body = $self->body; # recursive!
      
      if (defined $body and $body eq $_[1]) {
        # 2.
        #
      } elsif (defined $body) {
        # 3.
        $body->parent_node->replace_child ($_[1], $body);
      } else {
        my $de = $self->document_element;
        if (defined $de) {
          # 5.
          $de->append_child ($_[1]);
        } else {
          # 4.
          _throw Web::DOM::Exception 'HierarchyRequestError',
              'There is no root element';
        }
      }
      return unless defined wantarray;
    }
  
    # The body element
    my $html = $self->manakai_html or return undef;
    for ($html->child_nodes->to_list) {
      next unless $_->node_type == ELEMENT_NODE;
      if ($_->manakai_element_type_match (HTML_NS, 'body') or
          $_->manakai_element_type_match (HTML_NS, 'frameset')) {
        return $_;
      }
    }
    return undef;
  } # body
  
  # XXX need O(1) implementation...
  # XXX <https://github.com/whatwg/dom/commit/1e953d1b2205dbf0ca78af82e6fd7c59a04c347e>
  # XXX Move to ParentNode
  sub get_element_by_id ($$) {
    my $id = ''.$_[1];
    return undef unless length $id;
    my @nodes = $_[0]->child_nodes->to_list;
     while (@nodes) {
      my $node = shift @nodes;
      next unless $node->node_type == ELEMENT_NODE;
      return $node if $node->id eq $id;
      unshift @nodes, $node->child_nodes->to_list;
    }
    return undef;
  } # get_element_by_id
  
  sub images ($) {
    return ${$_[0]}->[0]->collection_by_el ($_[0], 'images', HTML_NS, 'img');
  } # images
  
  sub embeds ($) {
    return ${$_[0]}->[0]->collection_by_el ($_[0], 'embeds', HTML_NS, 'embed');
  } # embeds
  
  *plugins = \&embeds;
  
  sub forms ($) {
    return ${$_[0]}->[0]->collection_by_el ($_[0], 'forms', HTML_NS, 'form');
  } # forms
  
  sub scripts ($) {
    return ${$_[0]}->[0]->collection_by_el ($_[0], 'scripts', HTML_NS, 'script');
  } # scripts
  
  sub applets ($) {
    return ${$_[0]}->[0]->collection_by_el ($_[0], 'applets', HTML_NS, '');
  } # applets
  
  sub links ($) {
    my $self = $_[0];
    return $$self->[0]->collection ('links', $self, sub {
      my $node = $_[0];
      my $data = $$node->[0]->{data};
      my @node_id = @{$data->[$$node->[1]]->{child_nodes} or []};
      my @id;
      while (@node_id) {
        my $id = shift @node_id;
        next unless $data->[$id]->{node_type} == ELEMENT_NODE;
        unshift @node_id, @{$data->[$id]->{child_nodes} or []};
        next unless ${$data->[$id]->{local_name}} eq 'a' or
                    ${$data->[$id]->{local_name}} eq 'area';
        next unless ${$data->[$id]->{namespace_uri} || \''} eq HTML_NS;
        next unless defined $data->[$id]->{attrs}->{''}->{href}; # AttrValueRef
        push @id, $id;
      }
      return @id;
    });
  } # links
  
  sub anchors ($) {
    my $self = $_[0];
    return $$self->[0]->collection ('anchors', $self, sub {
      my $node = $_[0];
      my $data = $$node->[0]->{data};
      my @node_id = @{$data->[$$node->[1]]->{child_nodes} or []};
      my @id;
      while (@node_id) {
        my $id = shift @node_id;
        next unless $data->[$id]->{node_type} == ELEMENT_NODE;
        unshift @node_id, @{$data->[$id]->{child_nodes} or []};
        next unless ${$data->[$id]->{local_name}} eq 'a';
        next unless ${$data->[$id]->{namespace_uri} || \''} eq HTML_NS;
        next unless defined $data->[$id]->{attrs}->{''}->{name}; # AttrValueRef
        push @id, $id;
      }
      return @id;
    });
  } # anchors
  
  sub get_elements_by_name ($$) {
    my $self = $_[0];
    my $name = ''.$_[1];
    return $$self->[0]->collection (['by_name', $name], $self, sub {
      my $node = $_[0];
      my $data = $$node->[0]->{data};
      my @node_id = @{$data->[$$node->[1]]->{child_nodes} or []};
      my @id;
      while (@node_id) {
        my $id = shift @node_id;
        next unless $data->[$id]->{node_type} == ELEMENT_NODE;
        unshift @node_id, @{$data->[$id]->{child_nodes} or []};
        next unless ${$data->[$id]->{namespace_uri} || \''} eq HTML_NS;
        next unless defined (my $value = $data->[$id]->{attrs}->{''}->{name}); # AttrValueRef
        if (ref $value) {
          next unless $name eq join '', map { $_->[0] } @$value; # AttrValueRef/IndexedString
        } else {
          next unless $name eq join '', map { $_->[0] } @{$data->[$value]->{data}}; # IndexedString
        }
        push @id, $id;
      }
      return @id;
    });
  } # get_elements_by_name
  
  sub all ($) {
    my $self = $_[0];
    return $$self->[0]->collection (['all'], $self, sub {
      my $node = $_[0];
      my $data = $$node->[0]->{data};
      my @node_id = @{$data->[$$node->[1]]->{child_nodes} or []};
      my @id;
      while (@node_id) {
        my $id = shift @node_id;
        next unless $data->[$id]->{node_type} == ELEMENT_NODE;
        unshift @node_id, @{$data->[$id]->{child_nodes} or []};
        push @id, $id;
      }
      return @id;
    });
  } # all
  
  # XXX commands css_element_map
  
  # XXX getter
  
  ## ------ Node factory ------
  
  # XXX custom elements
  sub create_element ($$) {
    my $self = $_[0];
    my $ln = ''.$_[1];
  
    # 1.
    if ($$self->[2]->{no_strict_error_checking}) {
      unless (length $ln) {
        _throw Web::DOM::Exception 'InvalidCharacterError',
            'The local name is not an XML Name';
      }
    } else {
      unless ($ln =~ /\A\p{InNameStartChar}\p{InNameChar}*\z/) {
        _throw Web::DOM::Exception 'InvalidCharacterError',
            'The local name is not an XML Name';
      }
    }
  
    # 2.
    my $ns;
    if ($$self->[2]->{is_html}) {
      $ln =~ tr/A-Z/a-z/; ## ASCII lowercase
      $ns = $Web::DOM::Internal::Text->{(HTML_NS)};
    } else {
      my $ct = ${$_[0]}->[2]->{content_type}; # or application/xml
      if (defined $ct and $ct eq 'application/xhtml+xml') {
        $ns = $Web::DOM::Internal::Text->{(HTML_NS)};
      }
    }
  
    # 3.
    my $data = {node_type => ELEMENT_NODE,
                namespace_uri => $ns,
                local_name => ($Web::DOM::Internal::Text->{$ln} ||= \$ln)};
    my $id = $$self->[0]->add_data ($data);
    my $node = $$self->[0]->node ($id);
    if ($ln eq 'template') {
      my $tmpl_doc = $$self->[0]->template_doc;
      my $df_id = $$tmpl_doc->[0]->add_data ({node_type => DOCUMENT_FRAGMENT_NODE});
      $$self->[0]->set_template_content ($id => $$tmpl_doc->[0]->node ($df_id));
    }
    return $node;
  } # create_element
  
  sub create_element_ns {
    my $self = $_[0];
    my $qname;
    my $prefix;
    my $ln;
    my $not_strict = $$self->[0]->{data}->[0]->{no_strict_error_checking};
  
    # DOMPERL
    if (defined $_[2] and ref $_[2] eq 'ARRAY') {
      $prefix = $_[2]->[0];
      $prefix = ''.$prefix if defined $prefix;
      $ln = ''.$_[2]->[1];
      $qname = defined $prefix ? $prefix . ':' . $ln : $ln;
    } else {
      $qname = ''.$_[2];
    }
  
    # 1.
    my $nsurl = defined $_[1] ? length $_[1] ? ''.$_[1] : undef : undef;
  
    if ($not_strict) {
      unless (length $qname) {
        _throw Web::DOM::Exception 'InvalidCharacterError',
            'The qualified name is not an XML QName';
      }
    } else {
      if (defined $ln) {
        if (defined $prefix and
            not $prefix =~ /\A\p{InNCNameStartChar}\p{InNCNameChar}*\z/) {
          _throw Web::DOM::Exception 'InvalidCharacterError',
              'The prefix is not an XML NCName';
        }
        unless ($ln =~ /\A\p{InNCNameStartChar}\p{InNCNameChar}*\z/) {
          _throw Web::DOM::Exception 'InvalidCharacterError',
              'The local name is not an XML NCName';
        }
      }
      unless ($qname =~ /\A\p{InNCNameStartChar}\p{InNCNameChar}*(?::\p{InNCNameStartChar}\p{InNCNameChar}*)?\z/) {
        _throw Web::DOM::Exception 'InvalidCharacterError',
            'The qualified name is not an XML QName';
      }
    } # strict
  
    # 4.
    if (not defined $ln) {
      $ln = $qname;
      if ($ln =~ s{\A([^:]+):(?=.)}{}s) {
        $prefix = $1;
      }
    }
  
    unless ($not_strict) {
      # 5.
      if (defined $prefix and not defined $nsurl) {
        _throw Web::DOM::Exception 'NamespaceError',
            'Namespace prefix cannot be bound to the null namespace';
      }
  
      # 6.
      if (defined $prefix and $prefix eq 'xml' and
          (not defined $nsurl or $nsurl ne XML_NS)) {
        _throw Web::DOM::Exception 'NamespaceError',
            'Prefix |xml| cannot be bound to anything other than XML namespace';
      }
  
      # 7.
      if (($qname eq 'xmlns' or (defined $prefix and $prefix eq 'xmlns')) and
          (not defined $nsurl or $nsurl ne XMLNS_NS)) {
        _throw Web::DOM::Exception 'NamespaceError',
            'Namespace of |xmlns| or |xmlns:*| must be the XMLNS namespace';
      }
  
      # 8.
      if (defined $nsurl and $nsurl eq XMLNS_NS and
          not ($qname eq 'xmlns' or (defined $prefix and $prefix eq 'xmlns'))) {
        _throw Web::DOM::Exception 'NamespaceError',
            'XMLNS namespace must be bound to |xmlns| or |xmlns:*|';
      }
    } # strict
  
    # 9.
    my $data = {node_type => ELEMENT_NODE,
                local_name => ($Web::DOM::Internal::Text->{$ln} ||= \$ln)};
    $data->{namespace_uri} = ($Web::DOM::Internal::Text->{$nsurl} ||= \$nsurl)
        if defined $nsurl;
    $data->{prefix} = ($Web::DOM::Internal::Text->{$prefix} ||= \$prefix)
        if defined $prefix;
    my $id = $$self->[0]->add_data ($data);
    my $node = $$self->[0]->node ($id);
    if ($ln eq 'template' and defined $nsurl and $nsurl eq HTML_NS) {
      my $tmpl_doc = $$self->[0]->template_doc;
      my $df_id = $$tmpl_doc->[0]->add_data
          ({node_type => DOCUMENT_FRAGMENT_NODE});
      $$self->[0]->set_template_content ($id => $$tmpl_doc->[0]->node ($df_id));
    }
    return $node;
  } # create_element_ns
  
  sub create_attribute ($$) {
    my $self = $_[0];
    my $ln = ''.$_[1];
  
    # 1.
    if ($$self->[2]->{no_strict_error_checking}) {
      unless (length $ln) {
        _throw Web::DOM::Exception 'InvalidCharacterError',
            'The local name is not an XML Name';
      }
    } else {
      unless ($ln =~ /\A\p{InNameStartChar}\p{InNameChar}*\z/) {
        _throw Web::DOM::Exception 'InvalidCharacterError',
            'The local name is not an XML Name';
      }
    }
  
    # 2.
    if ($$self->[2]->{is_html}) {
      $ln =~ tr/A-Z/a-z/; ## ASCII lowercase
    }
  
    # 3.
    my $data = {node_type => ATTRIBUTE_NODE,
                local_name => Web::DOM::Internal->text ($ln),
                value => ''};
    my $id = $$self->[0]->add_data ($data);
    return $$self->[0]->node ($id);
  } # create_attribute
  
  sub create_attribute_ns {
    my $self = $_[0];
    my $qname;
    my $prefix;
    my $ln;
    my $not_strict = $$self->[0]->{data}->[0]->{no_strict_error_checking};
  
    # WebIDL / 1.
    my $nsurl = defined $_[1] ? length $_[1] ? ''.$_[1] : undef : undef;
  
    # DOMPERL
    if (defined $_[2] and ref $_[2] eq 'ARRAY') {
      $prefix = $_[2]->[0];
      $prefix = ''.$prefix if defined $prefix;
      $ln = ''.$_[2]->[1];
      $qname = defined $prefix ? $prefix . ':' . $ln : $ln;
    } else {
      $qname = ''.$_[2];
    }
  
    if ($not_strict) {
      unless (length $qname) {
        _throw Web::DOM::Exception 'InvalidCharacterError',
            'The qualified name is not an XML QName';
      }
    } else {
      if (defined $ln) {
        if (defined $prefix and
            not $prefix =~ /\A\p{InNCNameStartChar}\p{InNCNameChar}*\z/) {
          _throw Web::DOM::Exception 'InvalidCharacterError',
              'The prefix is not an XML NCName';
        }
        unless ($ln =~ /\A\p{InNCNameStartChar}\p{InNCNameChar}*\z/) {
          _throw Web::DOM::Exception 'InvalidCharacterError',
              'The local name is not an XML NCName';
        }
      }
      unless ($qname =~ /\A\p{InNCNameStartChar}\p{InNCNameChar}*(?::\p{InNCNameStartChar}\p{InNCNameChar}*)?\z/) {
        _throw Web::DOM::Exception 'InvalidCharacterError',
            'The qualified name is not an XML QName';
      }
    } # strict
  
    # 4.
    unless (defined $ln) {
      $ln = $qname;
      if ($ln =~ s{\A([^:]+):(?=.)}{}s) {
        $prefix = $1;
      }
    }
  
    unless ($not_strict) {
      # 5.
      if (defined $prefix and not defined $nsurl) {
        _throw Web::DOM::Exception 'NamespaceError',
            'Namespace prefix cannot be bound to the null namespace';
      }
  
      # 6.
      if (defined $prefix and $prefix eq 'xml' and
          (not defined $nsurl or $nsurl ne XML_NS)) {
        _throw Web::DOM::Exception 'NamespaceError',
            'Prefix |xml| cannot be bound to anything other than XML namespace';
      }
  
      # 7.
      if (($qname eq 'xmlns' or (defined $prefix and $prefix eq 'xmlns')) and
          (not defined $nsurl or $nsurl ne XMLNS_NS)) {
        _throw Web::DOM::Exception 'NamespaceError',
            'Namespace of |xmlns| or |xmlns:*| must be the XMLNS namespace';
      }
  
      # 8.
      if (defined $nsurl and $nsurl eq XMLNS_NS and
          not ($qname eq 'xmlns' or (defined $prefix and $prefix eq 'xmlns'))) {
        _throw Web::DOM::Exception 'NamespaceError',
            'XMLNS namespace must be bound to |xmlns| or |xmlns:*|';
      }
    } # strict
  
    # 9.
    my $data = {node_type => ATTRIBUTE_NODE,
                prefix => Web::DOM::Internal->text ($prefix),
                namespace_uri => Web::DOM::Internal->text ($nsurl),
                local_name => Web::DOM::Internal->text ($ln),
                value => ''};
    my $id = $$self->[0]->add_data ($data);
    return $$self->[0]->node ($id);
  } # create_attribute_ns
  
  sub create_document_fragment ($) {
    my $id = ${$_[0]}->[0]->add_data ({node_type => DOCUMENT_FRAGMENT_NODE});
    return ${$_[0]}->[0]->node ($id);
  } # create_document_fragment
  
  sub create_text_node ($) {
    ## See also ParentNode::manakai_append_text
  
    # IndexedStringSegment
    my $segment = [ref $_[1] eq 'SCALAR' ? ${$_[1]} : $_[1], -1, 0];
    $segment->[0] = ''.$segment->[0] if ref $segment->[0];
  
    my $id = ${$_[0]}->[0]->add_data
        ({node_type => TEXT_NODE,
          data => length $segment->[0] ? [$segment] : []});
    return ${$_[0]}->[0]->node ($id);
  } # create_text_node
  
  sub create_cdata_section ($) {
    _throw Web::DOM::Exception 'NotSupportedError',
        'CDATASection is obsolete';
  } # create_cdata_section
  
  sub create_comment ($) {
    # IndexedStringSegment
    my $segment = [ref $_[1] eq 'SCALAR' ? ${$_[1]} : $_[1], -1, 0];
    $segment->[0] = ''.$segment->[0] if ref $segment->[0];
  
    my $id = ${$_[0]}->[0]->add_data
        ({node_type => COMMENT_NODE,
          data => length $segment->[0] ? [$segment] : []});
    return ${$_[0]}->[0]->node ($id);
  } # create_comment
  
  sub create_entity_reference ($) {
    _throw Web::DOM::Exception 'NotSupportedError',
        'EntityReference is obsolete';
  } # create_entity_reference
  
  sub create_processing_instruction ($$$) {
    my $self = $_[0];
    my $target = ''.$_[1];
    my $data = ''.$_[2];
  
    if ($$self->[2]->{no_strict_error_checking}) {
      unless (length $target) {
        _throw Web::DOM::Exception 'InvalidCharacterError',
            'The target is not an XML Name';
      }
    } else {
      # 1.
      unless ($target =~ /\A\p{InNameStartChar}\p{InNameChar}*\z/) {
        _throw Web::DOM::Exception 'InvalidCharacterError',
            'The target is not an XML Name';
      }
  
      # 2.
      if ($data =~ /\?>/) {
        _throw Web::DOM::Exception 'InvalidCharacterError',
            'The data cannot contain ?>';
      }
    } # strict
    
    # 3.
    my $id = $$self->[0]->add_data
        ({node_type => PROCESSING_INSTRUCTION_NODE,
          target => Web::DOM::Internal->text ($target),
          data => length $data ? [[$data, -1, 0]] : []}); # IndexedString
    return $$self->[0]->node ($id);
  } # create_processing_instruction
  
  sub create_document_type_definition ($$) {
    my $self = $_[0];
    my $qname = ''.$_[1];
  
    unless ($$self->[2]->{no_strict_error_checking}) {
      unless ($qname =~ /\A\p{InNameStartChar}\p{InNameChar}*\z/) {
        _throw Web::DOM::Exception 'InvalidCharacterError',
            'The qualified name is not an XML Name';
      }
    } # strict
  
    my $data = {node_type => DOCUMENT_TYPE_NODE,
                name => Web::DOM::Internal->text ($qname),
                public_id => Web::DOM::Internal->text (''),
                system_id => Web::DOM::Internal->text ('')};
    my $id = $$self->[0]->add_data ($data);
    return $$self->[0]->node ($id);
  } # create_document_type_definition
  
  sub create_element_type_definition ($$) {
    my $self = $_[0];
    my $qname = ''.$_[1];
  
    unless ($$self->[2]->{no_strict_error_checking}) {
      unless ($qname =~ /\A\p{InNameStartChar}\p{InNameChar}*\z/) {
        _throw Web::DOM::Exception 'InvalidCharacterError',
            'The qualified name is not an XML Name';
      }
    } # strict
  
    my $data = {node_type => ELEMENT_TYPE_DEFINITION_NODE,
                node_name => Web::DOM::Internal->text ($qname)};
    my $id = $$self->[0]->add_data ($data);
    return $$self->[0]->node ($id);
  } # create_element_type_definition
  
  sub create_attribute_definition ($$) {
    my $self = $_[0];
    my $qname = ''.$_[1];
  
    unless ($$self->[2]->{no_strict_error_checking}) {
      unless ($qname =~ /\A\p{InNameStartChar}\p{InNameChar}*\z/) {
        _throw Web::DOM::Exception 'InvalidCharacterError',
            'The qualified name is not an XML Name';
      }
    } # strict
  
    my $data = {node_type => ATTRIBUTE_DEFINITION_NODE,
                node_name => Web::DOM::Internal->text ($qname),
                node_value => ''};
    my $id = $$self->[0]->add_data ($data);
    return $$self->[0]->node ($id);
  } # create_attribute_definition
  
  sub create_general_entity ($$) {
    my $self = $_[0];
    my $qname = ''.$_[1];
  
    unless ($$self->[2]->{no_strict_error_checking}) {
      unless ($qname =~ /\A\p{InNameStartChar}\p{InNameChar}*\z/) {
        _throw Web::DOM::Exception 'InvalidCharacterError',
            'The qualified name is not an XML Name';
      }
    } # strict
  
    my $data = {node_type => ENTITY_NODE,
                name => Web::DOM::Internal->text ($qname),
                public_id => Web::DOM::Internal->text (''),
                system_id => Web::DOM::Internal->text ('')};
    my $id = $$self->[0]->add_data ($data);
    return $$self->[0]->node ($id);
  } # create_general_entity
  
  sub create_notation ($$) {
    my $self = $_[0];
    my $qname = ''.$_[1];
  
    unless ($$self->[2]->{no_strict_error_checking}) {
      unless ($qname =~ /\A\p{InNameStartChar}\p{InNameChar}*\z/) {
        _throw Web::DOM::Exception 'InvalidCharacterError',
            'The qualified name is not an XML Name';
      }
    } # strict
  
    my $data = {node_type => NOTATION_NODE,
                name => Web::DOM::Internal->text ($qname),
                public_id => Web::DOM::Internal->text (''),
                system_id => Web::DOM::Internal->text ('')};
    my $id = $$self->[0]->add_data ($data);
    return $$self->[0]->node ($id);
  } # create_notation
  
  sub import_node ($$;$) {
    # WebIDL
    unless (UNIVERSAL::isa ($_[1], 'Web::DOM::Node')) {
      _throw Web::DOM::TypeError 'The argument is not a Node';
    }
    my $deep = !!$_[2];
  
    # 1.
    if ($_[1]->node_type == DOCUMENT_NODE) {
      _throw Web::DOM::Exception 'NotSupportedError',
          'Cannot import document node';
    }
  
    # 2.
    return $_[1]->_clone ($_[0], $deep);
  } # import_node
  
  sub adopt_node ($$) {
    # WebIDL
    unless (UNIVERSAL::isa ($_[1], 'Web::DOM::Node')) {
      _throw Web::DOM::TypeError 'The argument is not a Node';
    }
    
    # 1.
    my $node = $_[1];
    if ($node->node_type == DOCUMENT_NODE) {
      _throw Web::DOM::Exception 'NotSupportedError',
          'Cannot adopt document node';
    }
  
    # 2. Adopt
    {
      # Adopt 2. Remove
      if (defined $$node->[2]->{parent_node}) {
        $$node->[0]->remove_node
            ($$node->[2]->{parent_node}, $$node->[1], 0);
      } elsif (defined $$node->[2]->{owner}) {
        my $node_nt = $$node->[2]->{node_type};
        if ($node_nt == ATTRIBUTE_NODE) {
          $node->owner_element->remove_attribute_node ($node);
        } elsif ($node_nt == ELEMENT_TYPE_DEFINITION_NODE) {
          $node->owner_document_type_definition
              ->remove_element_type_definition_node ($node);
        } elsif ($node_nt == ENTITY_NODE) {
          $node->owner_document_type_definition
              ->remove_general_entity_node ($node);
        } elsif ($node_nt == NOTATION_NODE) {
          $node->owner_document_type_definition->remove_notation_node ($node);
        } elsif ($node_nt == ATTRIBUTE_DEFINITION_NODE) {
          $node->owner_element_type_definition
              ->remove_attribute_definition_node ($node);
        }
      }
  
      # Adopt 3.
      ${$_[0]}->[0]->adopt ($node);
  
      # Adopt 4. Adopting steps
      if ($$node->[2]->{node_type} == ELEMENT_NODE) {
        # XXX
      }
    }
  
    # 3.
    return $node;
  } # adopt_node
  
  sub create_event ($$) {
    my $str = ''.$_[1];
    $str =~ tr/A-Z/a-z/; ## ASCII case-insensitive.
    my $if = {
      customevent => 'CustomEvent',
      event => 'Event',
      events => 'Event',
      htmlevents => 'Event',
      keyboardevent => 'KeyboardEvent',
      messageevent => 'MessageEvent',
      mouseevent => 'MouseEvent',
      mouseevents => 'MouseEvent',
      touchevent => 'TouchEvent',
      uievent => 'UIEvent',
      uievents => 'UIEvent',
      # XXX and more keywords from the DOM spec
    }->{$str}
        or _throw Web::DOM::Exception 'NotSupportedError',
            'Unknown event interface';
    
    require Web::DOM::Event;
    return "Web::DOM::$if"->_new;
  } # create_event
  
  # XXX createRange
  
  sub create_node_iterator ($;$$$) {
    # WebIDL
    _throw Web::DOM::TypeError 'The first argument is not a Node'
        unless UNIVERSAL::isa ($_[1], 'Web::DOM::Node');
    my $wts = _idl_unsigned_long (defined $_[2] ? $_[2] : 0xFFFFFFFF);
    _throw Web::DOM::TypeError 'The third argument is not a code reference'
        if defined $_[3] and not ref $_[3] eq 'CODE';
    # $_[4] (expand entity references) is obsolete
  
    return ${$_[0]}->[0]->iterator ($_[1], $wts, $_[3]);
  } # create_node_iterator
  
  sub create_tree_walker ($;$$$) {
    # WebIDL
    _throw Web::DOM::TypeError 'The first argument is not a Node'
        unless UNIVERSAL::isa ($_[1], 'Web::DOM::Node');
    my $wts = _idl_unsigned_long (defined $_[2] ? $_[2] : 0xFFFFFFFF);
    _throw Web::DOM::TypeError 'The third argument is not a code reference'
        if defined $_[3] and not ref $_[3] eq 'CODE';
    # $_[4] (expand entity references) is obsolete
  
    require Web::DOM::TreeWalker;
    return bless {
      root => $_[1],
      current_node => $_[1],
      what_to_show => $wts,
      filter => $_[3],
    }, 'Web::DOM::TreeWalker';
  } # create_tree_walker
  
  sub create_touch ($$$$$$$$) {
    # WebIDL
    _throw Web::DOM::TypeError 'The first argument is not a WindowProxy'
        unless UNIVERSAL::isa ($_[1], 'Web::DOM::WindowProxy');
    _throw Web::DOM::TypeError 'The second argument is not an EventTarget'
        unless UNIVERSAL::isa ($_[2], 'Web::DOM::EventTarget');
    require Web::DOM::Touch;
    return bless {
      target => $_[2],
      identifier => (_idl_long $_[3]),
      page_x => (_idl_long $_[4]),
      page_y => (_idl_long $_[5]),
      screen_x => (_idl_long $_[6]),
      screen_y => (_idl_long $_[7]),
      client_x => 0,
      client_y => 0,
    }, 'Web::DOM::Touch';
  } # create_touch
  
  sub create_touch_list ($;@) {
    shift;
    # WebIDL
    for (@_) {
      _throw Web::DOM::TypeError 'An argument is not a Touch'
          unless UNIVERSAL::isa ($_, 'Web::DOM::Touch');
    }
    require Web::DOM::TouchList;
    my $list = bless [@_], 'Web::DOM::TouchList';
    Internals::SvREADONLY (@$list, 1);
    Internals::SvREADONLY ($_, 1) for @$list;
    return $list;
  } # create_touch_list
  
  ## ------ Markup interaction ------
  
  # XXX open close write writeln current_script
  
  sub clear ($) { }
  
  # XXX readystate onreadystatechange
  
  ## ------ Browsing context and user interaction ------
  
  # XXX default_view active_element has_focus design_mode *command*
  
  1;
  
  =head1 LICENSE
  
  Copyright 2007-2016 Wakaba <wakaba@suikawiki.org>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
WEB_DOM_DOCUMENT

$fatpacked{"Web/DOM/DocumentFragment.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WEB_DOM_DOCUMENTFRAGMENT';
  package Web::DOM::DocumentFragment;
  use strict;
  use warnings;
  our $VERSION = '1.0';
  use Web::DOM::Node;
  use Web::DOM::ParentNode;
  push our @ISA, qw(Web::DOM::ParentNode Web::DOM::Node);
  
  # XXX constructor
  
  # XXX ancestor
  
  sub node_name ($) {
    return '#document-fragment';
  } # node_name
  
  1;
  
  =head1 LICENSE
  
  Copyright 2012 Wakaba <wakaba@suikawiki.org>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
WEB_DOM_DOCUMENTFRAGMENT

$fatpacked{"Web/DOM/DocumentType.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WEB_DOM_DOCUMENTTYPE';
  package Web::DOM::DocumentType;
  use strict;
  use warnings;
  our $VERSION = '1.0';
  use Web::DOM::Node;
  use Web::DOM::ChildNode;
  push our @ISA, qw(Web::DOM::Node Web::DOM::ChildNode);
  use Web::DOM::Internal;
  
  *node_name = \&name;
  
  sub name ($) {
    return ${${$_[0]}->[2]->{name}};
  } # name
  
  sub public_id ($) {
    if (@_ > 1) {
      ${$_[0]}->[2]->{public_id} = Web::DOM::Internal->text
          (defined $_[1] ? ''.$_[1] : '');
    }
    return ${${$_[0]}->[2]->{public_id}};
  } # public_id
  
  sub system_id ($) {
    if (@_ > 1) {
      ${$_[0]}->[2]->{system_id} = Web::DOM::Internal->text
          (defined $_[1] ? ''.$_[1] : '');
    }
    return ${${$_[0]}->[2]->{system_id}};
  } # system_id
  
  sub declaration_base_uri ($;$) {
    return $_[0]->base_uri;
  } # declaration_base_uri
  
  *manakai_declaration_base_uri = \&declaration_base_uri;
  
  sub element_types ($) {
    return ${$_[0]}->[0]->collection ('element_types', $_[0], sub {
      my $int = ${$_[0]}->[0];
      return sort {
        ${$int->{data}->[$a]->{node_name}} cmp ${$int->{data}->[$b]->{node_name}};
      } grep { defined $_ } values %{${$_[0]}->[2]->{element_types} or {}};
    });
  } # element_types
  
  sub general_entities ($) {
    return ${$_[0]}->[0]->collection ('general_entities', $_[0], sub {
      my $int = ${$_[0]}->[0];
      return sort {
        ${$int->{data}->[$a]->{name}} cmp ${$int->{data}->[$b]->{name}};
      } grep { defined $_ } values %{${$_[0]}->[2]->{general_entities} or {}};
    });
  } # general_entities
  
  *entities = \&general_entities;
  
  sub notations ($) {
    return ${$_[0]}->[0]->collection ('notations', $_[0], sub {
      my $int = ${$_[0]}->[0];
      return sort {
        ${$int->{data}->[$a]->{name}} cmp ${$int->{data}->[$b]->{name}};
      } grep { defined $_ } values %{${$_[0]}->[2]->{notations} or {}};
    });
  } # notations
  
  sub get_element_type_definition_node ($$) {
    my $id = ${$_[0]}->[2]->{element_types}->{''.$_[1]};
    return defined $id ? ${$_[0]}->[0]->node ($id) : undef;
  } # get_element_type_definition_node
  
  sub get_general_entity_node ($$) {
    my $id = ${$_[0]}->[2]->{general_entities}->{''.$_[1]};
    return defined $id ? ${$_[0]}->[0]->node ($id) : undef;
  } # get_general_entity_node
  
  sub get_notation_node ($$) {
    my $id = ${$_[0]}->[2]->{notations}->{''.$_[1]};
    return defined $id ? ${$_[0]}->[0]->node ($id) : undef;
  } # get_notation_node
  
  sub set_element_type_definition_node ($$) {
    # WebIDL
    unless (UNIVERSAL::isa ($_[1], 'Web::DOM::ElementTypeDefinition')) {
      _throw Web::DOM::TypeError 'The argument is not an ElementTypeDefinition';
    }
    return $_[0]->_set_node ('element_types', $_[1]);
  } # set_element_type_definition_node
  
  sub set_general_entity_node ($$) {
    # WebIDL
    unless (UNIVERSAL::isa ($_[1], 'Web::DOM::Entity')) {
      _throw Web::DOM::TypeError 'The argument is not an Entity';
    }
    return $_[0]->_set_node ('general_entities', $_[1]);
  } # set_general_entity_node
  
  sub set_notation_node ($$) {
    # WebIDL
    unless (UNIVERSAL::isa ($_[1], 'Web::DOM::Notation')) {
      _throw Web::DOM::TypeError 'The argument is not a Notation';
    }
    return $_[0]->_set_node ('notations', $_[1]);
  } # set_notation_node
  
  sub _set_node ($$$) {
    my ($node, $key, $obj) = @_;
  
    # 1.
    if (defined $$obj->[2]->{owner} and
        not ($$obj->[0] eq $$node->[0] and
             $$obj->[2]->{owner} == $$node->[1])) {
      _throw Web::DOM::Exception 'HierarchyRequestError',
          'The specified node has already attached to another node';
    }
  
    # 2. Adopt (simplified)
    $$node->[0]->adopt ($obj);
    # XXX Adopting steps??
  
    # 3.-4.
    my $obj_name = $obj->node_name;
    my $old_node_id = $$node->[2]->{$key}->{$obj_name};
    if (defined $old_node_id) {
      # Remove 1.
      #
  
      # 2.-3.
      #delete $$node->[2]->{$key}->{$obj_name};
      delete $$node->[0]->{data}->[$old_node_id]->{owner};
      $$node->[0]->disconnect ($old_node_id);
  
      # 4.
      #
    }
  
    # 5.-6.
    $$node->[2]->{$key}->{$obj_name} = $$obj->[1];
    $$obj->[2]->{owner} = $$node->[1];
    $$node->[0]->connect ($$obj->[1] => $$node->[1]);
    $$node->[0]->{revision}++;
  
    # 7.
    if (defined $old_node_id) {
      return $$node->[0]->node ($old_node_id);
    } else {
      return undef;
    }
  } # _set_node
  
  sub remove_element_type_definition_node ($$) {
    # WebIDL
    unless (UNIVERSAL::isa ($_[1], 'Web::DOM::ElementTypeDefinition')) {
      _throw Web::DOM::TypeError 'The argument is not an ElementTypeDefinition';
    }
    my ($node, $obj) = @_;
  
    # 1.
    if ($$node->[0] eq $$obj->[0] and
        defined $$obj->[2]->{owner} and
        $$node->[1] == $$obj->[2]->{owner}) {
      #
    } else {
      _throw Web::DOM::Exception 'NotFoundError',
          'The specified node is not attached to the context object';
    }
  
    # 2.-3.
    delete $$node->[2]->{element_types}->{${$$obj->[2]->{node_name}}};
    delete $$obj->[2]->{owner};
    $$node->[0]->disconnect ($$obj->[1]);
    $$node->[0]->{revision}++;
  
    # 4.
    return $obj;
  } # remove_element_type_definition_node
  
  sub remove_general_entity_node ($$) {
    # WebIDL
    unless (UNIVERSAL::isa ($_[1], 'Web::DOM::Entity')) {
      _throw Web::DOM::TypeError 'The argument is not an Entity';
    }
    my ($node, $obj) = @_;
  
    # 1.
    if ($$node->[0] eq $$obj->[0] and
        defined $$obj->[2]->{owner} and
        $$node->[1] == $$obj->[2]->{owner}) {
      #
    } else {
      _throw Web::DOM::Exception 'NotFoundError',
          'The specified node is not attached to the context object';
    }
  
    # 2.-3.
    delete $$node->[2]->{general_entities}->{${$$obj->[2]->{name}}};
    delete $$obj->[2]->{owner};
    $$node->[0]->disconnect ($$obj->[1]);
    $$node->[0]->{revision}++;
  
    # 4.
    return $obj;
  } # remove_general_entity_node
  
  sub remove_notation_node ($$) {
    # WebIDL
    unless (UNIVERSAL::isa ($_[1], 'Web::DOM::Notation')) {
      _throw Web::DOM::TypeError 'The argument is not a Notation';
    }
    my ($node, $obj) = @_;
  
    # 1.
    if ($$node->[0] eq $$obj->[0] and
        defined $$obj->[2]->{owner} and
        $$node->[1] == $$obj->[2]->{owner}) {
      #
    } else {
      _throw Web::DOM::Exception 'NotFoundError',
          'The specified node is not attached to the context object';
    }
  
    # 2.-3.
    delete $$node->[2]->{notations}->{${$$obj->[2]->{name}}};
    delete $$obj->[2]->{owner};
    $$node->[0]->disconnect ($$obj->[1]);
    $$node->[0]->{revision}++;
  
    # 4.
    return $obj;
  } # remove_notations_node
  
  1;
  
  =head1 LICENSE
  
  Copyright 2012 Wakaba <wakaba@suikawiki.org>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
WEB_DOM_DOCUMENTTYPE

$fatpacked{"Web/DOM/Element.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WEB_DOM_ELEMENT';
  package Web::DOM::Element;
  use strict;
  use warnings;
  no warnings 'utf8';
  use warnings FATAL => 'recursion';
  our $VERSION = '5.0';
  use Web::DOM::Internal;
  use Web::DOM::Node;
  use Web::DOM::ParentNode;
  use Web::DOM::ChildNode;
  push our @ISA, qw(Web::DOM::ParentNode Web::DOM::ChildNode Web::DOM::Node);
  use Web::DOM::Exception;
  
  our @EXPORT;
  
  *node_name = \&tag_name;
  
  sub tag_name ($) {
    my $data = ${$_[0]}->[2];
    my $qname;
    if (defined $data->{prefix}) {
      $qname = ${$data->{prefix}} . ':' . ${$data->{local_name}};
    } else {
      $qname = ${$data->{local_name}};
    }
    if (defined $data->{namespace_uri} and 
        ${$data->{namespace_uri}} eq 'http://www.w3.org/1999/xhtml' and
        ${$_[0]}->[0]->{data}->[0]->{is_html}) {
      $qname =~ tr/a-z/A-Z/; # ASCII uppercase
    }
    return $qname;
  } # tag_name
  
  sub manakai_tag_name ($) {
    my $data = ${$_[0]}->[2];
    my $qname;
    if (defined $data->{prefix}) {
      $qname = ${$data->{prefix}} . ':' . ${$data->{local_name}};
    } else {
      $qname = ${$data->{local_name}};
    }
    return $qname;
  } # manakai_tag_name
  
  sub manakai_element_type_match ($$$) {
    my ($self, $nsuri, $ln) = @_;
    $nsuri = ''.$nsuri if defined $nsuri;
    if (defined $nsuri and length $nsuri) {
      my $self_nsurl = $self->namespace_uri;
      if (defined $self_nsurl and $nsuri eq $self_nsurl) {
        return $ln eq $self->local_name;
      } else {
        return 0;
      }
    } else {
      if (not defined $self->namespace_uri) {
        return $ln eq $self->local_name;
      } else {
        return 0;
      }
    }
  } # manakai_element_type_match
  
  
  ## Content attributes
  ##
  ## A content attribute is represented as either:
  ##
  ##   - A pair of attribute name and value, or
  ##   - An |Attr| node.
  ##
  ## An attribute can be represented as a pair when it does not have any
  ## additional data (e.g. namespace, user data, or attribute type) and
  ## there is no reference to the |Attr| object.  The |$InflateAttr|
  ## operation below converts an attribute represented as a pair into
  ## |Attr|-object form.
  ##
  ## Any content attribute of an element is stored in the node data of
  ## the element in BOTH of following forms:
  ##
  ##   $$node->[2]->{attrs}->{$ns // ''}->{$ln} = AttrValueRef
  ##   $$node->[2]->{attributes} = [array of AttrNameRef]
  ##
  ## Note that the |attributes| hash reference is used to preserve the
  ## order of the attributes in the element.
  ##
  ## An AttrNameRef is either a scalar reference to a string
  ## representing the attribute name (a character string) or the node ID
  ## of an |Attr| object.
  ##
  ## An AttrValueRef is either an IndexedString (i.e. an array
  ## reference) representing the attribute value or the node ID of an
  ## |Attr| object.
  ##
  ## If an attribute is represented as an |Attr| node, both AttrNameRef
  ## and AttrValueRef for the attribute are the same node ID.
  ## Otherwise, AttrNameRef must be a scalar reference and AttrValueRef
  ## must be an IndexedString.
  
  my $InflateAttr = sub ($$) {
    my ($node, $nameref) = @_; # AttrNameRef
    my $data = {node_type => ATTRIBUTE_NODE,
                local_name => Web::DOM::Internal->text ($$nameref),
                data => $$node->[2]->{attrs}->{''}->{$$nameref}, # AttrValueRef/IndexedString
                owner => $$node->[1]};
    my $attr_id = $$node->[0]->add_data ($data);
    $$node->[2]->{attrs}->{''}->{$$nameref} = $attr_id; # AttrValueRef
    $$node->[0]->connect ($attr_id => $$node->[1]);
    return $attr_id; # new AttrNameRef
  }; # $InflateAttr
  
  sub attributes ($) {
    return ${$_[0]}->[0]->collection ('attributes', $_[0], sub {
      my $node = $_[0];
      for (@{$$node->[2]->{attributes} or []}) {
        $_ = $InflateAttr->($node, $_) if ref $_; # AttrNameRef
      }
      return @{$$node->[2]->{attributes} or []};
    });
  } # attributes
  
  sub has_attributes ($) {
    return !!@{${$_[0]}->[2]->{attributes} or []};
  } # has_attributes
  
  sub get_attribute_names ($) {
    return [map {
      if (ref $_) { # AttrNameRef
        $$_;
      } else {
        ${$_[0]}->[0]->node ($_)->name;
      }
    } @{${$_[0]}->[2]->{attributes} or []}];
  } # get_attribute_names
  
  sub has_attribute ($$) {
    my $node = $_[0];
    my $name = ''.$_[1];
  
    # 1.
    if (${$$node->[2]->{namespace_uri} || \''} eq HTML_NS and
        $$node->[0]->{data}->[0]->{is_html}) {
      $name =~ tr/A-Z/a-z/; ## ASCII lowercase
    }
  
    # 2.
    return 1 if ref ($$node->[2]->{attrs}->{''}->{$name} || ''); # AttrValueRef
    for (@{$$node->[2]->{attributes} or []}) {
      if (ref $_) { # AttrNameRef
        return 1 if $$_ eq $name;
      } else { # node ID
        return 1 if $$node->[0]->node ($_)->name eq $name;
      }
    }
    return 0;
  } # has_attribute
  
  sub has_attribute_ns ($$$) {
    # WebIDL, 1., 2.
    return defined ${$_[0]}->[2]->{attrs}->{defined $_[1] ? $_[1] : ''}->{''.$_[2]};
  } # has_attribute_ns
  
  sub get_attribute ($$) {
    my $node = $_[0];
    my $name = ''.$_[1];
  
    # 1.
    if (${$$node->[2]->{namespace_uri} || \''} eq HTML_NS and
        $$node->[0]->{data}->[0]->{is_html}) {
      $name =~ tr/A-Z/a-z/; ## ASCII lowercase
    }
  
    # 2.
    for (@{$$node->[2]->{attributes} or []}) {
      if (ref $_) { # AttrNameRef
        if ($$_ eq $name) {
          return join '', map { $_->[0] } @{$$node->[2]->{attrs}->{''}->{$name}}; # AttrValueRef/IndexedString
        }
      } else { # node ID
        my $attr_node = $$node->[0]->node ($_);
        if ($attr_node->name eq $name) {
          return $attr_node->value;
        }
      }
    }
    return undef;
  } # get_attribute
  
  sub get_attribute_ns ($$$) {
    my $node = $_[0];
    my $nsurl = defined $_[1] ? ''.$_[1] : undef; # can be empty
    my $ln = ''.$_[2];
  
    # 1., 2. / Get an attribute 1., 2.
    my $attr_id = $$node->[2]->{attrs}->{defined $nsurl ? $nsurl : ''}->{$ln}; # AttrValueRef
    if (defined $attr_id) {
      if (ref $attr_id) {
        return join '', map { $_->[0] } @$attr_id; # AttrValueRef/IndexedString
      } else {
        return join '', map { $_->[0] } @{$$node->[0]->{data}->[$attr_id]->{data}}; # IndexedString
      }
    } else {
      return undef;
    }
  } # get_attribute_ns
  
  sub manakai_get_attribute_indexed_string_ns ($$$) {
    my $node = $_[0];
    my $nsurl = defined $_[1] ? ''.$_[1] : undef; # can be empty
    my $ln = ''.$_[2];
  
    # 1., 2. / Get an attribute 1., 2.
    my $attr_id = $$node->[2]->{attrs}->{defined $nsurl ? $nsurl : ''}->{$ln}; # AttrValueRef
    if (defined $attr_id) {
      if (ref $attr_id) {
        return [map { [$_->[0], $_->[1], $_->[2]] } @$attr_id]; # AttrValueRef/IndexedString
      } else {
        return [map { [$_->[0], $_->[1], $_->[2]] } @{$$node->[0]->{data}->[$attr_id]->{data}}]; # IndexedString
      }
    } else {
      return undef;
    }
  } # manakai_get_attribute_indexed_string_ns
  
  sub get_attribute_node ($$) {
    my $node = $_[0];
    my $name = ''.$_[1];
  
    # 1.
    if (${$$node->[2]->{namespace_uri} || \''} eq HTML_NS and
        $$node->[0]->{data}->[0]->{is_html}) {
      $name =~ tr/A-Z/a-z/; ## ASCII lowercase
    }
  
    # 2.
    for (@{$$node->[2]->{attributes} or []}) {
      if (ref $_) { # AttrNameRef
        if ($$_ eq $name) {
          $_ = $InflateAttr->($node, $_);
          return $$node->[0]->node ($_); # node ID
        }
      } else { # node ID
        my $attr_node = $$node->[0]->node ($_);
        if ($attr_node->name eq $name) {
          return $attr_node;
        }
      }
    }
    return undef;
  } # get_attribute_node
  
  sub get_attribute_node_ns ($$$) {
    my $node = $_[0];
    my $nsurl = defined $_[1] ? ''.$_[1] : undef; # can be empty
    my $ln = ''.$_[2];
  
    # 1., 2. / Get an attribute 1., 2.
    my $attr_id = $$node->[2]->{attrs}->{defined $nsurl ? $nsurl : ''}->{$ln}; # AttrValueRef
    if (defined $attr_id) {
      if (ref $attr_id) {
        $attr_id = $InflateAttr->($node, \$ln);
        @{$$node->[2]->{attributes}} = map {
          ref $_ && $$_ eq $ln ? $attr_id : $_; # AttrNameRef
        } @{$$node->[2]->{attributes}};
        return $$node->[0]->node ($attr_id);
      } else {
        return $$node->[0]->node ($attr_id);
      }
    } else {
      return undef;
    }
  } # get_attribute_node_ns
  
  sub set_attribute ($$$) {
    my $node = $_[0];
    my $name = ''.$_[1];
    my $value = ''.$_[2];
  
    # 1.
    if ($$node->[0]->{data}->[0]->{no_strict_error_checking}) {
      unless (length $name) {
        _throw Web::DOM::Exception 'InvalidCharacterError',
            'The name is not an XML Name';
      }
    } else {
      unless ($name =~ /\A\p{InNameStartChar}\p{InNameChar}*\z/) {
        _throw Web::DOM::Exception 'InvalidCharacterError',
            'The name is not an XML Name';
      }
    }
  
    # 2.
    if (${$$node->[2]->{namespace_uri} || \''} eq HTML_NS and
        $$node->[0]->{data}->[0]->{is_html}) {
      $name =~ tr/A-Z/a-z/; ## ASCII lowercase
    }
  
    $$node->[0]->{revision}++;
  
    # 3.
    for (@{$$node->[2]->{attributes} or []}) {
      if (ref $_) { # AttrNameRef
        if ($$_ eq $name) {
          # 5.
          {
            # Change 1.
            # XXX mutation
  
            # Change 2.
            $$node->[2]->{attrs}->{''}->{$name} = [[$value, -1, 0]]; # AttrValueRef/IndexedString
  
            # Change 3.
            $node->_attribute_is (undef, \$name, set => 1, changed => 1);
          }
          return;
        }
      } else { # node ID
        my $attr_node = $$node->[0]->node ($_);
        if ($attr_node->name eq $name) {
          # 5.
          {
            # Change 1.
            # XXX mutation
  
            # Change 2.
            $$attr_node->[2]->{data} = [[$value, -1, 0]]; # IndexedString
  
            # Change 3.
            $node->_attribute_is
                ($$attr_node->[2]->{namespace_uri},
                 $$attr_node->[2]->{local_name},
                 set => 1, changed => 1);
          }
          return;
        }
      }
    }
  
    # 4.
    {
      # Append 1.
      # XXX mutation
  
      # Append 2.
      push @{$$node->[2]->{attributes} ||= []},
          Web::DOM::Internal->text ($name); # AttrNameRef
      $$node->[2]->{attrs}->{''}->{$name} = [[$value, -1, 0]]; # AttrValueRef/IndexedString
  
      # Append 3.
      $node->_attribute_is (undef, \$name, set => 1, added => 1);
    }
    return;
  } # set_attribute
  
  sub set_attribute_ns ($$$$) {
    return $_[0]->manakai_set_attribute_indexed_string_ns
        ($_[1], $_[2], [[$_[3], -1, 0]]);
  } # set_attribute_ns
  
  sub manakai_set_attribute_indexed_string_ns ($$$$) {
    my $node = $_[0];
    my $qname;
    my $prefix;
    my $ln;
    my $not_strict = $$node->[0]->{data}->[0]->{no_strict_error_checking};
  
    # WebIDL / 1.
    my $nsurl = defined $_[1] ? ''.$_[1] : undef;
    $nsurl = undef if defined $nsurl and not length $nsurl;
  
    # DOMPERL
    if (defined $_[2] and ref $_[2] eq 'ARRAY') {
      $prefix = $_[2]->[0];
      $ln = ''.$_[2]->[1];
      $qname = defined $prefix ? $prefix . ':' . $ln : $ln;
    } else {
      $qname = ''.$_[2];
    }
  
    # IndexedStringSegment
    _throw Web::DOM::TypeError 'The argument is not an IndexedString'
        if not ref $_[3] eq 'ARRAY' or
           grep { not ref $_ eq 'ARRAY' } @{$_[3]};
    my $value = [map { [''.$_->[0], 0+$_->[1], 0+$_->[2]] } @{$_[3]}];
  
    if ($not_strict) {
      unless (length $qname) {
        _throw Web::DOM::Exception 'InvalidCharacterError',
            'The qualified name is not an XML QName';
      }
    } else {
      if (defined $ln) {
        if (defined $prefix and
            not $prefix =~ /\A\p{InNCNameStartChar}\p{InNCNameChar}*\z/) {
          _throw Web::DOM::Exception 'InvalidCharacterError',
              'The prefix is not an XML NCName';
        }
        unless ($ln =~ /\A\p{InNCNameStartChar}\p{InNCNameChar}*\z/) {
          _throw Web::DOM::Exception 'InvalidCharacterError',
              'The local name is not an XML NCName';
        }
      }
      unless ($qname =~ /\A\p{InNCNameStartChar}\p{InNCNameChar}*(?::\p{InNCNameStartChar}\p{InNCNameChar}*)?\z/) {
        _throw Web::DOM::Exception 'InvalidCharacterError',
            'The qualified name is not an XML QName';
      }
    }
  
    # 4.
    unless (defined $ln) {
      $ln = $qname;
      if ($ln =~ s{\A([^:]+):(?=.)}{}s) {
        $prefix = $1;
      }
    }
  
    unless ($not_strict) {
      # 5.
      if (defined $prefix and not defined $nsurl) {
        _throw Web::DOM::Exception 'NamespaceError',
            'Namespace prefix cannot be bound to the null namespace';
      }
  
      # 6.
      if (defined $prefix and $prefix eq 'xml' and
          (not defined $nsurl or $nsurl ne XML_NS)) {
        _throw Web::DOM::Exception 'NamespaceError',
            'Prefix |xml| cannot be bound to anything other than XML namespace';
      }
  
      # 7.
      if (($qname eq 'xmlns' or (defined $prefix and $prefix eq 'xmlns')) and
          (not defined $nsurl or $nsurl ne XMLNS_NS)) {
        _throw Web::DOM::Exception 'NamespaceError',
            'Namespace of |xmlns| or |xmlns:*| must be the XMLNS namespace';
      }
  
      # 8.
      if (defined $nsurl and $nsurl eq XMLNS_NS and
          not ($qname eq 'xmlns' or (defined $prefix and $prefix eq 'xmlns'))) {
        _throw Web::DOM::Exception 'NamespaceError',
            'XMLNS namespace must be bound to |xmlns| or |xmlns:*|';
      }
    } # strict
  
    $$node->[0]->{revision}++;
  
    # 9. Set an attribute
    {
      # Set 1.-4.
      my $attr_id = $$node->[2]->{attrs}->{defined $nsurl ? $nsurl : ''}->{$ln}; # AttrValueRef
      if (defined $attr_id) {
        # 6.
        {
          # Change 1.
          # XXX mutation
  
          # Change 2.
          if (ref $attr_id) {
            @$attr_id = @$value; # AttrValueRef/IndexedString
          } else {
            $$node->[0]->{data}->[$attr_id]->{data} = $value; # IndexedString
          }
  
          # Change 3.
          $node->_attribute_is (defined $nsurl ? \$nsurl : undef, \$ln,
                                set => 1, changed => 1);
        }
      } else {
        # 5.
        {
          # Append 1.
          # XXX mutation
  
          # Append 2.
          if (defined $nsurl or defined $prefix) {
            my $data = {node_type => ATTRIBUTE_NODE,
                        namespace_uri => Web::DOM::Internal->text ($nsurl),
                        prefix => Web::DOM::Internal->text ($prefix),
                        local_name => Web::DOM::Internal->text ($ln),
                        data => $value, # IndexedString
                        owner => $$node->[1]};
            my $attr_id = $$node->[0]->add_data ($data);
            push @{$$node->[2]->{attributes} ||= []}, $attr_id; # AttrNameRef
            $$node->[2]->{attrs}->{defined $nsurl ? $nsurl : ''}->{$ln}
                = $attr_id; # AttrValueRef
            $$node->[0]->connect ($attr_id => $$node->[1]);
          } else {
            push @{$$node->[2]->{attributes} ||= []},
                Web::DOM::Internal->text ($ln); # AttrNameRef
            $$node->[2]->{attrs}->{''}->{$ln} = $value; # AttrValueRef/IndexedString
          }
  
          # Append 3.
          $node->_attribute_is (defined $nsurl ? \$nsurl : undef, \$ln,
                                set => 1, added => 1);
        }
      }
    }
    return;
  } # manakai_set_attribute_indexed_string_ns
  
  sub set_attribute_node ($$) {
    # WebIDL
    unless (UNIVERSAL::isa ($_[1], 'Web::DOM::Attr')) {
      _throw Web::DOM::TypeError 'The argument is not an Attr';
    }
  
    my ($node, $attr) = @_;
  
    ## Set an attribute
  
    ## 1.
    if (defined $$attr->[2]->{owner} and
        not ($$attr->[0] eq $$node->[0] and
             $$attr->[2]->{owner} == $$node->[1])) {
      _throw Web::DOM::Exception 'InUseAttributeError',
          'The specified attribute has already attached to another node';
    }
  
    ## 2. Get an attribute by namespace and local name
    my $old_attr = $node->get_attribute_node_ns
        ($attr->namespace_uri, $attr->local_name);
  
    ## 3.
    return $attr if defined $old_attr and $attr eq $old_attr;
  
    if (defined $old_attr) {
      ## 4. Replace
      {
        ## 1. Mutation
        # XXX
  
        ## 3.
        delete $$node->[2]->{attrs}->{${$$old_attr->[2]->{namespace_uri} || \''}}->{${$$old_attr->[2]->{local_name}}}; # AttrValueRef
        my $i = 0;
        my $found = 0;
        @{$$node->[2]->{attributes}} = grep {
          if ($_ != $$old_attr->[1]) {
            $i++ unless $found;
            1;
          } else {
            $found = 1;
            0;
          }
        } @{$$node->[2]->{attributes}}; # AttrNameRef
        delete $$old_attr->[2]->{owner};
        $$node->[0]->disconnect ($$old_attr->[1]);
  
        ## 4.
        $$node->[0]->adopt ($attr);
        my $nsurl = ${$$attr->[2]->{namespace_uri} || \''};
        my $ln = ${$$attr->[2]->{local_name}};
        splice @{$$node->[2]->{attributes}}, $i, 0, ($$attr->[1]); # AttrNameRef
        $$node->[2]->{attrs}->{$nsurl}->{$ln} = $$attr->[1]; # AttrValueRef
        $$attr->[2]->{owner} = $$node->[1];
        $$node->[0]->connect ($$attr->[1] => $$node->[1]);
  
        ## 5.
        $node->_attribute_is
            ($$attr->[2]->{namespace_uri}, $$attr->[2]->{local_name},
             set => 1, changed => 1);
      }
    } else {
      ## 5. Append
      $$node->[0]->adopt ($attr);
      my $nsurl = ${$$attr->[2]->{namespace_uri} || \''};
      my $ln = ${$$attr->[2]->{local_name}};
      push @{$$node->[2]->{attributes} ||= []}, $$attr->[1]; # AttrNameRef
      $$node->[2]->{attrs}->{$nsurl}->{$ln} = $$attr->[1]; # AttrValueRef
      $$attr->[2]->{owner} = $$node->[1];
      $$node->[0]->connect ($$attr->[1] => $$node->[1]);
      $node->_attribute_is
          ($$attr->[2]->{namespace_uri}, $$attr->[2]->{local_name},
           set => 1, added => 1);
    }
  
    ## 6.
    return $old_attr; # or undef
  } # set_attribute_node
  *set_attribute_node_ns = \&set_attribute_node;
  
  sub remove_attribute ($$) {
    my $node = $_[0];
    my $name = ''.$_[1];
  
    # 1.
    if (${$$node->[2]->{namespace_uri} || \''} eq HTML_NS and
        $$node->[0]->{data}->[0]->{is_html}) {
      $name =~ tr/A-Z/a-z/; ## ASCII lowercase
    }
  
    # 2. Remove
    {
      # Remove 1.
      # XXX mutation if $found
  
      # Remove 2.
      my $found;
      my $nsref;
      my $lnref;
      @{$$node->[2]->{attributes} or []} = map { # AttrNameRef
        if ($found) {
          $_;
        } elsif (ref $_) {
          if ($$_ eq $name) {
            $found = 1;
            ($nsref, $lnref) = (undef, $_);
            delete $$node->[2]->{attrs}->{''}->{$name}; # AttrValueRef
            ();
          } else {
            $_;
          }
        } else { # node ID
          my $attr_node = $$node->[0]->node ($_);
          if ($attr_node->name eq $name) {
            $found = 1;
            ($nsref, $lnref) = ($$attr_node->[2]->{namespace_uri},
                                $$attr_node->[2]->{local_name});
            delete $$node->[2]->{attrs}
                ->{defined $nsref ? $$nsref : ''}->{$$lnref}; # AttrValueRef
            $$node->[0]->disconnect ($_);
            ();
          } else {
            $_;
          }
        }
      } @{$$node->[2]->{attributes} or []};
  
      if ($found) {
        $$node->[0]->{revision}++;
  
        # Remove 3.
        $node->_attribute_is ($nsref, $lnref, removed => 1);
      }
    }
    return;
  } # remove_attribute
  
  sub remove_attribute_ns ($$$) {
    my $node = $_[0];
    my $ln = ''.$_[2];
    
    # 1., 2.
    my $nsurl = defined $_[1] ? ''.$_[1] : undef;
    $nsurl = undef if defined $nsurl and not length $nsurl;
    my $attr_id = $$node->[2]->{attrs}->{defined $nsurl ? $nsurl : ''}->{$ln}; # AttrValueRef
    if (defined $attr_id) {
      # Remove 1.
      # XXX mutation if found
  
      $$node->[0]->{revision}++;
  
      # Remove 2.
      if (ref $attr_id) { # AttrValueRef
        @{$$node->[2]->{attributes}} = grep { not ref $_ or $$_ ne $ln } @{$$node->[2]->{attributes}}; # AttrNameRef
      } else { # node ID
        $$node->[0]->disconnect ($attr_id);
        @{$$node->[2]->{attributes}} = grep { $_ ne $attr_id } @{$$node->[2]->{attributes}}; # AttrNameRef
      }
      delete $$node->[2]->{attrs}->{defined $nsurl ? $nsurl : ''}->{$ln}; # AttrValueRef
  
      # Remove 3.
      $node->_attribute_is
          (defined $nsurl ? \$nsurl : undef, \$ln, removed => 1);
    }
    return;
  } # remove_attribute_ns
  
  sub remove_attribute_node ($$) {
    # WebIDL
    unless (UNIVERSAL::isa ($_[1], 'Web::DOM::Attr')) {
      _throw Web::DOM::TypeError 'The argument is not an Attr';
    }
  
    my ($node, $attr) = @_;
    
    if ($$node->[0] eq $$attr->[0] and
        defined $$attr->[2]->{owner} and
        $$node->[1] == $$attr->[2]->{owner}) {
      #
    } else {
      _throw Web::DOM::Exception 'NotFoundError',
          'The specified attribute is not an attribute of the element';
    }
  
    $$node->[0]->{revision}++;
    
    delete $$node->[2]->{attrs}->{${$$attr->[2]->{namespace_uri} || \''}}->{${$$attr->[2]->{local_name}}}; # AttrValueRef
    @{$$node->[2]->{attributes}} = grep {
      $_ != $$attr->[1];
    } @{$$node->[2]->{attributes}}; # AttrNameRef
    delete $$attr->[2]->{owner};
    $$node->[0]->disconnect ($$attr->[1]);
  
    $node->_attribute_is ($$attr->[2]->{namespace_uri},
                          $$attr->[2]->{local_name},
                          removed => 1);
  
    return $attr;
  } # remove_attribute_node
  
  my $DOMTokenListAttributeMapping = {
    class => 'class_list',
    rel => 'rel_list',
  };
  
  sub _attribute_is ($$$%) {
    my ($self, $nsref, $lnref, %args) = @_;
    ## - attribute is set
    ## - attribute is added
    ## - attribute is changed
    ## - attribute is removed
  
    if (not defined $nsref and defined $lnref) {
      my $key = $DOMTokenListAttributeMapping->{$$lnref};
      if (defined $key) {
        my $value = $self->get_attribute_ns (undef, $$lnref);
        my %found;
        @{$$self->[2]->{$key} ||= []}
            = grep { length $_ and not $found{$_}++ }
              split /[\x09\x0A\x0C\x0D\x20]+/,
              (defined $value ? $value : '');
      }
  
      if ($$lnref eq 'style') {
        ## See |Web::DOM::Internal::source_style| and
        ## |Web::DOM::CSSStyleDeclaration::_modified|.
        my $style = $$self->[0]->{source_style}->[$$self->[1]];
        if (defined $style and not $$style->[2]) { # updating flag
          my $value = $self->get_attribute_ns (undef, $$lnref);
          local $$style->[2] = 1; # updating flag
          $style->css_text (defined $value ? $value : '');
        }
      }
    }
  
    $$self->[0]->{revision}++;
  } # _attribute_is
  
  push @EXPORT, qw(_define_reflect_string);
  sub _define_reflect_string ($$;$) {
    my ($perl_name, $content_name, $default) = @_;
    my $class = caller;
    $default = '' if not defined $default;
    eval sprintf q{
      *%s::%s = sub ($;$) {
        if (@_ > 1) {
          $_[0]->set_attribute_ns (undef, '%s', $_[1]);
          return unless defined wantarray;
        }
  
        my $v = $_[0]->get_attribute_ns (undef, '%s');
        return defined $v ? $v : $default;
      };
      1;
    }, $class, $perl_name, $content_name, $content_name or die $@;
  } # _define_reflect_string
  
  push @EXPORT, qw(_define_reflect_url);
  sub _define_reflect_url ($$) {
    my ($perl_name, $content_name) = @_;
    my $class = caller;
    eval sprintf q{
      *%s::%s = sub ($;$) {
        if (@_ > 1) {
          $_[0]->set_attribute_ns (undef, '%s', $_[1]);
          return unless defined wantarray;
        }
  
        my $v = $_[0]->get_attribute_ns (undef, '%s');
        if (defined $v) {
          my $w = _resolve_url $v, $_[0]->base_uri;
          return defined $w ? $w : $v;
        } else {
          return '';
        }
      };
      1;
    }, $class, $perl_name, $content_name, $content_name or die $@;
  } # _define_reflect_url
  
  push @EXPORT, qw(_define_reflect_neurl);
  *_define_reflect_neurl = \&_define_reflect_url;
  
  push @EXPORT, qw(_define_reflect_string_undef);
  sub _define_reflect_string_undef ($$) {
    my ($perl_name, $content_name) = @_;
    my $class = caller;
    eval sprintf q{
      *%s::%s = sub ($;$) {
        if (@_ > 1) {
          $_[0]->set_attribute_ns (undef, '%s', defined $_[1] ? $_[1] : '');
          return unless defined wantarray;
        }
  
        my $v = $_[0]->get_attribute_ns (undef, '%s');
        return defined $v ? $v : '';
      };
      1;
    }, $class, $perl_name, $content_name, $content_name or die $@;
  } # _define_reflect_string_undef
  
  push @EXPORT, qw(_define_reflect_enumerated);
  sub _define_reflect_enumerated ($$$) {
    my ($perl_name, $content_name, $values) = @_;
    my $class = caller;
    eval sprintf q{
      *%s::%s = sub ($;$) {
        if (@_ > 1) {
          $_[0]->set_attribute_ns (undef, '%s', $_[1]);
          return unless defined wantarray;
        }
  
        my $v = $_[0]->get_attribute_ns (undef, '%s');
        if (defined $v) {
          $v =~ tr/A-Z/a-z/; ## ASCII case-insensitive.
          if (defined $values->{$v} and not $v =~ /^\#/) {
            return $values->{$v};
          } else {
            return defined $values->{'#invalid'} ? $values->{'#invalid'} :
                   defined $values->{'#missing'} ? $values->{'#missing'} : '';
          }
        } else {
          return defined $values->{'#missing'} ? $values->{'#missing'} : '';
        }
      };
      1;
    }, $class, $perl_name, $content_name, $content_name or die $@;
  } # _define_reflect_enumerated
  
  push @EXPORT, qw(_define_reflect_nullable_enumerated);
  sub _define_reflect_nullable_enumerated ($$$) {
    my ($perl_name, $content_name, $values) = @_;
    my $class = caller;
    eval sprintf q{
      *%s::%s = sub ($;$) {
        if (@_ > 1) {
          if (defined $_[1]) {
            $_[0]->set_attribute_ns (undef, '%s', $_[1]);
          } else {
            $_[0]->remove_attribute_ns (undef, '%s');
          }
          return unless defined wantarray;
        }
  
        my $v = $_[0]->get_attribute_ns (undef, '%s');
        if (defined $v) {
          $v =~ tr/A-Z/a-z/; ## ASCII case-insensitive.
          if (defined $values->{$v} and not $v =~ /^\#/) {
            return $values->{$v};
          } else {
            return defined $values->{'#invalid'} ? $values->{'#invalid'} : undef;
          }
        } else {
          return undef;
        }
      };
      1;
    }, $class, $perl_name, $content_name, $content_name, $content_name or die $@;
  } # _define_reflect_nullable_enumerated
  
  push @EXPORT, qw(_define_reflect_boolean);
  sub _define_reflect_boolean ($$) {
    my ($perl_name, $content_name) = @_;
    my $class = caller;
    eval sprintf q{
      *%s::%s = sub ($;$) {
        if (@_ > 1) {
          if ($_[1]) {
            $_[0]->set_attribute_ns (undef, '%s', '');
          } else {
            $_[0]->remove_attribute_ns (undef, '%s');
          }
          return unless defined wantarray;
        }
  
        return $_[0]->has_attribute_ns (undef, '%s');
      };
      1;
    }, $class, $perl_name, $content_name, $content_name, $content_name or die $@;
  } # _define_reflect_boolean
  
  push @EXPORT, qw(_define_reflect_long);
  sub _define_reflect_long ($$$) {
    my ($perl_name, $content_name, $get_default) = @_;
    my $class = caller;
    eval sprintf q{
      *%s::%s = sub ($;$) {
        if (@_ > 1) {
          $_[0]->set_attribute_ns
              (undef, '%s', Web::DOM::Internal::_idl_long $_[1]);
          return unless defined wantarray;
        }
  
        my $v = $_[0]->get_attribute_ns (undef, '%s');
        if (defined $v and $v =~ /\A[\x09\x0A\x0C\x0D\x20]*([+-]?[0-9]+)/) {
          my $v = $1;
          return 0+$v if -2**31 <= $v and $v <= 2**31-1; # WebIDL long
        }
        return $get_default->($_[0]);
      };
      1;
    }, $class, $perl_name, $content_name, $content_name or die $@;
  } # _define_reflect_long
  
  push @EXPORT, qw(_define_reflect_long_nn);
  sub _define_reflect_long_nn ($$$) {
    my ($perl_name, $content_name, $get_default) = @_;
    my $class = caller;
    eval sprintf q{
      *%s::%s = sub ($;$) {
        if (@_ > 1) {
          my $v = Web::DOM::Internal::_idl_long $_[1];
          if ($v < 0) {
            _throw Web::DOM::Exception 'IndexSizeError',
                'The value cannot be set to a negative value';
          }
          $_[0]->set_attribute_ns (undef, '%s', $v);
          return unless defined wantarray;
        }
  
        my $v = $_[0]->get_attribute_ns (undef, '%s');
        if (defined $v and $v =~ /\A[\x09\x0A\x0C\x0D\x20]*([+-]?[0-9]+)/) {
          my $v = $1;
          return 0+$v if 0 <= $v and $v <= 2**31-1; # Web IDL long
        }
        return $get_default->($_[0]);
      };
      1;
    }, $class, $perl_name, $content_name, $content_name or die $@;
  } # _define_reflect_long_nn
  
  push @EXPORT, qw(_define_reflect_unsigned_long);
  sub _define_reflect_unsigned_long ($$$) {
    my ($perl_name, $content_name, $get_default) = @_;
    my $class = caller;
    eval sprintf q{
      *%s::%s = sub ($;$) {
        if (@_ > 1) {
          $_[0]->set_attribute_ns
              (undef, '%s', Web::DOM::Internal::_idl_unsigned_long $_[1]);
          return unless defined wantarray;
        }
  
        my $v = $_[0]->get_attribute_ns (undef, '%s');
        if (defined $v and $v =~ /\A[\x09\x0A\x0C\x0D\x20]*([+-]?[0-9]+)/) {
          my $v = $1;
          return 0+$v if 0 <= $v and $v <= 2**31-1; # Web IDL unsigned long
        }
        return $get_default->($_[0]);
      };
      1;
    }, $class, $perl_name, $content_name, $content_name or die $@;
  } # _define_reflect_unsigned_long
  
  push @EXPORT, qw(_define_reflect_unsigned_long_positive);
  sub _define_reflect_unsigned_long_positive ($$$) {
    my ($perl_name, $content_name, $get_default) = @_;
    my $class = caller;
    eval sprintf q{
      *%s::%s = sub ($;$) {
        if (@_ > 1) {
          my $v = Web::DOM::Internal::_idl_unsigned_long $_[1];
          if ($v == 0) {
            _throw Web::DOM::Exception 'IndexSizeError',
                'The value cannot be set to zero';
          }
          $_[0]->set_attribute_ns (undef, '%s', $v);
          return unless defined wantarray;
        }
  
        my $v = $_[0]->get_attribute_ns (undef, '%s');
        if (defined $v and $v =~ /\A[\x09\x0A\x0C\x0D\x20]*([+-]?[0-9]+)/) {
          my $v = $1;
          return 0+$v if 1 <= $v and $v <= 2**31-1; # Web IDL unsigned long
        }
        return $get_default->($_[0]);
      };
      1;
    }, $class, $perl_name, $content_name, $content_name or die $@;
  } # _define_reflect_unsigned_long_positive
  
  push @EXPORT, qw(_define_reflect_unsigned_long_positive_fb);
  sub _define_reflect_unsigned_long_positive_fb ($$$) {
    my ($perl_name, $content_name, $get_default) = @_;
    my $class = caller;
    eval sprintf q{
      *%s::%s = sub ($;$) {
        if (@_ > 1) {
          my $v = Web::DOM::Internal::_idl_unsigned_long $_[1];
          $v = $get_default->($_[0]) if $v == 0;
          $_[0]->set_attribute_ns (undef, '%s', $v);
          return unless defined wantarray;
        }
  
        my $v = $_[0]->get_attribute_ns (undef, '%s');
        if (defined $v and $v =~ /\A[\x09\x0A\x0C\x0D\x20]*([+-]?[0-9]+)/) {
          my $v = $1;
          return 0+$v if 1 <= $v and $v <= 2**31-1; # Web IDL unsigned long
        }
        return $get_default->($_[0]);
      };
      1;
    }, $class, $perl_name, $content_name, $content_name or die $@;
  } # _define_reflect_unsigned_long_positive_fb
  
  my $SupportedTokensList = {rel => {}, sandbox => {}, dropzone => {}}; # XXX
  
  push @EXPORT, qw(_define_reflect_settable_token_list);
  sub _define_reflect_settable_token_list ($$) {
    my ($perl_name, $content_name) = @_;
    my $class = caller;
    my $supported = $SupportedTokensList->{$content_name};
    eval sprintf q{
      *%s::%s = sub ($;$) {
        my $self = $_[0];
        if (@_ > 1) {
          $self->%s->value ($_[1]); # recursive!
          return unless defined wantarray;
        }
  
        return $$self->[0]->tokens ('%s', $self, sub {
          my $new = $$self->[2]->{%s} || [];
          $self->set_attribute_ns (undef, '%s' => join ' ', @$new)
              if @$new or $self->has_attribute_ns (undef, '%s');
        }, '%s', $supported);
      };
      1;
    }, $class, $perl_name, $perl_name,
       $perl_name, $perl_name, $content_name, $content_name, $content_name
       or die $@;
    $DOMTokenListAttributeMapping->{$content_name} = $perl_name;
  } # _define_reflect_settable_token_list
  
  _define_reflect_string id => 'id';
  
  sub manakai_ids ($) {
    my $id = $_[0]->get_attribute ('id');
    return defined $id ? [$id] : [];
  } # manakai_ids
  
  _define_reflect_string class_name => 'class';
  
  sub class_list ($) {
    my $self = $_[0];
    if (@_ > 1) {
      $self->class_name ($_[1]);
      return unless defined wantarray;
    }
    return $$self->[0]->tokens ('class_list', $self, sub {
      $self->set_attribute_ns
          (undef, class => join ' ', @{$$self->[2]->{class_list} ||= []});
    }, 'class');
  } # class_list
  
  sub manakai_base_uri ($;$) {
    return undef;
  } # manakai_base_uri
  
  sub outer_html ($;$) {
    ## See also: ParentNode->inner_html, Element->insert_adjacent_html
    my $self = $_[0];
    if (@_ > 1) {
      # 1.-2.
      my $parent = $self->parent_node or do { my $v = ''.$_[1]; return };
      my $parent_nt = $parent->node_type;
      my $context = $parent;
  
      if ($parent_nt == DOCUMENT_NODE) {
        # 3.
        _throw Web::DOM::Exception 'NoModificationAllowedError',
            'Cannot set outer_html of the document element';
      } elsif ($parent_nt == DOCUMENT_FRAGMENT_NODE) {
        # 4.
        $context = $parent->owner_document->create_element_ns (HTML_NS, 'body');
      }
  
      # 5.
      my $parser;
      if ($$self->[0]->{data}->[0]->{is_html}) {
        require Web::HTML::Parser;
        $parser = Web::HTML::Parser->new;
      } else {
        require Web::XML::Parser;
        $parser = Web::XML::Parser->new;
        my $orig_onerror = $parser->onerror;
        $parser->onerror (sub {
          my %args = @_;
          $orig_onerror->(@_);
          if (($args{level} || 'm') eq 'm') {
            $parser->throw (sub {
              undef $parser;
              _throw Web::DOM::Exception 'SyntaxError',
                  'The given string is ill-formed as XML';
            });
          }
        });
      }
      # XXX errors should be redirected to the Console object.
      my $new_children = $parser->parse_char_string_with_context
          (defined $_[1] ? ''.$_[1] : '', $context, new Web::DOM::Document);
      my $fragment = $self->owner_document->create_document_fragment;
      $fragment->append_child ($_) for $new_children->to_list;
  
      # 6.
      $parent->replace_child ($fragment, $self);
      
      return undef unless defined wantarray;
    }
  
    if ($$self->[0]->{data}->[0]->{is_html}) {
      require Web::HTML::Serializer;
      return ${ Web::HTML::Serializer->new->get_inner_html ([$self]) };
    } else {
      require Web::XML::Serializer;
      return ${ Web::XML::Serializer->new->get_inner_html ([$self]) };
    }
  } # outer_html
  
  sub insert_adjacent_html ($$$) {
    my $self = $_[0];
    my $position = ''.$_[1];
    my $v = defined $_[2] ? ''.$_[2] : '';
  
    my $code = sub {
      ## See also: ParentNode->inner_html, Element->outer_html
  
      my $context = $_[0];
  
      if (not $context->node_type == ELEMENT_NODE or
          ($$self->[0]->{data}->[0]->{is_html} and
           $context->manakai_element_type_match (HTML_NS, 'html'))) {
        $context = $self->owner_document->create_element_ns (HTML_NS, 'body');
      }
  
      my $parser;
      if ($$self->[0]->{data}->[0]->{is_html}) {
        require Web::HTML::Parser;
        $parser = Web::HTML::Parser->new;
      } else {
        require Web::XML::Parser;
        $parser = Web::XML::Parser->new;
        my $orig_onerror = $parser->onerror;
        $parser->onerror (sub {
          my %args = @_;
          $orig_onerror->(@_);
          if (($args{level} || 'm') eq 'm') {
            $parser->throw (sub {
              undef $parser;
              _throw Web::DOM::Exception 'SyntaxError',
                  'The given string is ill-formed as XML';
            });
          }
        });
      }
      # XXX errors should be redirected to the Console object.
      my $new_children = $parser->parse_char_string_with_context
          ($v, $context, new Web::DOM::Document);
      undef $parser;
  
      my $fragment = $self->owner_document->create_document_fragment;
      $fragment->append_child ($_) for $new_children->to_list;
  
      return $fragment;
  
    }; # $code
  
    $self->_insert_adjacent ($position, $code, 'html');
    return;
  } # insert_adjacent_html
  
  sub insert_adjacent_element ($$$) {
    my $self = $_[0];
    my $position = ''.$_[1];
    my $el = $_[2];
    unless (UNIVERSAL::isa ($el, 'Web::DOM::Element')) {
      _throw Web::DOM::TypeError 'The argument is not an Element';
    }
    if ($self->_insert_adjacent ($position, sub { return $el }, 0)) {
      return $el;
    } else {
      return undef;
    }
  } # insert_adjacent_element
  
  sub insert_adjacent_text ($$$) {
    my $self = $_[0];
    my $position = ''.$_[1];
    my $text = $self->owner_document->create_text_node (''.$_[2]);
    $self->_insert_adjacent ($position, sub { return $text }, 0);
    return undef;
  } # insert_adjacent_text
  
  sub _insert_adjacent ($$$$) {
    my ($self, $position, $code, $html) = @_;
    $position =~ tr/A-Z/a-z/;
    my $context;
    if ($position eq 'beforebegin' or $position eq 'afterend') {
      $context = $self->parent_node;
      if ($html) {
        if (not defined $context or $context->node_type == DOCUMENT_NODE) {
          _throw Web::DOM::Exception 'NoModificationAllowedError',
              'Cannot insert before or after the root element';
        }
      } else {
        return 0 if not defined $context;
      }
    } elsif ($position eq 'afterbegin' or $position eq 'beforeend') {
      $context = $self;
    } else {
      _throw Web::DOM::Exception 'SyntaxError',
          'Unknown position is specified';
    }
  
    my $node = $code->($context);
  
    if ($position eq 'beforebegin') {
      $self->parent_node->insert_before ($node, $self);
    } elsif ($position eq 'afterbegin') {
      $self->insert_before ($node, $self->first_child);
    } elsif ($position eq 'beforeend') {
      $self->append_child ($node);
    } elsif ($position eq 'afterend') {
      $self->parent_node->insert_before ($node, $self->next_sibling);
    }
    return 1;
  } # _insert_adjacent
  
  push @EXPORT, qw(_define_reflect_child_string);
  sub _define_reflect_child_string ($$$) {
    my ($perl_name, $nsurl, $ln) = @_;
    my $class = caller;
    eval sprintf q{
      sub %s::%s ($;$) {
        my $self = $_[0];
  
        my $el;
        for ($self->child_nodes->to_list) {
          if ($_->node_type == ELEMENT_NODE and
              $_->local_name eq '%s' and
              ($_->namespace_uri || '') eq '%s') {
            $el = $_;
            last;
          }
        }
  
        if (@_ > 1) {
          if ($el) {
            $el->text_content ($_[1]);
          } else {
            $el = $self->owner_document->create_element_ns ('%s', '%s');
            $el->text_content ($_[1]);
            $self->append_child ($el);
          }
          return unless defined wantarray;
        }
  
        return $el ? $el->text_content : '';
      }
      1;
    }, $class, $perl_name, $ln, $nsurl, $nsurl, $ln or die $@;
  } # _define_reflect_child_string
  
  push @EXPORT, qw(_define_reflect_child_url);
  sub _define_reflect_child_url ($$$) {
    my ($perl_name, $nsurl, $ln) = @_;
    my $class = caller;
    eval sprintf q{
      sub %s::%s ($;$) {
        my $self = $_[0];
  
        my $el;
        for ($self->child_nodes->to_list) {
          if ($_->node_type == ELEMENT_NODE and
              $_->local_name eq '%s' and
              ($_->namespace_uri || '') eq '%s') {
            $el = $_;
            last;
          }
        }
  
        if (@_ > 1) {
          if ($el) {
            $el->text_content ($_[1]);
          } else {
            $el = $self->owner_document->create_element_ns ('%s', '%s');
            $el->text_content ($_[1]);
            $self->append_child ($el);
          }
          return unless defined wantarray;
        }
  
        if ($el) {
          my $v = _resolve_url $el->text_content, $el->base_uri;
          return defined $v ? $v : '';
        } else {
          return '';
        }
      }
      1;
    }, $class, $perl_name, $ln, $nsurl, $nsurl, $ln or die $@;
  } # _define_reflect_child_url
  
  # XXX scripting enabled flag consideration...
  
  # XXX Slotable slot assignShadow shadowRoot
  
  1;
  
  =head1 LICENSE
  
  Copyright 2012-2016 Wakaba <wakaba@suikawiki.org>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
WEB_DOM_ELEMENT

$fatpacked{"Web/DOM/Error.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WEB_DOM_ERROR';
  package Web::DOM::Error;
  use strict;
  use warnings;
  no warnings 'utf8';
  our $VERSION = '2.0';
  use Carp;
  
  $Web::DOM::Error::L1ObjectClass->{(__PACKAGE__)} = 1;
  
  use overload
      '""' => 'stringify', bool => sub { 1 },
      cmp => sub {
        carp "Use of uninitialized value in string comparison (cmp)"
            unless defined $_[1];
        overload::StrVal ($_[0]) cmp overload::StrVal ($_[1])
      },
      fallback => 1;
  
  sub is_error ($$) {
    return $Web::DOM::Error::L1ObjectClass->{ref $_[1]};
  } # is_error
  
  sub new ($$) {
    my $self = bless {name => 'Error',
                      message => defined $_[1] ? ''.$_[1] : ''}, $_[0];
    $self->_set_stacktrace;
    return $self;
  } # new
  
  sub _set_stacktrace ($) {
    my $self = $_[0];
    if (Carp::shortmess =~ /at (.+) line ([0-9]+)\.?$/) {
      $self->{file_name} = $1;
      $self->{line_number} = $2;
    }
    # XXX stack
  } # _set_stacktrace
  
  sub wrap ($$) {
    return $_[1] if $_[0]->is_error ($_[1]);
    return $_[0]->new (
      (defined $_[1] && length $_[1]) ? $_[1] : "Something's wrong"
    );
  } # wrap
  
  sub name ($) { $_[0]->{name} }
  sub file_name ($) { $_[0]->{file_name} }
  sub line_number ($) { $_[0]->{line_number} || 0 }
  sub message ($) { $_[0]->{message} }
  
  sub stringify ($) {
    my $self = $_[0];
    my $name = $self->name;
    my $msg = $self->message;
    if (length $msg) {
      $msg = $name . ': ' . $msg if length $name;
    } else {
      $msg = $name;
    }
    my $fn = $self->file_name;
    return sprintf "%s at %s line %d.\n",
        $msg, defined $fn ? $fn : '(unknown)', $self->line_number || 0;
  } # stringify
  
  1;
  
  =head1 LICENSE
  
  Copyright 2012-2017 Wakaba <wakaba@suikawiki.org>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
WEB_DOM_ERROR

$fatpacked{"Web/DOM/Event.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WEB_DOM_EVENT';
  package Web::DOM::Event;
  use strict;
  use warnings;
  our $VERSION = '3.0';
  use Web::DOM::Internal;
  use Web::DOM::TypeError;
  
  our @EXPORT;
  *import = \&Web::DOM::Internal::import;
  
  push our @CARP_NOT, qw(Web::DOM::TypeError);
  
  sub _new ($) {
    return bless {
      type => '',
      timestamp => time, # XXX provide an option to enable Time::HiRes::time ?
    }, $_[0];
  } # _new
  
  sub _init_members ($) { [bubbles => 'boolean'], [cancelable => 'boolean'] }
  
  sub new ($$;$) {
    _throw Web::DOM::TypeError 'The second argument is not a hash reference'
        if defined $_[2] and not ref $_[2] eq 'HASH';
    my $self = $_[0]->_new;
    $self->{initialized} = 1;
    $self->{type} = ''.$_[1];
    for ($self->_init_members) {
      my ($key, $type, $if) = @$_;
      if (defined $_[2]->{$key}) {
        if ($type eq 'boolean') {
          $self->{$key} = !!$_[2]->{$key};
        } elsif ($type eq 'any') {
          $self->{$key} = $_[2]->{$key};
        } elsif ($type eq 'long') {
          $self->{$key} = _idl_long $_[2]->{$key};
        } elsif ($type eq 'unsigned long') {
          $self->{$key} = _idl_unsigned_long $_[2]->{$key};
        } elsif ($type eq 'unsigned short') {
          $self->{$key} = _idl_unsigned_short $_[2]->{$key};
        } elsif ($type eq 'double') { # WebIDL double
          my $value = 0+$_[2]->{$key};
          if ($value =~ /\A-?(?:[Nn]a[Nn]|[Ii]nf)\z/) {
            _throw Web::DOM::TypeError "The |$key| value is out of range";
          }
          $self->{$key} = $value;
        } elsif ($type eq 'string') {
          $self->{$key} = ''.$_[2]->{$key};
        } elsif ($type eq 'string?') {
          $self->{$key} = defined $_[2]->{$key} ? ''.$_[2]->{$key} : undef;
        } elsif ($type eq 'object?') {
          if (defined $_[2]->{$key}) {
            _throw Web::DOM::TypeError
                "The |$key| value is not an object of interface |$if|"
                unless UNIVERSAL::isa ($_[2]->{$key}, "Web::DOM::$if");
            $self->{$key} = $_[2]->{$key};
          } else {
            delete $self->{$key};
          }
        } else {
          die "Value type |$type| is not defined";
        }
      }
    }
    return $self;
  } # new
  
  sub type ($) { $_[0]->{type} }
  sub target ($) { $_[0]->{target} } # or undef
  *src_element = \&target;
  sub current_target ($) { $_[0]->{current_target} } # or undef
  
  push @EXPORT, qw(NONE CAPTURING_PHASE AT_TARGET BUBBLING_PHASE);
  sub NONE () { 0 }
  sub CAPTURING_PHASE () { 1 }
  sub AT_TARGET () { 2 }
  sub BUBBLING_PHASE () { 3 }
  sub event_phase ($) { $_[0]->{event_phase} || 0 }
  sub manakai_dispatched ($) { $_[0]->{dispatch} }
  
  sub stop_propagation ($) { $_[0]->{stop_propagation} = 1; undef }
  sub manakai_propagation_stopped ($) { $_[0]->{stop_propagation} }
  
  sub cancel_bubble ($;$) {
    if (@_ > 1) {
      $_[0]->{stop_propagation} = 1 if $_[1];
    }
    return $_[0]->{stop_propagation};
  } # cancel_bubble
  
  sub stop_immediate_propagation ($) {
    $_[0]->{stop_propagation} = 1;
    $_[0]->{stop_immediate_propagation} = 1;
    return undef;
  } # stop_immediate_propagation
  
  sub manakai_immediate_propagation_stopped ($) {
    return $_[0]->{stop_immediate_propagation};
  } # manakai_immediate_propagation_stopped
  
  sub bubbles ($) { $_[0]->{bubbles} }
  sub cancelable ($) { $_[0]->{cancelable} }
  
  sub prevent_default ($) {
    ## Set the canceled flag
    $_[0]->{canceled} = 1 if $_[0]->{cancelable} and
                             not $_[0]->{in_passive_listener};
    return undef;
  } # prevent_default
  sub default_prevented ($) { $_[0]->{canceled} }
  sub return_value ($;$) {
    if (@_ > 1) {
      if (not $_[1]) {
        ## Set the canceled flag
        $_[0]->{canceled} = 1 if $_[0]->{cancelable} and
                                 not $_[0]->{in_passive_listener};
      }
    }
    return not $_[0]->{canceled};
  } # return_value
  
  sub is_trusted ($) { $_[0]->{is_trusted} }
  sub timestamp ($) { $_[0]->{timestamp} }
  
  sub _initialize ($;$$$) {
    my $self = $_[0];
    return 0 if $self->{dispatch};
  
    ## Initialize
    ## <https://dom.spec.whatwg.org/#concept-event-initialize>.
  
    $self->{initialized} = 1;
    delete $self->{stop_propagation};
    delete $self->{stop_immediate_propagation};
    delete $self->{canceled};
    delete $self->{is_trusted};
    delete $self->{target};
    
    $self->{type} = $_[1];
    $self->{bubbles} = $_[2];
    $self->{cancelable} = $_[3];
    return 1;
  } # _initialize
  
  sub init_event ($$;$$) {
    $_[0]->_initialize (''.$_[1], !!$_[2], !!$_[3]) or return undef;
    return undef;
  } # init_event
  
  package Web::DOM::CustomEvent;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::Event);
  
  sub _init_members ($) { $_[0]->SUPER::_init_members, [detail => 'any'] }
  
  sub detail ($) { $_[0]->{detail} } # or undef
  
  sub init_custom_event ($$;$$$) {
    $_[0]->_initialize (''.$_[1], !!$_[2], !!$_[3]) or return undef;
    $_[0]->{detail} = $_[4];
    return undef;
  } # init_custom_event
  
  package Web::DOM::UIEvent;
  our $VERSION = '2.0';
  push our @ISA, qw(Web::DOM::Event);
  use Web::DOM::Internal;
  
  sub _init_members ($) { $_[0]->SUPER::_init_members,
                          [view => 'object?', 'WindowProxy'], # willful violation
                          [detail => 'long'] }
  
  sub detail ($) { $_[0]->{detail} || 0 }
  sub view ($) { $_[0]->{view} } # or undef
  
  sub init_ui_event ($$$$$$) {
    my ($type, $bubbles, $cancelable) = (''.$_[1], !!$_[2], !!$_[3]);
    _throw Web::DOM::TypeError 'The fourth argument is not a WindowProxy'
        if defined $_[4] and not UNIVERSAL::isa ($_[4], 'Web::DOM::WindowProxy');
    ## s/AbstractView/WindowProxy/, this is a willful violation to DOM3Events
    my $detail = _idl_long ($_[5]);
    $_[0]->_initialize ($type, $bubbles, $cancelable) or return undef;
    $_[0]->{view} = $_[4];
    $_[0]->{detail} = $detail;
    return undef;
  } # init_ui_event
  
  package Web::DOM::FocusEvent;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::UIEvent);
  
  sub _init_members ($) { $_[0]->SUPER::_init_members,
                          [related_target => 'object?', 'EventTarget'] }
  
  sub related_target ($) { $_[0]->{related_target} } # or undef
  
  # initFocusEvent not implemented by Chrome
  
  package Web::DOM::MouseEvent;
  our $VERSION = '2.0';
  push our @ISA, qw(Web::DOM::UIEvent);
  use Web::DOM::Internal;
  
  sub _init_members ($) { $_[0]->SUPER::_init_members,
                          [screen_x => 'long'],
                          [screen_y => 'long'],
                          [client_x => 'long'],
                          [client_y => 'long'],
                          [ctrl_key => 'boolean'],
                          [shift_key => 'boolean'],
                          [alt_key => 'boolean'],
                          [meta_key => 'boolean'],
                          [button => 'unsigned short'],
                          [buttons => 'unsigned short'],
                          [related_target => 'object?', 'EventTarget'],
                          [region => 'string?'] }
  
  sub alt_key ($) { $_[0]->{alt_key} }
  sub alt_graph_key ($) { $_[0]->{alt_graph_key} }
  sub button ($) { $_[0]->{button} || 0 }
  sub buttons ($) { $_[0]->{buttons} || 0 }
  sub client_x ($) { $_[0]->{client_x} || 0 }
  sub client_y ($) { $_[0]->{client_y} || 0 }
  sub ctrl_key ($) { $_[0]->{ctrl_key} }
  sub meta_key ($) { $_[0]->{meta_key} }
  sub related_target ($) { $_[0]->{related_target} } # or undef
  sub screen_x ($) { $_[0]->{screen_x} || 0 }
  sub screen_y ($) { $_[0]->{screen_y} || 0 }
  sub shift_key ($) { $_[0]->{shift_key} }
  sub offset_x ($) { $_[0]->{offset_x} || 0 }
  sub offset_y ($) { $_[0]->{offset_y} || 0 }
  sub page_x ($) { $_[0]->{page_x} || 0 }
  sub page_y ($) { $_[0]->{page_y} || 0 }
  sub x ($) { $_[0]->client_x }
  sub y ($) { $_[0]->client_y }
  sub region ($) { $_[0]->{region} } # or undef
  
  # XXX layer_x layer_y
  
  *get_modifier_state = \&Web::DOM::KeyboardEvent::get_modifier_state;
  
  sub init_mouse_event ($$$$$$$$$$$$$$$$) {
    my ($type, $bubbles, $cancelable) = (''.$_[1], !!$_[2], !!$_[3]);
    _throw Web::DOM::TypeError 'The fourth argument is not a WindowProxy'
        if defined $_[4] and not UNIVERSAL::isa ($_[4], 'Web::DOM::WindowProxy');
        ## A willful violation
    my $detail = _idl_long $_[5];
    my $sx = _idl_long $_[6];
    my $sy = _idl_long $_[7];
    my $cx = _idl_long $_[8];
    my $cy = _idl_long $_[9];
    my ($ctrl, $alt, $shift, $meta) = (!!$_[10], !!$_[11], !!$_[12], !!$_[13]);
    my $button = _idl_unsigned_short $_[14];
    _throw Web::DOM::TypeError 'The 16th argument is not an EventTarget'
        if defined $_[15] and
           not UNIVERSAL::isa ($_[15], 'Web::DOM::EventTarget');
    $_[0]->_initialize ($type, $bubbles, $cancelable) or return undef;
    $_[0]->{view} = $_[4];
    $_[0]->{detail} = $detail;
    $_[0]->{screen_x} = $sx;
    $_[0]->{screen_y} = $sy;
    $_[0]->{client_x} = $cx;
    $_[0]->{client_y} = $cy;
    $_[0]->{ctrl_key} = $ctrl;
    $_[0]->{alt_key} = $alt;
    $_[0]->{shift_key} = $shift;
    $_[0]->{meta_key} = $meta;
    $_[0]->{button} = $button;
    $_[0]->{related_target} = $_[15];
    return undef;
  } # init_mouse_event
  
  package Web::DOM::WheelEvent;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::MouseEvent);
  
  our @EXPORT;
  *import = \&Web::DOM::Internal::import;
  
  sub _init_members ($) { $_[0]->SUPER::_init_members,
                          [delta_x => 'double'],
                          [delta_y => 'double'],
                          [delta_z => 'double'],
                          [delta_mode => 'unsigned long'] }
  
  push @EXPORT, qw(DOM_DELTA_PIXEL DOM_DELTA_LINE DOM_DELTA_PAGE);
  
  sub DOM_DELTA_PIXEL () { 0x00 }
  sub DOM_DELTA_LINE () { 0x01 }
  sub DOM_DELTA_PAGE () { 0x02 }
  
  sub delta_x ($) { $_[0]->{delta_x} || 0 }
  sub delta_y ($) { $_[0]->{delta_y} || 0 }
  sub delta_z ($) { $_[0]->{delta_z} || 0 }
  sub delta_mode ($) { $_[0]->{delta_mode} || 0 }
  
  # Chrome implements initWebkitWheelEvent, not initWheelEvent
  
  package Web::DOM::KeyboardEvent;
  our $VERSION = '2.0';
  push our @ISA, qw(Web::DOM::UIEvent);
  use Web::DOM::Internal;
  
  sub _init_members ($) { $_[0]->SUPER::_init_members,
                          [char => 'string'],
                          [key => 'string'],
                          [code => 'string'],
                          [location => 'unsigned long'],
                          [ctrl_key => 'boolean'],
                          [shift_key => 'boolean'],
                          [alt_key => 'boolean'],
                          [meta_key => 'boolean'],
                          [repeat => 'boolean'],
                          [locale => 'string'],
                          [char_code => 'unsigned long'],
                          [key_code => 'unsigned long'],
                          [which => 'unsigned long'] }
  
  our @EXPORT = qw(DOM_KEY_LOCATION_STANDARD DOM_KEY_LOCATION_LEFT
                   DOM_KEY_LOCATION_RIGHT DOM_KEY_LOCATION_NUMPAD
                   DOM_KEY_LOCATION_MOBILE DOM_KEY_LOCATION_JOYSTICK);
  *import = \&Web::DOM::Internal::import;
  
  sub DOM_KEY_LOCATION_STANDARD () { 0x00 }
  sub DOM_KEY_LOCATION_LEFT     () { 0x01 }
  sub DOM_KEY_LOCATION_RIGHT    () { 0x02 }
  sub DOM_KEY_LOCATION_NUMPAD   () { 0x03 }
  sub DOM_KEY_LOCATION_MOBILE   () { 0x04 }
  sub DOM_KEY_LOCATION_JOYSTICK () { 0x05 }
  
  sub char ($) { defined $_[0]->{char} ? $_[0]->{char} : '' }
  sub key ($) { defined $_[0]->{key} ? $_[0]->{key} : '' }
  sub location ($) { $_[0]->{location} || 0 }
  sub ctrl_key ($) { $_[0]->{ctrl_key} }
  sub shift_key ($) { $_[0]->{shift_key} }
  sub alt_key ($) { $_[0]->{alt_key} }
  sub alt_graph_key ($) { $_[0]->{alt_graph_key} }
  sub meta_key ($) { $_[0]->{meta_key} }
  sub repeat ($) { $_[0]->{repeat} }
  sub locale ($) { defined $_[0]->{locale} ? $_[0]->{locale} : '' }
  sub char_code ($) { $_[0]->{char_code} || 0 }
  sub key_code ($) { $_[0]->{key_code} || 0 }
  sub which ($) { $_[0]->{which} || 0 }
  sub code ($) { defined $_[0]->{code} ? $_[0]->{code} : '' }
  
  sub get_modifier_state ($$) {
    return $_[0]->{{
      Alt => 'alt_key',
      AltGraph => 'alt_graph_key',
      CapsLock => '_caps_lock_key',
      Control => 'ctrl_key',
      Fn => '_fn_key',
      Meta => 'meta_key',
      NumLock => '_num_lock_key',
      ScrollLock => '_scroll_lock_key',
      Shift => 'shift_key',
      SymbolLock => '_symbol_lock_key',
      OS => '_os_key',
    }->{''.$_[1]} || ''};
  } # get_modifier_state
  
  # XXX queryKeyCap queryLocale
  
  sub init_keyboard_event ($$$$$$$$$$$) {
    my ($type, $bubbles, $cancelable) = (''.$_[1], !!$_[2], !!$_[3]);
    _throw Web::DOM::TypeError 'The fourth argument is not a WindowProxy'
        if defined $_[4] and not UNIVERSAL::isa ($_[4], 'Web::DOM::WindowProxy');
    my $char = ''.$_[5];
    my $key = ''.$_[6];
    my $location = _idl_unsigned_long $_[7];
    my $modifiers_list = ''.$_[8];
    my $repeat = !!$_[9];
    my $locale = ''.$_[10];
    $_[0]->_initialize ($type, $bubbles, $cancelable) or return undef;
    $_[0]->{view} = $_[4];
    $_[0]->{char} = $char;
    $_[0]->{key} = $key;
    $_[0]->{location} = $location;
    delete $_[0]->{ctrl_key};
    delete $_[0]->{meta_key};
    delete $_[0]->{alt_key};
    delete $_[0]->{alt_graph_key};
    delete $_[0]->{shift_key};
    for (split /[\x09\x0A\x0D\x20]/, $modifiers_list) { # XML S
      if ($_ eq 'Control') {
        $_[0]->{ctrl_key} = 1;
      } elsif ($_ eq 'Shift') {
        $_[0]->{shift_key} = 1;
      } elsif ($_ eq 'Alt') {
        $_[0]->{alt_key} = 1;
      } elsif ($_ eq 'Meta') {
        $_[0]->{meta_key} = 1;
      } elsif ($_ eq 'AltGraph') {
        $_[0]->{alt_graph_key} = 1;
      }
    }
    $_[0]->{repeat} = $repeat;
    $_[0]->{locale} = $locale;
    return undef;
  } # init_keyboard_event
  
  package Web::DOM::CompositionEvent;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::UIEvent);
  
  sub _init_members ($) { $_[0]->SUPER::_init_members,
                          [data => 'string?'],
                          [locale => 'string'] }
  
  sub data ($) { $_[0]->{data} } # or undef
  sub locale ($) { defined $_[0]->{locale} ? $_[0]->{locale} : '' }
  
  sub init_composition_event ($$$$$$$) {
    my ($type, $bubbles, $cancelable) = (''.$_[1], !!$_[2], !!$_[3]);
    _throw Web::DOM::TypeError 'The fourth argument is not a Window'
        if defined $_[4] and not UNIVERSAL::isa ($_[4], 'Web::DOM::Window');
    my $data = defined $_[5] ? ''.$_[5] : undef;
    my $locale = $_[6];
    $_[0]->_initialize ($type, $bubbles, $cancelable) or return undef;
    $_[0]->{view} = $_[4];
    $_[0]->{data} = $data;
    $_[0]->{locale} = $locale;
    return undef;
  }
  
  package Web::DOM::TouchEvent;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::UIEvent);
  
  sub _init_members ($) { $_[0]->SUPER::_init_members,
                          [touches => 'object?', 'TouchList'],
                          [target_touches => 'object?', 'TouchList'],
                          [changed_touches => 'object?', 'TouchList'],
                          [alt_key => 'boolean'],
                          [meta_key => 'boolean'],
                          [ctrl_key => 'boolean'],
                          [shift_key => 'boolean'] }
  
  sub _touch () {
    require Web::DOM::TouchList;
    my $list = bless [], 'Web::DOM::TouchList';
    Internals::SvREADONLY (@$list, 1);
    return $list;
  } # _touch
  
  sub touches ($) { $_[0]->{touches} ||= _touch }
  sub target_touches ($) { $_[0]->{target_touches} ||= _touch }
  sub changed_touches ($) { $_[0]->{changed_touches} ||= _touch }
  sub ctrl_key ($) { $_[0]->{ctrl_key} }
  sub shift_key ($) { $_[0]->{shift_key} }
  sub alt_key ($) { $_[0]->{alt_key} }
  sub meta_key ($) { $_[0]->{meta_key} }
  
  package Web::DOM::MessageEvent;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::Event);
  
  sub _init_members ($) { $_[0]->SUPER::_init_members,
                          [data => 'any'],
                          [origin => 'string'],
                          [last_event_id => 'string'],
                          [source => 'object?', 'WindowProxy'], # XXX or MessagePort
                          [ports => 'object?', 'XXX sequence<MessagePort>'] }
  
  sub data ($) { $_[0]->{data} }
  sub origin ($) { defined $_[0]->{origin} ? $_[0]->{origin} : '' }
  sub last_event_id ($) { defined $_[0]->{last_event_id} ? $_[0]->{last_event_id} : '' }
  sub source ($) { $_[0]->{source} }
  sub ports ($) { $_[0]->{ports} }
  
  1;
  
  =head1 LICENSE
  
  Copyright 2013-2018 Wakaba <wakaba@suikawiki.org>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
WEB_DOM_EVENT

$fatpacked{"Web/DOM/EventTarget.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WEB_DOM_EVENTTARGET';
  package Web::DOM::EventTarget;
  use strict;
  use warnings;
  our $VERSION = '4.0';
  use Web::DOM::TypeError;
  use Web::DOM::Exception;
  use Web::DOM::Event;
  use Web::DOM::_Defs;
  
  push our @CARP_NOT, qw(Web::DOM::TypeError Web::DOM::Exception);
  
  ## event listener
  ##   0 - CODE
  ##   1 - capture flag
  ##   2 - removed flag
  ##   3 - Other options
  
  sub add_event_listener ($$;$$) {
    # WebIDL
    my $type = ''.$_[1];
    _throw Web::DOM::TypeError 'The second argument is not a code reference'
        if defined $_[2] and not ref $_[2] eq 'CODE';
  
    ## Flatten
    my $capture = 0;
    my $options = {};
    if (defined $_[3] and ref $_[3] eq 'HASH') {
      $capture = $_[3]->{capture} ? 1 : 0;
      $options->{passive} = 1 if $_[3]->{passive};
      $options->{once} = 1 if $_[3]->{once};
    } elsif ($_[3]) {
      $capture = 1;
    }
  
    # 1.
    return undef unless defined $_[2];
  
    # 2.
    my $obj = $_[0]->isa ('Web::DOM::Node') ? ${$_[0]}->[2] : $_[0];
    my $list = $obj->{event_listeners}->{$type} ||= [];
    for (@$list) {
      return undef if $_->[0] eq $_[2] and
                      $_->[1] == $capture;
    }
    push @$list, [$_[2], $capture, 0, $options];
    return undef;
  } # add_event_listener
  
  sub remove_event_listener ($$;$$) {
    # WebIDL
    my $type = ''.$_[1];
    _throw Web::DOM::TypeError 'The second argument is not a code reference'
        if defined $_[2] and not ref $_[2] eq 'CODE';
  
    ## Flatten
    my $capture = 0;
    if (defined $_[3] and ref $_[3] eq 'HASH') {
      $capture = $_[3]->{capture} ? 1 : 0;
    } elsif ($_[3]) {
      $capture = 1;
    }
  
    return undef unless defined $_[2];
    my $obj = $_[0]->isa ('Web::DOM::Node') ? ${$_[0]}->[2] : $_[0];
    my $list = $obj->{event_listeners}->{$type} ||= [];
    $obj->{event_listeners}->{$type} = [grep {
      if ($_->[0] eq $_[2] and $_->[1] == $capture) {
        $_->[2] = 1; # removed
        ();
      } else {
        $_;
      }
    } @$list];
    return undef;
  } # remove_event_listener
  
  sub dispatch_event ($$) {
    # WebIDL
    _throw Web::DOM::TypeError 'The argument is not an Event'
        unless UNIVERSAL::isa ($_[1], 'Web::DOM::Event');
  
    # 1.
    if ($_[1]->{dispatch} or not $_[1]->{initialized}) {
      _throw Web::DOM::Exception 'InvalidStateError',
          'The specified event is not dispatchable';
    }
  
    # 2.
    delete $_[1]->{is_trusted};
    
    # 3.
    return $_[0]->_dispatch_event ($_[1]);
  } # dispatch_event
  
  sub _dispatch_event ($$) {
    ## Dispatch <https://dom.spec.whatwg.org/#concept-event-dispatch>.
  
    # XXX Shadow DOM, relatedTarget
    
    # 1.-3.
    my $event = $_[1];
    $event->{dispatch} = 1;
    $event->{target} = $_[0];
  
    # 4.
    my $event_path = [];
    if ($_[0]->isa ('Web::DOM::Node')) {
      ## Ancestors: root .. parent
      my $p = $_[0];
      while ($p = $p->parent_node) {
        unshift @$event_path, $p;
      }
      # XXX
      #if (@$event_path and
      #    $event_path->[0]->node_type == DOCUMENT_NODE and
      #    $event_path->[0]->default_view and
      #    $event->type ne 'load') {
      #  unshift @$event_path, $event_path->[0]->default_view;
      #}
    } # Node
  
    # 5.-6.
    $event->{event_phase} = CAPTURING_PHASE;
    for my $obj (@$event_path) {
      last if $event->{stop_propagation};
      $_[0]->_invoke_event_listeners ($event => $obj);
    }
  
    # 6.-8.
    unless ($event->{stop_propagation}) {
      $event->{event_phase} = AT_TARGET;
      $_[0]->_invoke_event_listeners ($event => $_[0]);
    }
  
    # 9.
    if ($event->bubbles) {
      $event->{event_phase} = BUBBLING_PHASE;
      for my $obj (reverse @$event_path) {
        last if $event->{stop_propagation};
        $_[0]->_invoke_event_listeners ($event => $obj);
      }
    }
  
    # 10.-13.
    delete $event->{dispatch};
    delete $event->{stop_propagation};
    delete $event->{stop_immediate_propagation};
    delete $event->{event_phase};
    delete $event->{current_target};
  
    # XXX if shadow tree, ...
  
    return not $event->{canceled};
  } # _dispatch_event
  
  sub _invoke_event_listeners ($$$) {
    # 1.
    my $event = $_[1];
    my $orig_type = $event->type;
    my $legacy_type = $Web::DOM::_Defs->{legacy_event}->{$orig_type};
    
    # 2.
    my $obj = $_[2]->isa ('Web::DOM::Node') ? ${$_[2]}->[2] : $_[2];
    my $orig_listeners = $obj->{event_listeners}->{$orig_type} || [];
    my $legacy_listeners = defined $legacy_type
        ? $obj->{event_listeners}->{$legacy_type} || [] : [];
  
    # 3.
    $event->{current_target} = $_[2];
  
    # 4.
    my $inner = sub {
      my $found = 0;
      my @listener = @{$_[0]};
      for my $listener (@listener) {
        return if $event->{stop_immediate_propagation};
        next if $listener->[2]; # removed
        $found = 1;
        next if not $listener->[1] and $event->event_phase == CAPTURING_PHASE;
        next if $listener->[1] and $event->event_phase == BUBBLING_PHASE;
  
        @{$_[0]} = grep { $_ ne $listener } @{$_[0]} if $listener->[3]->{once};
  
        # XXX exception handling
        local $event->{in_passive_listener} = $listener->[3]->{passive};
        $listener->[0]->($event->current_target, $event);
      }
      return $found;
    }; # $inner
    my $found = $inner->($orig_listeners);
    if (not $found and $event->{is_trusted} and @$legacy_listeners) {
      local $event->{type} = $legacy_type;
      $inner->($legacy_listeners);
    }
  } # _invoke_event_listeners
  
  sub _fire_simple_event ($$$) {
    ## Fire an event named e
    ## <https://dom.spec.whatwg.org/#concept-event-fire>.
  
    require Web::DOM::Event;
    my $ev = Web::DOM::Event->new ($_[1], $_[2]);
    $ev->{is_trusted} = 1;
    return $_[0]->_dispatch_event ($ev);
  } # _fire_simple_event
  
  1;
  
  =head1 LICENSE
  
  Copyright 2013-2017 Wakaba <wakaba@suikawiki.org>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
WEB_DOM_EVENTTARGET

$fatpacked{"Web/DOM/Exception.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WEB_DOM_EXCEPTION';
  package Web::DOM::Exception;
  use strict;
  use warnings;
  no warnings 'utf8';
  use Web::DOM::Error;
  push our @ISA, qw(Web::DOM::Error);
  our $VERSION = '3.0';
  use Web::DOM::Internal;
  
  $Web::DOM::Error::L1ObjectClass->{(__PACKAGE__)} = 1;
  
  our @EXPORT;
  *import = \&Web::DOM::Internal::import;
  
  sub INDEX_SIZE_ERR () { 1 }
  sub DOMSTRING_SIZE_ERR () { 2 }
  sub HIERARCHY_REQUEST_ERR () { 3 }
  sub WRONG_DOCUMENT_ERR () { 4 }
  sub INVALID_CHARACTER_ERR () { 5 }
  sub NO_DATA_ALLOWED_ERR () { 6 }
  sub NO_MODIFICATION_ALLOWED_ERR () { 7 }
  sub NOT_FOUND_ERR () { 8 }
  sub NOT_SUPPORTED_ERR () { 9 }
  sub INUSE_ATTRIBUTE_ERR () { 10 }
  sub INVALID_STATE_ERR () { 11 }
  sub SYNTAX_ERR () { 12 }
  sub INVALID_MODIFICATION_ERR () { 13 }
  sub NAMESPACE_ERR () { 14 }
  sub INVALID_ACCESS_ERR () { 15 }
  sub VALIDATION_ERR () { 16 }
  sub TYPE_MISMATCH_ERR () { 17 }
  sub SECURITY_ERR () { 18 }
  sub NETWORK_ERR () { 19 }
  sub ABORT_ERR () { 20 }
  sub URL_MISMATCH_ERR () { 21 }
  sub QUOTA_EXCEEDED_ERR () { 22 }
  sub TIMEOUT_ERR () { 23 }
  sub INVALID_NODE_TYPE_ERR () { 24 }
  sub DATA_CLONE_ERR () { 25 }
  
  push @EXPORT, qw(
    INDEX_SIZE_ERR DOMSTRING_SIZE_ERR HIERARCHY_REQUEST_ERR
    WRONG_DOCUMENT_ERR INVALID_CHARACTER_ERR NO_DATA_ALLOWED_ERR
    NO_MODIFICATION_ALLOWED_ERR NOT_FOUND_ERR NOT_SUPPORTED_ERR
    INUSE_ATTRIBUTE_ERR INVALID_STATE_ERR SYNTAX_ERR
    INVALID_MODIFICATION_ERR NAMESPACE_ERR INVALID_ACCESS_ERR
    VALIDATION_ERR TYPE_MISMATCH_ERR SECURITY_ERR NETWORK_ERR ABORT_ERR
    URL_MISMATCH_ERR QUOTA_EXCEEDED_ERR TIMEOUT_ERR
    INVALID_NODE_TYPE_ERR DATA_CLONE_ERR
  );
  
  ## <http://dom.spec.whatwg.org/#error-names-table>
  my $NameToCode = {
    "IndexSizeError" => INDEX_SIZE_ERR,
    "HierarchyRequestError" => HIERARCHY_REQUEST_ERR,
    "WrongDocumentError" => WRONG_DOCUMENT_ERR,
    "InvalidCharacterError" => INVALID_CHARACTER_ERR,
    "NoModificationAllowedError" => NO_MODIFICATION_ALLOWED_ERR,
    "NotFoundError" => NOT_FOUND_ERR,
    "NotSupportedError" => NOT_SUPPORTED_ERR,
    "InUseAttributeError" => INUSE_ATTRIBUTE_ERR,
    "InvalidStateError" => INVALID_STATE_ERR,
    "SyntaxError" => SYNTAX_ERR,
    "InvalidModificationError" => INVALID_MODIFICATION_ERR,
    "NamespaceError" => NAMESPACE_ERR,
    "InvalidAccessError" => INVALID_ACCESS_ERR,
    "SecurityError" => SECURITY_ERR,
    "NetworkError" => NETWORK_ERR,
    "AbortError" => ABORT_ERR,
    "URLMismatchError" => URL_MISMATCH_ERR,
    "QuotaExceededError" => QUOTA_EXCEEDED_ERR,
    "TimeoutError" => TIMEOUT_ERR,
    "InvalidNodeTypeError" => INVALID_NODE_TYPE_ERR,
    "DataCloneError" => DATA_CLONE_ERR,
  }; # $NameToCode
  
  sub new ($$$) {
    my $self = bless {name => defined $_[2] ? ''.$_[2] : 'Error',
                      message => defined $_[1] ? ''.$_[1] : ''}, $_[0];
    $self->_set_stacktrace;
    return $self;
  } # new
  
  sub _throw ($$$) {
    die $_[0]->new ($_[2], $_[1]);
  } # _throw
  
  sub code ($) {
    return $NameToCode->{$_[0]->name} || 0;
  } # code
  
  1;
  
  =head1 LICENSE
  
  Copyright 2012-2017 Wakaba <wakaba@suikawiki.org>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
WEB_DOM_EXCEPTION

$fatpacked{"Web/DOM/HTMLCollection.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WEB_DOM_HTMLCOLLECTION';
  package Web::DOM::HTMLCollection;
  use strict;
  use warnings;
  use Web::DOM::Collection;
  push our @ISA, qw(Web::DOM::Collection);
  our $VERSION = '1.0';
  use Web::DOM::Internal;
  
  use overload
      '%{}' => sub {
        if (defined ${$_[0]}->[4] and
            ${${$_[0]}->[0]}->[0]->{revision} == ${$_[0]}->[5]) {
          return ${$_[0]}->[4];
        } else {
          return ${$_[0]}->[4] = do {
            my %data = map {
              my $name = ($_->namespace_uri || '') eq HTML_NS
                  ? $_->get_attribute_ns (undef, 'name') : undef;
              my $id = $_->get_attribute_ns (undef, 'id');
              (
               (defined $name && length $name ? ($name => $_) : ()),
               (defined $id && length $id ? ($id => $_) : ()),
              );
            } reverse $_[0]->to_list;
            tie my %hash, 'Web::DOM::Internal::ReadOnlyHash', \%data;
            delete ${$_[0]}->[2];
            ${$_[0]}->[5] = ${${$_[0]}->[0]}->[0]->{revision};
            \%hash;
          };
        }
      },
      fallback => 1;
  
  sub named_item ($$) {
    return $_[0]->{$_[1]};
  } # named_item
  
  1;
  
  =head1 LICENSE
  
  Copyright 2012-2013 Wakaba <wakaba@suikawiki.org>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
WEB_DOM_HTMLCOLLECTION

$fatpacked{"Web/DOM/HTMLElement.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WEB_DOM_HTMLELEMENT';
  package Web::DOM::HTMLElement;
  use strict;
  use warnings;
  our $VERSION = '2.0';
  push our @ISA, qw(Web::DOM::Element);
  use Web::DOM::Internal;
  use Web::DOM::Element;
  use Web::DOM::Exception;
  
  # XXX Constructor *EventHandlers
  
  _define_reflect_string title => 'title';
  _define_reflect_string lang => 'lang';
  _define_reflect_url itemid => 'itemid';
  _define_reflect_string accesskey => 'accesskey';
  _define_reflect_boolean itemscope => 'itemscope';
  _define_reflect_boolean hidden => 'hidden';
  _define_reflect_settable_token_list dropzone => 'dropzone';
  _define_reflect_settable_token_list itemtype => 'itemtype';
  _define_reflect_settable_token_list itemprop => 'itemprop';
  _define_reflect_settable_token_list itemref => 'itemref';
  _define_reflect_enumerated dir => 'dir', {
    ltr => 'ltr',
    rtl => 'rtl',
    auto => 'auto',
  };
  _define_reflect_enumerated inputmode => 'inputmode', {
    none => 'none',
    text => 'text',
    tel => 'tel',
    email => 'email',
    url => 'url',
    numeric => 'numeric',
    decimal => 'decimal',
    search => 'search',
  };
  _define_reflect_enumerated enterkeyhint => 'enterkeyhint', {
    map { $_ => $_ } qw(enter done go next previous search send)
  };
  
  sub translate ($;$) {
    if (@_ > 1) {
      $_[0]->set_attribute_ns (undef, translate => $_[1] ? 'yes' : 'no');
      return unless defined wantarray;
    }
  
    my $value = ($_[0]->namespace_uri || '') eq HTML_NS
        ? $_[0]->get_attribute_ns (undef, 'translate') : undef;
    if (defined $value) {
      if ($value eq '' or $value =~ /\A[Yy][Ee][Ss]\z/) {
        return 1;
      } elsif ($value =~ /\A[Nn][Oo]\z/) {
        return 0;
      }
    }
    my $pe = $_[0]->parent_element;
    if (defined $pe) {
      return $pe->Web::DOM::HTMLElement::translate;
    }
    return 1;
  } # translate
  
  sub draggable ($;$) {
    if (@_ > 1) {
      $_[0]->set_attribute_ns (undef, 'draggable', $_[1] ? 'true' : 'false');
      return unless defined wantarray;
    }
  
    my $value = $_[0]->get_attribute_ns (undef, 'draggable');
    if (defined $value) {
      if ($value =~ /\A[Tt][Rr][Uu][Ee]\z/) {
        return 1;
      } elsif ($value =~ /\A[Ff][Aa][Ll][Ss][Ee]\z/) {
        return 0;
      }
    }
    if (($_[0]->namespace_uri || '') eq HTML_NS) {
      my $ln = $_[0]->local_name;
      if ($ln eq 'img') {
        return 1;
      } elsif ($ln eq 'a' and $_[0]->has_attribute_ns (undef, 'href')) {
        return 1;
      }
    }
    return 0;
  } # draggable
  
  sub contenteditable ($;$) {
    if (@_ > 1) {
      my $value = ''.$_[1];
      if ($value =~ /\A[Tt][Rr][Uu][Ee]\z/) {
        $_[0]->set_attribute_ns (undef, contenteditable => 'true');
      } elsif ($value =~ /\A[Ff][Aa][Ll][Ss][Ee]\z/) {
        $_[0]->set_attribute_ns (undef, contenteditable => 'false');
      } elsif ($value =~ /\A[Ii][Nn][Hh][Ee][Rr][Ii][Tt]\z/) {
        $_[0]->remove_attribute_ns (undef, 'contenteditable');
      } else {
        _throw Web::DOM::Exception 'SyntaxError',
            'An invalid |contenteditable| value is specified';
      }
      return unless defined wantarray;
    }
  
    my $value = $_[0]->get_attribute_ns (undef, 'contenteditable');
    if (defined $value) {
      if ($value =~ /\A[Tt][Rr][Uu][Ee]\z/) {
        return 'true';
      } elsif ($value =~ /\A[Ff][Aa][Ll][Ss][Ee]\z/) {
        return 'false';
      }
    }
    return 'inherit';
  } # contenteditable
  
  sub dataset ($) {
    return ${$_[0]}->[0]->strmap ($_[0]);
  } # dataset
  
  sub manakai_get_properties ($) {
    my $self = $_[0];
    my $result = {};
  
    if ($self->has_attribute_ns (undef, 'itemscope')) {
      require Web::HTML::Microdata;
      my $md = Web::HTML::Microdata->new;
      # XXX onerror -> console
      my $item = $md->_get_item_of_element ($self, no_value => 1);
      for my $prop (keys %{$item->{props}}) {
        next unless @{$item->{props}->{$prop}};
        $result->{$prop} = [map { $_->{node} } @{$item->{props}->{$prop}}];
        Internals::SvREADONLY (@{$result->{$prop}}, 1);
        Internals::SvREADONLY ($_, 1) for @{$result->{$prop}};
      }
    }
  
    tie my %hash, 'Web::DOM::Internal::ReadOnlyHash', $result;
    return \%hash;
  } # manakai_get_properties
  
  sub itemvalue ($;$) {
    my $self = shift;
  
    unless ($self->has_attribute_ns (undef, 'itemprop')) {
      if (@_ > 0) {
        _throw Web::DOM::Exception 'InvalidAccessError',
            'The element has no |itemprop| attribute';
      }
      return undef;
    }
  
    if ($self->has_attribute_ns (undef, 'itemscope')) {
      if (@_ > 0) {
        _throw Web::DOM::Exception 'InvalidAccessError',
            'The value is an item';
      }
      return $self;
    }
  
    my $ln = $self->local_name;
    if ($ln eq 'meta') {
      return $self->content (@_);
    } elsif ($ln eq 'audio' or $ln eq 'embed' or $ln eq 'iframe' or
             $ln eq 'img' or $ln eq 'source' or $ln eq 'track' or
             $ln eq 'video') {
      return $self->src (@_);
    } elsif ($ln eq 'a' or $ln eq 'area' or $ln eq 'link') {
      return $self->href (@_);
    } elsif ($ln eq 'object') {
      return $self->data (@_);
    } elsif ($ln eq 'data') {
      return $self->value (@_);
    } elsif ($ln eq 'meter') {
      if (@_ > 0) {
        $self->set_attribute_ns (undef, 'value', $_[0]);
      }
      my $v = $self->get_attribute_ns (undef, 'value');
      return defined $v ? $v : '';
    } elsif ($ln eq 'time') {
      if (@_ > 0) {
        $self->datetime ($_[0]);
      }
      my $value = $self->get_attribute_ns (undef, 'datetime');
      return $value if defined $value;
      my $s = '';
      for ($self->child_nodes->to_list) {
        if ($_->node_type == 3) { # TEXT_NODE
          $s .= $_->data;
        }
      }
      return $s;
    } else {
      return $self->text_content (@_);
    }
  } # itemvalue
  
  # ElementCSSInlineStyle
  sub style ($;$) {
    my $style = ${$_[0]}->[0]->source_style ('attr', $_[0]);
    if (@_ > 1) {
      $style->css_text ($_[1]);
    }
    return $style;
  } # style
  
  # XXX autocapitalize
  
  ## ------ User interaction ------
  
  # XXX tabindex click focus blur accesskey_label is_contenteditable
  # spellcheck force_spell_check
  
  package Web::DOM::HTMLUnknownElement;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  
  package Web::DOM::HTMLHtmlElement;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  use Web::DOM::Element;
  
  _define_reflect_string version => 'version';
  
  package Web::DOM::HTMLHeadElement;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  
  package Web::DOM::HTMLTitleElement;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  use Web::DOM::Node;
  
  sub text ($;$) {
    if (@_ > 1) {
      $_[0]->text_content ($_[1]);
    }
  
    ## Child text content
    return join '',
        map { $_->data }
        grep { $_->node_type == TEXT_NODE } @{$_[0]->child_nodes};
  } # text
  
  package Web::DOM::HTMLBaseElement;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  use Web::DOM::Internal;
  use Web::DOM::Element;
  
  sub href ($;$) {
    if (@_ > 1) {
      $_[0]->set_attribute_ns (undef, href => $_[1]);
    }
  
    # 1., 3.
    my $url = $_[0]->get_attribute_ns (undef, 'href');
    return $_[0]->owner_document->base_uri if not defined $url;
  
    # 2. fallback base URL
    my $fallback_base_url = do {
      # 1.
      my $doc = $_[0]->owner_document;
      if ($doc->manakai_is_srcdoc) {
        # XXX
      }
  
      # 2.
      my $url = $doc->url;
      if ($url eq 'about:blank' and 'XXX') {
        # XXX
      }
  
      # 3.
      $url;
    };
  
    # 4.-5.
    $url = _resolve_url $url, $fallback_base_url;
    return $url if defined $url;
  
    # 6.
    return '';
  } # href
  
  _define_reflect_string target => 'target';
  
  package Web::DOM::HTMLLinkElement;
  our $VERSION = '2.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  use Web::DOM::Element;
  
  _define_reflect_neurl href => 'href';
  _define_reflect_string rel => 'rel';
  _define_reflect_string media => 'media';
  _define_reflect_string hreflang => 'hreflang';
  _define_reflect_string type => 'type';
  _define_reflect_nullable_enumerated crossorigin => 'crossorigin', {
    '' => 'anonymous',
    anonymous => 'anonymous',
    'use-credentials' => 'use-credentials',
    # #missing => no cors
  };
  _define_reflect_settable_token_list sizes => 'sizes';
  _define_reflect_string nonce => 'nonce';
  _define_reflect_string integrity => 'integrity';
  _define_reflect_string charset => 'charset';
  _define_reflect_string rev => 'rev';
  _define_reflect_string target => 'target';
  _define_reflect_settable_token_list rel_list => 'rel';
  
  _define_reflect_enumerated as => 'as', {
    map { $_ => $_ }
  qw(
  audio document embed font image manifest object report script
  serviceworker sharedworker style track video worker xslt
  fetch
  )
  };
  
  # XXX LinkStyle
  
  # XXX <link> -> StyleSheet reflection
  
  # XXX disabled
  
  package Web::DOM::HTMLMetaElement;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  use Web::DOM::Element;
  
  _define_reflect_string name => 'name';
  _define_reflect_string content => 'content';
  _define_reflect_string http_equiv => 'http-equiv';
  
  _define_reflect_string scheme => 'scheme';
  
  package Web::DOM::HTMLStyleElement;
  our $VERSION = '3.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  use Web::DOM::Element;
  
  _define_reflect_string type => 'type';
  _define_reflect_string media => 'media';
  _define_reflect_string nonce => 'nonce';
  
  ## The |LinkStyle| interface [NoInterfaceObject]
  ## Test: linkstyle.t
  sub sheet ($) {
    my $sheet_id = ${$_[0]}->[2]->{sheet};
    return defined $sheet_id ? ${$_[0]}->[0]->node ($sheet_id) : undef;
  } # sheet
  
  # XXX <style> -> StyleSheet reflection
  # XXX sheet should be cleared by removing steps
    # XXX test: appendChild, removeChild, adoptNode
  
  ## Test: cssstylesheet.t
  sub disabled ($;$) {
    my $sheet = $_[0]->sheet;
    if (defined $sheet) {
      return $sheet->disabled (@_ > 1 ? ($_[1]) : ());
    } else {
      return 0;
    }
  } # disabled
  
  package Web::DOM::HTMLScriptElement;
  our $VERSION = '2.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  use Web::DOM::Node;
  use Web::DOM::Element;
  
  _define_reflect_neurl src => 'src';
  _define_reflect_string type => 'type';
  _define_reflect_string charset => 'charset';
  _define_reflect_nullable_enumerated crossorigin => 'crossorigin', {
    '' => 'anonymous',
    anonymous => 'anonymous',
    'use-credentials' => 'use-credentials',
    # #missing => no cors
  };
  _define_reflect_boolean defer => 'defer';
  _define_reflect_boolean nomodule => 'nomodule';
  _define_reflect_string event => 'event';
  _define_reflect_string html_for => 'for';
  _define_reflect_string nonce => 'nonce';
  _define_reflect_string integrity => 'integrity';
  
  # XXX async
  
  sub text ($;$) {
    if (@_ > 1) {
      $_[0]->text_content ($_[1]);
    }
  
    ## Child text content
    return join '',
        map { $_->data }
        grep { $_->node_type == TEXT_NODE } @{$_[0]->child_nodes};
  } # text
  
  package Web::DOM::HTMLBodyElement;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  # XXX WindowEventHandlers
  use Web::DOM::Element;
  
  _define_reflect_string_undef text => 'text';
  _define_reflect_string_undef link => 'link';
  _define_reflect_string_undef alink => 'alink';
  _define_reflect_string_undef vlink => 'vlink';
  _define_reflect_string_undef bgcolor => 'bgcolor';
  _define_reflect_string background => 'background';
  
  package Web::DOM::HTMLHeadingElement;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  use Web::DOM::Element;
  
  _define_reflect_string align => 'align';
  
  package Web::DOM::HTMLParagraphElement;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  use Web::DOM::Element;
  
  _define_reflect_string align => 'align';
  
  package Web::DOM::HTMLHRElement;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  use Web::DOM::Element;
  
  _define_reflect_string align => 'align';
  _define_reflect_string color => 'color';
  _define_reflect_string size => 'size';
  _define_reflect_string width => 'width';
  _define_reflect_boolean noshade => 'noshade';
  
  package Web::DOM::HTMLPreElement;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  use Web::DOM::Element;
  
  _define_reflect_long width => 'width', sub { 0 };
  
  package Web::DOM::HTMLQuoteElement;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  use Web::DOM::Element;
  
  _define_reflect_url cite => 'cite';
  
  package Web::DOM::HTMLOListElement;
  our $VERSION = '2.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  use Web::DOM::Internal;
  use Web::DOM::Node;
  use Web::DOM::Element;
  
  _define_reflect_string type => 'type';
  _define_reflect_boolean reversed => 'reversed';
  _define_reflect_long start => 'start', sub { 1 };
  _define_reflect_boolean compact => 'compact';
  
  package Web::DOM::HTMLUListElement;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  use Web::DOM::Element;
  
  _define_reflect_boolean compact => 'compact';
  _define_reflect_string type => 'type';
  
  package Web::DOM::HTMLLIElement;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  use Web::DOM::Element;
  
  _define_reflect_long value => 'value', sub { 0 };
  _define_reflect_string type => 'type';
  
  package Web::DOM::HTMLDListElement;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  use Web::DOM::Element;
  
  _define_reflect_boolean compact => 'compact';
  
  package Web::DOM::HTMLDivElement;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  use Web::DOM::Element;
  
  _define_reflect_string align => 'align';
  
  package Web::DOM::HTMLAnchorElement;
  our $VERSION = '2.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  use Web::DOM::Element;
  
  _define_reflect_string target => 'target';
  _define_reflect_string download => 'download';
  _define_reflect_string rel => 'rel';
  _define_reflect_string hreflang => 'hreflang';
  _define_reflect_string type => 'type';
  _define_reflect_url href => 'href';
  _define_reflect_string ping => 'ping';
  
  # XXX URLUtils toString
  
  _define_reflect_string coords => 'coords';
  _define_reflect_string charset => 'charset';
  _define_reflect_string name => 'name';
  _define_reflect_string rev => 'rev';
  _define_reflect_string shape => 'shape';
  _define_reflect_settable_token_list rel_list => 'rel';
  
  sub text ($;$) {
    return shift->text_content (@_);
  } # text
  
  package Web::DOM::HTMLDataElement;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  use Web::DOM::Element;
  
  _define_reflect_string value => 'value';
  
  package Web::DOM::HTMLTimeElement;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  use Web::DOM::Element;
  
  _define_reflect_string datetime => 'datetime';
  
  package Web::DOM::HTMLSpanElement;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  
  package Web::DOM::HTMLBRElement;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  use Web::DOM::Element;
  
  _define_reflect_string clear => 'clear';
  
  package Web::DOM::HTMLModElement;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  use Web::DOM::Element;
  
  _define_reflect_url cite => 'cite';
  _define_reflect_string datetime => 'datetime';
  
  package Web::DOM::HTMLPictureElement;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  use Web::DOM::Element;
  
  package Web::DOM::HTMLImageElement;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  use Web::DOM::Element;
  
  # XXX constructor
  
  _define_reflect_string alt => 'alt';
  _define_reflect_neurl src => 'src';
  _define_reflect_string srcset => 'srcset';
  _define_reflect_nullable_enumerated crossorigin => 'crossorigin', {
    '' => 'anonymous',
    anonymous => 'anonymous',
    'use-credentials' => 'use-credentials',
    # #missing => no cors
  };
  _define_reflect_string usemap => 'usemap';
  _define_reflect_boolean ismap => 'ismap';
  _define_reflect_enumerated decoding => 'decoding', {
    sync => 'sync',
    async => 'async',
    auto => 'auto',
    '#missing' => 'auto',
    '#invalid', 'auto',
  };
  
  # XXX width height natural_width natural_height complete current_src
  
  _define_reflect_string align => 'align';
  _define_reflect_url longdesc => 'longdesc';
  _define_reflect_url lowsrc => 'lowsrc';
  _define_reflect_string name => 'name';
  _define_reflect_string_undef border => 'border';
  _define_reflect_unsigned_long hspace => 'hspace', sub { 0 };
  _define_reflect_unsigned_long vspace => 'vspace', sub { 0 };
  
  package Web::DOM::HTMLIFrameElement;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  use Web::DOM::Element;
  
  # XXX content_document content_window get_svg_document
  
  _define_reflect_string srcdoc => 'srcdoc';
  _define_reflect_string name => 'name';
  _define_reflect_neurl src => 'src';
  _define_reflect_string allow => 'allow';
  _define_reflect_boolean allowfullscreen => 'allowfullscreen';
  _define_reflect_boolean allowpaymentrequest => 'allowpaymentrequest';
  _define_reflect_string width => 'width';
  _define_reflect_string height => 'height';
  _define_reflect_settable_token_list sandbox => 'sandbox';
  
  _define_reflect_string align => 'align';
  _define_reflect_string frameborder => 'frameborder';
  _define_reflect_url longdesc => 'longdesc';
  _define_reflect_string scrolling => 'scrolling';
  _define_reflect_string_undef marginwidth => 'marginwidth';
  _define_reflect_string_undef marginheight => 'marginheight';
  
  package Web::DOM::HTMLEmbedElement;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  use Web::DOM::Element;
  # XXX plugin-specific interface getSVGDocument
  
  _define_reflect_neurl src => 'src';
  _define_reflect_string type => 'type';
  _define_reflect_string width => 'width';
  _define_reflect_string height => 'height';
  
  _define_reflect_string align => 'align';
  _define_reflect_string name => 'name';
  
  package Web::DOM::HTMLObjectElement;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  use Web::DOM::Element;
  # XXX plugin-specific interface
  
  # XXX form content_document content_window will_validate validity
  # validation_message check_validity set_custom_validity
  # get_svg_document
  
  _define_reflect_neurl data => 'data';
  _define_reflect_string type => 'type';
  _define_reflect_boolean typemustmatch => 'typemustmatch';
  _define_reflect_string name => 'name';
  _define_reflect_string usemap => 'usemap';
  _define_reflect_string width => 'width';
  _define_reflect_string height => 'height';
  
  _define_reflect_string align => 'align';
  _define_reflect_string archive => 'archive';
  _define_reflect_string_undef border => 'border';
  _define_reflect_string code => 'code';
  _define_reflect_boolean declare => 'declare';
  _define_reflect_unsigned_long hspace => 'hspace', sub { 0 };
  _define_reflect_string standby => 'standby';
  _define_reflect_unsigned_long vspace => 'vspace', sub { 0 };
  _define_reflect_string codetype => 'codetype';
  _define_reflect_url codebase => 'codebase';
  
  package Web::DOM::HTMLParamElement;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  use Web::DOM::Element;
  
  _define_reflect_string name => 'name';
  _define_reflect_string value => 'value';
  
  _define_reflect_string type => 'type';
  _define_reflect_string valuetype => 'valuetype';
  
  package Web::DOM::HTMLMediaElement;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  use Web::DOM::Element;
  
  _define_reflect_nullable_enumerated crossorigin => 'crossorigin', {
    '' => 'anonymous',
    anonymous => 'anonymous',
    'use-credentials' => 'use-credentials',
    # #missing => no cors
  };
  _define_reflect_boolean autoplay => 'autoplay';
  _define_reflect_boolean loop => 'loop';
  _define_reflect_boolean controls => 'controls';
  _define_reflect_boolean default_muted => 'muted';
  _define_reflect_neurl src => 'src';
  
  # XXX and more
  
  package Web::DOM::HTMLVideoElement;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::HTMLMediaElement);
  use Web::DOM::Element;
  
  _define_reflect_unsigned_long width => 'width', sub { 0 };
  _define_reflect_unsigned_long height => 'height', sub { 0 };
  _define_reflect_neurl poster => 'poster';
  _define_reflect_boolean playsinline => 'playsinline';
  
  # XXX video_width video_height
  
  package Web::DOM::HTMLAudioElement;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::HTMLMediaElement);
  
  # XXX constructor
  
  package Web::DOM::HTMLSourceElement;
  our $VERSION = '2.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  use Web::DOM::Element;
  
  _define_reflect_neurl src => 'src';
  _define_reflect_string type => 'type';
  _define_reflect_string media => 'media';
  _define_reflect_string srcset => 'srcset';
  _define_reflect_string sizes => 'sizes';
  
  package Web::DOM::HTMLTrackElement;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  use Web::DOM::Element;
  
  _define_reflect_neurl src => 'src';
  _define_reflect_enumerated kind => 'kind', {
    'subtitles' => 'subtitles',
    'captions' => 'captions',
    'descriptions' => 'descriptions',
    'chapters' => 'chapters',
    'metadata' => 'metadata',
    '#missing' => 'subtitles',
  };
  _define_reflect_string srclang => 'srclang';
  _define_reflect_string label => 'label';
  _define_reflect_boolean default => 'default';
  
  our @EXPORT = qw(NONE LOADING LOADED ERROR);
  
  sub NONE () { 0 }
  sub LOADING () { 1 }
  sub LOADED () { 2 }
  sub ERROR () { 3 }
  
  # XXX ready_state track
  
  package Web::DOM::HTMLCanvasElement;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  use Web::DOM::Element;
  
  _define_reflect_unsigned_long width => 'width', sub { 300 };
  _define_reflect_unsigned_long height => 'height', sub { 150 };
  
  # XXX and more
  
  package Web::DOM::HTMLMapElement;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  use Web::DOM::Element;
  
  _define_reflect_string name => 'name';
  
  # XXX areas
  
  package Web::DOM::HTMLAreaElement;
  our $VERSION = '2.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  use Web::DOM::Element;
  
  _define_reflect_string alt => 'alt';
  _define_reflect_string coords => 'coords';
  _define_reflect_string shape => 'shape';
  _define_reflect_string target => 'target';
  _define_reflect_string download => 'download';
  _define_reflect_string rel => 'rel';
  _define_reflect_url href => 'href';
  _define_reflect_string ping => 'ping';
  
  # XXX URLUtils toString
  
  _define_reflect_boolean nohref => 'nohref';
  _define_reflect_settable_token_list rel_list => 'rel';
  
  package Web::DOM::HTMLTableElement;
  our $VERSION = '2.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  use Web::DOM::Internal;
  use Web::DOM::Node;
  use Web::DOM::Element;
  
  _define_reflect_string align => 'align';
  _define_reflect_string border => 'border';
  _define_reflect_string frame => 'frame';
  _define_reflect_string rules => 'rules';
  _define_reflect_string summary => 'summary';
  _define_reflect_string width => 'width';
  _define_reflect_string_undef bgcolor => 'bgcolor';
  _define_reflect_string_undef cellpadding => 'cellpadding';
  _define_reflect_string_undef cellspacing => 'cellspacing';
  
  sub caption ($;$) {
    if (@_ > 1) {
      _throw Web::DOM::TypeError
          'The new value is not a |caption| element'
          if defined $_[1] and
             not UNIVERSAL::isa ($_[1], 'Web::DOM::HTMLTableCaptionElement');
      my $cap = $_[0]->caption; # recursive!
      $_[0]->remove_child ($cap) if defined $cap;
      $_[0]->insert_before ($_[1], $_[0]->first_child) if defined $_[1];
      return unless defined wantarray;
    }
  
    for ($_[0]->child_nodes->to_list) {
      if ($_->node_type == ELEMENT_NODE and
          $_->manakai_element_type_match (HTML_NS, 'caption')) {
        return $_;
      }
    }
    return undef;
  } # caption
  
  sub create_caption ($) {
    my $caption = $_[0]->caption;
    unless (defined $caption) {
      $caption = $_[0]->owner_document->create_element_ns (HTML_NS, 'caption');
      $_[0]->insert_before ($caption, $_[0]->first_child);
    }
    return $caption;
  } # create_caption
  
  sub delete_caption ($) {
    my $caption = $_[0]->caption;
    $_[0]->remove_child ($caption) if defined $caption;
    return;
  } # delete_caption
  
  sub thead ($;$) {
    if (@_ > 1) {
      _throw Web::DOM::TypeError
          'The new value is not a |thead| element'
          if defined $_[1] and
             not UNIVERSAL::isa ($_[1], 'Web::DOM::HTMLTableSectionElement');
      _throw Web::DOM::Exception 'HierarchyRequestError',
          'The new value is not a |thead| element'
              if defined $_[1] and not $_[1]->local_name eq 'thead';
      my $current = $_[0]->thead; # recursive!
      $_[0]->remove_child ($current) if defined $current;
      if (defined $_[1]) {
        my $after;
        for ($_[0]->child_nodes->to_list) {
          next unless $_->node_type == ELEMENT_NODE;
          next if $_->manakai_element_type_match (HTML_NS, 'caption');
          next if $_->manakai_element_type_match (HTML_NS, 'colgroup');
          $after = $_;
          last;
        }
        $_[0]->insert_before ($_[1], $after);
      }
      return unless defined wantarray;
    }
  
    for ($_[0]->child_nodes->to_list) {
      if ($_->node_type == ELEMENT_NODE and
          $_->manakai_element_type_match (HTML_NS, 'thead')) {
        return $_;
      }
    }
    return undef;
  } # thead
  
  sub create_thead ($) {
    my $current = $_[0]->thead;
    unless (defined $current) {
      $current = $_[0]->owner_document->create_element_ns (HTML_NS, 'thead');
      $_[0]->thead ($current);
    }
    return $current;
  } # create_thead
  
  sub delete_thead ($) {
    my $current = $_[0]->thead;
    $_[0]->remove_child ($current) if defined $current;
    return;
  } # delete_thead
  
  sub tfoot ($;$) {
    if (@_ > 1) {
      _throw Web::DOM::TypeError
          'The new value is not a |tfoot| element'
          if defined $_[1] and
             not UNIVERSAL::isa ($_[1], 'Web::DOM::HTMLTableSectionElement');
      _throw Web::DOM::Exception 'HierarchyRequestError',
          'The new value is not a |tfoot| element'
              if defined $_[1] and not $_[1]->local_name eq 'tfoot';
      my $current = $_[0]->tfoot; # recursive!
      $_[0]->remove_child ($current) if defined $current;
      $_[0]->append_child ($_[1]) if defined $_[1];
      return unless defined wantarray;
    }
  
    for ($_[0]->child_nodes->to_list) {
      if ($_->node_type == ELEMENT_NODE and
          $_->manakai_element_type_match (HTML_NS, 'tfoot')) {
        return $_;
      }
    }
    return undef;
  } # tfoot
  
  sub create_tfoot ($) {
    my $current = $_[0]->tfoot;
    unless (defined $current) {
      $current = $_[0]->owner_document->create_element_ns (HTML_NS, 'tfoot');
      $_[0]->tfoot ($current);
    }
    return $current;
  } # create_tfoot
  
  sub delete_tfoot ($) {
    my $current = $_[0]->tfoot;
    $_[0]->remove_child ($current) if defined $current;
    return;
  } # delete_tfoot
  
  sub tbodies ($) {
    my $self = shift;
    return $$self->[0]->collection ('tbodies', $self, sub {
      my $node = $_[0];
      return grep {
        $$node->[0]->{data}->[$_]->{node_type} == ELEMENT_NODE and
        ${$$node->[0]->{data}->[$_]->{namespace_uri} || \''} eq HTML_NS and
        ${$$node->[0]->{data}->[$_]->{local_name}} eq 'tbody';
      } @{$$node->[0]->{data}->[$$node->[1]]->{child_nodes} or []};
    });
  } # tbodies
  
  sub create_tbody ($) {
    my $tbody;
    for (reverse $_[0]->child_nodes->to_list) {
      if ($_->node_type == ELEMENT_NODE and
          $_->manakai_element_type_match (HTML_NS, 'tbody')) {
        $tbody = $_;
        last;
      }
    }
    my $new = $_[0]->owner_document->create_element_ns (HTML_NS, 'tbody');
    $_[0]->insert_before ($new, $tbody ? $tbody->next_sibling : undef);
    return $new;
  } # create_tbody
  
  sub rows ($) {
    my $self = shift;
    return $$self->[0]->collection ('rows', $self, sub {
      my $node = $_[0];
      my @head;
      my @body;
      my @foot;
      for (@{$$node->[0]->{data}->[$$node->[1]]->{child_nodes} or []}) {
        my $data = $$node->[0]->{data}->[$_];
        next unless $data->{node_type} == ELEMENT_NODE;
        next unless ${$data->{namespace_uri} || \''} eq HTML_NS;
        my $ln = ${$data->{local_name}};
        if ($ln eq 'tbody') {
          push @body, @{$$node->[0]->{data}->[$_]->{child_nodes} or []};
        } elsif ($ln eq 'thead') {
          push @head, @{$$node->[0]->{data}->[$_]->{child_nodes} or []};
        } elsif ($ln eq 'tfoot') {
          push @foot, @{$$node->[0]->{data}->[$_]->{child_nodes} or []};
        } elsif ($ln eq 'tr') {
          push @body, $_;
        }
      }
      return grep {
        $$node->[0]->{data}->[$_]->{node_type} == ELEMENT_NODE and
        ${$$node->[0]->{data}->[$_]->{namespace_uri} || \''} eq HTML_NS and
        ${$$node->[0]->{data}->[$_]->{local_name}} eq 'tr';
      } @head, @body, @foot;
    });
  } # rows
  
  sub insert_row ($;$) {
    my $index = _idl_long (defined $_[1] ? $_[1] : -1);
    my $rows = $_[0]->rows;
    my $row_count = $rows->length;
  
    if ($index < -1 or $index > $row_count) {
      _throw Web::DOM::Exception 'IndexSizeError',
          'The specified row index is invalid';
    } elsif ($row_count == 0) {
      my $tbodies = $_[0]->tbodies;
      if ($tbodies->length == 0) {
        my $doc = $_[0]->owner_document;
        my $tbody = $doc->create_element_ns (HTML_NS, 'tbody');
        my $tr = $doc->create_element_ns (HTML_NS, 'tr');
        $tbody->append_child ($tr);
        $_[0]->append_child ($tbody);
        return $tr;
      } else {
        my $tr = $_[0]->owner_document->create_element_ns (HTML_NS, 'tr');
        return $tbodies->[-1]->append_child ($tr);
      }
    } elsif ($index == -1 or $index == $row_count) {
      my $tr = $_[0]->owner_document->create_element_ns (HTML_NS, 'tr');
      return $rows->[-1]->parent_node->append_child ($tr);
    } else {
      my $tr = $_[0]->owner_document->create_element_ns (HTML_NS, 'tr');
      my $after = $rows->[$index];
      return $after->parent_node->insert_before ($tr, $after);
    }
  } # insert_row
  
  sub delete_row ($$) {
    my $index = _idl_long $_[1];
    my $rows = $_[0]->rows;
    my $row_count = @$rows;
  
    return if $index == -1 and $row_count == 0;
    $index = $row_count - 1 if $index == -1;
  
    if ($index < 0 or $index >= $row_count) {
      _throw Web::DOM::Exception 'IndexSizeError',
          'The specified row index is invalid';
    }
  
    my $row = $rows->[$index];
    $row->parent_node->remove_child ($row);
    return;
  } # delete_row
  
  package Web::DOM::HTMLTableCaptionElement;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  use Web::DOM::Element;
  
  _define_reflect_string align => 'align';
  
  package Web::DOM::HTMLTableColElement;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  use Web::DOM::Element;
  
  _define_reflect_unsigned_long_positive_fb span => 'span', sub { 1 };
  
  _define_reflect_string align => 'align';
  _define_reflect_string width => 'width';
  _define_reflect_string ch => 'char';
  _define_reflect_string ch_off => 'charoff';
  _define_reflect_string valign => 'valign';
  
  package Web::DOM::HTMLTableSectionElement;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  use Web::DOM::Internal;
  use Web::DOM::Node;
  use Web::DOM::Element;
  
  _define_reflect_string align => 'align';
  _define_reflect_string ch => 'char';
  _define_reflect_string ch_off => 'charoff';
  _define_reflect_string valign => 'valign';
  
  sub rows ($) {
    my $self = shift;
    return $$self->[0]->collection ('rows', $self, sub {
      my $node = $_[0];
      return grep {
        $$node->[0]->{data}->[$_]->{node_type} == ELEMENT_NODE and
        ${$$node->[0]->{data}->[$_]->{namespace_uri} || \''} eq HTML_NS and
        ${$$node->[0]->{data}->[$_]->{local_name}} eq 'tr';
      } @{$$node->[0]->{data}->[$$node->[1]]->{child_nodes} or []};
    });
  } # rows
  
  sub insert_row ($;$) {
    my $index = _idl_long (defined $_[1] ? $_[1] : -1);
    my $rows = $_[0]->rows;
    my $row_count = $rows->length;
  
    if ($index < -1 or $index > $row_count) {
      _throw Web::DOM::Exception 'IndexSizeError',
          'The specified row index is invalid';
    } elsif ($index == -1 or $index == $row_count) {
      my $tr = $_[0]->owner_document->create_element_ns (HTML_NS, 'tr');
      return $_[0]->append_child ($tr);
    } else {
      my $tr = $_[0]->owner_document->create_element_ns (HTML_NS, 'tr');
      my $after = $rows->[$index];
      return $_[0]->insert_before ($tr, $after);
    }
  } # insert_row
  
  sub delete_row ($$) {
    my $index = _idl_long $_[1];
    my $rows = $_[0]->rows;
  
    if ($index < 0 or $index >= @$rows) {
      _throw Web::DOM::Exception 'IndexSizeError',
          'The specified row index is invalid';
    }
  
    $_[0]->remove_child ($rows->[$index]);
    return;
  } # delete_row
  
  package Web::DOM::HTMLTableRowElement;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  use Web::DOM::Internal;
  use Web::DOM::Node;
  use Web::DOM::Element;
  
  _define_reflect_string align => 'align';
  _define_reflect_string_undef bgcolor => 'bgcolor';
  _define_reflect_string ch => 'char';
  _define_reflect_string ch_off => 'charoff';
  _define_reflect_string valign => 'valign';
  
  sub row_index ($) {
    my $parent = $_[0]->parent_node or return -1;
    return -1 unless $parent->node_type == ELEMENT_NODE;
    return -1 unless ($parent->namespace_uri || '') eq HTML_NS;
    my $parent_ln = $parent->local_name;
    if ($parent_ln eq 'tbody' or $parent_ln eq 'thead' or
        $parent_ln eq 'tfoot') {
      my $gp = $parent->parent_node or return -1;
      return -1 unless $gp->node_type == ELEMENT_NODE;
      return -1 unless $gp->manakai_element_type_match (HTML_NS, 'table');
      my $i = 0;
      for ($gp->rows->to_list) {
        return $i if $_ eq $_[0];
        $i++;
      }
    } elsif ($parent_ln eq 'table') {
      my $i = 0;
      for ($parent->rows->to_list) {
        return $i if $_ eq $_[0];
        $i++;
      }
    }
    return -1;
  } # row_index
  
  sub section_row_index ($) {
    my $parent = $_[0]->parent_node or return -1;
    return -1 unless $parent->node_type == ELEMENT_NODE;
    return -1 unless ($parent->namespace_uri || '') eq HTML_NS;
    my $parent_ln = $parent->local_name;
    if ($parent_ln eq 'tbody' or $parent_ln eq 'thead' or
        $parent_ln eq 'tfoot' or $parent_ln eq 'table') {
      my $i = 0;
      for ($parent->rows->to_list) {
        return $i if $_ eq $_[0];
        $i++;
      }
    }
    return -1;
  } # section_row_index
  
  sub cells ($) {
    my $self = shift;
    return $$self->[0]->collection ('cells', $self, sub {
      my $node = $_[0];
      return grep {
        $$node->[0]->{data}->[$_]->{node_type} == ELEMENT_NODE and
        ${$$node->[0]->{data}->[$_]->{namespace_uri} || \''} eq HTML_NS and
        ${$$node->[0]->{data}->[$_]->{local_name}} =~ /\At[dh]\z/; # td/th
      } @{$$node->[0]->{data}->[$$node->[1]]->{child_nodes} or []};
    });
  } # cells
  
  sub insert_cell ($;$) {
    my $index = _idl_long (defined $_[1] ? $_[1] : -1);
    my $cells = $_[0]->cells;
    my $cell_count = $cells->length;
  
    if ($index < -1 or $index > $cell_count) {
      _throw Web::DOM::Exception 'IndexSizeError',
          'The specified cell index is invalid';
    } elsif ($index == -1 or $index == $cell_count) {
      my $td = $_[0]->owner_document->create_element_ns (HTML_NS, 'td');
      return $_[0]->append_child ($td);
    } else {
      my $td = $_[0]->owner_document->create_element_ns (HTML_NS, 'td');
      my $after = $cells->[$index];
      return $_[0]->insert_before ($td, $after);
    }
  } # insert_cell
  
  sub delete_cell ($$) {
    my $index = _idl_long $_[1];
    my $cells = $_[0]->cells;
  
    if ($index < 0 or $index >= @$cells) {
      _throw Web::DOM::Exception 'IndexSizeError',
          'The specified cell index is invalid';
    }
  
    $_[0]->remove_child ($cells->[$index]);
    return;
  } # delete_cell
  
  package Web::DOM::HTMLTableCellElement;
  our $VERSION = '3.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  use Web::DOM::Internal;
  use Web::DOM::Node;
  use Web::DOM::Element;
  
  _define_reflect_unsigned_long colspan => 'colspan', sub { 1 };
  _define_reflect_unsigned_long rowspan => 'rowspan', sub { 1 };
  _define_reflect_string headers => 'headers';
  
  _define_reflect_string align => 'align';
  _define_reflect_string axis => 'axis';
  _define_reflect_string height => 'height';
  _define_reflect_string ch => 'char';
  _define_reflect_string ch_off => 'charoff';
  _define_reflect_boolean nowrap => 'nowrap';
  _define_reflect_string valign => 'valign';
  _define_reflect_string width => 'width';
  _define_reflect_string_undef bgcolor => 'bgcolor';
  
  sub cell_index ($) {
    my $parent = $_[0]->parent_node or return -1;
    return -1 unless $parent->node_type == ELEMENT_NODE;
    return -1 unless $parent->manakai_element_type_match (HTML_NS, 'tr');
    my $i = 0;
    for ($parent->cells->to_list) {
      return $i if $_ eq $_[0];
      $i++;
    }
    return -1;
  } # cell_index
  
  _define_reflect_enumerated scope => 'scope', {
    row => 'row',
    col => 'col',
    rowgroup => 'rowgroup',
    colgroup => 'colgroup',
    # #missing => #auto
  };
  _define_reflect_string abbr => 'abbr';
  
  package Web::DOM::HTMLFormElement;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  use Web::DOM::Element;
  
  _define_reflect_string accept_charset => 'accept-charset';
  _define_reflect_enumerated autocomplete => 'autocomplete', {
    on => 'on',
    off => 'off',
    '#missing' => 'on',
  };
  _define_reflect_enumerated enctype => 'enctype', {
    'application/x-www-form-urlencoded' => 'application/x-www-form-urlencoded',
    'multipart/form-data' => 'multipart/form-data',
    'text/plain' => 'text/plain',
    '#invalid' => 'application/x-www-form-urlencoded',
    '#missing' => 'application/x-www-form-urlencoded',
  };
  _define_reflect_enumerated encode => 'enctype', {
    'application/x-www-form-urlencoded' => 'application/x-www-form-urlencoded',
    'multipart/form-data' => 'multipart/form-data',
    'text/plain' => 'text/plain',
    '#invalid' => 'application/x-www-form-urlencoded',
    '#missing' => 'application/x-www-form-urlencoded',
  };
  _define_reflect_enumerated method => 'method', {
    get => 'get',
    post => 'post',
    dialog => 'dialog',
    '#invalid' => 'get',
    '#missing' => 'get',
  };
  _define_reflect_string name => 'name';
  _define_reflect_boolean novalidate => 'novalidate';
  _define_reflect_string target => 'target';
  _define_reflect_neurl action => 'action';
  
  # XXX elements length getter request_autocomplete
  
  ## ------ Validation and Submission ------
  
  # XXX submit reset check_validity
  
  package Web::DOM::HTMLFieldSetElement;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  use Web::DOM::Element;
  
  _define_reflect_boolean disabled => 'disabled';
  _define_reflect_string name => 'name';
  
  sub type ($) { 'fieldset' }
  
  # XXX form elements
  
  ## ------ Validation and Submission ------
  
  # XXX will_validate validity validation_message check_validity
  # set_custom_validity
  
  package Web::DOM::HTMLLegendElement;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  use Web::DOM::Element;
  
  # XXX form
  
  _define_reflect_string align => 'align';
  
  package Web::DOM::HTMLLabelElement;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  use Web::DOM::Internal;
  use Web::DOM::Element;
  
  # XXX form
  
  _define_reflect_string html_for => 'for';
  
  my $LabelableLocalNames = {
    button => 1,
    #input => 1,
    meter => 1,
    output => 1,
    progress => 1,
    select => 1,
    textarea => 1,
  };
  
  sub control ($) {
    my $for = $_[0]->get_attribute_ns (undef, 'for');
    if (defined $for) {
      my $control = $_[0]->owner_document->get_element_by_id ($for);
      if (defined $control) {
        my $ln = $control->local_name;
        if ($LabelableLocalNames->{$ln} and
            ($control->namespace_uri || '') eq HTML_NS) {
          return $control;
        } elsif ($ln eq 'input' and
                 ($control->namespace_uri || '') eq HTML_NS and
                 not $control->type eq 'hidden') {
          return $control;
        }
      }
      return undef;
    } else {
      # XXX input:not([type=hidden i])
      my $s = join ',', 'input:not([type=hidden])', keys %$LabelableLocalNames;
      return [grep { $_->local_name ne 'input' or $_->type ne 'hidden' } @{$_[0]->query_selector_all ($s, sub { HTML_NS })}]->[0]; # or undef
    }
  } # control
  
  package Web::DOM::HTMLInputElement;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  use Web::DOM::Internal;
  use Web::DOM::Element;
  
  _define_reflect_string accept => 'accept';
  _define_reflect_string alt => 'alt';
  _define_reflect_boolean autofocus => 'autofocus';
  _define_reflect_boolean default_checked => 'checked';
  _define_reflect_string dirname => 'dirname';
  _define_reflect_boolean disabled => 'disabled';
  _define_reflect_neurl formaction => 'formaction';
  _define_reflect_enumerated formenctype => 'formenctype', {
    'application/x-www-form-urlencoded' => 'application/x-www-form-urlencoded',
    'multipart/form-data' => 'multipart/form-data',
    'text/plain' => 'text/plain',
    '#invalid' => 'application/x-www-form-urlencoded',
    # #missing
  };
  _define_reflect_enumerated formmethod => 'formmethod', {
    get => 'get',
    post => 'post',
    dialog => 'dialog',
    '#invalid' => 'get',
    # #missing
  };
  _define_reflect_boolean formnovalidate => 'formnovalidate';
  _define_reflect_string formtarget => 'formtarget';
  _define_reflect_string max => 'max';
  _define_reflect_long_nn maxlength => 'maxlength', sub { -1 };
  _define_reflect_string min => 'min';
  _define_reflect_boolean multiple => 'multiple';
  _define_reflect_string name => 'name';
  _define_reflect_string pattern => 'pattern';
  _define_reflect_string placeholder => 'placeholder';
  _define_reflect_boolean readonly => 'readonly';
  _define_reflect_boolean required => 'required';
  _define_reflect_unsigned_long_positive size => 'size', sub { 20 };
  _define_reflect_string step => 'step';
  _define_reflect_neurl src => 'src';
  _define_reflect_enumerated type => 'type', {
    hidden => 'hidden',
    text => 'text',
    search => 'search',
    tel => 'tel',
    url => 'url',
    email => 'email',
    password => 'password',
    datetime => 'datetime',
    date => 'date',
    month => 'month',
    week => 'week',
    time => 'time',
    'datetime-local' => 'datetime-local',
    number => 'number',
    range => 'range',
    color => 'color',
    checkbox => 'checkbox',
    radio => 'radio',
    file => 'file',
    submit => 'submit',
    image => 'image',
    reset => 'reset',
    button => 'button',
    '#missing' => 'text',
  };
  _define_reflect_string default_value => 'value';
  
  _define_reflect_string align => 'align';
  _define_reflect_string usemap => 'usemap';
  
  sub list ($) {
    my $id = $_[0]->get_attribute_ns (undef, 'list');
    return undef unless defined $id;
    my $el = $_[0]->owner_document->get_element_by_id ($id) or return undef;
    return $el if $el->manakai_element_type_match (HTML_NS, 'datalist');
    return undef;
  } # list
  
  # XXX form labels
  
  ## ------ Media ------
  
  # XXX height width
  
  ## ------ Form processing ------
  
  # XXX autocomplete checked files indeterminate value* step*; form
  # validation API
  
  # XXX selection/range API
  
  package Web::DOM::HTMLButtonElement;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  use Web::DOM::Element;
  
  _define_reflect_boolean autofocus => 'autofocus';
  _define_reflect_boolean disabled => 'disabled';
  _define_reflect_neurl formaction => 'formaction';
  _define_reflect_enumerated formenctype => 'formenctype', {
    'application/x-www-form-urlencoded' => 'application/x-www-form-urlencoded',
    'multipart/form-data' => 'multipart/form-data',
    'text/plain' => 'text/plain',
    '#invalid' => 'application/x-www-form-urlencoded',
    # #missing
  };
  _define_reflect_enumerated formmethod => 'formmethod', {
    get => 'get',
    post => 'post',
    dialog => 'dialog',
    '#invalid' => 'get',
    # #missing
  };
  _define_reflect_boolean formnovalidate => 'formnovalidate';
  _define_reflect_string formtarget => 'formtarget';
  _define_reflect_string name => 'name';
  _define_reflect_enumerated type => 'type', {
    submit => 'submit',
    reset => 'reset',
    button => 'button',
    '#missing' => 'submit',
  };
  _define_reflect_string value => 'value';
  
  # XXX form labels; form validation API
  
  package Web::DOM::HTMLSelectElement;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  use Web::DOM::Element;
  
  # XXX form autocomplete
  
  _define_reflect_boolean autofocus => 'autofocus';
  _define_reflect_boolean disabled => 'disabled';
  _define_reflect_boolean multiple => 'multiple';
  _define_reflect_string name => 'name';
  _define_reflect_boolean required => 'required';
  _define_reflect_unsigned_long size => 'size', sub { 0 };
  
  sub type ($) {
    if ($_[0]->has_attribute ('multiple')) {
      return 'select-multiple';
    } else {
      return 'select-one';
    }
  } # type
  
  package Web::DOM::HTMLDataListElement;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  use Web::DOM::Internal;
  
  sub options ($) {
    return ${$_[0]}->[0]->collection_by_el ($_[0], 'options', HTML_NS, 'option');
  } # options
  
  package Web::DOM::HTMLOptGroupElement;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  use Web::DOM::Element;
  
  _define_reflect_boolean disabled => 'disabled';
  _define_reflect_string label => 'label';
  
  package Web::DOM::HTMLOptionElement;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  use Web::DOM::Internal;
  use Web::DOM::Node;
  use Web::DOM::Element;
  
  # XXX constructor form selected index
  
  _define_reflect_boolean disabled => 'disabled';
  _define_reflect_boolean default_selected => 'selected';
  
  sub text ($;$) {
    if (@_ > 1) {
      $_[0]->text_content ($_[1]);
      return unless defined wantarray;
    }
    my @text;
    my @node = $_[0]->child_nodes->to_list;
    while (@node) {
      my $node = shift @node;
      if ($node->node_type == TEXT_NODE) {
        push @text, $node;
      } elsif ($node->node_type == ELEMENT_NODE and
               $node->local_name eq 'script') {
        my $ns = $node->namespace_uri || '';
        unless ($ns eq HTML_NS or $ns eq SVG_NS) {
          unshift @node, $node->child_nodes->to_list;
        }
      } else {
        unshift @node, $node->child_nodes->to_list;
      }
    }
    my $value = join '', map { $_->data } @text;
    $value =~ s/[\x09\x0A\x0C\x0D\x20]+/ /g;
    $value =~ s/^ //;
    $value =~ s/ $//;
    return $value;
  } # text
  
  sub label ($;$) {
    if (@_ > 1) {
      $_[0]->set_attribute_ns (undef, label => $_[1]);
      return unless defined wantarray;
    }
    my $value = $_[0]->get_attribute_ns (undef, 'label');
    return $value if defined $value;
    return $_[0]->text;
  } # label
  
  sub value ($;$) {
    if (@_ > 1) {
      $_[0]->set_attribute_ns (undef, value => $_[1]);
      return unless defined wantarray;
    }
    my $value = $_[0]->get_attribute_ns (undef, 'value');
    return $value if defined $value;
    return $_[0]->text;
  } # value
  
  package Web::DOM::HTMLTextAreaElement;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  use Web::DOM::Node;
  use Web::DOM::Element;
  
  # XXX autocomplete form
  
  _define_reflect_boolean autofocus => 'autofocus';
  _define_reflect_unsigned_long_positive_fb cols => 'cols', sub { 20 };
  _define_reflect_string dirname => 'dirname';
  _define_reflect_boolean disabled => 'disabled';
  _define_reflect_long_nn maxlength => 'maxlength', sub { -1 };
  _define_reflect_string name => 'name';
  _define_reflect_string placeholder => 'placeholder';
  _define_reflect_boolean readonly => 'readonly';
  _define_reflect_boolean required => 'required';
  _define_reflect_unsigned_long_positive_fb rows => 'rows', sub { 2 };
  _define_reflect_enumerated wrap => 'wrap', {
    soft => 'soft',
    hard => 'hard',
    '#missing' => 'soft',
  };
  
  sub type ($) { 'textarea' }
  
  sub default_value ($;$) {
    if (@_ > 1) {
      $_[0]->text_content ($_[1]);
    }
  
    ## Child text content
    return join '',
        map { $_->data }
        grep { $_->node_type == TEXT_NODE } @{$_[0]->child_nodes};
  } # default_value
  
  # XXX value text_length; validation API; labels; selection API
  
  package Web::DOM::HTMLOutputElement;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  use Web::DOM::Element;
  
  # XXX form
  
  _define_reflect_string name => 'name';
  _define_reflect_settable_token_list html_for => 'for';
  
  sub type ($) { 'output' }
  
  # XXX default_value value labels; validation API
  
  package Web::DOM::HTMLProgressElement;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  
  # XXX  value max position labels
  
  package Web::DOM::HTMLMeterElement;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  
  # XXX value min max low high optimum labels
  
  package Web::DOM::HTMLDetailsElement;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  use Web::DOM::Element;
  
  _define_reflect_boolean open => 'open';
  
  package Web::DOM::HTMLMenuElement;
  our $VERSION = '3.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  use Web::DOM::Element;
  
  _define_reflect_boolean compact => 'compact';
  
  package Web::DOM::HTMLDialogElement;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  use Web::DOM::Element;
  
  _define_reflect_boolean open => 'open';
  
  sub return_value ($;$) {
    if (@_ > 1) {
      ${$_[0]}->[2]->{return_value} = ''.$_[1];
    }
    return defined ${$_[0]}->[2]->{return_value}
        ? ${$_[0]}->[2]->{return_value} : '';
  } # return_value
  
  # XXX show* close
  
  package Web::DOM::HTMLAppletElement;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  use Web::DOM::Element;
  
  _define_reflect_string align => 'align';
  _define_reflect_string alt => 'alt';
  _define_reflect_string archive => 'archive';
  _define_reflect_string code => 'code';
  _define_reflect_url codebase => 'codebase';
  _define_reflect_string height => 'height';
  _define_reflect_string name => 'name';
  _define_reflect_url object => 'object';
  _define_reflect_string width => 'width';
  _define_reflect_unsigned_long hspace => 'hspace', sub { 0 };
  _define_reflect_unsigned_long vspace => 'vspace', sub { 0 };
  
  package Web::DOM::HTMLMarqueeElement;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  use Web::DOM::Element;
  
  _define_reflect_string behavior => 'behavior';
  _define_reflect_string bgcolor => 'bgcolor';
  _define_reflect_string direction => 'direction';
  _define_reflect_string height => 'height';
  _define_reflect_unsigned_long hspace => 'hspace', sub { 0 };
  _define_reflect_unsigned_long scrollamount => 'scrollamount', sub { 6 };
  _define_reflect_unsigned_long scrolldelay => 'scrolldelay', sub { 85 };
  _define_reflect_unsigned_long vspace => 'vspace', sub { 0 };
  _define_reflect_string width => 'width';
  _define_reflect_boolean truespeed => 'truespeed';
  
  # XXX loop on* start stop
  
  package Web::DOM::HTMLFrameSetElement;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  # XXX WindowEventHandlers
  use Web::DOM::Element;
  
  _define_reflect_string cols => 'cols';
  _define_reflect_string rows => 'rows';
  
  package Web::DOM::HTMLFrameElement;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  use Web::DOM::Element;
  
  _define_reflect_string name => 'name';
  _define_reflect_string scrolling => 'scrolling';
  _define_reflect_string frameborder => 'frameborder';
  _define_reflect_boolean noresize => 'noresize';
  _define_reflect_string_undef marginheight => 'marginheight';
  _define_reflect_string_undef marginwidth => 'marginwidth';
  _define_reflect_url src => 'src';
  _define_reflect_url longdesc => 'longdesc';
  
  # XXX content*
  
  package Web::DOM::HTMLDirectoryElement;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  use Web::DOM::Element;
  
  _define_reflect_boolean compact => 'compact';
  
  package Web::DOM::HTMLFontElement;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  use Web::DOM::Element;
  
  _define_reflect_string color => 'color';
  _define_reflect_string face => 'face';
  _define_reflect_string size => 'size';
  
  package Web::DOM::HTMLTemplateElement;
  our $VERSION = '2.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  
  sub content ($) {
    my $df = ${$_[0]}->[2]->{content_df};
    if ($df =~ /\A[0-9]+\z/) {
      return ${$_[0]}->[0]->node ($df);
    } else {
      return $df;
    }
  } # content
  
  sub manakai_append_content ($$) {
    return $_[0]->content->manakai_append_content ($_[1]);
  } # manakai_append_content
  
  package Web::DOM::HTMLSlotElement;
  our $VERSION = '1.0';
  push our @ISA, qw(Web::DOM::HTMLElement);
  use Web::DOM::Element;
  
  _define_reflect_string name => 'name';
  
  # XXX assigned_nodes
  
  1;
  
  =head1 LICENSE
  
  Copyright 2013-2018 Wakaba <wakaba@suikawiki.org>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
WEB_DOM_HTMLELEMENT

$fatpacked{"Web/DOM/Implementation.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WEB_DOM_IMPLEMENTATION';
  package Web::DOM::Implementation;
  use strict;
  use warnings;
  no warnings 'utf8';
  our $VERSION = '5.0';
  use Carp;
  our @CARP_NOT = qw(Web::DOM::Document Web::DOM::TypeError);
  use Web::DOM::Node;
  use Web::DOM::Internal;
  use Web::DOM::TypeError;
  use Web::DOM::Exception;
  
  use overload
      '""' => sub {
        return ref ($_[0]) . '=DOM(' . ${$_[0]}->[0] . ')';
      },
      bool => sub { 1 },
      cmp => sub {
        carp "Use of uninitialized value in string comparison (cmp)"
            unless defined $_[1];
        overload::StrVal ($_[0]) cmp overload::StrVal ($_[1])
      },
      fallback => 1;
  
  sub new ($) {
    require Web::DOM::Document;
    my $doc = Web::DOM::Document->new;
    return $doc->implementation;
  } # new
  
  sub create_document ($;$$$) {
    my ($self, $ns, $qn, $doctype) = @_;
    $ns = ''.$ns if defined $ns;
    $qn = ''.$qn if defined $qn and (not ref $qn or not ref $qn eq 'ARRAY');
    if (ref $qn eq 'ARRAY') {
      $qn->[0] = ''.$qn->[0] if defined $qn->[0];
      $qn->[1] = ''.$qn->[1];
    }
  
    ## WebIDL
    if (defined $doctype and
        not UNIVERSAL::isa ($doctype, 'Web::DOM::DocumentType')) {
      _throw Web::DOM::TypeError 'Third argument is not a DocumentType';
    }
  
    ## 1.
    my $data = {node_type => DOCUMENT_NODE, is_XMLDocument => 1};
    my $objs = Web::DOM::Internal::Objects->new;
    my $id = $objs->add_data ($data);
    $objs->{rc}->[$id]++;
    my $doc = $objs->node ($id);
  
    ## 2.
    my $el;
  
    ## WebIDL, 3.
    if (defined $qn and length $qn) {
      $el = $doc->create_element_ns ($ns, $qn); # or throw
    }
  
    ## 4.
    $doc->append_child ($doctype) if defined $doctype;
  
    ## 5.
    $doc->append_child ($el) if defined $el;
  
    ## 6.
    # XXX origin
  
    ## 7.
    if (defined $ns) {
      if ($ns eq HTML_NS) {
        $doc->_set_content_type ('application/xhtml+xml');
      } elsif ($ns eq SVG_NS) {
        $doc->_set_content_type ('image/svg+xml');
      }
    }
  
    ## 8.
    return $doc;
  } # create_document
  
  sub create_html_document ($;$) {
    ## 1., 2.
    require Web::DOM::Document;
    my $doc = Web::DOM::Document->new;
    $doc->manakai_is_html (1);
    #$doc->_set_content_type ('text/html');
  
    ## 3.
    my $dt = $doc->implementation->create_document_type ('html', '', '');
    $doc->append_child ($dt);
  
    ## 4.
    my $html = $doc->create_element_ns (HTML_NS, 'html');
    $doc->append_child ($html);
  
    # 5.
    my $head = $doc->create_element_ns (HTML_NS, 'head');
    $html->append_child ($head);
  
    # 6.
    if (defined $_[1]) {
      # 1.
      my $title = $doc->create_element_ns (HTML_NS, 'title');
      $head->append_child ($title);
  
      # 2.
      my $text = $doc->create_text_node ($_[1]);
      $title->append_child ($text);
    }
  
    # 7.
    my $body = $doc->create_element_ns (HTML_NS, 'body');
    $html->append_child ($body);
    
    # 8.
    # XXX origin
  
    # 9.
    return $doc;
  } # create_html_document
  
  sub create_atom_feed_document ($$;$$) {
    # 1.
    require Web::DOM::Document;
    my $doc = Web::DOM::Document->new;
    
    # 2.
    $doc->_set_content_type ('application/atom+xml');
  
    # 3.
    my $feed = $doc->create_element_ns (ATOM_NS, 'feed');
  
    # 5.
    my $id = $doc->create_element_ns (ATOM_NS, 'id');
    $id->text_content ($_[1]);
    $feed->append_child ($id);
  
    # 6.
    my $title = $doc->create_element_ns (ATOM_NS, 'title');
    $title->text_content (defined $_[2] ? $_[2] : '');
    $feed->append_child ($title);
  
    # 4.
    $feed->set_attribute_ns
        (XML_NS, ['xml', 'lang'] => defined $_[3] ? $_[3] : '');
  
    # 7.
    my $updated = $doc->create_element_ns (ATOM_NS, 'updated');
    $updated->value (time);
    $feed->append_child ($updated);
  
    # 8.
    $doc->append_child ($feed);
  
    # 9.
    return $doc;
  } # create_atom_feed_document
  
  sub create_atom_entry_document ($$;$$) {
    # 1.
    require Web::DOM::Document;
    my $doc = Web::DOM::Document->new;
    
    # 2.
    $doc->_set_content_type ('application/atom+xml');
  
    # 3.
    my $entry = $doc->create_element_ns (ATOM_NS, 'entry');
  
    # 5.
    my $id = $doc->create_element_ns (ATOM_NS, 'id');
    $id->text_content ($_[1]);
    $entry->append_child ($id);
  
    # 6.
    my $title = $doc->create_element_ns (ATOM_NS, 'title');
    $title->text_content (defined $_[2] ? $_[2] : '');
    $entry->append_child ($title);
  
    # 4.
    $entry->set_attribute_ns
        (XML_NS, ['xml', 'lang'] => defined $_[3] ? $_[3] : '');
  
    # 7.
    my $updated = $doc->create_element_ns (ATOM_NS, 'updated');
    $updated->value (time);
    $entry->append_child ($updated);
  
    # 8.
    $doc->append_child ($entry);
  
    # 9.
    return $doc;
  } # create_atom_entry_document
  
  sub create_document_type ($$;$$) {
    my $self = $_[0];
    my $qname = ''.$_[1];
    my $pubid = defined $_[2] ? ''.$_[2] : '';
    my $sysid = defined $_[3] ? ''.$_[3] : '';
  
    unless ($$self->[0]->{data}->[0]->{no_strict_error_checking}) {
      unless ($qname =~ /\A\p{InNCNameStartChar}\p{InNCNameChar}*(?::\p{InNCNameStartChar}\p{InNCNameChar}*)?\z/) {
        _throw Web::DOM::Exception 'InvalidCharacterError',
            'The qualified name is not an XML QName';
      }
    } # strict
  
    my $data = {node_type => DOCUMENT_TYPE_NODE,
                name => Web::DOM::Internal->text ($qname),
                public_id => Web::DOM::Internal->text ($pubid),
                system_id => Web::DOM::Internal->text ($sysid)};
    my $id = $$self->[0]->add_data ($data);
    return $$self->[0]->node ($id);
  } # create_document_type
  
  sub has_feature ($) { 1 }
  
  1;
  
  =head1 LICENSE
  
  Copyright 2012-2017 Wakaba <wakaba@suikawiki.org>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
WEB_DOM_IMPLEMENTATION

$fatpacked{"Web/DOM/Internal.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WEB_DOM_INTERNAL';
  package Web::DOM::Internal;
  use strict;
  use warnings;
  no warnings 'utf8';
  our $VERSION = '5.0';
  use Carp;
  
  ## Web::DOM internal data structure and core utilities
  
  our @EXPORT;
  
  sub import ($;@) {
    my $from_class = shift;
    my ($to_class, $file, $line) = caller;
    no strict 'refs';
    for (@_ ? @_ : @{$from_class . '::EXPORT'}) {
      my $code = $from_class->can ($_)
          or croak qq{"$_" is not exported by the $from_class module at $file line $line};
      *{$to_class . '::' . $_} = $code;
    }
  } # import
  
  use Web::DOM::_CharClasses;
  push @EXPORT, qw(InNameStartChar InNameChar
                   InNCNameStartChar InNCNameChar
                   InPCENChar);
  
  push @EXPORT, qw(_idl_long);
  sub _idl_long ($) {
    if (defined $_[0]) {
      if (ref $_[0]) {
        my $v = 0+$_[0]; # can throw
        if ($v =~ /\A-?(?:[Nn]a[Nn]|[Ii]nf)\z/) {
          return 0;
        } else {
          return unpack 'l', pack 'L', $v % 2**32;
        }
      } else {
        if ($_[0] =~ /\A-?(?:[Nn]a[Nn]|[Ii]nf)\z/) {
          return 0;
        } else {
          return unpack 'l', pack 'L', $_[0] % 2**32;
        }
      }
    } else {
      carp 'Use of uninitialized value in method argument';
    }
  } # _idl_long
  
  push @EXPORT, qw(_idl_unsigned_long);
  sub _idl_unsigned_long ($) {
    if (defined $_[0]) {
      if (ref $_[0]) {
        my $v = 0+$_[0]; # can throw
        if ($v =~ /\A-?(?:[Nn]a[Nn]|[Ii]nf)\z/) {
          return 0;
        } else {
          return unpack 'L', pack 'L', $v % 2**32;
        }
      } else {
        if ($_[0] =~ /\A-?(?:[Nn]a[Nn]|[Ii]nf)\z/) {
          return 0;
        } else {
          return unpack 'L', pack 'L', $_[0] % 2**32;
        }
      }
    } else {
      carp 'Use of uninitialized value in method argument';
    }
  } # _idl_unsigned_long
  
  push @EXPORT, qw(_idl_unsigned_short);
  sub _idl_unsigned_short ($) {
    if (defined $_[0]) {
      if (ref $_[0]) {
        my $v = 0+$_[0]; # can throw
        if ($v =~ /\A-?(?:[Nn]a[Nn]|[Ii]nf)\z/) {
          return 0;
        } else {
          return unpack 'S', pack 'S', $v % 2**16;
        }
      } else {
        if ($_[0] =~ /\A-?(?:[Nn]a[Nn]|[Ii]nf)\z/) {
          return 0;
        } else {
          return unpack 'S', pack 'S', $_[0] % 2**16;
        }
      }
    } else {
      carp 'Use of uninitialized value in method argument';
    }
  } # _idl_unsigned_short
  
  ## "Interned" string
  ##
  ## Used to represent namespace URLs and node names.
  ##
  ## Note that |$Web::DOM::Internal::Text| is directly accessed from
  ## |Web::DOM::Document| for performance reason.
  our $Text = {};
  sub text ($$) {
    return defined $_[1] ? $Text->{$_[1]} ||= \(''.$_[1]) : undef;
  } # text
  
  ## Namespace URLs
  push @EXPORT, qw(HTML_NS SVG_NS MML_NS XML_NS XMLNS_NS ATOM_NS ATOM_THREAD_NS);
  sub HTML_NS () { q<http://www.w3.org/1999/xhtml> }
  sub SVG_NS () { q<http://www.w3.org/2000/svg> }
  sub MML_NS () { q<http://www.w3.org/1998/Math/MathML> }
  sub XML_NS () { q<http://www.w3.org/XML/1998/namespace> }
  sub XMLNS_NS () { q<http://www.w3.org/2000/xmlns/> }
  sub ATOM_NS () { q<http://www.w3.org/2005/Atom> }
  sub ATOM_THREAD_NS () { q<http://purl.org/syndication/thread/1.0> }
  $Text->{(HTML_NS)} = \HTML_NS;
  
  ## Index-related data structures
  ##
  ## Following data structures are described in SuikaWiki:manakai index
  ## data structure
  ## <http://wiki.suikawiki.org/n/manakai%20index%20data%20structures>:
  ##
  ##   DocumentIndex CharacterIndex IndexedStringSegment IndexedString
  ##
  ## These are used by |Web::DOM::CharacterData| and |Web::DOM::Attr|,
  ## as well as by |Web::DOM::Element|, |Web::DOM::Document|,
  ## |Web::DOM::ParentNode|, and |Web::DOM::Node| methods related to
  ## them.
  
  ## URLs
  ##
  ## URLs are internally saved as strings.
  push @EXPORT, qw(_resolve_url);
  sub _resolve_url ($$) {
    require Web::URL::Canonicalize;
    return Web::URL::Canonicalize::url_to_canon_url ($_[0], $_[1]);
  } # _resolve_url
  
  ## Internal data structure for DOM tree.
  ##
  ## This module is for internal use only.  Applications should not use
  ## this module directly.
  ##
  ## This module has no test by itself.  Tests for Node and its
  ## subclasses covers this module.
  package Web::DOM::Internal::Objects;
  use Scalar::Util qw(weaken refaddr);
  push our @CARP_NOT, qw(Web::DOM::Exception Web::DOM::StringArray);
  
  ## Nodes of a DOM document share an object store, which is represented
  ## by this class.  Each node in the store is distinguished by the node
  ## ID.  Node ID #0 is always the |Document| node for the tree.
  ##
  ## Nodes of the document form several trees, which are identified by
  ## tree IDs.  This ID is used for, e.g., garbage collection.
  ##
  ## Objects belongging to the store is not limited to nodes.  Non-node
  ## objects controlled by the store include |HTMLCollection| objects
  ## returned by the |get_elements_by_tag_name| method and DOM range
  ## objects.
  
  sub new ($) {
    return bless {
      ## Nodes
      next_node_id => 0,
      # data nodes rc
  
      ## Trees
      # tree_id
  
      ## Lists
      # cols tokens strmap
  
      ## CSS
      # source_style media
  
      ## Other objects
      # impl
      # config config_obj config_hashref config_names
      # template_doc
  
      # document_base_url document_base_url_revision
  
      ## $internal->{revision} is a non-negative integer, incremented
      ## when some mutation has occurred on some node such that cached
      ## data should not be hornored.  It is incremented when, for
      ## example, a node is appended to another node, an attribute is
      ## set, or a CSS rule is inserted.  This value is used to discard
      ## caches of, e.g., collections and document base URL, and to
      ## invalidate |XPathResult| objects.
      revision => 1,
    }, $_[0];
  } # new
  
  ## Tree
  ##
  ## The tree ID (|tree_id|) of a node is same as the node ID of the
  ## root node of the tree to which the node belongs.
  
  ## Node
  ##
  ## Various characteristics of the node are put into the "data" hash
  ## reference for the node.
  ##
  ## For the purpose of the internal, two separete types of concepts are
  ## treated as "nodes": DOM |Node| and CSSOM |StyleSheet| or |CSSRule|.
  ## The "data" hash reference for the DOM |Node| contains |node_type|
  ## value representing the node type.  The "data" hash reference for
  ## the CSSOM object contains |rule_type| value representing the rule
  ## type (or the "style sheet" type).
  ##
  ## A tree can contain both DOM |Node| and CSSOM objects.  For example,
  ## an HTML |style| element |Node| might have a reference to a CSSOM
  ## |StyleSheet| in the "sheet" field (corresponding to the |sheet|
  ## attribute), which is considered as a parent-child link similar to
  ## the |childNodes| attribute of DOM |Node|s, and the |StyleSheet|
  ## would have a reference to the |Node| in the "owner" field
  ## (corresponding to the |ownerNode| attribute), which isconsidered as
  ## a child-parent link similar to the |parentNode| attribute of DOM
  ## |Node|s.
  ##
  ## A node is identified by a non-negative integer, referrred to as
  ## node ID (|node_id|).  Node IDs are unique within a document.  At
  ## the time of writing, no node ID is reused even after the node
  ## associated with the ID is GCed.  However, this should not be
  ## assumed by the implementation.
  ##
  ## The |Node| / |StyleSheet| / |CSSRule| object exposed to the
  ## application is a blessed reference to the array reference, which
  ## consists of following members:
  ##
  ##   0 - The object store object
  ##   1 - The node ID
  ##   2 - The node data
  ##
  ## Its the reference to the reference, not just the reference, to
  ## allow overloading of |@{}| and |%{}| in some kinds of nodes.
  
  ## Node data
  ##
  ## |Node|
  ##   all_declarations_processed     boolean   [all declarations processed]
  ##   allowed_tokens                 [string]  Allowed tokens
  ##   attributes                     [AttrNameRef] Attributes by index
  ##   attribute_definitions          {node_id} Attribute definitions
  ##   attribute_type                 integer   [attribute type]
  ##   attrs                          {{AttrValueRef}} Attributes by name
  ##   child_nodes                    [node_id] Child nodes
  ##   class_list                     [string]  Classes
  ##   compat_mode                    string    Quirksness
  ##   content_df                     scalar    Template content
  ##   content_type                   string    MIME type
  ##   data                           IndexedString Data
  ##   declared_type                  integer   Declared type
  ##   default_type                   integer   Default type
  ##   element_types                  {node_id} Element types
  ##   encoding                       string    Character encoding
  ##   event_listeners                {}[]      Event listener callbacks
  ##   general_entities               {node_id} General entities
  ##   host_el                        scalar    Host element
  ##   i_in_parent                    integer   Index in parent's child_nodes
  ##   is_html                        boolean   An HTML document?
  ##   is_srcdoc                      boolean   An iframe srcdoc document?
  ##   is_XMLDocument                 boolean   An XMLDocument?
  ##   iterators                      {addr-of-iterator => iterator}
  ##   local_name                     \string   Local name
  ##   manakai_charset                string    Content-Type charset=""
  ##   manakai_entity_base_uri        \string   Entity base URL
  ##   manakai_entity_uri             \string   Entity URL
  ##   manakai_has_bom                boolean   Has BOM?
  ##   name                           \string   Name
  ##   namespace_uri                  \string   Namespace URL
  ##   node_name                      \string   Node name
  ##   node_type                      integer   Node type
  ##   node_value                     string    Node value
  ##   no_strict_error_checking       boolean   !Strict error checking flag
  ##   notations                      {node_id} Notations
  ##   notation_name                  string    Notation name
  ##   owner                          node_id   Owner
  ##   parent_node                    node_id   Parent node
  ##   prefix                         \string   Namespace prefix
  ##   public_id                      \string   Public ID
  ##   return_value                   string    Return value
  ##   serialize_as_cdata             boolean   CDATA section?
  ##   sheet                          node_id   Style sheet
  ##   source_di                      DocumentIndex Source document index
  ##   source_index                   CharacterIndex Source character index
  ##   system_id                      \string   System ID
  ##   target                         \string   Target
  ##   url                            string    Document URL
  ##   user_data                      {object}  User data
  ##   xml_encoding                   string    XML encoding=""
  ##   xml_standalone                 boolean   XML standalone=""
  ##   xml_version                    string    XML version
  ##
  ## |StyleSheet| / |CSSRule|
  ##   rule_type, rule_ids, parent_id, selectors,
  ##   prop_keys, prop_values, prop_importants, encoding,
  ##   href, mqs, prefix, nsurl       - See |Web::CSS::Parser|
  ##   context                        object    Web::CSS::Context
  ##   owner                          node_id   Owner |Node| or |@import|
  ##   owner_sheet                    node_id   Owner style sheet
  ##   parent_style_sheet             node_id   Parent style sheet
  ##   sheet                          node_id   Style sheet (for |@import|)
  
  ## Data structures for element's content attributs are described in
  ## |Element.pm|.
  
  ## Create a node with no parent or child, in this document.
  sub add_data ($$) {
    my $self = shift;
    my $id = $self->{next_node_id}++;
    $self->{data}->[$id] = $_[0];
    $self->{tree_id}->[$id] = $id;
    ## The |import_parsed_ss| method can also add |data| to the
    ## internal.
    return $id;
  } # add_data
  
  my $NodeClassByNodeType = {
    2 => 'Web::DOM::Attr',
    3 => 'Web::DOM::Text',
    6 => 'Web::DOM::Entity',
    7 => 'Web::DOM::ProcessingInstruction',
    8 => 'Web::DOM::Comment',
    10 => 'Web::DOM::DocumentType',
    11 => 'Web::DOM::DocumentFragment',
    12 => 'Web::DOM::Notation',
    81001 => 'Web::DOM::ElementTypeDefinition',
    81002 => 'Web::DOM::AttributeDefinition',
  };
  
  my $ElementClass = {};
  my $ClassToModule = {};
  
  ## Mapping of element names from element interfaces' classes
  for (
    ['*' => 'HTMLUnknownElement'],
    ['html' => 'HTMLHtmlElement'],
    ['head' => 'HTMLHeadElement'],
    ['title' => 'HTMLTitleElement'],
    ['base' => 'HTMLBaseElement'],
    ['link' => 'HTMLLinkElement'],
    ['meta' => 'HTMLMetaElement'],
    ['style' => 'HTMLStyleElement'],
    ['script' => 'HTMLScriptElement'],
    ['noscript' => 'HTMLElement'],
    ['body' => 'HTMLBodyElement'],
    ['article' => 'HTMLElement'],
    ['section' => 'HTMLElement'],
    ['nav' => 'HTMLElement'],
    ['aside' => 'HTMLElement'],
    ['h1' => 'HTMLHeadingElement'],
    ['h2' => 'HTMLHeadingElement'],
    ['h3' => 'HTMLHeadingElement'],
    ['h4' => 'HTMLHeadingElement'],
    ['h5' => 'HTMLHeadingElement'],
    ['h6' => 'HTMLHeadingElement'],
    ['hgroup' => 'HTMLElement'],
    ['header' => 'HTMLElement'],
    ['footer' => 'HTMLElement'],
    ['address' => 'HTMLElement'],
    ['p' => 'HTMLParagraphElement'],
    ['hr' => 'HTMLHRElement'],
    ['pre' => 'HTMLPreElement'],
    ['blockquote' => 'HTMLQuoteElement'],
    ['ol' => 'HTMLOListElement'],
    ['ul' => 'HTMLUListElement'],
    ['li' => 'HTMLLIElement'],
    ['dl' => 'HTMLDListElement'],
    ['dt' => 'HTMLElement'],
    ['dd' => 'HTMLElement'],
    ['figure' => 'HTMLElement'],
    ['figcaption' => 'HTMLElement'],
    ['div' => 'HTMLDivElement'],
    ['a' => 'HTMLAnchorElement'],
    ['em' => 'HTMLElement'],
    ['strong' => 'HTMLElement'],
    ['small' => 'HTMLElement'],
    ['s' => 'HTMLElement'],
    ['cite' => 'HTMLElement'],
    ['q' => 'HTMLQuoteElement'],
    ['dfn' => 'HTMLElement'],
    ['abbr' => 'HTMLElement'],
    ['data' => 'HTMLDataElement'],
    ['time' => 'HTMLTimeElement'],
    ['code' => 'HTMLElement'],
    ['var' => 'HTMLElement'],
    ['samp' => 'HTMLElement'],
    ['kbd' => 'HTMLElement'],
    ['sub' => 'HTMLElement'],
    ['sup' => 'HTMLElement'],
    ['i' => 'HTMLElement'],
    ['b' => 'HTMLElement'],
    ['u' => 'HTMLElement'],
    ['mark' => 'HTMLElement'],
    ['ruby' => 'HTMLElement'],
    ['rt' => 'HTMLElement'],
    ['rtc' => 'HTMLElement'],
    ['rb' => 'HTMLElement'],
    ['rp' => 'HTMLElement'],
    ['bdi' => 'HTMLElement'],
    ['bdo' => 'HTMLElement'],
    ['span' => 'HTMLSpanElement'],
    ['br' => 'HTMLBRElement'],
    ['wbr' => 'HTMLElement'],
    ['ins' => 'HTMLModElement'],
    ['del' => 'HTMLModElement'],
    ['img' => 'HTMLImageElement'],
    ['iframe' => 'HTMLIFrameElement'],
    ['embed' => 'HTMLEmbedElement'],
    ['object' => 'HTMLObjectElement'],
    ['param' => 'HTMLParamElement'],
    ['video' => 'HTMLVideoElement'],
    ['audio' => 'HTMLAudioElement'],
    ['source' => 'HTMLSourceElement'],
    ['track' => 'HTMLTrackElement'],
    ['canvas' => 'HTMLCanvasElement'],
    ['map' => 'HTMLMapElement'],
    ['area' => 'HTMLAreaElement'],
    ['table' => 'HTMLTableElement'],
    ['caption' => 'HTMLTableCaptionElement'],
    ['colgroup' => 'HTMLTableColElement'],
    ['col' => 'HTMLTableColElement'],
    ['tbody' => 'HTMLTableSectionElement'],
    ['thead' => 'HTMLTableSectionElement'],
    ['tfoot' => 'HTMLTableSectionElement'],
    ['tr' => 'HTMLTableRowElement'],
    ['td' => 'HTMLTableCellElement'],
    ['th' => 'HTMLTableCellElement'],
    ['form' => 'HTMLFormElement'],
    ['fieldset' => 'HTMLFieldSetElement'],
    ['legend' => 'HTMLLegendElement'],
    ['label' => 'HTMLLabelElement'],
    ['input' => 'HTMLInputElement'],
    ['button' => 'HTMLButtonElement'],
    ['select' => 'HTMLSelectElement'],
    ['datalist' => 'HTMLDataListElement'],
    ['optgroup' => 'HTMLOptGroupElement'],
    ['option' => 'HTMLOptionElement'],
    ['textarea' => 'HTMLTextAreaElement'],
    ['keygen' => 'HTMLUnknownElement'],
    ['output' => 'HTMLOutputElement'],
    ['progress' => 'HTMLProgressElement'],
    ['meter' => 'HTMLMeterElement'],
    ['details' => 'HTMLDetailsElement'],
    ['summary' => 'HTMLElement'],
    ['menu' => 'HTMLMenuElement'],
    ['dialog' => 'HTMLDialogElement'],
    ['applet' => 'HTMLAppletElement'],
    ['marquee' => 'HTMLMarqueeElement'],
    ['frameset' => 'HTMLFrameSetElement'],
    ['frame' => 'HTMLFrameElement'],
    ['basefont' => 'HTMLElement'],
    ['dir' => 'HTMLDirectoryElement'],
    ['font' => 'HTMLFontElement'],
    ['listing' => 'HTMLPreElement'],
    ['plaintext' => 'HTMLElement'],
    ['xmp' => 'HTMLPreElement'],
    ['acronym' => 'HTMLElement'],
    ['noframes' => 'HTMLElement'],
    ['noembed' => 'HTMLElement'],
    ['strike' => 'HTMLElement'],
    ['big' => 'HTMLElement'],
    ['center' => 'HTMLElement'],
    ['nobr' => 'HTMLElement'],
    ['tt' => 'HTMLElement'],
    ['template' => 'HTMLTemplateElement'],
    ['slot' => 'HTMLSlotElement'],
    ['picture' => 'HTMLPictureElement'],
  ) {
    $ElementClass->{Web::DOM::Internal::HTML_NS}->{$_->[0]}
        = "Web::DOM::$_->[1]";
    $ClassToModule->{"Web::DOM::$_->[1]"} = "Web::DOM::HTMLElement";
  }
  for (
    ['*', 'AtomElement'],
    ['id', 'AtomIdElement'],
    ['icon', 'AtomIconElement'],
    ['name', 'AtomNameElement'],
    ['uri', 'AtomUriElement'],
    ['email', 'AtomEmailElement'],
    ['logo', 'AtomLogoElement'],
    ['rights', 'AtomRightsElement'],
    ['subtitle', 'AtomSubtitleElement'],
    ['summary', 'AtomSummaryElement'],
    ['title', 'AtomTitleElement'],
    ['author', 'AtomAuthorElement'],
    ['contributor', 'AtomContributorElement'],
    ['published', 'AtomPublishedElement'],
    ['updated', 'AtomUpdatedElement'],
    ['feed', 'AtomFeedElement'],
    ['entry', 'AtomEntryElement'],
    ['source', 'AtomSourceElement'],
    ['content', 'AtomContentElement'],
    ['category', 'AtomCategoryElement'],
    ['generator', 'AtomGeneratorElement'],
    ['link', 'AtomLinkElement'],
  ) {
    $ElementClass->{Web::DOM::Internal::ATOM_NS}->{$_->[0]}
        = "Web::DOM::$_->[1]";
    $ClassToModule->{"Web::DOM::$_->[1]"} = "Web::DOM::AtomElement";
  }
  for (
    ['*', 'AtomElement'],
    ['in-reply-to', 'AtomThreadInReplyToElement'],
    ['total', 'AtomThreadTotalElement'],
  ) {
    $ElementClass->{Web::DOM::Internal::ATOM_THREAD_NS}->{$_->[0]}
        = "Web::DOM::$_->[1]";
    $ClassToModule->{"Web::DOM::$_->[1]"} = "Web::DOM::AtomElement";
  }
  
  my $RuleClassByRuleType = {
    #sheet => 'Web::DOM::CSSStyleSheet',
    style => 'Web::DOM::CSSStyleRule',
    charset => 'Web::DOM::CSSCharsetRule',
    import => 'Web::DOM::CSSImportRule',
    media => 'Web::DOM::CSSMediaRule',
    font_face => 'Web::DOM::CSSFontFaceRule',
    page => 'Web::DOM::CSSPageRule',
    namespace => 'Web::DOM::CSSNamespaceRule',
  };
  
  my $ModuleLoaded = {};
  
  sub node ($$) {
    my ($self, $id) = @_;
    return $self->{nodes}->[$id] if defined $self->{nodes}->[$id];
  
    my $data = $self->{data}->[$id];
    my $class;
    my $module;
    if (defined (my $nt = $data->{node_type})) {
      if ($nt == 1) {
        my $ns = $data->{namespace_uri} || \'';
        $class = $ElementClass->{$$ns}->{${$data->{local_name}}} ||
            $ElementClass->{$$ns}->{'*'} ||
            'Web::DOM::Element';
        $module = $ClassToModule->{$class} || $class;
      } elsif ($nt == 9) {
        $module = $class = $data->{is_XMLDocument}
            ? 'Web::DOM::XMLDocument' : 'Web::DOM::Document';
      } else {
        $module = $class = $NodeClassByNodeType->{$nt};
      }
    } else {
      if ($data->{rule_type} eq 'sheet') {
        $class = $module = 'Web::DOM::CSSStyleSheet';
      } else {
        $class = $RuleClassByRuleType->{$data->{rule_type}} ||
            'Web::DOM::CSSUnknownRule';
        $module = 'Web::DOM::CSSRule';
      }
    }
    unless ($ModuleLoaded->{$module}) {
      eval qq{ require $module } or die $@;
      $ModuleLoaded->{$module}++;
    }
    my $node = bless \[$self, $id, $data], $class;
    weaken ($self->{nodes}->[$id] = $node);
    return $node;
  } # node
  
  ## $int->{template_doc} - appropriate template contents owner document
  ##     undef    - not yet created
  ##     Document - associated inert template document (strong ref)
  ##     node ID  - same document
  ## $data->{host_el} - host element
  ##     undef    - not a template document or host element no longer available
  ##     Element  - outermost document's host element (weak ref)
  ##     node ID  - same document's host element
  ## $data->{content_df} - template content's document fragment
  ##     undef    - not a template content
  ##     DocumentFragment - template document's document fragment (strong ref)
  ##     node ID  - same document's document fragment
  
  ## Return the appropriate template contents owner document.
  sub template_doc ($) {
    my $int = $_[0];
    if (defined $int->{template_doc}) {
      if (not ref $int->{template_doc}) {
        return $int->node ($int->{template_doc});
      } else {
        return $int->{template_doc};
      }
    } else {
      require Web::DOM::Document;
      my $doc = $int->{template_doc} = Web::DOM::Document->new;
      $$doc->[2]->{is_html} = 1 if $int->{data}->[0]->{is_html};
      $$doc->[0]->{template_doc} = $$doc->[1];
      return $doc;
    }
  } # template_doc
  
  sub set_template_content ($$$) {
    my ($int, $node_id => $df) = @_;
    if ($int eq $$df->[0]) {
      $int->{data}->[$node_id]->{content_df} = $$df->[1];
      $$df->[2]->{host_el} = $node_id;
      $int->connect ($$df->[1] => $node_id);
    } else {
      $int->{data}->[$node_id]->{content_df} = $df;
      weaken ($$df->[2]->{host_el} = $int->node ($node_id));
    }
  } # set_template_content
  
  ## Remove <http://dom.spec.whatwg.org/#concept-node-remove>
  sub remove_node ($$$$) {
    my ($int, $parent_id, $child_id, $suppress_observers) = @_;
  
    ## 9. removing steps
    ## Before a node is removed from the iterator collection
    ## <http://dom.spec.whatwg.org/#iterator-collection>
    {
      ## 1.
      my @iterator;
      my @id = ($child_id);
      my %descendant_id;
      while (@id) {
        my $id = shift @id;
        $descendant_id{$id} = 1;
        my $data = $int->{data}->[$id];
        push @iterator, grep { defined } values %{$data->{iterators} or {}};
        push @id, @{$data->{child_nodes} or []};
      }
      last unless @iterator;
      my $child = $int->node ($child_id);
      for my $iterator (@iterator) {
        next if $descendant_id{${$iterator->{root}}->[1]};
        $int->change_iterator_reference_node ($iterator, $child);
  
        if ($iterator->{pointer_before_reference_node}) {
          ## 3.
          my $node = do {
            local $iterator->{pointer_before_reference_node} = 0;
            $iterator->_traverse ('next', 'remove');
          };
  
          ## 4.
          unless (defined $node) {
            $iterator->{pointer_before_reference_node} = 1;
            $iterator->_traverse (!'next', 'remove');
            delete $iterator->{pointer_before_reference_node};
          }
        } else {
          ## 2.
          local $iterator->{pointer_before_reference_node} = 1;
          $iterator->_traverse (!'next', 'remove');
        }
      }
    }
  
    ## 1.-5.
    # XXX range
  
    ## 6.-7.
    # XXX mutation
  
    ## 8.
    my $parent_data = $int->{data}->[$parent_id];
    my $child_data = $int->{data}->[$child_id];
    my $child_i = delete $child_data->{i_in_parent};
    splice @{$parent_data->{child_nodes}}, $child_i, 1, ();
    delete $child_data->{parent_node};
    for ($child_i..$#{$parent_data->{child_nodes}}) {
      $int->{data}->[$parent_data->{child_nodes}->[$_]]->{i_in_parent}--;
    }
    $int->{revision}++;
    $int->disconnect ($child_id);
  
    ## 9. removing steps
    # XXX
  
    ## Create a Node object such that the node data is GCed if it is no
    ## longer referenced.  Return the object such that if the callee
    ## does not want the node data to be GCed yet, it can hold the
    ## reference.
    return $int->node ($child_id); # mark for GC
  } # remove_node
  
  ## Remove <http://dom.spec.whatwg.org/#concept-node-remove>, but
  ## iterated for all children.
  sub remove_children ($$$$) {
    my ($int, $parent_id, $suppress_observers) = @_;
    my $parent_data = $int->{data}->[$parent_id];
    my @removed = @{$parent_data->{child_nodes} or []};
    return unless @removed;
  
    ## 9. removing steps
    ## Before a node is removed from the iterator collection
    ## <http://dom.spec.whatwg.org/#iterator-collection>
    {
      ## 1.
      my @iterator;
      my @id = (@removed);
      my %descendant_id;
      while (@id) {
        my $id = shift @id;
        $descendant_id{$id} = 1;
        my $data = $int->{data}->[$id];
        push @iterator, grep { defined } values %{$data->{iterators} or {}};
        push @id, @{$data->{child_nodes} or []};
      }
      last unless @iterator;
      my $parent = $int->node ($parent_id);
      for my $iterator (@iterator) {
        next if $descendant_id{${$iterator->{root}}->[1]};
  
        if ($iterator->{pointer_before_reference_node}) {
          ## 3.
          my $node = do {
            local $iterator->{pointer_before_reference_node} = 0;
            $int->change_iterator_reference_node ($iterator, $parent);
            $iterator->_traverse ('next', 'remove');
          };
  
          ## 4.
          unless (defined $node) {
            $int->change_iterator_reference_node ($iterator, $parent);
            delete $iterator->{pointer_before_reference_node};
          }
        } else {
          ## 2.
          local $iterator->{pointer_before_reference_node} = 1;
          $int->change_iterator_reference_node ($iterator, $parent);
        }
      }
    }
  
    ## 1.-5.
    # XXX range
  
    ## 6.-7.
    # XXX mutation
  
    ## 8.
    for (@removed) {
      my $child_data = $int->{data}->[$_];
      delete $child_data->{parent_node};
      delete $child_data->{i_in_parent};
      $int->disconnect ($_);
    }
    @{$parent_data->{child_nodes}} = ();
    $int->{revision}++;
  
    ## 9. removing steps
    # XXX
  
    ## Create a Node object such that the node data is GCed if it is no
    ## longer referenced.  Return the object such that if the callee
    ## does not want the node data to be GCed yet, it can hold the
    ## reference.
    return map { $int->node ($_) } @removed;
  } # remove_children
  
  ## Live collection data structure
  ##
  ##   0 - The root node
  ##   1 - Filter
  ##   2 - List of the nodes in the collection
  ##   3 - Collection keys
  ##   4 - Hash reference for %{} operation
  ##   5 - Mutation revision number
  ##
  ## $self->{cols}->[$root_node_id]->
  ## 
  ##   - {anchors}                  - $doc->anchors
  ##   - {attributes}               - $el->attributes
  ##   - {attribute_definitions}    - $et->attribute_definitions
  ##   - {author_elements}          - $el->author_elements
  ##   - {category_elements}        - $el->category_elements
  ##   - {cells}                    - $el->cells
  ##   - {child_nodes}              - $node->child_nodes
  ##   - {children}                 - $node->children
  ##   - {contributor_elements}     - $el->contributor_elements
  ##   - {css_rules}                - $css->css_rules
  ##   - {element_types}            - $dt->element_types
  ##   - {embeds}                   - $doc->embeds
  ##   - {entry_elements}           - $el->entry_elements
  ##   - {forms}                    - $doc->forms
  ##   - {general_entities}         - $dt->general_entities
  ##   - {images}                   - $doc->images
  ##   - {link_elements}            - $el->link_elements
  ##   - {links}                    - $doc->links
  ##   - {notations}                - $dt->notations
  ##   - {options}                  - $el->options
  ##   - {rights_elements}          - $el->rights_elements
  ##   - {rows}                     - $el->rows
  ##   - {scripts}                  - $doc->scripts
  ##   - {tbodies}                  - $table->tbodies
  ##   - {"by_class_name$;$cls"}    - $node->get_elements_by_class_name ($cls)
  ##   - {"by_tag_name$;$type;$ln"} - $node->get_elements_by_tag_name ($ln)
  ##   - {"by_tag_name_ns$;$n$;$l"} - $node->get_elements_by_tag_name_ns ($n, $l)
  ##   - {"by_name$;$name"}         - $doc->get_elements_by_name ($name)
  ##   - {"all$;$name$;..."}        - $doc->all->{$name}->...
  
  my $CollectionClass = {
    child_nodes => 'Web::DOM::NodeList',
    attributes => 'Web::DOM::NamedNodeMap',
    attribute_definitions => 'Web::DOM::NamedNodeMap',
    element_types => 'Web::DOM::NamedNodeMap',
    general_entities => 'Web::DOM::NamedNodeMap',
    notations => 'Web::DOM::NamedNodeMap',
    by_name => 'Web::DOM::NodeList',
    all => 'Web::DOM::HTMLAllCollection',
    css_rules => 'Web::DOM::CSSRuleList',
  }; # $CollectionClass
  
  sub collection ($$$$) {
    my ($self, $keys, $root_node, $filter) = @_;
    my $key = ref $keys ? (join $;, map {
      defined $_ ? do {
        s/($;|\x00)/\x00$1/g;
        $_;
      } : '';
    } @$keys) : $keys;
    my $id = $$root_node->[1];
    return $self->{cols}->[$id]->{$key}
        if defined $self->{cols}->[$id]->{$key};
    my $class = $CollectionClass->{ref $keys ? $keys->[0] : $key}
        || 'Web::DOM::HTMLCollection';
    if (not $ModuleLoaded->{$class}++) {
      eval qq{ require $class } or die $@;
    }
    my $nl = bless \[$root_node, $filter, undef, $keys, undef, $self->{revision}], $class;
    weaken ($self->{cols}->[$id]->{$key} = $nl);
    return $nl;
  } # collection
  
  sub collection_by_el ($$$$$) {
    my ($self, $node, $key, $ns, $ln) = @_;
    return $self->collection ($key, $node, sub {
      my $node = $_[0];
      my $data = $$node->[0]->{data};
      my @node_id = @{$data->[$$node->[1]]->{child_nodes} or []};
      my @id;
      while (@node_id) {
        my $id = shift @node_id;
        next unless $data->[$id]->{node_type} == 1; # ELEMENT_NODE
        unshift @node_id, @{$data->[$id]->{child_nodes} or []};
        next unless ${$data->[$id]->{local_name}} eq $ln;
        next unless ${$data->[$id]->{namespace_uri} || \''} eq $ns;
        push @id, $id;
      }
      return @id;
    });
  } # collection_by_el
  
  ## NodeIterators
  ##
  ## $self->{iterators}->[$node_id]->[]
  ##
  ##   - {root}                          - Root node
  ##   - {reference_node}                - Reference node
  ##   - {pointer_before_reference_node} - Boolean
  ##   - {what_to_show}                  - Bit vector
  ##   - {filter}                        - Code reference
  ##
  ## |$self->{data}->[$reference_node_id]->{iterators}->{refaddr $iterator}|
  ## contains the node iterator object such that when the reference
  ## node is removed from the tree, the reference node of the iterator
  ## can be adjusted.  See |remove_node| and |remove_children|.
  sub iterator ($$$$) {
    require Web::DOM::NodeIterator;
    my $it = bless {
      root => $_[1],
      reference_node => $_[1],
      pointer_before_reference_node => 1,
      what_to_show => $_[2],
      filter => $_[3],
    }, 'Web::DOM::NodeIterator';
    weaken (${$_[1]}->[2]->{iterators}->{refaddr $_[1]} = $it);
    return $it;
  } # iterator
  
  sub change_iterator_reference_node ($$$) {
    delete ${$_[2]}->[2]->{iterators}->{refaddr ($_[1]->{reference_node})};
    $_[1]->{reference_node} = $_[2];
    weaken (${$_[2]}->[2]->{iterators}->{refaddr $_[2]} = $_[1]);
  } # change_iterator_reference_node
  
  ## Live token data structure
  ##
  ##   \ DOMStringArray
  ##
  ## $self->{tokens}->[$node_id]->
  ## 
  ##   - {class_list}           - $el->class_list
  ##   - {rel_list}             - $el->rel_list
  ##   - {dropzone}             - $el->dropzone
  ##   - {headers}              - $el->headers
  ##   - {html_for}             - $el->html_for
  ##   - {itemprop}             - $el->itemprop
  ##   - {itemref}              - $el->itemref
  ##   - {itemtype}             - $el->itemtype
  ##   - {ping}                 - $el->ping
  ##   - {sandbox}              - $el->sandbox
  ##   - {sizes}                - $el->sizes
  ##
  ## $element->class_name ------------------------------------------->+
  ## $$element->[2]->{attr...}... = class attribute <--------------<--+
  ##   |                                                              |
  ##   v $element->_attribute_is                                      |
  ## $$element->[2]->{class_list} = classes arrayref                  |
  ## $$element->[0]->{tokenlists}->{class_list}->[$id] =weak= bless [ |
  ##   ::DOMStringArray::                                             |
  ##   0 - classes arrayref                                           |
  ##   1 - update steps --------------------------------------------->+
  ##   2 - token validator
  ##   3 - serializer
  ##   4 - supportedness
  ## ], DOMTokenList
  
  sub tokens ($$$$$$) {
    my ($self, $key, $node, $updater, $attr_name, $supported) = @_;
    my $id = $$node->[1];
    return $self->{tokens}->[$id]->{$key}
        if $self->{tokens}->[$id]->{$key};
  
    my $uniquer = sub {
      my %found;
      @{$$node->[2]->{$key}} = grep {
        length $_ and not $found{$_}++;
      } @{$$node->[2]->{$key}};
    };
    my %found;
    $$node->[2]->{$key} ||= [
      grep { length $_ and not $found{$_}++ }
      split /[\x09\x0A\x0C\x0D\x20]+/,
      do { my $v = $node->get_attribute_ns (undef, $attr_name);
           defined $v ? $v : '' }
    ];
  
    require Web::DOM::StringArray;
    require Web::DOM::Exception;
    tie my @array, 'Web::DOM::StringArray', $$node->[2]->{$key}, sub {
      $uniquer->();
      $updater->();
    }, sub {
      if ($_[0] eq '') {
        _throw Web::DOM::Exception 'SyntaxError',
            'The token cannot be the empty string';
      } elsif ($_[0] =~ /[\x09\x0A\x0C\x0D\x20]/) {
        _throw Web::DOM::Exception 'InvalidCharacterError',
            'The token cannot contain any ASCII white space character';
      }
      return $_[0];
    }, sub {
      my $v = $node->get_attribute_ns (undef, $attr_name);
      return defined $v ? $v : '';
    }, $supported;
  
    my $class = 'Web::DOM::TokenList';
    if (not $ModuleLoaded->{$class}++) {
      eval qq{ require $class } or die $@;
    }
    my $nl = bless \@array, $class;
    weaken ($self->{tokens}->[$id]->{$key} = $nl);
  
    return $nl;
  } # tokens
  
  ## DOMStringMap
  sub strmap ($$) {
    my ($self, $el) = @_;
    return $self->{strmap}->[$$el->[1]] if defined $self->{strmap}->[$$el->[1]];
    require Web::DOM::StringMap;
    my $map = bless \[], 'Web::DOM::StringMap';
    tie my %hash, 'Web::DOM::StringMap::Hash', $el;
    $$map->[0] = \%hash;
    weaken ($self->{strmap}->[$$el->[1]] = $map);
    return $map;
  } # strmap
  
  ## DOMImplementation
  sub impl ($) {
    my $self = shift;
    return $self->{impl} || do {
      require Web::DOM::Implementation;
      my $impl = bless \[$self], 'Web::DOM::Implementation';
      weaken ($self->{impl} = $impl);
      $impl;
    };
  } # impl
  
  ## DOMConfiguration
  sub config ($) {
    my $self = shift;
    return $self->{config_obj} || do {
      require Web::DOM::Configuration;
      my $config = bless \[$self], 'Web::DOM::Configuration';
      weaken ($self->{config_obj} = $config);
      $config;
    };
  } # config
  
  sub config_hashref ($) {
    my $self = shift;
    my $config = $self->config;
    return $$config->[1] ||= do {
      require Web::DOM::Configuration;
      tie my %config, 'Web::DOM::Configuration::Hash', $self;
      \%config;
    };
  } # config_hashref
  
  sub import_parsed_ss ($$;$) {
    my ($self, $ss, $osid) = @_;
    ## $ss - Parsed style sheet data structure (See Web::CSS::Parser)
    ## (This method is destructive and some data in $ss is used as
    ## part of the internal.)
  
    ## $ss->{rules}->[0] is always the style sheet construct
  
    ## If $osid is defined, instead of importing $ss->{rules}->[0],
    ## import rules into existing style sheet with ID $osid.
  
    my $id_delta = $self->{next_node_id};
    my $new_osid = defined $osid ? $osid : $id_delta + 0;
    my $tree_id = defined $osid ? $self->{tree_id}->[$osid] : $new_osid;
  
    for my $rule (@{$ss->{rules}}) {
      next if $rule->{id} == 0 and defined $osid;
      my $id = $id_delta + delete $rule->{id};
      $rule->{parent_id} += $id_delta if defined $rule->{parent_id};
      @{$rule->{rule_ids}} = map { $_ + $id_delta } @{$rule->{rule_ids}}
          if $rule->{rule_ids};
      $rule->{owner_sheet} = $new_osid if $id != $id_delta + 0;
      $self->{data}->[$id] = $rule;
      $self->{tree_id}->[$id] = $tree_id;
    }
  
    ## $ss->{base_urlref} is ignored
  
    $self->{next_node_id} += @{$ss->{rules}};
  
    return defined $osid ? $id_delta + 1 : $id_delta + 0;
  
    ## This method is invoked by
    ## |Web::CSS::Parser::process_style_element| and
    ## |Web::DOM::CSSStyleSheet::insert_rule|.
  } # import_parsed_ss
  
  sub source_style ($$$) {
    my ($self, $type, $obj) = @_;
    return $self->{source_style}->[$$obj->[1]] || do {
      require Web::DOM::CSSStyleDeclaration;
      ## $type = 'rule', $obj = CSSStyleRule - Declarations in the style rule
      ## $type = 'attr', $obj = Element      - style="" attribute
      my $style = bless \[$type, $obj], 'Web::DOM::CSSStyleDeclaration';
          ## [0] $type
          ## [1] $obj
          ## [2] updating flag (See |Web::DOM::Element::_attribute_is|.)
          ## [3] Property struct (See |Web::CSS::Parser|.)
      weaken ($self->{source_style}->[$$obj->[1]] = $style);
      if ($type eq 'attr') {
        $$style->[3] = {prop_keys => [], prop_values => {},
                        prop_importants => {}};
        my $value = $obj->get_attribute_ns (undef, 'style');
        if (defined $value) {
          local $$style->[2] = 1; # updating
          $style->css_text ($value);
        }
      } else { # rule
        $$style->[3] = $$obj->[2];
      }
      $style;
    };
  } # source_style
  
  sub media ($$) {
    my ($self, $obj) = @_;
    return $self->{media}->[$$obj->[1]] || do {
      require Web::DOM::MediaList;
      my $list = bless \[$obj], 'Web::DOM::MediaList';
      weaken ($self->{media}->[$$obj->[1]] = $list);
      $list;
    };
  } # media
  
  sub connect ($$$) {
    my ($self, $id => $parent_id) = @_;
    my @id = ($id);
    my $tree_id = $self->{tree_id}->[$parent_id];
    while (@id) {
      my $id = shift @id;
      $self->{tree_id}->[$id] = $tree_id;
      my $data = $self->{data}->[$id];
      my $nt = $data->{node_type};
      if (not defined $nt) {
        push @id, @{$data->{rule_ids}} if defined $data->{rule_ids};
        push @id, $data->{sheet} if defined $data->{sheet};
      } elsif ($nt == 1) { # ELEMENT_NODE
        push @id, grep { not ref $_ } @{$data->{attributes} or []}; # AttrNameRef
        push @id, @{$data->{child_nodes}} if defined $data->{child_nodes};
        push @id, $data->{content_df}
            if defined $data->{content_df} and not ref $data->{content_df};
        push @id, $data->{sheet} if defined $data->{sheet};
      } elsif ($nt == 3 or $nt == 2) { # TEXT_NODE, ATTRIBUTE_NODE
        #
      } else {
        push @id, @{$data->{child_nodes}} if defined $data->{child_nodes};
        push @id, values %{$data->{element_types}}
            if defined $data->{element_types};
        push @id, values %{$data->{general_entities}}
            if defined $data->{general_entities};
        push @id, values %{$data->{notations}}
            if defined $data->{notations};
        push @id, values %{$data->{attribute_definitions}}
            if defined $data->{attribute_definitions};
      }
    }
  } # connect
  
  sub disconnect ($$) {
    my ($self, $id) = @_;
    my @id = ($id);
    my $tree_id = $id;
    while (@id) {
      my $id = shift @id;
      $self->{tree_id}->[$id] = $tree_id;
      my $data = $self->{data}->[$id];
      push @id, grep { not ref $_ } @{$data->{attributes} or []}; # AttrNameRef
      push @id,
          @{$data->{child_nodes} or []},
          @{$data->{rule_ids} or []},
          grep { defined $_ } 
          values %{$data->{element_types} or {}},
          values %{$data->{general_entities} or {}},
          values %{$data->{notations} or {}},
          values %{$data->{attribute_definitions} or {}},
          $data->{sheet};
      push @id, $data->{content_df}
          if defined $data->{content_df} and
             not ref $data->{content_df};
      delete $data->{owner_sheet};
    }
    ## This method is not invoked when template content is disconnected
    ## by the |set_template_content| invocation in |adopt|.
  } # disconnect
  
  ## Move a node, with its descendants and their related objects, from
  ## the document to another (this) document.  Please note that this
  ## method is not enough for the "adopt" operation as defined in the
  ## DOM Standard; that operation requires more than this method does,
  ## including removal of the parent node of the node.  This method
  ## assumes that $node has no parent or owner.
  sub adopt ($$) {
    my ($new_int, $node) = @_;
    my $old_int = $$node->[0];
    return if $old_int eq $new_int;
  
    my @old_id = ($$node->[1]);
    my $new_templ_doc;
    my %id_map;
    my @data;
    my @template;
    while (@old_id) {
      my $old_id = shift @old_id;
      my $new_id = $new_int->{next_node_id}++;
      $id_map{$old_id} = $new_id;
  
      my $data = $new_int->{data}->[$new_id]
          = delete $old_int->{data}->[$old_id];
      push @data, $data;
  
      $new_int->{tree_id}->[$new_id]
          = $id_map{delete $old_int->{tree_id}->[$old_id]};
  
      if (defined $data->{content_df}) {
        my $df = $data->{content_df};
        $df = $old_int->node ($df) if not ref $df;
        $new_templ_doc ||= $new_int->template_doc;
        $$new_templ_doc->[0]->adopt ($df);
        push @template, [$new_id => $df];
      }
  
      push @old_id, grep { not ref $_ } @{$data->{attributes} or []}; # AttrNameRef
      push @old_id,
          @{$data->{child_nodes} or []},
          @{$data->{rule_ids} or []},
          grep { defined $_ } 
          values %{$data->{element_types} or {}},
          values %{$data->{general_entities} or {}},
          values %{$data->{notations} or {}},
          values %{$data->{attribute_definitions} or {}},
          $data->{sheet};
  
      if (my $node = delete $old_int->{nodes}->[$old_id]) {
        weaken ($new_int->{nodes}->[$new_id] = $node);
        $$node->[0] = $new_int;
        $$node->[1] = $new_id;
      }
  
      if (my $cols = delete $old_int->{cols}->[$old_id]) {
        $new_int->{cols}->[$new_id] = $cols;
        for (values %$cols) {
          delete $$_->[2] if defined $_;
          delete $$_->[4] if defined $_;
        }
      }
  
      $new_int->{rc}->[$new_id] = delete $old_int->{rc}->[$old_id]
          if $old_int->{rc}->[$old_id];
    } # @old_id
  
    for my $data (@data) {
      @{$data->{attributes}} = map {
        ref $_ ? $_ : $id_map{$_}; # AttrNameRef
      } @{$data->{attributes}} if $data->{attributes};
      for (values %{$data->{attrs} or {}}) {
        for my $ln (keys %$_) {
          if (defined $_->{$ln} and not ref $_->{$ln}) { # AttrValueRef
            $_->{$ln} = $id_map{$_->{$ln}};
          }
        }
      }
      @{$data->{child_nodes}} = map { $id_map{$_} } @{$data->{child_nodes}}
          if $data->{child_nodes};
      @{$data->{rule_ids}} = map { $id_map{$_} } @{$data->{rule_ids}}
          if $data->{rule_ids};
      for my $key (qw(element_types general_entities notations
                      attribute_definitions)) {
        for (keys %{$data->{$key} or {}}) {
          if (defined $data->{$key}->{$_}) {
            $data->{$key}->{$_} = $id_map{$data->{$key}->{$_}};
          }
        }
      }
      for (qw(sheet
              parent_node owner
              owner_sheet)) {
        $data->{$_} = $id_map{$data->{$_}} if defined $data->{$_};
      }
    } # @data
  
    ## Note that |disconnect| is not invoked here, as all descendants
    ## are also adopted anyway.
    $new_int->set_template_content (@$_) for @template;
  
    if (defined $$node->[2]->{host_el}) {
      my $el = $$node->[2]->{host_el};
      $el = defined $id_map{$el} ? $new_int->node ($id_map{$el})
                                 : $old_int->node ($el) if not ref $el;
      ## Note that |disconnect| is not invoked here.
      $$el->[0]->set_template_content ($$el->[1] => $node);
    }
  } # adopt
  
  sub css_parser ($) {
    return $_[0]->{css_parser} ||= do {
      require Web::CSS::Parser;
      Web::CSS::Parser->new;
    }; # XXX onerror -> error console
  } # css_parser
  
  sub css_serializer ($) {
    return $_[0]->{css_serializer} ||= do {
      require Web::CSS::Serializer;
      Web::CSS::Serializer->new;
    };
  } # css_serializer
  
  sub gc ($$) {
    return if @{$_[0]->{data} or []} > 100 and 0.995 > rand 1;
    my ($self, $id) = @_;
    delete $self->{nodes}->[$id];
    my $tree_id = $self->{tree_id}->[$id];
    ## The tree with ID |0| is special, which cannot be freed until the
    ## entire grove can be freed.
    return if $tree_id == 0;
    my @id = grep { defined $self->{tree_id}->[$_] and 
                    $self->{tree_id}->[$_] == $tree_id } 0..$#{$self->{tree_id}};
    for (@id) {
      return if $self->{nodes}->[$_] or ($self->{rc}->[$_] or 0) > 0;
    }
    for (@id) {
      delete $self->{data}->[$_];
      delete $self->{tree_id}->[$_];
      delete $self->{rc}->[$_];
      delete $self->{cols}->[$_];
    }
  } # gc
  
  sub DESTROY ($) {
    {
      local $@;
      eval { die };
      warn "Potential memory leak detected" if $@ =~ /during global destruction/;
    }
  } # DESTROY
  
  ## Read-only hash
  ##
  ## Note that Perl's native read-only hash does not allow access to
  ## undefined hash keys (thrown).
  package Web::DOM::Internal::ReadOnlyHash;
  use Carp;
  
  sub TIEHASH ($$) {
    return bless $_[1], $_[0]
  } # TIEHASH
  
  sub FETCH ($$) {
    return $_[0]->{$_[1]}; # or undef
  } # FETCH
  
  sub STORE ($$$) {
    croak 'Modification of a read-only value attempted';
  } # STORE
  
  sub DELETE ($$) {
    croak 'Modification of a read-only value attempted';
  } # DELETE
  
  sub CLEAR ($) {
    croak 'Modification of a read-only value attempted';
  } # CLEAR
  
  sub EXISTS ($$) {
    return exists $_[0]->{$_[1]};
  } # EXISTS
  
  sub FIRSTKEY ($) {
    keys %{$_[0]};
    return each %{$_[0]}; # or undef
  } # FIRSTKEY
  
  sub NEXTKEY ($$) {
    return each %{$_[0]}; # or undef
  } # NEXTKEY
  
  sub SCALAR ($) {
    return scalar %{$_[0]};
  } # SCALAR
  
  sub DESTROY ($) {
    local $@;
    eval { die };
    warn "Possible memory leak detected (Web::DOM::Internal)\n"
        if $@ =~ /during global destruction/;
  } # DESTROY
  
  1;
  
  =head1 LICENSE
  
  Copyright 2012-2015 Wakaba <wakaba@suikawiki.org>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
WEB_DOM_INTERNAL

$fatpacked{"Web/DOM/NamedNodeMap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WEB_DOM_NAMEDNODEMAP';
  package Web::DOM::NamedNodeMap;
  use strict;
  use warnings;
  use Web::DOM::Collection;
  push our @ISA, qw(Web::DOM::Collection);
  our $VERSION = '3.0';
  push our @CARP_NOT, qw(
    Web::DOM::Element Web::DOM::DocumentType Web::DOM::ElementTypeDefinition
  );
  use Web::DOM::Internal;
  use Web::DOM::Node;
  use Web::DOM::TypeError;
  use Web::DOM::Exception;
  
  use overload
      '%{}' => sub {
        if (defined ${$_[0]}->[4] and
            ${${$_[0]}->[0]}->[0]->{revision} == ${$_[0]}->[5]) {
          return ${$_[0]}->[4];
        } else {
          return ${$_[0]}->[4] = do {
            my %data = map { $_->node_name => $_ } reverse $_[0]->to_list;
            my $root = ${$_[0]}->[0];
            if (defined $$root->[2]->{namespace_uri} and 
                ${$$root->[2]->{namespace_uri}} eq 'http://www.w3.org/1999/xhtml' and
                $$root->[0]->{data}->[0]->{is_html}) {
              my @bad = grep { /[A-Z]/ } keys %data; ## ASCII case-insensitive
              delete $data{$_} for @bad;
            }
            tie my %hash, 'Web::DOM::Internal::ReadOnlyHash', \%data;
            delete ${$_[0]}->[2];
            ${$_[0]}->[5] = ${${$_[0]}->[0]}->[0]->{revision};
            \%hash;
          };
        }
      },
      fallback => 1;
  
  my $GetMethod = {
    attributes => 'get_attribute_node',
    element_types => 'get_element_type_definition_node',
    general_entities => 'get_general_entity_node',
    notations => 'get_notation_node',
    attribute_definitions => 'get_attribute_definition_node',
  };
  
  sub get_named_item ($$) {
    my $method = $GetMethod->{${$_[0]}->[3]}
        or _throw Web::DOM::Exception 'NotSupportedError',
               'This operation is not supported';
    return ${$_[0]}->[0]->$method ($_[1]);
  } # get_named_item
  
  my $GetMethodNS = {
    attributes => 'get_attribute_node_ns',
  };
  
  sub get_named_item_ns ($$$) {
    my $method = $GetMethodNS->{${$_[0]}->[3]}
        or _throw Web::DOM::Exception 'NotSupportedError',
               'This operation is not supported';
    return ${$_[0]}->[0]->$method ($_[1], $_[2]);
  } # get_named_item_ns
  
  my $SetMethod = {
    attributes => 'set_attribute_node',
    element_types => 'set_element_type_definition_node',
    general_entities => 'set_general_entity_node',
    notations => 'set_notation_node',
    attribute_definitions => 'set_attribute_definition_node',
  };
  
  my $SetNodeType = {
    attributes => ATTRIBUTE_NODE,
    element_types => ELEMENT_TYPE_DEFINITION_NODE,
    general_entities => ENTITY_NODE,
    notations => NOTATION_NODE,
    attribute_definitions => ATTRIBUTE_DEFINITION_NODE,
  };
  
  sub set_named_item ($$) {
    my $method = $SetMethod->{${$_[0]}->[3]}
        or _throw Web::DOM::Exception 'NotSupportedError',
               'This operation is not supported';
  
    # WebIDL
    unless (UNIVERSAL::isa ($_[1], 'Web::DOM::Node')) {
      _throw Web::DOM::TypeError 'The argument is not a Node';
    }
  
    unless ($_[1]->node_type == $SetNodeType->{${$_[0]}->[3]}) {
      _throw Web::DOM::Exception 'HierarchyRequestError',
          'Specified type of node cannot be set';
    }
    return ${$_[0]}->[0]->$method ($_[1]);
  } # set_named_item
  
  my $SetMethodNS = {
    attributes => 'set_attribute_node_ns',
  };
  
  sub set_named_item_ns ($$) {
    # WebIDL
    unless (UNIVERSAL::isa ($_[1], 'Web::DOM::Node')) {
      _throw Web::DOM::TypeError 'The argument is not a Node';
    }
  
    my $method = $SetMethodNS->{${$_[0]}->[3]}
        or _throw Web::DOM::Exception 'NotSupportedError',
               'This operation is not supported';
  
    unless ($_[1]->node_type == $SetNodeType->{${$_[0]}->[3]}) {
      _throw Web::DOM::Exception 'HierarchyRequestError',
          'Specified type of node cannot be set';
    }
    return ${$_[0]}->[0]->$method ($_[1]);
  } # set_named_item_ns
  
  my $RemoveMethod = {
    attributes => 'remove_attribute_node',
    element_types => 'remove_element_type_definition_node',
    general_entities => 'remove_general_entity_node',
    notations => 'remove_notation_node',
    attribute_definitions => 'remove_attribute_definition_node',
  };
  
  sub remove_named_item ($$) {
    my $node = $_[0]->get_named_item ($_[1]);
    unless ($node) {
      _throw Web::DOM::Exception 'NotFoundError',
          'Specified node not found';
    }
    my $method = $RemoveMethod->{${$_[0]}->[3]}
        or _throw Web::DOM::Exception 'NotSupportedError',
               'This operation is not supported';
    ${$_[0]}->[0]->$method ($node);
    return $node;
  } # remove_named_item
  
  sub remove_named_item_ns ($$$) {
    my $node = $_[0]->get_named_item_ns ($_[1], $_[2]);
    unless ($node) {
      _throw Web::DOM::Exception 'NotFoundError',
          'Specified node not found';
    }
    my $method = $RemoveMethod->{${$_[0]}->[3]}
        or _throw Web::DOM::Exception 'NotSupportedError',
               'This operation is not supported';
    ${$_[0]}->[0]->$method ($node);
    return $node;
  } # remove_named_item_ns
  
  1;
  
  =head1 LICENSE
  
  Copyright 2012-2016 Wakaba <wakaba@suikawiki.org>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
WEB_DOM_NAMEDNODEMAP

$fatpacked{"Web/DOM/Node.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WEB_DOM_NODE';
  package Web::DOM::Node;
  use strict;
  use warnings;
  no warnings 'utf8';
  our $VERSION = '3.0';
  use Web::DOM::TypeError;
  use Web::DOM::Exception;
  use Web::DOM::Internal;
  use Web::DOM::EventTarget;
  push our @ISA, qw(Web::DOM::EventTarget);
  use Carp;
  our @CARP_NOT = qw(Web::DOM::Exception Web::DOM::TypeError);
  
  use overload
      '""' => sub {
        return ref ($_[0]) . '=DOM(' . ${$_[0]}->[2] . ')';
      },
      bool => sub { 1 },
      cmp => sub {
        carp "Use of uninitialized value in string comparison (cmp)"
            unless defined $_[1];
        if ((ref $_[0]) eq (ref $_[1]) or
            UNIVERSAL::isa ($_[1], 'Web::DOM::Node')) {
          return (${$_[0]}->[0] cmp ${$_[1]}->[0] ||
                  ${$_[0]}->[1] <=> ${$_[1]}->[1]);
        } else {
          return ${$_[0]}->[0] cmp $_[1];
        }
      },
      fallback => 1;
  
  our @EXPORT;
  *import = \&Web::DOM::Internal::import;
  
  push @EXPORT, qw(
    ELEMENT_NODE ATTRIBUTE_NODE TEXT_NODE CDATA_SECTION_NODE 
    ENTITY_REFERENCE_NODE ENTITY_NODE PROCESSING_INSTRUCTION_NODE
    COMMENT_NODE DOCUMENT_NODE DOCUMENT_TYPE_NODE DOCUMENT_FRAGMENT_NODE
    NOTATION_NODE ELEMENT_TYPE_DEFINITION_NODE ATTRIBUTE_DEFINITION_NODE
    XPATH_NAMESPACE_NODE
  );
  
  sub ELEMENT_NODE () { 1 }
  sub ATTRIBUTE_NODE () { 2 }
  sub TEXT_NODE () { 3 }
  sub CDATA_SECTION_NODE () { 4 }
  sub ENTITY_REFERENCE_NODE () { 5 }
  sub ENTITY_NODE () { 6 }
  sub PROCESSING_INSTRUCTION_NODE () { 7 }
  sub COMMENT_NODE () { 8 }
  sub DOCUMENT_NODE () { 9 }
  sub DOCUMENT_TYPE_NODE () { 10 }
  sub DOCUMENT_FRAGMENT_NODE () { 11 }
  sub NOTATION_NODE () { 12 }
  sub XPATH_NAMESPACE_NODE () { 13 }
  sub ELEMENT_TYPE_DEFINITION_NODE () { 81001 }
  sub ATTRIBUTE_DEFINITION_NODE () { 81002 }
  
  sub node_type ($) {
    return ${$_[0]}->[2]->{node_type};
  } # node_type
  
  sub node_name ($) {
    die ref ($_[0]) . "::node_name not implemented";
  } # node_name
  
  sub namespace_uri ($) {
    return ${${$_[0]}->[2]->{namespace_uri} || \undef};
  } # namespace_uri
  
  sub prefix ($;$) {
    if (@_ > 1) {
      # 1.
      my $prefix = defined $_[1] ? ''.$_[1] : undef;
  
      # 2.
      unless (${$_[0]}->[2]->{namespace_uri}) {
        if (not ${$_[0]}->[2]->{local_name} or
            not ${$_[0]}->[0]->{data}->[0]->{no_strict_error_checking}) {
          _throw Web::DOM::Exception 'NamespaceError',
              'Namespace prefix can only be specified for namespaced node';
        }
      }
  
      if (defined $prefix and length $prefix) {
        unless (${$_[0]}->[0]->{data}->[0]->{no_strict_error_checking}) {
          # 4.1.
          unless ($prefix =~ /\A\p{InNameStartChar}\p{InNameChar}*\z/) {
            _throw Web::DOM::Exception 'InvalidCharacterError',
                'The prefix is not an XML Name';
          }
  
          # 4.2.
          unless ($prefix =~ /\A\p{InNCNameStartChar}\p{InNCNameChar}*\z/) {
            _throw Web::DOM::Exception 'NamespaceError',
                'The prefix is not an XML NCName';
          }
        }
  
        # 5.
        ${$_[0]}->[2]->{prefix} = Web::DOM::Internal->text ($prefix);
      } else {
        # 3., 5.
        delete ${$_[0]}->[2]->{prefix};
      }
    } # setter
    return ${${$_[0]}->[2]->{prefix} || \undef};
  } # prefix
  
  *local_name = \&manakai_local_name;
  
  sub manakai_local_name ($) {
    return ${${$_[0]}->[2]->{local_name} || \undef};
  } # manakai_local_name
  
  sub manakai_expanded_uri ($) {
    my $self = shift;
    my $ln = $self->local_name;
    if (defined $ln) {
      my $nsuri = $self->namespace_uri;
      if (defined $nsuri) {
        return $nsuri . $ln;
      } else {
        return $ln;
      }
    } else {
      return undef;
    }
  } # manakai_expanded_uri
  
  sub base_uri ($) {
    my $self = $_[0];
    my $nt = $self->node_type;
    if ($nt == DOCUMENT_NODE) {
      return $$self->[0]->{document_base_url}
          if defined $$self->[0]->{document_base_url} and
             $$self->[0]->{document_base_url_revision} == $$self->[0]->{revision};
  
      # 1. document base URL
      # XXX <http://html5.org/tools/web-apps-tracker?from=7961&to=7962> is not applied yet
      
      # 1. fallback base URL
      my $fallback_base_url = do {
        # 1.
        if ($self->manakai_is_srcdoc) {
          # XXX
        }
  
        # 2.
        my $url = $self->url;
        if ($url eq 'about:blank' and 'XXX') {
          # XXX
        }
  
        # 3.
        $url;
      };
  
      # 2.
      my $base = [grep { $_->has_attribute_ns (undef, 'href') } $self->get_elements_by_tag_name_ns (HTML_NS, 'base')->to_list]->[0];
      if (defined $base) {
        my $url = $base->get_attribute_ns (undef, 'href');
        
        # 3.
        my $result = _resolve_url $url, $fallback_base_url;
  
        # 4.
        $$self->[0]->{document_base_url_revision} = $$self->[0]->{revision};
        return $$self->[0]->{document_base_url}
            = defined $result ? $result : $fallback_base_url;
      } else {
        $$self->[0]->{document_base_url_revision} = $$self->[0]->{revision};
        return $$self->[0]->{document_base_url} = $fallback_base_url;
      }
    }
    
    return $self->owner_document->base_uri;
  } # base_uri
  
  sub owner_document ($) {
    return ${$_[0]}->[0]->node (0);
  } # owner_document
  
  sub attributes ($) {
    return undef;
  } # attributes
  
  sub has_attributes ($) {
    return 0;
  } # has_attributes
  
  sub parent_node ($) {
    my $self = shift;
    my $pid = $$self->[2]->{parent_node};
    return undef unless defined $pid;
    return $$self->[0]->node ($pid);
  } # parent_node
  
  sub parent_element ($) {
    my $self = shift;
    my $pid = $$self->[2]->{parent_node};
    return undef unless defined $pid;
    my $node = $$self->[0]->node ($pid);
    return undef unless $node->node_type == ELEMENT_NODE;
    return $node;
  } # parent_element
  
  *manakai_parent_element = \&parent_element;
  
  sub child_nodes ($) {
    my $node = $_[0];
    return $$node->[0]->collection ('child_nodes', $node, sub {
      my $node = $_[0];
      return @{$$node->[2]->{child_nodes} or []};
    });
  } # child_nodes
  
  sub has_child_nodes ($) {
    return !!@{${$_[0]}->[2]->{child_nodes} or []};
  } # has_child_nodes
  
  sub first_child ($) {
    my $self = shift;
    my $id = $$self->[2]->{child_nodes}->[0];
    return undef unless defined $id;
    return $$self->[0]->node ($id);
  } # first_child
  
  sub last_child ($) {
    my $self = shift;
    my $id = $$self->[2]->{child_nodes}->[-1];
    return undef unless defined $id;
    return $$self->[0]->node ($id);
  } # last_child
  
  sub previous_sibling ($) {
    my $self = shift;
    my $parent_id = $$self->[2]->{parent_node};
    return undef unless defined $parent_id;
    my $self_id = $$self->[1];
    my $children = $$self->[0]->{data}->[$parent_id]->{child_nodes};
    for (0..$#$children) {
      if ($children->[$_] == $self_id) {
        if ($_ == 0) {
          return undef;
        } else {
          return $$self->[0]->node ($children->[$_ - 1]);
        }
      }
    }
    die "This node is not a child of the parent node";
  } # previous_sibling
  
  sub next_sibling ($) {
    my $self = shift;
    my $parent_id = $$self->[2]->{parent_node};
    return undef unless defined $parent_id;
    my $self_id = $$self->[1];
    my $children = $$self->[0]->{data}->[$parent_id]->{child_nodes};
    for (0..$#$children) {
      if ($children->[$_] == $self_id) {
        if ($_ == $#$children) {
          return undef;
        } else {
          return $$self->[0]->node ($children->[$_ + 1]);
        }
      }
    }
    die "This node is not a child of the parent node";
  } # next_sibling
  
  sub append_child ($$) {
    # WebIDL
    unless (UNIVERSAL::isa ($_[1], 'Web::DOM::Node')) {
      _throw Web::DOM::TypeError 'The first argument is not a Node';
    }
  
    # append
    {
      # pre-insert
      return $_[0]->_pre_insert ($_[1]);
    }
  } # append_child
  
  sub insert_before ($$$) {
    # WebIDL
    unless (UNIVERSAL::isa ($_[1], 'Web::DOM::Node')) {
      _throw Web::DOM::TypeError 'The first argument is not a Node';
    }
    if (defined $_[2] and not UNIVERSAL::isa ($_[2], 'Web::DOM::Node')) {
      _throw Web::DOM::TypeError 'The second argument is not a Node';
    }
  
    return $_[0]->_pre_insert ($_[1], $_[2]);
  } # insert_before
  
  sub replace_child ($$$) {
    # WebIDL
    unless (UNIVERSAL::isa ($_[1], 'Web::DOM::Node')) {
      _throw Web::DOM::TypeError 'The first argument is not a Node';
    }
    unless (UNIVERSAL::isa ($_[2], 'Web::DOM::Node')) {
      _throw Web::DOM::TypeError 'The second argument is not a Node';
    }
  
    return $_[0]->_pre_insert ($_[1], undef, $_[2]);
  } # replace_child
  
  sub _pre_insert ($$;$$) {
    my ($parent, $node, $child, $old_child) = @_;
  
    # pre-insert / replace
    my $parent_nt = $$parent->[2]->{node_type};
  
    # 1.
    if (not $parent_nt == DOCUMENT_TYPE_NODE or
        not $$parent->[0]->{config}->{manakai_allow_doctype_children}) {
      unless ($parent_nt == ELEMENT_NODE or
              $parent_nt == DOCUMENT_FRAGMENT_NODE or
              $parent_nt == DOCUMENT_NODE) {
        _throw Web::DOM::Exception 'HierarchyRequestError',
            'The parent node cannot have a child';
      }
    }
  
    # 2.
    {
      my $int = $$parent->[0];
      my $id = $$parent->[1];
      TREES: {
        if ($int eq $$node->[0]) {
          ## If the new child node belongs to the same tree as the
          ## parent, check inclusive ancestors.
          if ($int->{tree_id}->[$id] == $int->{tree_id}->[$$node->[1]]) {
            TREE: {
              if ($id == $$node->[1]) {
                _throw Web::DOM::Exception 'HierarchyRequestError',
                    'The child is a host-including inclusive ancestor of the parent';
              }
              if (defined $int->{data}->[$id]->{parent_node}) {
                $id = $int->{data}->[$id]->{parent_node};
                redo TREE;
              } elsif (defined $int->{data}->[$id]->{host_el}) {
                $id = $int->{data}->[$id]->{host_el};
                redo TREE unless ref $id;
                ## Otherwise, the new child node is never a
                ## host-inclusive ancestor of the parent.
              }
            }
          }
        } else {
          ## If the new child node does not belong to the same tree as
          ## the parent, check host element's tree, if any.
          my $host_el = $int->{data}->[$int->{tree_id}->[$id]]->{host_el};
          if (defined $host_el and ref $host_el) {
            $int = $$host_el->[0];
            $id = $$host_el->[1];
            redo TREES;
          }
        }
      } # TREES
    }
    
    # 3.
    if (defined $child or defined $old_child) {
      if ($$parent->[0] eq ${$child || $old_child}->[0]) {
        my $rc_parent = ${$child || $old_child}->[2]->{parent_node};
        if (not defined $rc_parent or $rc_parent != $$parent->[1]) {
          _throw Web::DOM::Exception 'NotFoundError',
              'The reference child is not a child of the parent node';
        }
      } else {
        _throw Web::DOM::Exception 'NotFoundError',
            'The reference child is not a child of the parent node';
      }
    }
  
    my $not_strict_doc
        = $$parent->[0]->{config}->{not_manakai_strict_document_children};
    my $node_nt = $$node->[2]->{node_type};
    if ($node_nt == TEXT_NODE) {
      # 5.
      if ($parent_nt == DOCUMENT_NODE and not $not_strict_doc) {
        _throw Web::DOM::Exception 'HierarchyRequestError',
            'Document node cannot contain this kind of node';
      }
    } elsif ($node_nt == DOCUMENT_TYPE_NODE) {
      # 5.
      if ($parent_nt != DOCUMENT_NODE) {
        _throw Web::DOM::Exception 'HierarchyRequestError',
            'Document type cannot be contained by this kind of node';
      }
    } elsif ($node_nt == DOCUMENT_FRAGMENT_NODE or
             $node_nt == ELEMENT_NODE or
             $node_nt == PROCESSING_INSTRUCTION_NODE or
             $node_nt == COMMENT_NODE) {
      #
    } else {
      # 4.
      _throw Web::DOM::Exception 'HierarchyRequestError',
          'The parent cannot contain this kind of node';
    }
  
    # 6.
    if ($parent_nt == DOCUMENT_NODE and not $not_strict_doc) {
      if ($node_nt == ELEMENT_NODE) {
        # 6.2.
        if (defined $old_child) { # replace
          my $has_child;
          for (@{$$parent->[2]->{child_nodes}}) {
            my $data = $$parent->[0]->{data}->[$_];
            if ($$old_child->[0] eq $$parent->[0] and $$old_child->[1] == $_) {
              $has_child = 1;
            } elsif ($data->{node_type} == ELEMENT_NODE) {
              _throw Web::DOM::Exception 'HierarchyRequestError',
                  'Document node cannot have two element children';
            } elsif ($has_child and $data->{node_type} == DOCUMENT_TYPE_NODE) {
              _throw Web::DOM::Exception 'HierarchyRequestError',
                  'Element cannot precede the document type';
            }
          }
        } else { # pre-insert
          my $has_child;
          for (@{$$parent->[2]->{child_nodes}}) {
            my $data = $$parent->[0]->{data}->[$_];
            if ($data->{node_type} == ELEMENT_NODE) {
              _throw Web::DOM::Exception 'HierarchyRequestError',
                  'Document node cannot have two element children';
            } elsif (defined $child and $_ == $$child->[1]) {
              $has_child = 1;
            }
            if ($has_child and $data->{node_type} == DOCUMENT_TYPE_NODE) {
              _throw Web::DOM::Exception 'HierarchyRequestError',
                  'Element cannot precede the document type';
            }
          }
        }
      } elsif ($node_nt == DOCUMENT_TYPE_NODE) {
        # 6.3.
        if (defined $old_child) { # replace
          my $has_child;
          for (@{$$parent->[2]->{child_nodes}}) {
            my $data = $$parent->[0]->{data}->[$_];
            if ($$old_child->[0] eq $$parent->[0] and $$old_child->[1] == $_) {
              $has_child = 1;
            } elsif ($data->{node_type} == DOCUMENT_TYPE_NODE) {
              _throw Web::DOM::Exception 'HierarchyRequestError',
                  'Document node cannot have two doctype children';
            } elsif ($data->{node_type} == ELEMENT_NODE and not $has_child) {
              _throw Web::DOM::Exception 'HierarchyRequestError',
                  'Element cannot precede the document type';
            }
          }
        } else { # pre-insert
          my $has_child;
          for (@{$$parent->[2]->{child_nodes}}) {
            my $data = $$parent->[0]->{data}->[$_];
            if (defined $child and $_ == $$child->[1]) {
              $has_child = 1;
            }
            if ($data->{node_type} == ELEMENT_NODE and not $has_child) {
              _throw Web::DOM::Exception 'HierarchyRequestError',
                  'Element cannot precede the document type';
            } elsif ($data->{node_type} == DOCUMENT_TYPE_NODE) {
              _throw Web::DOM::Exception 'HierarchyRequestError',
                  'Document node cannot have two doctype children';
            }
          }
        }
      } elsif ($node_nt == DOCUMENT_FRAGMENT_NODE) {
        # 6.1.1.
        my $has_element;
        for (@{$$node->[2]->{child_nodes}}) {
          my $data = $$node->[0]->{data}->[$_];
          if ($data->{node_type} == ELEMENT_NODE) {
            if ($has_element) {
              _throw Web::DOM::Exception 'HierarchyRequestError',
                  'Document node cannot have two element children';
            }
            $has_element = 1;
          } elsif ($data->{node_type} == TEXT_NODE) {
            _throw Web::DOM::Exception 'HierarchyRequestError',
                'Document node cannot contain this kind of node';
          }
        }
  
        # 6.1.2.
        if ($has_element) {
          if (defined $old_child) { # replace
            my $has_child;
            for (@{$$parent->[2]->{child_nodes}}) {
              my $data = $$parent->[0]->{data}->[$_];
              if ($$old_child->[0] eq $$parent->[0] and $$old_child->[1] == $_) {
                $has_child = 1;
              } elsif ($data->{node_type} == ELEMENT_NODE) {
                _throw Web::DOM::Exception 'HierarchyRequestError',
                    'Document node cannot have two element children';
              } elsif ($has_child and $data->{node_type} == DOCUMENT_TYPE_NODE) {
                _throw Web::DOM::Exception 'HierarchyRequestError',
                    'Element cannot precede the document type';
              }
            }
          } else { # pre-insert
            my $has_child;
            for (@{$$parent->[2]->{child_nodes}}) {
              my $data = $$parent->[0]->{data}->[$_];
              if ($data->{node_type} == ELEMENT_NODE) {
                _throw Web::DOM::Exception 'HierarchyRequestError',
                    'Document node cannot have two element children';
              } elsif (defined $child and $_ == $$child->[1]) {
                $has_child = 1;
              }
              if ($has_child and $data->{node_type} == DOCUMENT_TYPE_NODE) {
                _throw Web::DOM::Exception 'HierarchyRequestError',
                    'Element cannot precede the document type';
              }
            }
          }
        }
      }
    } # document children
  
    if ($parent_nt == DOCUMENT_TYPE_NODE) {
      if ($node_nt == DOCUMENT_FRAGMENT_NODE) {
        for (@{$$node->[2]->{child_nodes}}) {
          my $data = $$node->[0]->{data}->[$_];
          unless ($data->{node_type} == PROCESSING_INSTRUCTION_NODE) {
            _throw Web::DOM::Exception 'HierarchyRequestError',
                'The node cannot be contain this kind of node';
          }        
        }
      } elsif ($node_nt != PROCESSING_INSTRUCTION_NODE) {
        _throw Web::DOM::Exception 'HierarchyRequestError',
            'The node cannot be contain this kind of node';
      }
    } # doctype children
  
    # 7.-8.
    my $insert_position = 0;
    if (defined $child or # pre-insert (insertBefore)
        defined $old_child) { # replace
      my $child_id = defined $child ? $$child->[1] : $$old_child->[1];
      for (0..$#{$$parent->[2]->{child_nodes}}) {
        my $id = $$parent->[2]->{child_nodes}->[$_];
        if ($id == $child_id) {
          $insert_position += $_;
          last;
        } elsif ($$node->[0] eq $$parent->[0] and $id == $$node->[1]) {
          ## $node is a preceding sibling of $child.  Since it is
          ## removed from the parent in Step 8., insert position has to
          ## be decreased here.
          $insert_position--;
        }
      }
    } else { # pre-insert (appendChild)
      $insert_position = @{$$parent->[2]->{child_nodes} or []};
      if ($$node->[0] eq $$parent->[0] and
          defined $$node->[2]->{parent_node} and
          $$node->[2]->{parent_node} == $$parent->[1]) {
        ## $node is a child of $parent.  Since it is removed from the
        ## parent in Step 8., insert position has to be decreated here.
        $insert_position--;
      }
    }
    
    # 9. adopt
    {
      # Adopt 2.
      my $old_parent_id = $$node->[2]->{parent_node};
      $$node->[0]->remove_node ($old_parent_id, $$node->[1], 0)
          if defined $old_parent_id;
  
      # Adopt 3.
      $$parent->[0]->adopt ($node);
  
      # Adopt 4. Adopting steps
      if ($$node->[2]->{node_type} == ELEMENT_NODE) {
        # XXX
      }
    } # adopt
  
    # Replace 10.
    $$node->[0]->remove_node ($$parent->[1], $$old_child->[1], 'suppress')
        if defined $old_child;
  
    # Pre-insert 10. / Replace 11. insert
    {
      # XXX "suppress observers flag" is set if it's replace.
  
      # Insert 1.
      #
  
      # Insert 2.
      # XXX range
  
      if ($node_nt == DOCUMENT_FRAGMENT_NODE) {
        # Insert 3.
        my @node = @{$$node->[2]->{child_nodes} or []};
        
        # Insert 4.
        # XXX mutation
  
        # Insert 5.
        my @ref = $$node->[0]->remove_children ($$node->[1], 'suppress');
  
        # Insert 6.
        # XXX mutation
        
        # Insert 7.
        splice @{$$parent->[2]->{child_nodes}}, $insert_position, 0, @node;
        $$parent->[0]->{revision}++;
        for my $node_id (@node) {
          $$node->[0]->{data}->[$node_id]->{parent_node} = $$parent->[1];
          $$parent->[0]->connect ($node_id => $$parent->[1]);
        }
        {
          for ($insert_position..$#{$$parent->[2]->{child_nodes}}) {
            $$node->[0]->{data}->[$$parent->[2]->{child_nodes}->[$_]]->{i_in_parent} = $_;
          }
        }
        
        # Insert 8.
        # XXX insertion steps
      } else {
        # Insert 6.
        # XXX mutation
        
        # Insert 3., 7.
        splice @{$$parent->[2]->{child_nodes}}, $insert_position, 0, $$node->[1];
        $$parent->[0]->{revision}++;
        $$node->[2]->{parent_node} = $$parent->[1];
        {
          for ($insert_position..$#{$$parent->[2]->{child_nodes}}) {
            $$node->[0]->{data}->[$$parent->[2]->{child_nodes}->[$_]]->{i_in_parent} = $_;
          }
        }
        $$parent->[0]->connect ($$node->[1] => $$parent->[1]);
  
        # Insert 8. insertion steps
        # XXX
      }
    } # insert
  
    if (defined $old_child) {
      # Replace 12.
      # XXX $nodes = $node is df ? $node->child_nodes : $node
      
      # Replace 13.
      # XXX mutation
  
      # Replace 14.
      # XXX removing steps / insertion steps
    }
  
    # Pre-insert 11. / Replace 15.
    return $node;
  } # _insert
  
  sub remove_child ($$) {
    ## WebIDL
    unless (UNIVERSAL::isa ($_[1], 'Web::DOM::Node')) {
      _throw Web::DOM::TypeError 'The argument is not a Node';
    }
  
    ## Pre-remove 1.
    my ($parent, $child) = @_;
    if ($$child->[0] ne $$parent->[0] or
        not defined $$child->[2]->{parent_node} or
        $$child->[2]->{parent_node} != $$parent->[1]) {
      _throw Web::DOM::Exception 'NotFoundError',
          'The specified node is not a child of this node';
    }
  
    ## Pre-remove 2.
    $$parent->[0]->remove_node ($$parent->[1], $$child->[1], 0);
  
    ## Pre-remove 3.
    return $child;
  } # remove_child
  
  # XXX mutators
  
  sub node_value ($;$) {
    return undef;
  } # node_value
  
  sub text_content ($;$) {
    return undef;
  } # text_content
  
  sub manakai_get_indexed_string ($) {
    return undef;
  } # manakai_get_indexed_string
  
  sub manakai_append_text ($$) {
    my $dummy = ''.$_[1];
    return $_[0];
  } # manakai_append_text
  
  sub manakai_append_indexed_string ($$) {
    # IndexedStringSegment
    _throw Web::DOM::TypeError 'The argument is not an IndexedString'
        if not ref $_[1] eq 'ARRAY' or
           grep { not ref $_ eq 'ARRAY' } @{$_[1]}; # IndexedString
    return;
  } # manakai_append_indexed_string
  
  ## Overridden by |HTMLTemplateElement|.
  sub manakai_append_content ($$) {
    if (UNIVERSAL::isa ($_[1], 'Web::DOM::Node')) {
      $_[0]->append_child ($_[1]);
    } else {
      $_[0]->manakai_append_text ($_[1]);
    }
    return undef;
  } # manakai_append_content
  
  sub normalize ($) {
    my $self = shift;
    my $int = $$self->[0];
    my $parent_id = $$self->[1];
    my @text_id;
  
    my $normalize = sub {
      my $node_id;
      while (@text_id) {
        # 1.
        $node_id = shift @text_id;
  
        # 2.-3.
        unless (grep { length $_->[0] } @{$int->{data}->[$node_id]->{data}}) { # IndexedString
          $int->remove_node ($parent_id, $node_id, 0);
          return unless @text_id;
          next;
        } else {
          last;
        }
      }
  
      # 4., 5. Replace data (simplified)
      # XXX mutation
      push @{$int->{data}->[$node_id]->{data}},
          map { @{$int->{data}->[$_]->{data}} } @text_id;
      # XXX range
  
      # 6.-7.
      # XXX range
  
      # 8.
      $int->remove_node ($parent_id, $_, 0) for @text_id;
    }; # normalize
  
    my @child_id = @{$$self->[2]->{child_nodes} or []};
    for my $node_id (@child_id) {
      my $nt = $int->{data}->[$node_id]->{node_type};
      if ($nt == TEXT_NODE) {
        push @text_id, $node_id;
      } else {
        if (@text_id) {
          $normalize->();
          @text_id = ();
        }
        $int->node ($node_id)->normalize if $nt == ELEMENT_NODE;
      }
    }
    $normalize->() if @text_id;
    return;
  } # normalize
  
  sub clone_node ($;$) {
    return $_[0]->_clone ($_[0]->owner_document || $_[0], !!$_[1]);
  } # clone_node
  
  sub _clone ($$$) {
    # 1.
    my ($node, $od, $deep) = @_;
  
    my $orig_strict_error_checking = $od->strict_error_checking;
    $od->strict_error_checking (0);
    my $orig_strict_document_children
        = $od->dom_config->{manakai_strict_document_children};
    $od->dom_config->{manakai_strict_document_children} = 0;
    my $orig_allow_doctype_children
        = $od->dom_config->{manakai_allow_doctype_children};
    $od->dom_config->{manakai_allow_doctype_children} = 1;
    
    # 2.-4.
    my $copy;
    my $nt = $node->node_type;
    if ($nt == ELEMENT_NODE) {
      $copy = $od->create_element_ns
          ($node->namespace_uri, [$node->prefix, $node->local_name]);
      for ($node->attributes->to_list) {
        $copy->set_attribute_ns
            ($_->namespace_uri, [$_->prefix, $_->local_name], $_->value);
      }
  
      # 5. Cloning steps
      my $nsurl = $node->namespace_uri || '';
      my $ln = $node->local_name;
      if ($nsurl eq HTML_NS) {
        if ($ln eq 'template') {
          if ($deep) {
            my $copy_df = $copy->content;
            my $copy_od = $copy_df->owner_document;
            for ($node->content->child_nodes->to_list) {
              $copy_df->append_child ($_->_clone ($copy_od, 1));
            }
          }
        } elsif ($ln eq 'input') {
          # XXX
        } elsif ($ln eq 'script') {
          # XXX
        }
      } elsif ($nsurl eq SVG_NS) {
        if ($ln eq 'script') {
          # XXX
        }
      }
    } elsif ($nt == TEXT_NODE) {
      $copy = $od->create_text_node ($node->data);
    } elsif ($nt == COMMENT_NODE) {
      $copy = $od->create_comment ($node->data);
    } elsif ($nt == PROCESSING_INSTRUCTION_NODE) {
      $copy = $od->create_processing_instruction ($node->target, $node->data);
    } elsif ($nt == DOCUMENT_TYPE_NODE) {
      $copy = $od->implementation->create_document_type
          ($node->name, $node->public_id, $node->system_id);
      for my $sub ($node->element_types->to_list) {
        my $copy_sub = $od->create_element_type_definition ($sub->node_name);
        for my $sub_sub ($sub->attribute_definitions->to_list) {
          my $copy_sub_sub = $od->create_attribute_definition
              ($sub_sub->node_name);
          $copy_sub_sub->node_value ($sub_sub->node_value);
          $copy_sub_sub->declared_type ($sub_sub->declared_type);
          $copy_sub_sub->default_type ($sub_sub->default_type);
          $copy_sub_sub->allowed_tokens ($sub_sub->allowed_tokens);
          $copy_sub->set_attribute_definition_node ($copy_sub_sub);
        }
        $copy->set_element_type_definition_node ($copy_sub);
      }
      for my $sub ($node->general_entities->to_list) {
        my $copy_sub = $od->create_general_entity ($sub->node_name);
        $copy_sub->public_id ($sub->public_id);
        $copy_sub->system_id ($sub->system_id);
        $copy_sub->notation_name ($sub->notation_name);
        $copy_sub->node_value ($sub->node_value);
        $copy->set_general_entity_node ($copy_sub);
      }
      for my $sub ($node->notations->to_list) {
        my $copy_sub = $od->create_notation ($sub->node_name);
        $copy_sub->public_id ($sub->public_id);
        $copy_sub->system_id ($sub->system_id);
        $copy->set_notation_node ($copy_sub);
      }
    } elsif ($nt == ATTRIBUTE_NODE) {
      $copy = $od->create_attribute_ns
          ($node->namespace_uri, [$node->prefix, $node->local_name]);
      $copy->value ($node->value);
    } elsif ($nt == DOCUMENT_NODE) {
      $od->strict_error_checking ($orig_strict_error_checking);
      $od->dom_config->{manakai_strict_document_children}
          = $orig_strict_document_children;
      $od->dom_config->{manakai_allow_doctype_children}
          = $orig_allow_doctype_children;
  
      if ($node->isa ('Web::DOM::XMLDocument')) {
        $copy = Web::DOM::Document->new->implementation->create_document;
      } else {
        $copy = Web::DOM::Document->new;
      }
      $od = $copy;
  
      $$copy->[2]->{$_} = $$node->[2]->{$_}
          for qw(content_type is_html compat_mode encoding);
      # XXX and origin
  
      $orig_strict_error_checking = $od->strict_error_checking;
      $od->strict_error_checking (0);
      $orig_strict_document_children
          = $od->dom_config->{manakai_strict_document_children};
      $od->dom_config->{manakai_strict_document_children} = 0;
      $orig_allow_doctype_children
          = $od->dom_config->{manakai_allow_doctype_children};
      $od->dom_config->{manakai_allow_doctype_children} = 1;
    } elsif ($nt == DOCUMENT_FRAGMENT_NODE) {
      $copy = $od->create_document_fragment;
    } elsif ($nt == ELEMENT_TYPE_DEFINITION_NODE) {
      $copy = $od->create_element_type_definition ($node->node_name);
      for my $sub ($node->attribute_definitions->to_list) {
        my $copy_sub = $od->create_attribute_definition ($sub->node_name);
        $copy_sub->node_value ($sub->node_value);
        $copy_sub->declared_type ($sub->declared_type);
        $copy_sub->default_type ($sub->default_type);
        $copy_sub->allowed_tokens ($sub->allowed_tokens);
        $copy->set_attribute_definition_node ($copy_sub);
      }
    } elsif ($nt == ATTRIBUTE_DEFINITION_NODE) {
      $copy = $od->create_attribute_definition ($node->node_name);
      $copy->node_value ($node->node_value);
      $copy->declared_type ($node->declared_type);
      $copy->default_type ($node->default_type);
      $copy->allowed_tokens ($node->allowed_tokens);
    } elsif ($nt == ENTITY_NODE) {
      $copy = $od->create_general_entity ($node->node_name);
      $copy->public_id ($node->public_id);
      $copy->system_id ($node->system_id);
      $copy->notation_name ($node->notation_name);
      $copy->node_value ($node->node_value);
    } elsif ($nt == NOTATION_NODE) {
      $copy = $od->create_notation ($node->node_name);
      $copy->public_id ($node->public_id);
      $copy->system_id ($node->system_id);
    } else {
      die "Unknown node type $nt";
    }
  
    # 6.
    if ($deep) {
      for ($node->child_nodes->to_list) {
        $copy->append_child ($_->_clone ($od, 1));
      }
    }
  
    $od->strict_error_checking ($orig_strict_error_checking);
    $od->dom_config->{manakai_strict_document_children}
        = $orig_strict_document_children;
    $od->dom_config->{manakai_allow_doctype_children}
        = $orig_allow_doctype_children;
  
    # 7.
    return $copy;
  } # _clone
  
  sub is_same_node ($$) {
    return 0 unless defined $_[1];
  
    # WebIDL
    unless (UNIVERSAL::isa ($_[1], 'Web::DOM::Node')) {
      _throw Web::DOM::TypeError 'The argument is not a Node';
    }
    
    return $_[0] eq $_[1];
  } # is_same_node
  
  # XXX DOMDTDEF
  sub is_equal_node ($$) {
    my ($node1, $node2) = @_;
  
    return 0 unless defined $node2;
  
    # WebIDL
    unless (UNIVERSAL::isa ($_[1], 'Web::DOM::Node')) {
      _throw Web::DOM::TypeError 'The argument is not a Node';
    }
  
    my $nt1 = $node1->node_type;
    my $nt2 = $node2->node_type;
  
    return 0 if $nt1 != $nt2;
  
    if ($nt1 == ELEMENT_NODE or $nt2 == ATTRIBUTE_NODE) {
      return 0 unless $node1->local_name eq $node2->local_name;
      my $ns1 = $node1->namespace_uri;
      my $ns2 = $node2->namespace_uri;
      return 0 if defined $ns1 and not defined $ns2;
      return 0 if not defined $ns1 and defined $ns2;
      return 0 if defined $ns1 and not $ns1 eq $ns2;
  
      if ($nt1 == ELEMENT_NODE) {
        my $prefix1 = $node1->prefix;
        my $prefix2 = $node2->prefix;
        return 0 if defined $prefix1 and not defined $prefix2;
        return 0 if not defined $prefix1 and defined $prefix2;
        return 0 if defined $prefix1 and not $prefix1 eq $prefix2;
  
        my $attrs1 = $node1->attributes->to_a;
        my $attrs2 = $node2->attributes->to_a;
        return 0 unless @$attrs1 == @$attrs2;
        my %attrs1;
        for (@$attrs1) {
          my $nsurl = $_->namespace_uri;
          $attrs1{defined $nsurl ? $nsurl : ''}->{$_->local_name} = $_->value;
        }
        for (@$attrs2) {
          my $nsurl = $_->namespace_uri;
          my $value1 = $attrs1{defined $nsurl ? $nsurl : ''}->{$_->local_name};
          return 0 unless defined $value1;
          return 0 unless $value1 eq $_->value;
        }
      } elsif ($nt1 == ATTRIBUTE_NODE) {
        return 0 unless $node1->value eq $node2->value;
      }
    } elsif ($nt1 == TEXT_NODE or $nt1 == COMMENT_NODE) {
      return 0 unless $node1->data eq $node2->data;
    } elsif ($nt1 == DOCUMENT_TYPE_NODE) {
      return 0 unless $node1->name eq $node2->name;
      return 0 unless $node1->public_id eq $node2->public_id;
      return 0 unless $node1->system_id eq $node2->system_id;
  
      for (qw(element_types general_entities notations)) {
        my $objs1 = $node1->$_->to_a;
        my $objs2 = $node2->$_->to_a;
        return 0 unless @$objs1 == @$objs2;
        my %objs1;
        for (@$objs1) {
          $objs1{$_->node_name} = $_;
        }
        for (@$objs2) {
          my $obj1 = $objs1{$_->node_name} or return 0;
          return 0 unless $obj1->is_equal_node ($_);
        }
      }
    } elsif ($nt1 == PROCESSING_INSTRUCTION_NODE) {
      return 0 unless $node1->target eq $node2->target;
      return 0 unless $node1->data eq $node2->data;
    } elsif ($nt1 == ELEMENT_TYPE_DEFINITION_NODE) {
      return 0 unless $node1->node_name eq $node2->node_name;
  
      my $objs1 = $node1->attribute_definitions->to_a;
      my $objs2 = $node2->attribute_definitions->to_a;
      return 0 unless @$objs1 == @$objs2;
      my %objs1;
      for (@$objs1) {
        $objs1{$_->node_name} = $_;
      }
      for (@$objs2) {
        my $obj1 = $objs1{$_->node_name} or return 0;
        return 0 unless $obj1->is_equal_node ($_);
      }
    } elsif ($nt1 == ATTRIBUTE_DEFINITION_NODE) {
      return 0 unless $node1->node_name eq $node2->node_name;
      return 0 unless $node1->node_value eq $node2->node_value;
      return 0 unless $node1->declared_type eq $node2->declared_type;
      return 0 unless $node1->default_type eq $node2->default_type;
      
      my $tokens1 = $node1->allowed_tokens;
      my $tokens2 = $node2->allowed_tokens;
      return 0 unless @$tokens1 == @$tokens2;
  
      my %tokens1 = map { $_ => 1 } @$tokens1;
      for (@$tokens2) {
        return 0 unless $tokens1{$_};
      }
      my %tokens2 = map { $_ => 1 } @$tokens2;
      for (@$tokens1) {
        return 0 unless $tokens2{$_};
      }
    } elsif ($nt1 == ENTITY_NODE) {
      return 0 unless $node1->node_name eq $node2->node_name;
      return 0 unless $node1->node_value eq $node2->node_value;
      return 0 unless $node1->public_id eq $node2->public_id;
      return 0 unless $node1->system_id eq $node2->system_id;
      my $nn1 = $node1->notation_name;
      my $nn2 = $node2->notation_name;
      return 0 if defined $nn1 and not defined $nn2;
      return 0 if not defined $nn1 and defined $nn2;
      return 0 if defined $nn1 and not $nn1 eq $nn2;
    } elsif ($nt1 == NOTATION_NODE) {
      return 0 unless $node1->node_name eq $node2->node_name;
      return 0 unless $node1->public_id eq $node2->public_id;
      return 0 unless $node1->system_id eq $node2->system_id;
    }
  
    my @child1 = $node1->child_nodes->to_list;
    my @child2 = $node2->child_nodes->to_list;
    return 0 unless @child1 == @child2;
    for (0..$#child1) {
      return 0 unless $child1[$_]->is_equal_node ($child2[$_]);
    }
    return 1;
  } # is_equal_node
  
  sub DOCUMENT_POSITION_DISCONNECTED () { 0x01 }
  sub DOCUMENT_POSITION_PRECEDING () { 0x02 }
  sub DOCUMENT_POSITION_FOLLOWING () { 0x04 }
  sub DOCUMENT_POSITION_CONTAINS () { 0x08 }
  sub DOCUMENT_POSITION_CONTAINED_BY () { 0x10 }
  sub DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC () { 0x20 }
  
  push @EXPORT, qw(
    DOCUMENT_POSITION_DISCONNECTED DOCUMENT_POSITION_PRECEDING
    DOCUMENT_POSITION_FOLLOWING DOCUMENT_POSITION_CONTAINS
    DOCUMENT_POSITION_CONTAINED_BY DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC
  );
  
  sub compare_document_position ($$) {
    # WebIDL
    unless (UNIVERSAL::isa ($_[1], 'Web::DOM::Node')) {
      _throw Web::DOM::TypeError 'The argument is not a Node';
    }
  
    # 1.
    my $ref = $_[0];
    my $other = $_[1];
  
    # 2.
    return 0 if $ref eq $other;
  
    # 3.
    if (not $$ref->[0] eq $$other->[0]) {
      return DOCUMENT_POSITION_DISCONNECTED |
             DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC |
             ($$ref->[0] < $$other->[0] ? DOCUMENT_POSITION_PRECEDING
                                         : DOCUMENT_POSITION_FOLLOWING);
    } elsif (not $$ref->[0]->{tree_id}->[$$ref->[1]] ==
                 $$other->[0]->{tree_id}->[$$other->[1]]) {
      return DOCUMENT_POSITION_DISCONNECTED |
             DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC |
             ($$ref->[0]->{tree_id}->[$$ref->[1]] <
              $$other->[0]->{tree_id}->[$$other->[1]]
                 ? DOCUMENT_POSITION_PRECEDING
                 : DOCUMENT_POSITION_FOLLOWING);
    }
  
    my $ref_nt = $ref->node_type;
    my $other_nt = $other->node_type;
    if ($ref_nt == $other_nt and $ref_nt == ATTRIBUTE_NODE) {
      my $ref_oe = $ref->owner_element;
      my $other_oe = $other->owner_element;
      if ($ref_oe and $other_oe and $ref_oe eq $other_oe) {
        for ($other_oe->attributes->to_list) {
          if ($_ eq $other) {
            return DOCUMENT_POSITION_PRECEDING |
                DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC;
          } elsif ($_ eq $ref) {
            return DOCUMENT_POSITION_FOLLOWING |
                DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC;
          }
        }
      }
    } elsif (($other_nt == ELEMENT_TYPE_DEFINITION_NODE or
              $other_nt == ENTITY_NODE or
              $other_nt == NOTATION_NODE) and
             ($ref_nt == ELEMENT_TYPE_DEFINITION_NODE or
              $ref_nt == ENTITY_NODE or
              $ref_nt == NOTATION_NODE)) {
      my $ref_oe = $ref->owner_document_type_definition;
      my $other_oe = $other->owner_document_type_definition;
      if ($ref_oe and $other_oe and $ref_oe eq $other_oe) {
        for ($other_oe->general_entities->to_list,
             $other_oe->notations->to_list,
             $other_oe->element_types->to_list) {
          if ($_ eq $other) {
            return DOCUMENT_POSITION_PRECEDING |
                DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC;
          } elsif ($_ eq $ref) {
            return DOCUMENT_POSITION_FOLLOWING |
                DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC;
          }
        }
      }
    } elsif ($ref_nt == $other_nt and $ref_nt == ATTRIBUTE_DEFINITION_NODE) {
      my $ref_oe = $ref->owner_element_type_definition;
      my $other_oe = $other->owner_element_type_definition;
      if ($ref_oe and $other_oe and $ref_oe eq $other_oe) {
        for ($other_oe->attribute_definitions->to_list) {
          if ($_ eq $other) {
            return DOCUMENT_POSITION_PRECEDING |
                DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC;
          } elsif ($_ eq $ref) {
            return DOCUMENT_POSITION_FOLLOWING |
                DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC;
          }
        }
      }
    }
  
    # 4.
    my @ref = ();
    my $ref_p = $ref;
    if ($ref_nt == ATTRIBUTE_NODE) {
      $ref_p = $ref_p->owner_element;
      unshift @ref, -1;
    } elsif ($ref_nt == ELEMENT_TYPE_DEFINITION_NODE or
             $ref_nt == ENTITY_NODE or
             $ref_nt == NOTATION_NODE) {
      $ref_p = $ref_p->owner_document_type_definition;
      if ($ref_p) {
        my $i = 0;
        for (reverse ($ref_p->general_entities->to_list,
                      $ref_p->notations->to_list,
                      $ref_p->element_types->to_list)) {
          $i--;
          last if $_ eq $ref;
        }
        unshift @ref, $i;
      } else {
        unshift @ref, -1;
      }
    } elsif ($ref_nt == ATTRIBUTE_DEFINITION_NODE) {
      $ref_p = $ref_p->owner_element_type_definition;
      if ($ref_p) {
        my $i = 0;
        for (reverse $ref_p->attribute_definitions->to_list) {
          $i--;
          last if $_ eq $ref;
        }
        unshift @ref, $i;
        my $ref2 = $ref_p;
        $ref_p = $ref_p->owner_document_type_definition;
        if ($ref_p) {
          my $i = 0;
          for (reverse $ref_p->element_types->to_list) {
            $i--;
            last if $_ eq $ref2;
          }
          unshift @ref, $i;
        } else {
          unshift @ref, -1;
        }
      } else {
        unshift @ref, -1;
      }
    }
    while ($ref_p and my $pn = $ref_p->parent_node) {
      my $i = 0;
      for ($pn->child_nodes->to_list) {
        last if $_ eq $ref_p;
        $i++;
      }
      unshift @ref, $i;
      $ref_p = $pn;
    }
    unshift @ref, 0;
    my @other = ();
    my $other_p = $other;
    if ($other_nt == ATTRIBUTE_NODE) {
      $other_p = $other_p->owner_element;
      unshift @other, -1;
    } elsif ($other_nt == ELEMENT_TYPE_DEFINITION_NODE or
             $other_nt == ENTITY_NODE or
             $other_nt == NOTATION_NODE) {
      $other_p = $other_p->owner_document_type_definition;
      if ($other_p) {
        my $i = 0;
        for (reverse ($other_p->general_entities->to_list,
                      $other_p->notations->to_list,
                      $other_p->element_types->to_list)) {
          $i--;
          last if $_ eq $other;
        }
        unshift @other, $i;
      } else {
        unshift @other, -1;
      }
    } elsif ($other_nt == ATTRIBUTE_DEFINITION_NODE) {
      $other_p = $other_p->owner_element_type_definition;
      if ($other_p) {
        my $i = 0;
        for (reverse $other_p->attribute_definitions->to_list) {
          $i--;
          last if $_ eq $other;
        }
        unshift @other, $i;
        my $other2 = $other_p;
        $other_p = $other_p->owner_document_type_definition;
        if ($other_p) {
          my $i = 0;
          for (reverse $other_p->element_types->to_list) {
            $i--;
            last if $_ eq $other2;
          }
          unshift @other, $i;
        } else {
          unshift @other, -1;
        }
      } else {
        unshift @other, -1;
      }
    }
    while ($other_p and my $pn = $other_p->parent_node) {
      my $i = 0;
      for ($pn->child_nodes->to_list) {
        last if $_ eq $other_p;
        $i++;
      }
      unshift @other, $i;
      $other_p = $pn;
    }
    unshift @other, 0;
  
    while (@other) {
      if ($other[0] < $ref[0]) {
        return DOCUMENT_POSITION_PRECEDING;
      } elsif ($ref[0] < $other[0]) {
        return DOCUMENT_POSITION_FOLLOWING;
      } else {
        shift @other;
        shift @ref;
        return DOCUMENT_POSITION_PRECEDING | DOCUMENT_POSITION_CONTAINS
            unless @other;
        return DOCUMENT_POSITION_FOLLOWING | DOCUMENT_POSITION_CONTAINED_BY
            unless @ref;
      }
    }
  
    die "Unknown document position";
  } # compare_document_position
  
  sub contains ($$) {
    return 0 if not defined $_[1];
  
    # WebIDL
    unless (UNIVERSAL::isa ($_[1], 'Web::DOM::Node')) {
      _throw Web::DOM::TypeError 'The argument is not a Node';
    }
  
    my $node = $_[0];
    my $other = $_[1];
    while ($other) {
      if ($node eq $other) {
        return 1;
      }
      $other = $other->parent_node;
    }
    return 0;
  } # contains
  
  sub lookup_prefix ($$) {
    my $self = $_[0];
  
    # 1.
    my $prefix = defined $_[1] ? ''.$_[1] : undef;
    if (not defined $prefix or not length $prefix) {
      return undef;
    }
  
    # 2.
    my $nt = $self->node_type;
    if ($nt == ELEMENT_NODE) {
      return $self->_locate_prefix ($prefix);
    } elsif ($nt == DOCUMENT_NODE) {
      my $de = $self->document_element;
      if ($de) {
        return $de->_locate_prefix ($prefix);
      } else {
        return undef;
      }
    } elsif ($nt == DOCUMENT_TYPE_NODE or $nt == DOCUMENT_FRAGMENT_NODE) {
      return undef;
    } elsif ($nt == ATTRIBUTE_NODE) {
      my $oe = $self->owner_element;
      if ($oe) {
        return $oe->_locate_prefix ($prefix);
      } else {
        return undef;
      }
    } else {
      my $pe = $self->parent_element;
      if ($pe) {
        return $pe->_locate_prefix ($prefix);
      } else {
        return undef;
      }
    }
  } # lookup_prefix
  
  sub _locate_prefix ($$) {
    my $self = $_[0];
    my $nsurl = $_[1];
  
    # Locate a namespace prefix
  
    # 1.
    my $node_nsurl = $self->namespace_uri;
    $node_nsurl = '' if not defined $node_nsurl;
    if ($node_nsurl eq $nsurl) {
      my $prefix = $self->prefix;
      if (defined $prefix) {
        return $prefix;
      }
    }
  
    # 2.
    for my $attr ($self->attributes->to_list) {
      if (($attr->prefix || '') eq 'xmlns' and
          $attr->value eq $nsurl) {
        my $ln = $attr->local_name;
        my $lookup_url = $self->lookup_namespace_uri ($ln);
        $lookup_url = '' unless defined $lookup_url;
        if ($lookup_url eq $nsurl) { # DOM3 vs DOM4
          return $ln;
        }
      }
    }
    
    # 3.
    my $pe = $self->parent_element;
    if ($pe) {
      return $pe->_locate_prefix ($nsurl);
    } else {
      return undef;
    }
  } # _locate_prefix
  
  sub lookup_namespace_uri ($$) {
    my $self = $_[0];
    my $prefix = defined $_[1] ? ''.$_[1] : '';
  
    # Locate a namespace
    my $nt = $self->node_type;
    if ($nt == ELEMENT_NODE) {
      # 1.
      my $nsurl = $self->namespace_uri;
      my $node_prefix = $self->prefix;
      $node_prefix = '' unless defined $node_prefix;
      if (defined $nsurl and $prefix eq $node_prefix) {
        return $nsurl;
      }
  
      # 2.
      if ($prefix eq '') {
        my $attr = $self->get_attribute_node_ns (XMLNS_NS, 'xmlns');
        if ($attr and not defined $attr->prefix) {
          # 1.-2.
          my $value = $attr->value;
          return length $value ? $value : undef;
        }
      } else {
        my $attr = $self->get_attribute_node_ns (XMLNS_NS, $prefix);
        if ($attr and ($attr->prefix || '') eq 'xmlns') {
          # 1.-2.
          my $value = $attr->value;
          return length $value ? $value : undef;
        }
      }
  
      # 3.-4.
      my $pe = $self->parent_element;
      if ($pe) {
        return $pe->lookup_namespace_uri ($prefix);
      } else {
        return undef;
      }
    } elsif ($nt == DOCUMENT_NODE) {
      # 1.-2.
      my $de = $self->document_element;
      if (defined $de) {
        return $de->lookup_namespace_uri ($prefix);
      } else {
        return undef;
      }
    } elsif ($nt == DOCUMENT_TYPE_NODE or $nt == DOCUMENT_FRAGMENT_NODE) {
      return undef;
    } elsif ($nt == ATTRIBUTE_NODE) {
      # 1.-2.
      my $oe = $self->owner_element;
      if (defined $oe) {
        return $oe->lookup_namespace_uri ($prefix);
      } else {
        return undef;
      }
    } else {
      # 1.-2.
      my $pe = $self->parent_element;
      if (defined $pe) {
        return $pe->lookup_namespace_uri ($prefix);
      } else {
        return undef;
      }
    }
  } # lookup_namespace_uri
  
  sub is_default_namespace ($$) {
    # 2.
    my $default = $_[0]->lookup_namespace_uri (undef);
  
    # 1., 3.
    my $nsurl = defined $_[1] ? ''.$_[1] : '';
    if (defined $default and length $nsurl and $default eq $nsurl) {
      return 1;
    } elsif (not defined $default and $nsurl eq '') {
      return 1;
    } else {
      return 0;
    }
  } # is_default_namespace
  
  sub manakai_get_child_namespace_uri ($) {
    my $self = $_[0];
    if ($$self->[0]->{data}->[0]->{is_html}) {
      my $tag_name = defined $_[1] ? $_[1] : '';
      $tag_name =~ tr/A-Z/a-z/; ## ASCII case-insensitive.
  
      require Web::HTML::ParserData;
      my $ns = $self->namespace_uri;
      my $ln = $self->local_name;
      if (not defined $ln or not defined $ns) {
        #
      } elsif ($ns eq SVG_NS) {
        if ($Web::HTML::ParserData::SVGHTMLIntegrationPoints->{$ln}) {
          #
        } else {
          return $ns;
        }
      } elsif ($ns eq MML_NS) {
        if ($Web::HTML::ParserData::MathMLTextIntegrationPoints->{$ln}) {
          return MML_NS if $tag_name eq 'mglyph' or $tag_name eq 'malignmark';
        } elsif ($ln eq 'annotation-xml') {
          return SVG_NS if $tag_name eq 'svg';
          my $encoding = $self->get_attribute_ns (undef, 'encoding') || '';
          $encoding =~ tr/A-Z/a-z/; ## ASCII case-insensitive.
          unless ($encoding eq 'text/html' or $encoding eq 'application/xhtml+xml') {
            return $ns;
          }
        } elsif ($Web::HTML::ParserData::MathMLHTMLIntegrationPoints->{$ln}) {
          #
        } else {
          return $ns;
        }
      } # $ns
  
      if ($tag_name eq 'svg') {
        return SVG_NS;
      } elsif ($tag_name eq 'math') {
        return MML_NS;
      } else {
        return HTML_NS;
      }
    } else {
      my $prefix = defined $_[1] ? ''.$_[1] : undef;
      if (defined $_[1] and $prefix =~ /:/) {
        $prefix =~ s/:.*//gs;
        if ($prefix eq '') {
          return undef;
        } else {
          return $self->lookup_namespace_uri ($prefix);
        }
      } else {
        return $self->lookup_namespace_uri (undef);
      }
    }
  } # manakai_get_child_namespace_uri
  
  sub is_supported ($$;$) {
    return 1;
  } # is_supported
  
  sub manakai_get_source_location ($) {
    my $data = ${$_[0]}->[2];
    if (defined $data->{source_di}) {
      return ['', $data->{source_di}, $data->{source_index} || 0]; # IndexedStringSegment
    } elsif (defined $data->{data} and @{$data->{data}}) { # IndexedString
      my $first_segment = $data->{data}->[0];
      return ['', $first_segment->[1], $first_segment->[2]]; # IndexedStringSegment
    } else {
      return ['', -1, 0]; # IndexedStringSegment
    }
  } # manakai_get_source_location
  
  sub manakai_set_source_location ($$) {
    my $data = ${$_[0]}->[2];
    if (not defined $_[1]) {
      delete $data->{source_di};
      delete $data->{source_index};
    } elsif (ref $_[1] eq 'ARRAY') { # IndexedStringSegment
      my $dummy = ''.$_[1]->[0]; # DOMPERL
      $data->{source_di} = 0+$_[1]->[1];
      $data->{source_index} = 0+$_[1]->[2];
    } else {
      _throw Web::DOM::TypeError 'The argument is not an IndexedStringSegment';
    }
    return;
  } # manakai_set_source_location
  
  sub get_user_data ($$) {
    return ${$_[0]}->[2]->{user_data}->{$_[1]};
  } # get_user_data
  
  sub set_user_data ($$;$$) {
    if (defined $_[3]) {
      _throw Web::DOM::Exception 'NotSupportedError',
          'UserDataHandler is not supported';
    }
    if (defined $_[2]) {
      ${$_[0]}->[2]->{user_data}->{$_[1]} = $_[2];
    } else {
      delete ${$_[0]}->[2]->{user_data}->{$_[1]};
    }
    return;
  } # set_user_data
  
  # XXX manakai_language manakai_html_language
  
  ## Return [@{$parent_node_if_any->_tree_node_indexes}, /index/] where
  ## /index/ is the index of the node in the parent's child node list.
  ## If the node has no parent, /index/ is zero.
  ##
  ## Used by: |Web::HTML::Microdata| (XXX and possibly,
  ## |Web::XPath::Evaluator|).
  sub _tree_node_indexes ($) {
    my $n = $_[0];
    my $r = [];
    while (defined $n) {
      unless (defined $$n->[2]->{i_in_parent}) {
        unshift @$r, 0;
        return $r;
      }
      unshift @$r, $$n->[2]->{i_in_parent};
      $n = $n->parent_node;
    }
    die;
  } # _tree_node_indexes
  
  sub DESTROY ($) {
    ${$_[0]}->[0]->gc (${$_[0]}->[1]);
  } # DESTROY
  
  1;
  
  =head1 LICENSE
  
  Copyright 2007-2016 Wakaba <wakaba@suikawiki.org>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
WEB_DOM_NODE

$fatpacked{"Web/DOM/NodeList.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WEB_DOM_NODELIST';
  package Web::DOM::NodeList;
  use strict;
  use warnings;
  use Web::DOM::Collection;
  push our @ISA, qw(Web::DOM::Collection);
  our $VERSION = '1.0';
  
  1;
  
  =head1 LICENSE
  
  Copyright 2012-2013 Wakaba <wakaba@suikawiki.org>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
WEB_DOM_NODELIST

$fatpacked{"Web/DOM/ParentNode.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WEB_DOM_PARENTNODE';
  package Web::DOM::ParentNode;
  use strict;
  use warnings;
  our $VERSION = '5.0';
  use Web::DOM::Node;
  use Web::DOM::Internal;
  push our @CARP_NOT, qw(
    Web::DOM::TypeError Web::DOM::Exception
    Web::XML::Parser Web::HTML::Parser
    Web::HTML::Serializer Web::XML::Serializer
  );
  use Web::DOM::TypeError;
  use Web::DOM::Exception;
  
  sub get_elements_by_tag_name ($$) {
    my $self = $_[0];
    my $ln = ''.$_[1];
    return $$self->[0]->collection (['by_tag_name', $$self->[0]->{data}->[0]->{is_html}, $ln], $self, sub {
      my $node = $_[0];
      my $ln2 = $ln;
      my $is_html = $$self->[0]->{data}->[0]->{is_html};
      $ln2 =~ tr/A-Z/a-z/ if $is_html; ## ASCII lowercase.
      my $data = $$node->[0]->{data};
      my @node_id = @{$data->[$$node->[1]]->{child_nodes} or []};
      my @id;
      while (@node_id) {
        my $id = shift @node_id;
        next unless $data->[$id]->{node_type} == ELEMENT_NODE;
        unshift @node_id, @{$data->[$id]->{child_nodes} or []};
        my $qn = (defined $data->[$id]->{prefix}
                      ? ${$data->[$id]->{prefix}} . ':'
                      : '').${$data->[$id]->{local_name}};
        next unless $ln eq '*' or
            ($qn eq $ln2 and
             ${$data->[$id]->{namespace_uri} || \''} eq HTML_NS) or
            ($qn eq $ln and
             (not $is_html or ${$data->[$id]->{namespace_uri} || \''} ne HTML_NS));
        push @id, $id;
      }
      return @id;
    });
  } # get_elements_by_tag_name
  
  sub get_elements_by_tag_name_ns ($$$) {
    my $self = $_[0];
    my $ns = defined $_[1] ? ''.$_[1] : '';
    my $ln = ''.$_[2];
  
    # 1. 
    undef $ns if $ns eq '';
  
    return $$self->[0]->collection (['by_tag_name_ns', $ns, $ln], $self, sub {
      my $node = $_[0];
      my $data = $$node->[0]->{data};
      my @node_id = @{$data->[$$node->[1]]->{child_nodes} or []};
      my @id;
      while (@node_id) {
        my $id = shift @node_id;
        next unless $data->[$id]->{node_type} == ELEMENT_NODE;
        unshift @node_id, @{$data->[$id]->{child_nodes} or []};
        next unless ($ln eq '*' or ${$data->[$id]->{local_name}} eq $ln) and
            ((not defined $ns and not defined $data->[$id]->{namespace_uri}) or
             (defined $ns and $ns eq '*') or
             (defined $ns and ${$data->[$id]->{namespace_uri} || \''} eq $ns));
        push @id, $id;
      }
      return @id;
    });
  } # get_elements_by_tag_name_ns
  
  sub get_elements_by_class_name ($$) {
    my $self = $_[0];
    my $cns = ''.$_[1];
  
    # 1.
    my $classes = {map { $_ => 1 } grep { length $_ } split /[\x09\x0A\x0C\x0D\x20]+/, $cns};
  
    # 2.
    unless (keys %$classes) {
      return $$self->[0]->collection ('by_class_name'. $; . $cns, $self, sub {
        return ();
      });
    }
  
    # 3.
    return $$self->[0]->collection (['by_class_name', $cns], $self, sub {
      my $node = $_[0];
      my $is_quirks = (${$_[0]}->[0]->{data}->[0]->{compat_mode} || '') eq 'quirks';
      my %class = $is_quirks ? (map { my $v = $_; $v =~ tr/A-Z/a-z/; $v => 1; } keys %$classes) : %$classes;
  
      my $data = $$node->[0]->{data};
      my @node_id = @{$data->[$$node->[1]]->{child_nodes} or []};
      my @id;
      while (@node_id) {
        my $id = shift @node_id;
        next unless $data->[$id]->{node_type} == ELEMENT_NODE;
        unshift @node_id, @{$data->[$id]->{child_nodes} or []};
        my $found = {};
        if ($is_quirks) {
          for (@{$data->[$id]->{class_list} || []}) {
            my $v = $_;
            $v =~ tr/A-Z/a-z/; ## ASCII case-insensitive.
            $found->{$v} = 1 if $class{$v};
          }
        } else {
          for (@{$data->[$id]->{class_list} || []}) {
            $found->{$_} = 1 if $class{$_};
          }
        }
        next unless keys %$found == keys %class;
        push @id, $id;
      }
      return @id;
    });
  } # get_elements_by_class_name
  
  sub query_selector ($$;$) {
    my $sels = ''.$_[1];
    my $resolver = $_[2];
    if (defined $resolver and not ref $resolver eq 'CODE') {
      unless (UNIVERSAL::isa ($resolver, 'Web::DOM::XPathNSResolver')) {
        _throw Web::DOM::TypeError
            'The second argument is not an XPathNSResolver';
      }
      my $obj = $resolver;
      $resolver = sub { $obj->lookup_namespace_uri ($_[1]) }; # or throw
    }
    require Web::CSS::Selectors::API;
    my $api = Web::CSS::Selectors::API->new;
    $api->is_html (${$_[0]}->[0]->{data}->[0]->{is_html});
    $api->root_node ($_[0]);
    $api->set_selectors ($sels, $resolver, nsresolver => 1);
    if (not defined $api->selectors) {
      my $prefix = $api->selectors_has_ns_error;
      if (defined $prefix) {
        _throw Web::DOM::Exception 'NamespaceError',
            'The specified selectors has unresolvable namespace prefix |' . $prefix . '|';
      } else {
        _throw Web::DOM::Exception 'SyntaxError',
            'The specified selectors has syntax error';
      }
    }
    return $api->get_elements; # or undef
  } # query_selector
  
  sub query_selector_all ($$;$) {
    my $sels = ''.$_[1];
    my $resolver = $_[2];
    if (defined $resolver and not ref $resolver eq 'CODE') {
      unless (UNIVERSAL::isa ($resolver, 'Web::DOM::XPathNSResolver')) {
        _throw Web::DOM::TypeError
            'The second argument is not an XPathNSResolver';
      }
      my $obj = $resolver;
      $resolver = sub { $obj->lookup_namespace_uri ($_[1]) }; # or throw
    }
    require Web::CSS::Selectors::API;
    my $api = Web::CSS::Selectors::API->new;
    $api->is_html (${$_[0]}->[0]->{data}->[0]->{is_html});
    $api->root_node ($_[0]);
    $api->return_all (1);
    $api->set_selectors ($sels, $resolver, nsresolver => 1);
    if (not defined $api->selectors) {
      my $prefix = $api->selectors_has_ns_error;
      if (defined $prefix) {
        _throw Web::DOM::Exception 'NamespaceError',
            'The specified selectors has unresolvable namespace prefix |' . $prefix . '|';
      } else {
        _throw Web::DOM::Exception 'SyntaxError',
            'The specified selectors has syntax error';
      }
    }
  
    # 0, 3 - Keys for comparison
    # 1 - Items
    # 2 - Unused
    require Web::DOM::StaticNodeList;
    return bless \[''.$_[0], $api->get_elements, undef, ''.$api],
        'Web::DOM::StaticNodeList';
  } # query_selector_all
  
  sub get_items ($;$) {
    my $self = $_[0];
  
    ## Top-level microdata items
    my $nodes = [];
    my @cand = ($self);
    while (@cand) {
      my $node = shift @cand;
      if ($node->node_type == ELEMENT_NODE and
          ($node->namespace_uri || '') eq HTML_NS and
          $node->has_attribute_ns (undef, 'itemscope') and
          not $node->has_attribute_ns (undef, 'itemprop')) {
        push @$nodes, $node;
      }
      unshift @cand, @{$node->child_nodes};
    }
  
    my $types = [grep { length } split /[\x09\x0A\x0C\x0D\x20]+/, defined $_[1] ? ''.$_[1] : ''];
    my $result = $nodes;
    if (@$types) {
      $result = [];
      NODE: for my $node (@$nodes) {
        for my $type (@$types) {
          next NODE unless $node->itemtype->contains ($type);
        }
        push @$result, $node;
      }
    }
  
    # 0, 3 - Keys for comparison
    # 1 - Items
    # 2 - Unused
    require Web::DOM::StaticNodeList;
    return bless \[''.$_[0], $result, undef, ''.$nodes],
        'Web::DOM::StaticNodeList';
  } # get_items
  
  sub text_content ($;$) {
    if (@_ > 1) {
      my $self = $_[0];
  
      # 1.-2.
      my $node;
      my $text = defined $_[1] ? ''.$_[1] : '';
      $node = ($self->owner_document || $self)->create_text_node ($text)
          if length $text;
      my $int = $$self->[0];
  
      # 3. Replace all
      my @replaced;
      {
        # Replace 1.
        # adopt
  
        # Replace 2. Remove
        @replaced = $$self->[0]->remove_children ($$self->[1], 'suppress');
  
        # Replace 3. Insert (simplified)
        if (defined $node) {
          # XXX range
          $$node->[2]->{parent_node} = $$self->[1];
          $$node->[2]->{i_in_parent} = 0;
          @{$$self->[2]->{child_nodes} ||= []} = ($$node->[1]);
          $int->connect ($$node->[1] => $$self->[1]);
          #$int->{revision}++; # redundant
        }
      }
  
      # 4.-5.
      # XXXmutation
  
      # 6.
      $int->{revision}++;
      # XXX removing steps
  
      return unless defined wantarray;
    } # setter
  
    my @text;
    my @node = $_[0]->child_nodes->to_list;
    while (@node) {
      my $node = shift @node;
      my $nt = $node->node_type;
      if ($nt == TEXT_NODE) {
        push @text, $node;
      } elsif ($nt == ELEMENT_NODE) {
        unshift @node, $node->child_nodes->to_list;
      }
    }
    return join '', map { $_->data } @text;
  } # text_content
  
  sub manakai_get_indexed_string ($) {
    my @text = ($_[0]->manakai_get_source_location); # IndexedString
    my @node = $_[0]->child_nodes->to_list;
    while (@node) {
      my $node = shift @node;
      my $nt = $node->node_type;
      if ($nt == TEXT_NODE) {
        push @text, @{$node->manakai_get_indexed_string};
      } elsif ($nt == ELEMENT_NODE) {
        unshift @node, $node->child_nodes->to_list;
      }
    }
    return \@text; # IndexedString
  } # manakai_get_indexed_string
  
  ## See also |Web::DOM::Document::manakai_append_text|.
  sub manakai_append_text ($$) {
    my $self = $_[0];
  
    # IndexedStringSegment
    my $segment = [ref $_[1] eq 'SCALAR' ? ${$_[1]} : $_[1], -1, 0];
    $segment->[0] = ''.$segment->[0] if ref $segment->[0];
  
    return $self unless length $segment->[0];
  
    my $int = $$self->[0];
    my $last_child_id = $$self->[2]->{child_nodes}->[-1];
  
    if (defined $last_child_id and
        $int->{data}->[$last_child_id]->{node_type} == TEXT_NODE) {
      push @{$int->{data}->[$last_child_id]->{data}}, $segment; # IndexedString
      # XXX MutationObserver
    } else {
      my $data = {node_type => TEXT_NODE, data => [$segment]}; # IndexedString
      my $id = $int->add_data ($data);
  
      ## Pre-insert (simplified)
      {
        ## 1. Check validity
        #
        
        ## 4. Adopt
        #
  
        ## 2., 3., 5. Insert (simplified)
        {
          ## 1.-2.
          # XXX range
  
          ## 4.-5. If document fragment
          #
  
          ## 6.
          # XXX mutation
          
          ## 3., 7.
          push @{$$self->[2]->{child_nodes}}, $id;
          $int->{revision}++;
          $data->{parent_node} = $$self->[1];
          $data->{i_in_parent} = $#{$$self->[2]->{child_nodes}};
          $$self->[0]->connect ($id => $$self->[1]);
  
          ## 8. insertion steps
          # XXX
        } # insert
  
        ## 6.
        # return
      } # pre-insert
    } # no last child text node
    return $self;
  } # manakai_append_text
  
  ## See also |Web::DOM::Document::manakai_append_indexed_string|.
  sub manakai_append_indexed_string ($$) {
    my $self = $_[0];
  
    # IndexedStringSegment
    _throw Web::DOM::TypeError 'The argument is not an IndexedString'
        if not ref $_[1] eq 'ARRAY' or
           grep { not ref $_ eq 'ARRAY' } @{$_[1]}; # IndexedString
  
    my $int = $$self->[0];
    my $last_child_id = $$self->[2]->{child_nodes}->[-1];
  
    if (defined $last_child_id and
        $int->{data}->[$last_child_id]->{node_type} == TEXT_NODE) {
      push @{$int->{data}->[$last_child_id]->{data}}, map {
        [''.$_->[0], 0+$_->[1], 0+$_->[2]]; # string copy
      } @{$_[1]}; # IndexedString
      # XXX MutationObserver
    } else {
      LENGTH: {
        for (@{$_[1]}) {
          last LENGTH if length $_->[0];
        }
        return;
      }
  
      my $data = {node_type => TEXT_NODE, data => [map {
        [''.$_->[0], 0+$_->[1], 0+$_->[2]]; # string copy
      } @{$_[1]}]}; # IndexedString
      my $id = $int->add_data ($data);
  
      ## Pre-insert (simplified)
      {
        ## 1. Check validity
        #
        
        ## 4. Adopt
        #
  
        ## 2., 3., 5. Insert (simplified)
        {
          ## 1.-2.
          # XXX range
  
          ## 4.-5. If document fragment
          #
  
          ## 6.
          # XXX mutation
          
          ## 3., 7.
          push @{$$self->[2]->{child_nodes}}, $id;
          $int->{revision}++;
          $data->{parent_node} = $$self->[1];
          $data->{i_in_parent} = $#{$$self->[2]->{child_nodes}};
          $$self->[0]->connect ($id => $$self->[1]);
  
          ## 8. insertion steps
          # XXX
        } # insert
  
        ## 6.
        # return
      } # pre-insert
    } # no last child text node
    return;
  } # manakai_append_indexed_string
  
  sub children ($) {
    my $self = shift;
    return $$self->[0]->collection ('children', $self, sub {
      my $node = $_[0];
      return grep {
        $$node->[0]->{data}->[$_]->{node_type} == ELEMENT_NODE;
      } @{$$node->[0]->{data}->[$$node->[1]]->{child_nodes} or []};
    });
  } # children
  
  sub first_element_child ($) {
    my $self = shift;
    for (@{$$self->[2]->{child_nodes}}) {
      if ($$self->[0]->{data}->[$_]->{node_type} == ELEMENT_NODE) {
        return $$self->[0]->node ($_);
      }
    }
    return undef;
  } # first_element_child
  
  sub last_element_child ($) {
    my $self = shift;
    for (reverse @{$$self->[2]->{child_nodes}}) {
      if ($$self->[0]->{data}->[$_]->{node_type} == ELEMENT_NODE) {
        return $$self->[0]->node ($_);
      }
    }
    return undef;
  } # last_element_child
  
  sub child_element_count ($) {
    my $self = shift;
    my @el = grep {
      $$self->[0]->{data}->[$_]->{node_type} == ELEMENT_NODE;
    } @{$$self->[2]->{child_nodes}};
    return scalar @el;
  } # child_element_count
  
  # XXX prepend append
  
  sub inner_html ($;$) {
    ## See also: Element->outer_html, Element->insert_adjacent_html
    my $self = $_[0];
    if (@_ > 1) {
      ## For elements:
      ##   - <https://domparsing.spec.whatwg.org/#innerhtml>
      ##   - <https://domparsing.spec.whatwg.org/#parsing>
      ## For documents:
      ##   - <https://html5.org/tools/web-apps-tracker?from=6531&to=6532>
      ##   - <https://github.com/whatwg/domparsing/commit/59301cd77d4badbe16489087132a35621a2d460c>
      ## For document fragments:
      ##   - <https://suika.suikawiki.org/~wakaba/wiki/sw/n/manakai++DOM%20Extensions#anchor-143>
      
      my $parser;
      if ($$self->[0]->{data}->[0]->{is_html}) {
        require Web::HTML::Parser;
        $parser = Web::HTML::Parser->new;
      } else {
        require Web::XML::Parser;
        $parser = Web::XML::Parser->new;
        my $orig_onerror = $parser->onerror;
        $parser->onerror (sub {
          my %args = @_;
          $orig_onerror->(@_);
          if (($args{level} || 'm') eq 'm') {
            $parser->throw (sub {
              undef $parser;
              _throw Web::DOM::Exception 'SyntaxError',
                  'The given string is ill-formed as XML';
            });
          }
        });
      }
      # XXX errors should be redirected to the Console object.
      my $nt = $self->node_type;
      my $context =
          $nt == ELEMENT_NODE ? $self :
          $nt == DOCUMENT_NODE ? undef :
          $self->owner_document->create_element_ns (HTML_NS, 'body');
      my $new_children = $parser->parse_char_string_with_context
          (defined $_[1] ? ''.$_[1] : '', $context, new Web::DOM::Document);
  
      if ($nt == DOCUMENT_NODE) {
        # XXX If the document has an active parser, abort the parser.
      }
  
      # XXX mutation, ranges
      my $parent = ($self->node_type == ELEMENT_NODE and
                    $self->manakai_element_type_match (HTML_NS, 'template'))
          ? $self->content : $self;
      for ($parent->child_nodes->to_list) {
        $parent->remove_child ($_);
      }
      $parent->append_child ($_) for $new_children->to_list;
  
      return unless defined wantarray;
    }
  
    if ($$self->[0]->{data}->[0]->{is_html}) {
      require Web::HTML::Serializer;
      return ${ Web::HTML::Serializer->new->get_inner_html ($self) };
    } else {
      require Web::XML::Serializer;
      return ${ Web::XML::Serializer->new->get_inner_html ($self) };
    }
  } # inner_html
  
  1;
  
  =head1 LICENSE
  
  Copyright 2012-2019 Wakaba <wakaba@suikawiki.org>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
WEB_DOM_PARENTNODE

$fatpacked{"Web/DOM/Text.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WEB_DOM_TEXT';
  package Web::DOM::Text;
  use strict;
  use warnings;
  our $VERSION = '2.0';
  use Web::DOM::CharacterData;
  push our @ISA, qw(Web::DOM::CharacterData);
  use Web::DOM::Internal;
  use Web::DOM::Node;
  use Web::DOM::Exception;
  
  # XXX Constructor Slotable
  
  sub node_name ($) {
    return '#text';
  } # node_name
  
  sub split_text ($$) {
    my $node = $_[0];
    my $offset = _idl_unsigned_long $_[1];
  
    # Split
  
    # 1.
    my $length = $node->length;
  
    # 2.
    if ($length < $offset) {
      _throw Web::DOM::Exception 'IndexSizeError',
          'Offset is greater than the length';
    }
  
    # 3.-5.
    my $new_node = $node->owner_document->create_text_node
        ($node->substring_data ($offset, $length - $offset));
  
    # 6.
    my $parent = $node->parent_node;
  
    # 7.
    if (defined $parent) {
      # 1.
      $parent->insert_before ($new_node, $node->next_sibling);
  
      # 2.-5.
      # XXX range
    }
  
    # 8.
    $node->replace_data ($offset, $length - $offset, '');
    
    # 9.
    if (not defined $parent) {
      # 1.-2.
      # XXX range
    }
  
    # 10.
    return $new_node;
  } # split_text
  
  sub whole_text ($) {
    my $self = shift;
    my $parent = $self->parent_node or return $self->data;
    my $found;
    my @text;
    for my $node ($parent->child_nodes->to_list) {
      if ($node->node_type == TEXT_NODE) {
        push @text, $node;
        $found = 1 if $node eq $self;
      } else {
        if ($found and @text) {
          return join '', map { $_->data } @text;
        }
        @text = ();
      }
    }
    if ($found and @text) {
      return join '', map { $_->data } @text;
    }
    die "The node not found...";
  } # whole_text
  
  sub serialize_as_cdata ($;$) {
    if (@_ > 1) {
      if ($_[1]) {
        ${$_[0]}->[2]->{serialize_as_cdata} = 1;
      } else {
        delete ${$_[0]}->[2]->{serialize_as_cdata};
      }
    }
    return ${$_[0]}->[2]->{serialize_as_cdata};
  } # serialize_as_cdata
  
  1;
  
  =head1 LICENSE
  
  Copyright 2012-2016 Wakaba <wakaba@suikawiki.org>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
WEB_DOM_TEXT

$fatpacked{"Web/DOM/TypeError.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WEB_DOM_TYPEERROR';
  package Web::DOM::TypeError;
  use strict;
  use warnings;
  use Web::DOM::Error;
  push our @ISA, qw(Web::DOM::Error);
  our $VERSION = '2.0';
  
  $Web::DOM::Error::L1ObjectClass->{(__PACKAGE__)} = 1;
  
  sub new ($$) {
    my $self = bless {name => 'TypeError',
                      message => defined $_[1] ? ''.$_[1] : ''}, $_[0];
    $self->_set_stacktrace;
    return $self;
  } # new
  
  sub _throw ($$) {
    die $_[0]->new ($_[1]);
  } # _throw
  
  1;
  
  =head1 LICENSE
  
  Copyright 2012-2017 Wakaba <wakaba@suikawiki.org>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
WEB_DOM_TYPEERROR

$fatpacked{"Web/DOM/XPathEvaluator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WEB_DOM_XPATHEVALUATOR';
  package Web::DOM::XPathEvaluator;
  use strict;
  use warnings;
  our $VERSION = '2.0';
  use Web::DOM::Internal;
  use Web::DOM::TypeError;
  use Web::DOM::Exception;
  push our @CARP_NOT, qw(Web::DOM::TypeError Web::DOM::Exception);
  
  sub new ($) {
    return bless {}, $_[0];
  } # new
  
  sub create_expression ($$;$) {
    my $expr = ''.$_[1];
    my $resolver = sub { undef };
    if (not defined $_[2]) {
      #
    } elsif (ref $_[2] eq 'CODE') {
      my $code = $_[2];
      $resolver = sub {
        my $prefix = $_[0];
        my $url = eval { $code->($code, $prefix) };
        if ($@) { warn $@ } # XXX error reporting
        return defined $url ? ''.$url : undef;
      };
    } else {
      unless (UNIVERSAL::isa ($_[2], 'Web::DOM::XPathNSResolver')) {
        _throw Web::DOM::TypeError
            'The second argument is not an XPathNSResolver';
      }
      my $obj = $_[2];
      $resolver = sub {
        my $prefix = $_[0];
        return $obj->lookup_namespace_uri ($prefix); # or undef
      };
    }
  
    require Web::XPath::Parser;
    my $parser = Web::XPath::Parser->new;
    $parser->ns_resolver ($resolver);
    my $ns_error;
    my $onerror = $parser->onerror;
    $parser->onerror (sub {
      my %args = @_;
      $ns_error = $args{value} if $args{type} eq 'namespace prefix:not declared';
      $onerror->(%args);
    });
    my $parsed = $parser->parse_char_string_as_expression ($expr);
    if (defined $parsed) {
      require Web::DOM::XPathExpression;
      return bless \$parsed, 'Web::DOM::XPathExpression';
    } elsif (defined $ns_error) {
      _throw Web::DOM::Exception 'NamespaceError',
          'The specified expression has unresolvable namespace prefix |' . $ns_error . '|';
    } else {
      _throw Web::DOM::Exception 'SyntaxError',
          'The specified expression is syntactically invalid';
    }
  } # create_expression
  
  sub create_ns_resolver ($$) {
    # WebIDL
    unless (UNIVERSAL::isa ($_[1], 'Web::DOM::Node')) {
      _throw Web::DOM::TypeError 'The argument is not a Node';
    }
  
    require Web::DOM::XPathNSResolver;
    return bless \($_[1]), 'Web::DOM::XPathNSResolver';
  } # create_ns_resolver
  
  sub evaluate ($$$;$$$) {
    # WebIDL
    my $expr = ''.$_[1];
    unless (UNIVERSAL::isa ($_[2], 'Web::DOM::Node')) {
      _throw Web::DOM::TypeError 'The second argument is not a Node';
    }
    if (defined $_[3] and ref $_[3] ne 'CODE') {
      unless (UNIVERSAL::isa ($_[3], 'Web::DOM::XPathNSResolver')) {
        _throw Web::DOM::TypeError
            'The third argument is not an XPathNSResolver';
      }
    }
    my $type = _idl_unsigned_short (defined $_[4] ? $_[4] : 0);
    if (defined $_[5] and (not ref $_[5] or not UNIVERSAL::can ($_[5], 'isa'))) { # WebIDL object?
      _throw Web::DOM::TypeError 'The fifth argument is not an object';
    }
  
    $expr = $_[0]->create_expression ($expr, $_[3]); # or exception
    return $expr->evaluate ($_[2], $type, $_[5]); # or exception
  } # evaluate
  
  1;
  
  =head1 LICENSE
  
  Copyright 2013-2016 Wakaba <wakaba@suikawiki.org>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
WEB_DOM_XPATHEVALUATOR

$fatpacked{"Web/DOM/_CharClasses.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WEB_DOM__CHARCLASSES';
  package Web::DOM::Internal;
  sub InNameStartChar () { q{003A
  0041	005A
  005F
  0061	007A
  00C0	00D6
  00D8	00F6
  00F8	02FF
  0370	037D
  037F	1FFF
  200C	200D
  2070	218F
  2C00	2FEF
  3001	D7FF
  F900	FDCF
  FDF0	FFFD
  10000	EFFFF} }
  sub InNameChar () { q{002D	002E
  0030	003A
  0041	005A
  005F
  0061	007A
  00B7
  00C0	00D6
  00D8	00F6
  00F8	037D
  037F	1FFF
  200C	200D
  203F	2040
  2070	218F
  2C00	2FEF
  3001	D7FF
  F900	FDCF
  FDF0	FFFD
  10000	EFFFF} }
  sub InNCNameStartChar () { q{0041	005A
  005F
  0061	007A
  00C0	00D6
  00D8	00F6
  00F8	02FF
  0370	037D
  037F	1FFF
  200C	200D
  2070	218F
  2C00	2FEF
  3001	D7FF
  F900	FDCF
  FDF0	FFFD
  10000	EFFFF} }
  sub InNCNameChar () { q{002D	002E
  0030	0039
  0041	005A
  005F
  0061	007A
  00B7
  00C0	00D6
  00D8	00F6
  00F8	037D
  037F	1FFF
  200C	200D
  203F	2040
  2070	218F
  2C00	2FEF
  3001	D7FF
  F900	FDCF
  FDF0	FFFD
  10000	EFFFF} }
  sub InPCENChar () { q{002D	002E
  0030	0039
  005F
  0061	007A
  00B7
  00C0	00D6
  00D8	00F6
  00F8	037D
  037F	1FFF
  200C	200D
  203F	2040
  2070	218F
  2C00	2FEF
  3001	D7FF
  F900	FDCF
  FDF0	FFFD
  10000	EFFFF} }
  1;
WEB_DOM__CHARCLASSES

$fatpacked{"Web/DOM/_Defs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WEB_DOM__DEFS';
  $Web::DOM::_Defs = {
            'all_named' => {
                             'http://www.w3.org/1999/xhtml' => {
                                                                 'a' => 1,
                                                                 'button' => 1,
                                                                 'embed' => 1,
                                                                 'form' => 1,
                                                                 'frame' => 1,
                                                                 'frameset' => 1,
                                                                 'iframe' => 1,
                                                                 'img' => 1,
                                                                 'input' => 1,
                                                                 'map' => 1,
                                                                 'meta' => 1,
                                                                 'object' => 1,
                                                                 'select' => 1,
                                                                 'textarea' => 1
                                                               }
                           },
            'legacy_event' => {
                                'animationend' => 'webkitAnimationEnd',
                                'animationiteration' => 'webkitAnimationIteration',
                                'animationstart' => 'webkitAnimationStart',
                                'transitionend' => 'webkitTransitionEnd'
                              }
          };
  1;
WEB_DOM__DEFS

$fatpacked{"Web/Encoding.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WEB_ENCODING';
  package Web::Encoding;
  use strict;
  use warnings;
  no warnings 'utf8';
  our $VERSION = '8.0';
  use Carp;
  use Web::Encoding::_Defs;
  use Web::Encoding::Decoder;
  
  our @EXPORT = qw(
    encode_web_utf8
    decode_web_utf8
    decode_web_utf8_no_bom
    encode_web_charset
    decode_web_charset
    is_ascii_compat_charset_name
    encoding_names
  );
  
  sub import ($;@) {
    my $from_class = shift;
    my ($to_class, $file, $line) = caller;
    no strict 'refs';
    for (@_ ? @_ : @{$from_class . '::EXPORT'}) {
      my $code = $from_class->can ($_)
          or croak qq{"$_" is not exported by the $from_class module at $file line $line};
      *{$to_class . '::' . $_} = $code;
    }
  } # import
  
  sub encode_web_utf8 ($) {
    if (not defined $_[0]) {
      carp "Use of uninitialized value in subroutine entry";
      return '';
    } else {
      my $x = $_[0];
      if (utf8::is_utf8 $x) {
        $x =~ s/[^\x00-\x{D7FF}\x{E000}-\x{10FFFF}]/\x{FFFD}/g;
      } else {
        utf8::upgrade $x;
      }
      utf8::encode $x;
      return $x;
    }
  } # encode_web_utf8
  
  sub _decode8 ($$$;$$) {
    # $states, $x, $final, $index_offset, $onerror
    my $x = defined $_[0]->{lead} ? (delete $_[0]->{lead}) . $_[1] : $_[1]; # string copy!
    my $pos_offset = 0;
    pos ($x) = 0;
    my $xlength = length $x;
    while (pos ($x) < $xlength) {
      if ($x =~ /\G[\x00-\x7F]+/gc) {
        #
      } elsif ($x =~ m{\G(?:[\xC2-\xDF][\x80-\xBF])+}gc) {
        #
      } elsif ($x =~ m{\G(?:\xE0[\xA0-\xBF][\x80-\xBF])+}gc) {
        #
      } elsif ($x =~ m{\G(?:[\xE1-\xEC\xEE\xEF][\x80-\xBF][\x80-\xBF])+}gc) {
        #
      } elsif ($x =~ m{\G(?:\xED[\x80-\x9F][\x80-\xBF])+}gc) {
        #
      } elsif ($x =~ m{\G(?:\xF0[\x90-\xBF][\x80-\xBF][\x80-\xBF])+}gc) {
        #
      } elsif ($x =~ m{\G(?:[\xF1-\xF3][\x80-\xBF][\x80-\xBF][\x80-\xBF])+}gc) {
        #
      } elsif ($x =~ m{\G(?:\xF4[\x80-\x8F][\x80-\xBF][\x80-\xBF])+}gc) {
        #
      } else {
        my $pos = pos $x;
        if ($x =~ m{\G
     ((?:[\xC2-\xDF]                                      |
         \xE0               [\xA0-\xBF]?                  |
         [\xE1-\xEC\xEE\xEF][\x80-\xBF]?                  |
         \xED               [\x80-\x9F]?                  |
         \xF0               (?:[\x90-\xBF][\x80-\xBF]?|)  |
         [\xF1-\xF3]        (?:[\x80-\xBF][\x80-\xBF]?|)  |
         \xF4               (?:[\x80-\x8F][\x80-\xBF]?|))(\z)?)
      }gcx) {
            if ($_[2] or not defined $2) { # final or not at eof
              my $length = length $1;
              $_[4]->(type => 'utf-8:bad bytes', level => 'm', fatal => 1,
                      index => $_[3] + $pos - $pos_offset, value => $1) if $_[4];
              substr ($x, $pos, $length) = qq{\xEF\xBF\xBD}; # U+FFFD
              pos ($x) = $pos + 3;
              $pos_offset += 3 - $length;
              $xlength += 3 - $length;
            } else { # at end of chunk
              $_[0]->{lead} .= $1;
              substr ($x, $pos) = '';
              pos ($x) = $pos;
              #$pos_offset -= length $1;
              $xlength = $pos;
            }
          } else {
            my $value = substr $x, $pos, 1;
            substr ($x, $pos, 1) = qq{\xEF\xBF\xBD}; # U+FFFD
            $_[4]->(type => 'utf-8:bad bytes', level => 'm', fatal => 1,
                    index => $_[3] + $pos - $pos_offset, value => $value) if $_[4];
            pos ($x) = $pos + 3;
            $pos_offset += 2;
            $xlength += 2;
          }
      }
    } # while
    utf8::decode ($x);
    return $x;
  } # _decode8
  
  sub decode_web_utf8 ($) {
    if (not defined $_[0]) {
      carp "Use of uninitialized value in subroutine entry";
      return '';
    } elsif (utf8::is_utf8 $_[0]) {
      croak "Cannot decode string with wide characters";
    } else {
      return _decode8
          ({},
           substr ($_[0], 0, 3) eq "\xEF\xBB\xBF" ? substr $_[0], 3 : $_[0],
           1);
    }
  } # decode_web_utf8
  
  sub decode_web_utf8_no_bom ($) {
    if (not defined $_[0]) {
      carp "Use of uninitialized value an argument";
      return '';
    } elsif (utf8::is_utf8 $_[0]) {
      croak "Cannot decode string with wide characters";
    } else {
      return _decode8 {}, $_[0], 1;
    }
  } # decode_web_utf8_no_bom
  
  sub _encode_16 ($$) {
    if (not defined $_[0]) {
      carp "Use of uninitialized value an argument";
      return '';
    }
    my @s;
    for (split //, $_[0]) {
      my $c = ord $_;
      if ($c <= 0xFFFF) {
        push @s, pack $_[1], $c;
      } elsif ($c <= 0x10FFFF) {
        $c -= 0x10000;
        push @s, pack $_[1].$_[1], ($c >> 10) + 0xD800, ($c & 0x3FF) + 0xDC00;
      } else {
        push @s, $_[1] eq 'n' ? "\xFF\xFD" : "\xFD\xFF";
      }
    }
    return join '', @s;
  } # _encode_16
  
  sub _encode_mb ($$$$$) {
    my @s;
    pos ($_[0]) = 0;
    while ($_[0] =~ m{\G(?:([\x00-\x7F]+)|(.))}gs) {
      if (defined $1) {
        push @s, $1;
        utf8::downgrade $s[-1];
      } else {
        my $c = ord $2;
        if ($c > 0xFFFF) {
          my $v = $_[2]->{$c};
          if (defined $v) {
            push @s, $v;
            next;
          } else {
            #
          }
        } else {
          my $v = substr $_[1], $c * 2, 2;
          if ($v eq "\x00\x00") {
            #
          } elsif (substr ($v, 0, 1) eq "\x00") {
            push @s, substr $v, 1, 1;
            next;
          } else {
            push @s, $v;
            next;
          }
        }
  
        if ($c == 0x20AC) {
          push @s, $_[4] == 2 ? "\xA2\xE3" : "\x80";
          next;
        }
  
        if (@{$_[3]}) {
          ## <https://encoding.spec.whatwg.org/#index-gb18030-ranges-pointer>
  
          my $pointer;
          if ($c == 0xE5E5) {
            #
          } elsif ($c == 0xE7C7) {
            $pointer = 7457;
          } else {
            for (@{$_[3]}) {
              if ($_->[1] <= $c) {
                $pointer = $_->[0] + $c - $_->[1];
              }
            }
          }
  
          if (defined $pointer) {
            my $byte1 = int ($pointer / (10 * 126 * 10));
            $pointer = $pointer % (10 * 126 * 10);
            my $byte2 = int ($pointer / (10 * 126));
            $pointer = $pointer % (10 * 126);
            my $byte3 = int ($pointer / 10);
            my $byte4 = $pointer % 10;
            push @s, pack 'CCCC',
                $byte1 + 0x81, $byte2 + 0x30, $byte3 + 0x81, $byte4 + 0x30;
            next;
          }
        }
  
        push @s, sprintf '&#%d;', $c;
      }
    } # while
    return join '', @s;
  } # _encode_mb
  
  sub _encode_iso2022jp ($$$) {
    # $states $s $final
  
    my @s;
  
    for (split //, $_[1]) {
      my $c = ord $_;
      
      if ($c == 0x000E or $c == 0x000F or $c == 0x1B) {
        if (defined $_[0]->{state} and not $_[0]->{state} eq 'J') {
          delete $_[0]->{state};
          push @s, "\x1B\x28\x42";
        }
        push @s, '&#65533;'; # U+FFFD
      } elsif ($c == 0x5C or $c == 0x7E) {
        if (defined $_[0]->{state}) {
          delete $_[0]->{state};
          push @s, "\x1B\x28\x42";
        }
        push @s, pack 'C', $c;
      } elsif ($c <= 0x7F) {
        if (defined $_[0]->{state} and not $_[0]->{state} eq 'J') {
          delete $_[0]->{state};
          push @s, "\x1B\x28\x42";
        }
        push @s, pack 'C', $c;
      } elsif ($c == 0xA5) {
        if (not defined $_[0]->{state} or not $_[0]->{state} eq 'J') {
          $_[0]->{state} = 'J';
          push @s, "\x1B\x28\x4A";
        }
        push @s, "\x5C";
      } elsif ($c == 0x203E) {
        if (not defined $_[0]->{state} or not $_[0]->{state} eq 'J') {
          $_[0]->{state} = 'J';
          push @s, "\x1B\x28\x4A";
        }
        push @s, "\x7E";
      } elsif ($c > 0xFFFF) {
        if (defined $_[0]->{state} and not $_[0]->{state} eq 'J') {
          delete $_[0]->{state};
          push @s, "\x1B\x28\x42";
        }
        push @s, sprintf '&#%d;', $c;
      } else {
        if (0xFF61 <= $c and $c <= 0xFF9F) {
          $c = $Web::Encoding::_JIS::KatakanaHF->[$c - 0xFF61];
        }
  
        my $v = substr $Web::Encoding::_JIS::EncodeBMPEUC, $c * 2, 2;
        if ($v =~ /^[\xA1-\xFE]/) {
          if (not defined $_[0]->{state} or not $_[0]->{state} eq 'B') {
            $_[0]->{state} = 'B';
            push @s, "\x1B\x24\x42";
          }
          $v =~ tr/\x80-\xFF/\x00-\x7F/;
          push @s, $v;
        } else {
          if (defined $_[0]->{state} and not $_[0]->{state} eq 'J') {
            delete $_[0]->{state};
            push @s, "\x1B\x28\x42";
          }
          push @s, sprintf '&#%d;', $c;
        }
      }
    }
  
    if ($_[2]) {
      if (defined $_[0]->{state}) {
        delete $_[0]->{state};
        push @s, "\x1B\x28\x42";
      }
    }
  
    return join '', @s;
  } # _encode_iso2022jp
  
  sub _is_single ($) {
    return (($Web::Encoding::_Defs->{encodings}->{$_[0]} || {})->{single_byte});
  } # _is_single
  
  sub encode_web_charset ($$) {
    if ($_[0] eq 'utf-8') {
      return encode_web_utf8 $_[1];
    } elsif (_is_single $_[0]) {
      if (not defined $_[1]) {
        carp "Use of uninitialized value an argument";
        return '';
      }
      require Web::Encoding::_Single;
      my $s = $_[1]; # string copy!
      my $Map = $Web::Encoding::_Single::Encoder->{$_[0]};
      $s =~ s{([^\x00-\x7F])}{
        defined $Map->{$1} ? $Map->{$1} : sprintf '&#%d;', ord $1;
      }ge;
      utf8::downgrade $s if utf8::is_utf8 $s;
      return $s;
    } elsif ($_[0] eq 'utf-16be') {
      return _encode_16 $_[1], 'n';
    } elsif ($_[0] eq 'utf-16le') {
      return _encode_16 $_[1], 'v';
    } elsif ($_[0] eq 'gb18030') {
      require Web::Encoding::_GB;
      return _encode_mb $_[1], $Web::Encoding::_GB::EncodeBMP, {},
          $Web::Encoding::_GB::Ranges, 2;
    } elsif ($_[0] eq 'gbk') {
      require Web::Encoding::_GB;
      return _encode_mb $_[1], $Web::Encoding::_GB::EncodeBMP, {}, [], 1;
    } elsif ($_[0] eq 'big5') {
      require Web::Encoding::_Big5;
      return _encode_mb $_[1],
          $Web::Encoding::_Big5::EncodeBMP,
          $Web::Encoding::_Big5::EncodeNonBMP, [], 0;
    } elsif ($_[0] eq 'shift_jis') {
      require Web::Encoding::_JIS;
      return _encode_mb $_[1], $Web::Encoding::_JIS::EncodeBMPSJIS, {}, [], 0;
    } elsif ($_[0] eq 'euc-jp') {
      require Web::Encoding::_JIS;
      return _encode_mb $_[1], $Web::Encoding::_JIS::EncodeBMPEUC, {}, [], 0;
    } elsif ($_[0] eq 'euc-kr') {
      require Web::Encoding::_EUCKR;
      return _encode_mb $_[1], $Web::Encoding::_EUCKR::EncodeBMP, {}, [], 0;
    } elsif ($_[0] eq 'iso-2022-jp') {
      require Web::Encoding::_JIS;
      return _encode_iso2022jp {}, $_[1], 1;
    } elsif ($_[0] eq 'replacement') {
      croak "The replacement encoding has no encoder";
    } else {
      croak "Bad encoding key |$_[0]|";
    }
  } # encode_web_charset
  
  sub decode_web_charset ($$) {
    if ($_[0] eq 'utf-8') { # shortcut
      return decode_web_utf8 $_[1];
    } else {
      require Web::Encoding::Decoder;
      my $decoder = Web::Encoding::Decoder->new_from_encoding_key ($_[0]);
      $decoder->ignore_bom (1);
      return join '', @{$decoder->bytes ($_[1])}, @{$decoder->eof};
    }
  } # decode_web_charset
  
  push @EXPORT, qw(encoding_label_to_name);
  sub encoding_label_to_name ($) {
    ## Get an encoding
    ## <https://encoding.spec.whatwg.org/#concept-encoding-get>.
    my $label = $_[0] || '';
    $label =~ s/\A[\x09\x0A\x0C\x0D\x20]+//; ## ASCII whitespace
    $label =~ s/[\x09\x0A\x0C\x0D\x20]+\z//; ## ASCII whitespace
    $label =~ tr/A-Z/a-z/; ## ASCII case-insensitive.
    ## Returns the encoding key.
    return $Web::Encoding::_Defs->{supported_labels}->{$label}; # or undef
  } # encoding_label_to_name
  
  push @EXPORT, qw(is_encoding_label);
  sub is_encoding_label ($) {
    my $label = $_[0] || '';
    $label =~ tr/A-Z/a-z/; ## ASCII case-insensitive.
    return !!$Web::Encoding::_Defs->{supported_labels}->{$label};
  } # is_encoding_label
  
  push @EXPORT, qw(encoding_name_to_compat_name);
  sub encoding_name_to_compat_name ($) {
    return (($Web::Encoding::_Defs->{encodings}->{$_[0] || ''} || {})->{compat_name});
  } # encoding_name_to_compat_name
  
  push @EXPORT, qw(is_utf16_encoding_key);
  sub is_utf16_encoding_key ($) {
    return (($Web::Encoding::_Defs->{encodings}->{$_[0] || ''} || {})->{utf16});
  } # is_utf16_encoding_key
  
  push @EXPORT, qw(is_ascii_compat_encoding_name);
  sub is_ascii_compat_encoding_name ($) {
    return (($Web::Encoding::_Defs->{encodings}->{$_[0] || ''} || {})->{ascii_compat});
  } # is_ascii_compat_encoding_name
  
  push @EXPORT, qw(get_output_encoding_key);
  sub get_output_encoding_key ($) {
    return (($Web::Encoding::_Defs->{encodings}->{$_[0] || ''} || {})->{output}); # or undef
  } # get_output_encoding_key
  
  push @EXPORT, qw(fixup_html_meta_encoding_name);
  sub fixup_html_meta_encoding_name ($) {
    return (($Web::Encoding::_Defs->{encodings}->{$_[0] || ''} || {})->{html_decl_mapped}); # or undef
  } # fixup_html_meta_encoding_name
  
  # XXX can this deleted?
  sub is_ascii_compat_charset_name ($) {
    my $name = $_[0] or return 0;
    if ($name =~ m{^
      utf-8|
      iso-8859-[0-9]+|
      us-ascii|
      shift_jis|
      euc-jp|
      windows-[0-9]+|
      iso-2022-[0-9a-zA-Z-]+|
      hz-gb-2312
    $}xi) {
      return 1;
    } else {
      return 0;
    }
  } # is_ascii_compat_charset_name
  
  push @EXPORT, qw(locale_default_encoding_name);
  sub locale_default_encoding_name ($) {
    my $locale = $_[0] or return undef;
    $locale =~ tr/A-Z/a-z/;
    return $Web::Encoding::_Defs->{locale_default}->{$locale}; # or undef
  } # locale_default_encoding_name
  
  sub encoding_names () {
    return $Web::Encoding::_Defs->{names};
  } # encoding_names
  
  1;
  
  =head1 LICENSE
  
  Copyright 2011-2020 Wakaba <wakaba@suikawiki.org>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
WEB_ENCODING

$fatpacked{"Web/Encoding/Decoder.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WEB_ENCODING_DECODER';
  package Web::Encoding::Decoder;
  use strict;
  use warnings;
  our $VERSION = '1.0';
  use Carp;
  use Web::Encoding;
  
  push our @CARP_NOT, qw(Web::Encoding);
  
  sub new_from_encoding_key ($$) {
    return bless {
      key => $_[1],
      states => {},
    }, $_[0];
  } # new_from_encoding_key
  
  sub ignore_bom ($;$) {
    if (@_ > 1) {
      $_[0]->{ignore_bom} = $_[1];
    }
    return $_[0]->{ignore_bom};
  } # ignore_bom
  
  sub fatal ($;$) {
    if (@_ > 1) {
      $_[0]->{fatal} = 1;
    }
    return $_[0]->{fatal};
  } # fatal
  
  sub onerror ($;$) {
    if (@_ > 1) {
      $_[0]->{onerror} = $_[1];
    }
    return $_[0]->{onerror} || sub { };
  } # onerror
  
  sub _onerror ($) {
    my $onerror = $_[0]->{onerror};
    return $_[0]->{fatal} ? sub {
      my %args = @_;
      my $fatal = delete $args{fatal};
      $onerror->(%args);
      die "Input has invalid bytes" if $fatal;
    } : $onerror || sub { };
  } # _onerror
  
  sub used_encoding_key ($) {
    return $_[0]->{key};
  } # used_encoding_key
  
  sub _u16 ($$$$$) {
    #$states, $u, \@s, $onerror, $index;
    if ($_[1] < 0xD800 or 0xDFFF < $_[1]) {
      if (defined $_[0]->{lead_surrogate}) {
        $_[3]->(type => 'utf-16:lone high surrogate', level => 'm', fatal => 1,
                index => $_[0]->{index} + $_[4] - 2,
                text => sprintf '0x%04X', $_[0]->{lead_surrogate});
        push @{$_[2]}, "\x{FFFD}";
        delete $_[0]->{lead_surrogate};
      }
      push @{$_[2]}, chr $_[1];
    } elsif ($_[1] <= 0xDBFF) { # [U+D800, U+DBFF]
      if (defined $_[0]->{lead_surrogate}) {
        $_[3]->(type => 'utf-16:lone high surrogate', level => 'm', fatal => 1,
                index => $_[0]->{index} + $_[4] - 2,
                text => sprintf '0x%04X', $_[0]->{lead_surrogate});
        push @{$_[2]}, "\x{FFFD}";
        delete $_[0]->{lead_surrogate};
      }
      $_[0]->{lead_surrogate} = $_[1];
    } else { # [U+DC00, U+DFFF]
      if (defined $_[0]->{lead_surrogate}) {
        push @{$_[2]}, chr (0x10000
                            + ((delete ($_[0]->{lead_surrogate}) - 0xD800) << 10)
                            + $_[1] - 0xDC00);
      } else {
        $_[3]->(type => 'utf-16:lone low surrogate', level => 'm', fatal => 1,
                index => $_[0]->{index} + $_[4],
                text => sprintf '0x%04X', $_[1]);
        push @{$_[2]}, "\x{FFFD}";
      }
    }
  } # _u16
  
  sub _decode_16 ($$$$$) {
    my $states = $_[0];
    #my $onerror = $_[1];
    #my $is_last = $_[3];
    #my $endian = $_[4]
    my $offset = 0;
    my @s;
    my $len = length $_[2];
    if (defined $states->{lead_byte}) {
      if ($len) {
        my $lead = unpack 'C', delete $states->{lead_byte};
        my $sec = unpack 'C', substr $_[2], 0, 1;
        if ($_[4] eq 'n') {
          _u16 $states, $lead * 0x100 + $sec, \@s, $_[1], -1;
        } else {
          _u16 $states, $sec * 0x100 + $lead, \@s, $_[1], -1;
        }
        $offset++;
      } else { # empty
        if ($_[3]) { # $is_last
          $_[1]->(type => 'utf-16:lone byte', level => 'm', fatal => 1,
                  index => $states->{index} - 1, value => $states->{lead_byte});
          push @s, "\x{FFFD}";
          delete $states->{lead_surrogate};
        }
      }
    }
    my $Length = ($len - $offset) / 2;
    my $length = int $Length;
    my $i = 0;
    while ($i < $length) {
      _u16 $states, (unpack $_[4], substr $_[2], $offset + $i * 2, 2), \@s, $_[1], $offset + $i * 2;
      $i++;
    }
    if (defined $states->{lead_surrogate} and $_[3]) { # $is_last
      $_[1]->(type => 'utf-16:lone high surrogate', level => 'm', fatal => 1,
              index => $states->{index} + $len - 2,
              text => sprintf '0x%04X', $_[0]->{lead_surrogate});
      push @s, "\x{FFFD}";
    } elsif ($length != $Length) {
      if ($_[3]) { # $is_last
        $_[1]->(type => 'utf-16:lone byte', level => 'm', fatal => 1,
                index => $states->{index} + $len - 1,
                value => substr $_[2], -1);
        push @s, "\x{FFFD}";
      } else {
        $states->{lead_byte} = substr $_[2], -1;
      }
    }
  
    $states->{index} += $len;
  
    ## @s can't contain an empty string for the convenience of later BOM
    ## stripping.
    return \@s;
  } # _decode_16
  
  sub _gb ($$$$$) {
    # $b1 $b2 $out $index_offset $onerror
    if ($_[1] < 0x40 or $_[1] == 0x7F or $_[1] == 0xFF) {
      push @{$_[2]}, "\x{FFFD}";
      $_[4]->(type => 'encoding:unassigned', level => 'm', fatal => 1,
              index => $_[3], value => pack 'CC', $_[0], $_[1]);
      push @{$_[2]}, chr $_[1] if $_[1] < 0x80;
    } else {
      my $pointer = ($_[0] - 0x81) * 190 + $_[1] - ($_[1] < 0x7F ? 0x40 : 0x41);
      my $c = $Web::Encoding::_GB::DecodeIndex->[$pointer];
      if (defined $c) {
        if ($pointer == (0xA3 - 0x81) * 190 + 0xA0 - 0x41) {
          $_[4]->(type => 'encoding:not canonical', level => 'w',
                  index => $_[3], value => pack 'CC', $_[0], $_[1]);
        }
        push @{$_[2]}, $c;
      } else {
        if ($_[1] < 0x80) {
          push @{$_[2]}, "\x{FFFD}", chr $_[1];
          $_[4]->(type => 'encoding:unassigned', level => 'm', fatal => 1,
                  index => $_[3], value => pack 'CC', $_[0], $_[1]);
        } else {
          push @{$_[2]}, "\x{FFFD}";
          $_[4]->(type => 'encoding:unassigned', level => 'm', fatal => 1,
                  index => $_[3], value => pack 'CC', $_[0], $_[1]);
        }
      }
    }
  } # _gb
  
  sub _gb4 ($$$$$$) {
    # $b1b2 $b3 $b4 $out $index_offset $onerror
    my $pointer = ($_[0]->[0] - 0x81) * (10 * 126 * 10)
        + ($_[0]->[1] - 0x30) * (10 * 126)
        + ($_[1] - 0x81) * 10
        + $_[2] - 0x30;
  
    if (($pointer > 39419 and $pointer < 189000) or $pointer > 1237575) {
      push @{$_[3]}, "\x{FFFD}";
      $_[5]->(type => 'encoding:unassigned', level => 'm', fatal => 1,
              index => $_[4],
              value => pack 'CCCC', $_[0]->[0], $_[0]->[1], $_[1], $_[2]);
      return undef;
    }
  
    if ($pointer == 7457) {
      push @{$_[3]}, "\x{E7C7}";
      return undef;
    }
  
    my $offset;
    my $cp;
    for (@{$Web::Encoding::_GB::Ranges}) {
      if ($_->[0] <= $pointer) {
        $offset = $_->[0];
        $cp = $_->[1];
      }
    }
    push @{$_[3]}, chr ($cp + $pointer - $offset);
    return undef;
  } # _gb4
  
  sub _b5 ($$$$$) {
    # $b1 $b2 $out $index_offset $onerror
    if ((0x7F <= $_[1] and $_[1] <= 0xA0) or $_[1] == 0xFF) {
      push @{$_[2]}, "\x{FFFD}";
      $_[4]->(type => 'encoding:unassigned', level => 'm', fatal => 1,
              index => $_[3], value => pack 'CC', $_[0], $_[1]);
      push @{$_[2]}, chr $_[1] if $_[1] < 0x80;
    } else {
      my $pointer = ($_[0] - 0x81) * 157
          + $_[1] - ($_[1] < 0x7F ? 0x40 : 0x62);
      my $c = $Web::Encoding::_Big5::DecodeIndex->[$pointer];
      if (defined $c) {
        if ($pointer < (0xA1 - 0x81) * 157) {
          $_[4]->(type => 'big5:hkscs', level => 'w',
                  index => $_[3], value => pack 'CC', $_[0], $_[1]);
        } elsif ($Web::Encoding::_Big5::NonCanonical->{$pointer}) {
          $_[4]->(type => 'encoding:not canonical', level => 'w',
                  index => $_[3], value => pack 'CC', $_[0], $_[1]);
        }
        push @{$_[2]}, $c;
      } else {
        if ($_[1] < 0x80) {
          push @{$_[2]}, "\x{FFFD}", chr $_[1];
          $_[4]->(type => 'encoding:unassigned', level => 'm', fatal => 1,
                  index => $_[3], value => pack 'CC', $_[0], $_[1]);
        } else {
          push @{$_[2]}, "\x{FFFD}";
          $_[4]->(type => 'encoding:unassigned', level => 'm', fatal => 1,
                  index => $_[3], value => pack 'CC', $_[0], $_[1]);
        }
      }
    }
  } # _b5
  
  sub _kr ($$$$$) {
    # $b1 $b2 $out $index_offset $onerror
    if ($_[1] < 0x41 or $_[1] == 0xFF) {
      push @{$_[2]}, "\x{FFFD}";
      $_[4]->(type => 'encoding:unassigned', level => 'm', fatal => 1,
              index => $_[3], value => pack 'CC', $_[0], $_[1]);
      push @{$_[2]}, chr $_[1] if $_[1] < 0x80;
    } else {
      my $pointer = ($_[0] - 0x81) * 190 + $_[1] - 0x41;
      my $c = $Web::Encoding::_EUCKR::DecodeIndex->[$pointer];
      if (defined $c) {
        push @{$_[2]}, $c;
      } else {
        if ($_[1] < 0x80) {
          push @{$_[2]}, "\x{FFFD}", chr $_[1];
          $_[4]->(type => 'encoding:unassigned', level => 'm', fatal => 1,
                  index => $_[3], value => pack 'CC', $_[0], $_[1]);
        } else {
          push @{$_[2]}, "\x{FFFD}";
          $_[4]->(type => 'encoding:unassigned', level => 'm', fatal => 1,
                  index => $_[3], value => pack 'CC', $_[0], $_[1]);
        }
      }
    }
  } # _kr
  
  sub _sjis ($$$$$) {
    # $b1 $b2 $out $index_offset $onerror
    unless (0x40 <= $_[1] and $_[1] <= 0xFC and not $_[1] == 0x7F) {
      push @{$_[2]}, "\x{FFFD}";
      $_[4]->(type => 'encoding:unassigned', level => 'm', fatal => 1,
              index => $_[3], value => pack 'CC', $_[0], $_[1]);
      push @{$_[2]}, chr $_[1] if $_[1] < 0x80;
    } else {
      my $pointer = ($_[0] - ($_[0] < 0xA0 ? 0x81 : 0xC1)) * 188
          + $_[1] - ($_[1] < 0x7F ? 0x40 : 0x41);
      my $c = $Web::Encoding::_JIS::DecodeIndex->[$pointer];
      if (defined $c) {
        if ((8272 <= $pointer and $pointer <= 8835) or
            $Web::Encoding::_JIS::NonCanonicalSJIS->{$pointer}) {
          $_[4]->(type => 'encoding:not canonical', level => 'w',
                  index => $_[3], value => pack 'CC', $_[0], $_[1]);
        }
        push @{$_[2]}, $c;
      } elsif (8836 <= $pointer and $pointer <= 10715) {
        ## EUDC.  Though they are not roundtrippable, we don't emit any
        ## warning here, as we will report them at Unicode character
        ## validation.  PUA code points are not interoperable anyway.
        push @{$_[2]}, chr (0xE000 - 8836 + $pointer);
      } else {
        if ($_[1] < 0x80) {
          push @{$_[2]}, "\x{FFFD}", chr $_[1];
          $_[4]->(type => 'encoding:unassigned', level => 'm', fatal => 1,
                  index => $_[3], value => pack 'CC', $_[0], $_[1]);
        } else {
          push @{$_[2]}, "\x{FFFD}";
          $_[4]->(type => 'encoding:unassigned', level => 'm', fatal => 1,
                  index => $_[3], value => pack 'CC', $_[0], $_[1]);
        }
      }
    }
  } # _sjis
  
  sub _jis ($$$$$$) {
    # $b1 $b2 $out $index_offset $onerror $delta
    unless (0xA1 <= $_[1] and $_[1] <= 0xFE) {
      push @{$_[2]}, "\x{FFFD}";
      $_[4]->(type => 'encoding:unassigned', level => 'm', fatal => 1,
              index => $_[3],
              value => pack 'CC', $_[0] - $_[5], $_[1] - $_[5]);
    } elsif ($_[0] == 0x8E) {
      if ($_[1] <= 0xDF) {
        push @{$_[2]}, chr (0xFF61 - 0xA1 + $_[1]);
      } else {
        push @{$_[2]}, "\x{FFFD}";
        $_[4]->(type => 'encoding:unassigned', level => 'm', fatal => 1,
                index => $_[3],
                value => pack 'CC', $_[0] - $_[5], $_[1] - $_[5]);
      }
    } else {
      my $pointer = ($_[0] - 0xA1) * 94 + $_[1] - 0xA1;
      my $c = $Web::Encoding::_JIS::DecodeIndex->[$pointer];
      if (defined $c) {
        push @{$_[2]}, $c;
        if ($Web::Encoding::_JIS::NonCanonicalEUC->{$pointer}) {
          $_[4]->(type => 'encoding:not canonical', level => 'w',
                  index => $_[3],
                  value => pack 'CC', $_[0] - $_[5], $_[1] - $_[5]);
        }
      } else {
        push @{$_[2]}, "\x{FFFD}";
        $_[4]->(type => 'encoding:unassigned', level => 'm', fatal => 1,
                index => $_[3],
                value => pack 'CC', $_[0] - $_[5], $_[1] - $_[5]);
      }
    }
  } # _jis
  
  sub _eucjp0212 ($$$$$) {
    # $b1 $b2 $out $index_offset $onerror
    unless (0xA1 <= $_[1] and $_[1] <= 0xFE) {
      push @{$_[2]}, "\x{FFFD}";
      $_[4]->(type => 'encoding:unassigned', level => 'm', fatal => 1,
              index => $_[3], value => pack 'CCC', 0x8F, $_[0], $_[1]);
    } else {
      my $pointer = ($_[0] - 0xA1) * 94 + $_[1] - 0xA1;
      my $c = $Web::Encoding::_JIS::DecodeIndex0212->[$pointer];
      if (defined $c) {
        push @{$_[2]}, $c;
        $_[4]->(type => 'eucjp:0212', level => 'w',
                index => $_[3], value => pack 'CCC', 0x8F, $_[0], $_[1]);
      } else {
        push @{$_[2]}, "\x{FFFD}";
        $_[4]->(type => 'encoding:unassigned', level => 'm', fatal => 1,
                index => $_[3], value => pack 'CCC', 0x8F, $_[0], $_[1]);
      }
    }
  } # _eucjp0212
  
  sub _decode_mb ($$$$$) {
    # $states $s $final $onerror $char
    $_[0]->{index} = 0 unless defined $_[0]->{index};
    my @s;
    pos ($_[1]) = 0;
    if (defined $_[0]->{lead_byte}) {
      if ($_[1] =~ /\G([\x40-\xFF])/gc) {
        $_[4]->($_[0]->{lead_byte}, ord $1, \@s, $_[0]->{index} - 1, $_[3]);
        delete $_[0]->{lead_byte};
      } elsif ($_[1] eq '' and not $_[2]) {
        #
      } else {
        push @s, "\x{FFFD}";
        $_[3]->(type => 'multibyte:lone lead byte', level => 'm', fatal => 1,
                index => $_[0]->{index} - 1, value => pack 'C', $_[0]->{lead_byte});
        delete $_[0]->{lead_byte};
      }
    } # lead_byte
    while ($_[1] =~ m{
      \G(?:
        ([\x81-\xFE](?:[\x40-\xFF]|(\z)?)) |
        ([\x80\xFF]) |
        ([\x00-\x7F]+)
      )
    }gx) {
      if (defined $1) {
        if (2 == length $1) {
          $_[4]->(ord substr ($1, 0, 1), ord substr ($1, 1, 1), \@s, $_[0]->{index} + $-[0], $_[3]);
        } else {
          if (defined $2 and not $_[2]) {
            $_[0]->{lead_byte} = ord $1;
          } else {
            push @s, "\x{FFFD}";
            $_[3]->(type => 'multibyte:lone lead byte', level => 'm', fatal => 1,
                    index => $_[0]->{index} + $-[0], value => $1);
          }
        }
      } elsif (defined $3) {
        push @s, "\x{FFFD}";
        $_[3]->(type => 'encoding:unassigned', level => 'm', fatal => 1,
                index => $_[0]->{index} + $-[0], value => $3);
      } else {
        push @s, $4;
      }
    }
    $_[0]->{index} += length $_[1];
    return \@s;
  } # _decode_mb
  
  sub _decode_sjis ($$$$) {
    # $states $s $final $onerror
    $_[0]->{index} = 0 unless defined $_[0]->{index};
    my @s;
    pos ($_[1]) = 0;
    if (defined $_[0]->{lead_byte}) {
      if ($_[1] =~ /\G([\x40-\xFF])/gc) {
        _sjis $_[0]->{lead_byte}, ord $1, \@s, $_[0]->{index} - 1, $_[3];
        delete $_[0]->{lead_byte};
      } elsif ($_[1] eq '' and not $_[2]) {
        #
      } else {
        push @s, "\x{FFFD}";
        $_[3]->(type => 'multibyte:lone lead byte', level => 'm', fatal => 1,
                index => $_[0]->{index} - 1, value => pack 'C', $_[0]->{lead_byte});
        delete $_[0]->{lead_byte};
      }
    } # lead_byte
    while ($_[1] =~ m{
      \G(?:
        ([\x81-\x9F\xE0-\xFC](?:[\x40-\xFF]|(\z)?)) |
        ([\xA0-\xDF\xFD\xFE\xFF]) |
        ([\x00-\x7F\x80]+)
      )
    }gx) {
      if (defined $1) {
        if (2 == length $1) {
          _sjis ord substr ($1, 0, 1), ord substr ($1, 1, 1), \@s, $_[0]->{index} + $-[0], $_[3];
        } else {
          if (defined $2 and not $_[2]) {
            $_[0]->{lead_byte} = ord $1;
          } else {
            push @s, "\x{FFFD}";
            $_[3]->(type => 'multibyte:lone lead byte', level => 'm', fatal => 1,
                    index => $_[0]->{index} + $-[0], value => $1);
          }
        }
      } elsif (defined $3) {
        my $c = ord $3;
        if (0xA1 <= $c and $c <= 0xDF) {
          push @s, chr (0xFF61 - 0xA1 + $c);
        } else {
          push @s, "\x{FFFD}";
          $_[3]->(type => 'encoding:unassigned', level => 'm', fatal => 1,
                  index => $_[0]->{index} + $-[0], value => $3);
        }
      } else {
        push @s, $4;
      }
    }
    $_[0]->{index} += length $_[1];
    return \@s;
  } # _decode_sjis
  
  sub _decode_eucjp ($$$$) {
    # $states $s $final $onerror
    $_[0]->{index} = 0 unless defined $_[0]->{index};
    my @s;
    pos ($_[1]) = 0;
    if ($_[0]->{is_0212}) {
      if (defined $_[0]->{lead_byte}) {
        if ($_[1] =~ /\G([\x80-\xFF])/gc) {
          _eucjp0212 $_[0]->{lead_byte}, ord $1, \@s, $_[0]->{index} - 2, $_[3];
          delete $_[0]->{lead_byte};
          delete $_[0]->{is_0212};
        } elsif ($_[1] eq '' and not $_[2]) {
          #
        } else {
          push @s, "\x{FFFD}";
          $_[3]->(type => 'multibyte:lone lead byte', level => 'm', fatal => 1,
                  index => $_[0]->{index} - 2,
                  value => pack 'CC', 0x8F, $_[0]->{lead_byte});
          delete $_[0]->{lead_byte};
          delete $_[0]->{is_0212};
        }
      } else {
        if ($_[1] =~ /\G([\x80-\xFF])([\x80-\xFF])?/gc) {
          if (defined $2) {
            _eucjp0212 ord $1, ord $2, \@s, $_[0]->{index} - 1, $_[3];
            delete $_[0]->{is_0212};
          } else {
            if (1 == length $_[1] and not $_[2]) {
              $_[0]->{lead_byte} = ord $1;
            } else {
              push @s, "\x{FFFD}";
              $_[3]->(type => 'multibyte:lone lead byte', level => 'm', fatal => 1,
                      index => $_[0]->{index} - 1,
                      value => "\x8F" . $1);
              delete $_[0]->{is_0212};
            }
          }
        } elsif ($_[1] eq '' and not $_[2]) {
          #
        } else {
          push @s, "\x{FFFD}";
          $_[3]->(type => 'multibyte:lone lead byte', level => 'm', fatal => 1,
                  index => $_[0]->{index} - 1, value => "\x8F");
          delete $_[0]->{is_0212};
        }
      }
    } elsif (defined $_[0]->{lead_byte}) {
      if ($_[1] =~ /\G([\x80-\xFF])/gc) {
        _jis $_[0]->{lead_byte}, ord $1, \@s, $_[0]->{index} - 1, $_[3], 0;
        delete $_[0]->{lead_byte};
      } elsif ($_[1] eq '' and not $_[2]) {
        #
      } else {
        push @s, "\x{FFFD}";
        $_[3]->(type => 'multibyte:lone lead byte', level => 'm', fatal => 1,
                index => $_[0]->{index} - 1, value => pack 'C', $_[0]->{lead_byte});
        delete $_[0]->{lead_byte};
      }
    } # lead_byte
    while ($_[1] =~ m{
      \G(?:
        ([\x8E\xA1-\xFE](?:[\x80-\xFF]|(\z)?)) |
        \x8F ( (?:[\x80-\xFF] (?:[\x80-\xFF] |) |) (\z)? ) |
        ([\x80-\x8D\x90-\xA0\xFF]) |
        ([\x00-\x7F]+)
      )
    }gx) {
      if (defined $1) {
        if (2 == length $1) {
          _jis ord substr ($1, 0, 1), ord substr ($1, 1, 1), \@s, $_[0]->{index} + $-[0], $_[3], 0;
        } else {
          if (defined $2 and not $_[2]) {
            $_[0]->{lead_byte} = ord $1;
          } else {
            push @s, "\x{FFFD}";
            $_[3]->(type => 'multibyte:lone lead byte', level => 'm', fatal => 1,
                    index => $_[0]->{index} + $-[0], value => $1);
          }
        }
      } elsif (defined $3) {
        if (2 == length $3) {
          _eucjp0212 ord substr ($3, 0, 1), ord substr ($3, 1, 1), \@s, $_[0]->{index} + $-[0], $_[3];
        } else {
          if (defined $4 and not $_[2]) {
            $_[0]->{lead_byte} = length $3 ? ord $3 : undef;
            $_[0]->{is_0212} = 1;
          } else {
            push @s, "\x{FFFD}";
            $_[3]->(type => 'multibyte:lone lead byte', level => 'm', fatal => 1,
                    index => $_[0]->{index} + $-[0], value => "\x8F" . $3);
          }
        }
      } elsif (defined $5) {
        my $c = ord $5;
        push @s, "\x{FFFD}";
        $_[3]->(type => 'encoding:unassigned', level => 'm', fatal => 1,
                index => $_[0]->{index} + $-[0], value => $5);
      } else {
        push @s, $6;
      }
    }
    $_[0]->{index} += length $_[1];
    return \@s;
  } # _decode_eucjp
  
  sub _decode_gb18030 ($$$$) {
    # $states $s $final $onerror
    $_[0]->{index} = 0 unless defined $_[0]->{index};
    my @s;
    pos ($_[1]) = 0;
    if (defined $_[0]->{lead_byte}) {
      if ($_[1] =~ /\G([\x30-\x39\x40-\xFF])/gc) {
        my $b2 = ord $1;
        if (0x30 <= $b2 and $b2 <= 0x39) {
          if (defined $_[0]->{lead_surrogate}) {
            $_[0]->{lead_surrogate} = _gb4 $_[0]->{lead_surrogate}, $_[0]->{lead_byte}, $b2, \@s, $_[0]->{index} - 2, $_[3];
          } else {
            $_[0]->{lead_surrogate} = [$_[0]->{lead_byte}, $b2];
          }
        } else {
          if (defined $_[0]->{lead_surrogate}) {
            push @s, "\x{FFFD}", chr $_[0]->{lead_surrogate}->[1];
            $_[3]->(type => 'multibyte:lone lead byte', level => 'm', fatal => 1,
                    index => $_[0]->{index} - 3,
                    value => pack 'CC', @{delete $_[0]->{lead_surrogate}});
          }
          _gb $_[0]->{lead_byte}, $b2, \@s, $_[0]->{index} - 1, $_[3];
        }
        delete $_[0]->{lead_byte};
      } elsif ($_[1] eq '' and not $_[2]) {
        #
      } else {
        push @s, "\x{FFFD}";
        if (defined $_[0]->{lead_surrogate}) {
          push @s, chr $_[0]->{lead_surrogate}->[1] unless $_[2];
          $_[3]->(type => 'multibyte:lone lead byte', level => 'm', fatal => 1,
                  index => $_[0]->{index} - 3,
                  value => pack 'CCC', @{delete $_[0]->{lead_surrogate}}, $_[0]->{lead_byte});
        } else {
          $_[3]->(type => 'multibyte:lone lead byte', level => 'm', fatal => 1,
                  index => $_[0]->{index} - 1, value => pack 'C', $_[0]->{lead_byte});
        }
        delete $_[0]->{lead_byte};
      }
    } elsif (defined $_[0]->{lead_surrogate}) {
      if ($_[1] eq '') {
        if ($_[2]) { # final
          push @s, "\x{FFFD}";
          $_[3]->(type => 'multibyte:lone lead byte', level => 'm', fatal => 1,
                  index => $_[0]->{index} - 2,
                  value => pack 'CC', @{$_[0]->{lead_surrogate}});
          delete $_[0]->{lead_surrogate};
        }
      }
    } # lead_surrogate
  
    while ($_[1] =~ m{
      \G(?:
        ([\x81-\xFE](?:[\x30-\x39\x40-\xFF]|(\z)?)) |
        ([\x80\xFF]) |
        ([\x00-\x7F]+)
      )
    }gx) {
      if (defined $1) {
        if (2 == length $1) {
          my $b1 = ord substr ($1, 0, 1);
          my $b2 = ord substr ($1, 1, 1);
          if (0x30 <= $b2 and $b2 <= 0x39) {
            if (defined $_[0]->{lead_surrogate}) {
              $_[0]->{lead_surrogate} = _gb4 $_[0]->{lead_surrogate}, $b1, $b2, \@s, $_[0]->{index} + $-[0] - 2, $_[3];
            } else {
              $_[0]->{lead_surrogate} = [$b1, $b2];
            }
          } else {
            if (defined $_[0]->{lead_surrogate}) {
              push @s, "\x{FFFD}", chr $_[0]->{lead_surrogate}->[1];
              $_[3]->(type => 'multibyte:lone lead byte', level => 'm', fatal => 1,
                      index => $_[0]->{index} + $-[0] - 2,
                      value => (pack 'CC', @{delete $_[0]->{lead_surrogate}}));
            }
            _gb $b1, $b2, \@s, $_[0]->{index} + $-[0], $_[3];
          }
        } else {
          if (defined $2 and not $_[2]) {
            $_[0]->{lead_byte} = ord $1;
          } else {
            push @s, "\x{FFFD}";
            if (defined $_[0]->{lead_surrogate}) {
              push @s, chr $_[0]->{lead_surrogate}->[1];
              $_[3]->(type => 'multibyte:lone lead byte', level => 'm', fatal => 1,
                      index => $_[0]->{index} + $-[0] - 2,
                      value => (pack 'CC', @{delete $_[0]->{lead_surrogate}}).$1);
            } else {
              $_[3]->(type => 'multibyte:lone lead byte', level => 'm', fatal => 1,
                      index => $_[0]->{index} + $-[0], value => $1);
            }
          }
        }
      } elsif (defined $3) {
        if (defined $_[0]->{lead_surrogate}) {
          push @s, "\x{FFFD}", chr $_[0]->{lead_surrogate}->[1];
          $_[3]->(type => 'multibyte:lone lead byte', level => 'm', fatal => 1,
                  index => $_[0]->{index} + $-[0] - 2,
                  value => pack 'CC', @{delete $_[0]->{lead_surrogate}});
        }
        if ($3 eq "\x80") {
          $_[3]->(type => 'encoding:not canonical', level => 'w',
                  index => $_[0]->{index} + $-[0], value => $3);
          push @s, "\x{20AC}";
        } else {
          my $c = ord $3;
          push @s, "\x{FFFD}";
          $_[3]->(type => 'encoding:unassigned', level => 'm', fatal => 1,
                  index => $_[0]->{index} + $-[0], value => $3);
        }
      } else {
        if (defined $_[0]->{lead_surrogate}) {
          push @s, "\x{FFFD}", chr $_[0]->{lead_surrogate}->[1];
          $_[3]->(type => 'multibyte:lone lead byte', level => 'm', fatal => 1,
                  index => $_[0]->{index} + $-[0] - 2,
                  value => pack 'CC', @{delete $_[0]->{lead_surrogate}});
        }
        push @s, $4;
      }
    }
    $_[0]->{index} += length $_[1];
    return \@s;
  } # _decode_gb18030
  
  sub _esc ($$$$$) {
    # $states $s $final $onerror $out
    my $length = length $_[0]->{lead_escape};
    if ($length == 0) {
      if ($_[1] =~ m{\G(\x24[\x40\x42]?|\x28[BIJ]?)}gc) {
        $_[0]->{lead_escape} .= $1;
      }
    } elsif ($length == 1) {
      if ($_[0]->{lead_escape} eq "\x24" and $_[1] =~ m{\G([\x40\x42])}gc) {
        $_[0]->{lead_escape} .= $1;
      } elsif ($_[0]->{lead_escape} eq "\x28" and $_[1] =~ m{\G([BIJ])}gc) {
        $_[0]->{lead_escape} .= $1;
      }
    }
  
    my $new_state;
    if ($_[0]->{lead_escape} eq "\x24\x42") {
      $new_state = '0208';
    } elsif ($_[0]->{lead_escape} eq "\x24\x40") {
      $new_state = '6226';
      $_[3]->(type => 'iso2022jp:jis78', level => 'm',
              index => $_[0]->{index} + pos ($_[1]) - 2 - 1,
              value => "\x1B\x24\x40");
    } elsif ($_[0]->{lead_escape} eq "\x28\x42") {
      $new_state = 'ASCII';
    } elsif ($_[0]->{lead_escape} eq "\x28\x4A") {
      $new_state = 'Latin';
    } elsif ($_[0]->{lead_escape} eq "\x28\x49") {
      $new_state = 'Katakana';
    } else {
      if (not $_[2] and $_[1] =~ m{\G\z}gc) {
        return;
      } else {
        push @{$_[4]}, "\x{FFFD}", $_[0]->{lead_escape};
        $_[3]->(type => 'iso2022jp:lone escape', level => 'm', fatal => 1,
                index => $_[0]->{index} + pos ($_[1]) - length ($_[0]->{lead_escape}) - 1,
                value => "\x1B");
        delete $_[0]->{after_escape};
        delete $_[0]->{lead_escape};
        return;
      }
    }
  
    if ($_[0]->{after_escape}) {
      push @{$_[4]}, "\x{FFFD}";
      $_[3]->(type => 'iso2022jp:redundant escape',
              level => 'm', fatal => 1,
              index => $_[0]->{index} + pos ($_[1]) - length ($_[0]->{lead_escape}) - 1 - 3,
              value => {
                '0208' => "\x1B\x24\x42",
                '6226' => "\x1B\x24\x40",
                'ASCII' => "\x1B\x28\x42",
                'Latin' => "\x1B\x28\x4A",
                'Katakana' => "\x1B\x28\x49",
              }->{$_[0]->{state}});
    }
    $_[0]->{state} = $new_state;
    $_[0]->{after_escape} = 1;
    delete $_[0]->{lead_escape};
  } # _esc
  
  sub _decode_iso2022jp ($$$$) {
    # $states $s $final $onerror
    $_[0]->{index} = 0 unless defined $_[0]->{index};
    $_[0]->{state} = 'ASCII' unless defined $_[0]->{state};
    my @s;
  
    pos ($_[1]) = 0;
  
    if (defined $_[0]->{lead_escape}) {
      _esc $_[0], $_[1], $_[2], $_[3], \@s;
    }
  
    if (defined $_[0]->{lead_byte}) {
      if ($_[1] =~ m{\G([\x21-\x7E])}gc) {
        _jis 0x80 + $_[0]->{lead_byte}, 0x80 + ord $1, \@s, $_[0]->{index} - 1, $_[3], 0x80;
        delete $_[0]->{after_escape};
        delete $_[0]->{lead_byte};
      } elsif ($_[1] =~ m{\G([^\x1B])}gc) {
        push @s, "\x{FFFD}";
        $_[3]->(type => 'encoding:unassigned', level => 'm', fatal => 1,
                index => $_[0]->{index} - 1,
                value => (pack 'C', $_[0]->{lead_byte}) . $1);
        delete $_[0]->{after_escape};
        delete $_[0]->{lead_byte};
      } elsif ($_[2]) {
        push @s, "\x{FFFD}";
        $_[3]->(type => 'multibyte:lone lead byte', level => 'm', fatal => 1,
                index => $_[0]->{index} - 1,
                value => pack 'C', $_[0]->{lead_byte});
        delete $_[0]->{lead_byte};
      }
    } # lead_byte
  
    my $length = length $_[1];
    while (pos ($_[1]) < $length) {
      if ($_[0]->{state} eq 'ASCII') {
        if ($_[1] =~ m{\G([\x00-\x0D\x10-\x1A\x1C-\x7F]+)}gc) {
          push @s, $1;
          delete $_[0]->{after_escape};
        } elsif ($_[1] =~ m{\G([^\x1B])}gc) {
          push @s, "\x{FFFD}";
          $_[3]->(type => 'encoding:unassigned', level => 'm', fatal => 1,
                  index => $_[0]->{index} + $-[0], value => $1);
          delete $_[0]->{after_escape};
        }
      } elsif ($_[0]->{state} eq 'Latin') {
        if ($_[1] =~ m{\G([\x00-\x0D\x10-\x1A\x1C-\x7F]+)}gc) {
          push @s, $1;
          $s[-1] =~ tr/\x5C\x7E/\xA5\x{203E}/;
          delete $_[0]->{after_escape};
        } elsif ($_[1] =~ m{\G([^\x1B])}gc) {
          push @s, "\x{FFFD}";
          $_[3]->(type => 'encoding:unassigned', level => 'm', fatal => 1,
                  index => $_[0]->{index} + $-[0], value => $1);
          delete $_[0]->{after_escape};
        }
      } elsif ($_[0]->{state} eq '0208' or $_[0]->{state} eq '6226') {
        while ($_[1] =~ m{\G([\x21-\x7E])([\x21-\x7E])}gc) {
          _jis 0x80 + ord $1, 0x80 + ord $2, \@s, $_[0]->{index} + $-[0], $_[3], 0x80;
          delete $_[0]->{after_escape};
        }
        if ($_[1] =~ m{\G([\x21-\x7E][^\x1B])}gc) {
          push @s, "\x{FFFD}";
          $_[3]->(type => 'encoding:unassigned', level => 'm', fatal => 1,
                  index => $_[0]->{index} + $-[0], value => $1);
          delete $_[0]->{after_escape};
        } elsif (not $_[2] and $_[1] =~ m{\G([\x21-\x7E])\z}gc) {
          $_[0]->{lead_byte} = ord $1;
          delete $_[0]->{after_escape};
        } elsif ($_[1] =~ m{\G([^\x1B])}gc) {
          push @s, "\x{FFFD}";
          $_[3]->(type => 'encoding:unassigned', level => 'm', fatal => 1,
                  index => $_[0]->{index} + $-[0], value => $1);
          delete $_[0]->{after_escape};
        }
      } elsif ($_[0]->{state} eq 'Katakana') {
        while ($_[1] =~ m{\G([\x21-\x5F])}gc) {
          push @s, chr (0xFF61 - 0x21 + ord $1);
          delete $_[0]->{after_escape};
        }
        if ($_[1] =~ m{\G([^\x1B])}gc) {
          push @s, "\x{FFFD}";
          $_[3]->(type => 'encoding:unassigned', level => 'm', fatal => 1,
                  index => $_[0]->{index} + $-[0], value => $1);
          delete $_[0]->{after_escape};
        }
      }
  
      if ($_[1] =~ m{\G\x1B}gc) {
        $_[0]->{lead_escape} = '';
        _esc $_[0], $_[1], $_[2], $_[3], \@s;
      }
    } # while
  
    $_[0]->{index} += length $_[1];
  
    if ($_[2]) {
      unless ($_[0]->{state} eq 'ASCII') {
        $_[3]->(type => 'iso2022jp:not ascii at end', level => 'w',
                index => $_[0]->{index});
      }
    }
  
    return \@s;
  } # _decode_iso2022jp
  
  sub bytes ($$) {
    my $key = $_[0]->{key};
    if (not defined $_[1]) {
      carp "Use of uninitialized value an argument";
      return [];
    } elsif (utf8::is_utf8 $_[1]) {
      croak "Cannot decode string with wide characters";
    } elsif ($_[1] eq '') {
      return [];
    }
  
    $_[0]->{states}->{index} = 0 unless defined $_[0]->{states}->{index};
    if ($key eq 'utf-8') {
      my $offset = $_[0]->{states}->{index}
                 + (defined $_[0]->{states}->{lead} ? -length $_[0]->{states}->{lead} : 0);
      my $decoded = [Web::Encoding::_decode8 ($_[0]->{states}, $_[1], 0, $offset, $_[0]->_onerror)];
  
      $_[0]->{states}->{index} += length $_[1];
      if ($_[0]->{ignore_bom} and not $_[0]->{states}->{bom_seen}) {
        if (@$decoded and length $decoded->[0]) {
          if ($decoded->[0] =~ s/^\x{FEFF}//) {
            $_[0]->_onerror->(type => 'bom', level => 's', index => 0);
          }
          $_[0]->{states}->{bom_seen} = 1;
        }
      }
      return $decoded;
    } elsif (Web::Encoding::_is_single ($key)) {
      require Web::Encoding::_Single;
      my $s = $_[1]; # string copy!
      my $Map = \($Web::Encoding::_Single::Decoder->{$_[0]->{key}});
      $s =~ s{([\x80-\xFF])}{substr $$Map, -0x80 + ord $1, 1}ge;
      while ($s =~ m{\x{FFFD}}g) {
        $_[0]->_onerror->(type => 'encoding:unassigned', level => 'm', fatal => 1,
                          index => $_[0]->{states}->{index} + $-[0],
                          value => substr $_[1], $-[0], 1);
      }
      $_[0]->{states}->{index} += length $_[1];
      return [$s];
    } elsif ($key eq 'utf-16be') {
      my $decoded = _decode_16 $_[0]->{states}, $_[0]->_onerror, $_[1], 0, 'n';
      if ($_[0]->{ignore_bom} and not $_[0]->{states}->{bom_seen}) {
        if (@$decoded) {
          if ($decoded->[0] =~ s/^\x{FEFF}//) {
            $_[0]->_onerror->(type => 'bom', level => 's', index => 0);
          }
          $_[0]->{states}->{bom_seen} = 1;
        }
      }
      return $decoded;
    } elsif ($key eq 'utf-16le') {
      my $decoded = _decode_16 $_[0]->{states}, $_[0]->_onerror, $_[1], 0, 'v';
      if ($_[0]->{ignore_bom} and not $_[0]->{states}->{bom_seen}) {
        if (@$decoded) {
          if ($decoded->[0] =~ s/^\x{FEFF}//) {
            $_[0]->_onerror->(type => 'bom', level => 's', index => 0);
          }
          $_[0]->{states}->{bom_seen} = 1;
        }
      }
      return $decoded;
    } elsif ($key eq 'gb18030' or $key eq 'gbk') {
      require Web::Encoding::_GB;
      return _decode_gb18030 $_[0]->{states}, $_[1], 0, $_[0]->_onerror;
    } elsif ($key eq 'big5') {
      require Web::Encoding::_Big5;
      return _decode_mb $_[0]->{states}, $_[1], 0, $_[0]->_onerror, \&_b5;
    } elsif ($key eq 'shift_jis') {
      require Web::Encoding::_JIS;
      return _decode_sjis $_[0]->{states}, $_[1], 0, $_[0]->_onerror;
    } elsif ($key eq 'euc-jp') {
      require Web::Encoding::_JIS;
      return _decode_eucjp $_[0]->{states}, $_[1], 0, $_[0]->_onerror;
    } elsif ($key eq 'euc-kr') {
      require Web::Encoding::_EUCKR;
      return _decode_mb $_[0]->{states}, $_[1], 0, $_[0]->_onerror, \&_kr;
    } elsif ($key eq 'iso-2022-jp') {
      require Web::Encoding::_JIS;
      return _decode_iso2022jp $_[0]->{states}, $_[1], 0, $_[0]->_onerror;
    } elsif ($key eq 'replacement') {
      if (not $_[0]->{states}->{written}) {
        $_[0]->{states}->{written} = 1;
        $_[0]->_onerror->(type => 'encoding:replacement', level => 'm', fatal => 1,
                          index => 0);
        return ["\x{FFFD}"];
      } else {
        return [];
      }
    } else {
      croak "Bad encoding key |$key|";
    }
  } # bytes
  
  sub eof ($) {
    my $key = $_[0]->{key};
    if ($key eq 'utf-8') {
      $_[0]->{states}->{index} = 0 unless defined $_[0]->{states}->{index};
      my $offset = $_[0]->{states}->{index} + (defined $_[0]->{states}->{lead} ? -length $_[0]->{states}->{lead} : 0);
      ## Returns zero or more U+FFFD.
      return [Web::Encoding::_decode8 ($_[0]->{states}, '', 1, $offset, $_[0]->_onerror)];
    } elsif ($key eq 'utf-16be') {
      my $decoded = _decode_16 $_[0]->{states}, $_[0]->_onerror, '', 1, 'n';
      if ($_[0]->{ignore_bom} and not $_[0]->{states}->{bom_seen}) {
        if (@$decoded) {
          if ($decoded->[0] =~ s/^\x{FEFF}//) {
            $_[0]->_onerror->(type => 'bom', level => 's', index => 0);
          }
          $_[0]->{states}->{bom_seen} = 1;
        }
      }
      return $decoded;
    } elsif ($key eq 'utf-16le') {
      my $decoded = _decode_16 $_[0]->{states}, $_[0]->_onerror, '', 1, 'v';
      if ($_[0]->{ignore_bom} and not $_[0]->{states}->{bom_seen}) {
        if (@$decoded) {
          if ($decoded->[0] =~ s/^\x{FEFF}//) {
            $_[0]->_onerror->(type => 'bom', level => 's', index => 0);
          }
          $_[0]->{states}->{bom_seen} = 1;
        }
      }
      return $decoded;
    } elsif ($key eq 'gb18030' or $key eq 'gbk') {
      require Web::Encoding::_GB;
      return _decode_gb18030 $_[0]->{states}, '', 1, $_[0]->_onerror;
    } elsif ($key eq 'big5') {
      require Web::Encoding::_Big5;
      return _decode_mb $_[0]->{states}, '', 1, $_[0]->_onerror, \&_b5;
    } elsif ($key eq 'shift_jis') {
      require Web::Encoding::_JIS;
      return _decode_sjis $_[0]->{states}, '', 1, $_[0]->_onerror;
    } elsif ($key eq 'euc-jp') {
      require Web::Encoding::_JIS;
      return _decode_eucjp $_[0]->{states}, '', 1, $_[0]->_onerror;
    } elsif ($key eq 'euc-kr') {
      require Web::Encoding::_EUCKR;
      return _decode_mb $_[0]->{states}, '', 1, $_[0]->_onerror, \&_kr;
    } elsif ($key eq 'iso-2022-jp') {
      require Web::Encoding::_JIS;
      return _decode_iso2022jp $_[0]->{states}, '', 1, $_[0]->_onerror;
    } elsif ($key eq 'replacement' or Web::Encoding::_is_single ($key)) {
      return [];
    } else {
      croak "Bad encoding key |$key|";
    }
  } # eof
  
  1;
  
  =head1 LICENSE
  
  Copyright 2011-2017 Wakaba <wakaba@suikawiki.org>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
WEB_ENCODING_DECODER

$fatpacked{"Web/Encoding/Sniffer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WEB_ENCODING_SNIFFER';
  package Web::Encoding::Sniffer;
  use strict;
  use warnings;
  our $VERSION = '1.0';
  use Web::Encoding;
  
  ## context
  ##   html         - HTML (navigate)
  ##   responsehtml - HTML (responseXML)
  ##   xml          - XML (navigate, responseXML, responseText)
  ##   css          - CSS
  ##   text         - text (navigate)
  ##   responsetext - non-XML (responseText)
  ##   classicscript - <script src> with type "classic"
  sub new_from_context ($$) {
    return bless {
      context => $_[1],
    }, $_[0];
  } # new_from_context
  
  sub confident ($) {
    return $_[0]->{confident};
  } # confident
  
  sub encoding ($) {
    return $_[0]->{encoding};
  } # encoding
  
  sub source ($) {
    return $_[0]->{source};
  } # source
  
  my $Prescanner = {};
  
  ## get an attribute
  ## <https://www.whatwg.org/specs/web-apps/current-work/#concept-get-attributes-when-sniffing>.
  sub _get_attr ($) {
    # 1.
    $_[0] =~ /\G[\x09\x0A\x0C\x0D\x20\x2F]+/gc;
  
    # 2.
    if ($_[0] =~ /\G>/gc) {
      pos ($_[0])--;
      return undef;
    }
    
    # 3.
    my $attr = {name => '', value => ''};
  
    # 4.-5.
    if ($_[0] =~ m{\G([^\x09\x0A\x0C\x0D\x20/>][^\x09\x0A\x0C\x0D\x20/>=]*)}gc) {
      $attr->{name} .= $1;
      $attr->{name} =~ tr/A-Z/a-z/;
    }
    return undef if $_[0] =~ m{\G\z}gc;
    return $attr if $_[0] =~ m{\G(?=[/>])}gc;
  
    # 6.
    $_[0] =~ m{\G[\x09\x0A\x0C\x0D\x20]+}gc;
  
    # 7.-8.
    return $attr unless $_[0] =~ m{\G=}gc;
  
    # 9.
    $_[0] =~ m{\G[\x09\x0A\x0C\x0D\x20]+}gc;
  
    # 10.-12.
    if ($_[0] =~ m{\G\x22([^\x22]*)\x22}gc) {
      $attr->{value} .= $1;
      $attr->{value} =~ tr/A-Z/a-z/;
    } elsif ($_[0] =~ m{\G\x27([^\x27]*)\x27}gc) {
      $attr->{value} .= $1;
      $attr->{value} =~ tr/A-Z/a-z/;
    } elsif ($_[0] =~ m{\G([^\x09\x0A\x0C\x0D\x20>]+)}gc) {
      $attr->{value} .= $1;
      $attr->{value} =~ tr/A-Z/a-z/;
    }
    return undef if $_[0] =~ m{\G\z}gc;
    return $attr;
  } # _get_attr
  
  ## <https://github.com/whatwg/html/pull/1752/files> as of Oct 2016
  sub _prescan_xml ($) {
    if ($_[0] =~ m{^\x3C\x3F\x78\x6D}) { # <?xm
      if ($_[0] =~ m{^
        \x3C\x3F\x78\x6D\x6C             # <?xml
        (?>[^\x3E]*?                     #    more restrictive than the spec
        \x65\x6E\x63\x6F\x64\x69\x6E\x67 # encoding
        )
        [\x00-\x20]* \x3D                # =
        [\x00-\x20]*                     #    not in the spec
        (?:                              #    more restrictive than the spec
          \x22                           # "
          ([^\x22\x3E]*)
          \x22
        |
          \x27                           # '
          ([^\x27\x3E]*)
          \x27
        )
        [^\x3E]*                         #    more restrictive than the spec
        \x3E                             # >
      }x) {
        my $name = encoding_label_to_name ($1 || $2);
        if (defined $name) {
          $name = 'utf-8' if is_utf16_encoding_key $name;
        }
        return $name;
      } else {
        return undef;
      }
    } elsif ($_[0] =~ m{^\x3C\x00\x3F\x00\x78\x00}) {
      return 'utf-16le';
    } elsif ($_[0] =~ m{^\x00\x3C\x00\x3F\x00\x78}) {
      return 'utf-16be';
    } else {
      return undef;
    }
  } # _prescan_xml
  
  ## prescan a byte stream to determine its encoding
  ## <https://www.whatwg.org/specs/web-apps/current-work/#prescan-a-byte-stream-to-determine-its-encoding>.
  sub _prescan_byte_stream ($) {
    my $xml_result = _prescan_xml $_[0];
    return $xml_result if defined $xml_result;
  
    # 1.
    (pos $_[0]) = 0;
  
    # 2.
    LOOP: {
      $_[0] =~ /\G<!--+>/gc;
      $_[0] =~ /\G<!--.*?-->/gcs;
      if ($_[0] =~ /\G<[Mm][Ee][Tt][Aa](?=[\x09\x0A\x0C\x0D\x20\x2F])/gc) {
        # 1.
        #
  
        # 2.-5.
        my $attr_list = {};
        my $got_pragma = 0;
        my $need_pragma = undef;
        my $charset;
  
        # 6.
        ATTRS: {
          my $attr = _get_attr ($_[0]) or last ATTRS;
  
          # 7.
          redo ATTRS if $attr_list->{$attr->{name}};
          
          # 8.
          $attr_list->{$attr->{name}} = $attr;
  
          # 9.
          if ($attr->{name} eq 'http-equiv') {
            $got_pragma = 1 if $attr->{value} eq 'content-type';
          } elsif ($attr->{name} eq 'content') {
            ## algorithm for extracting a character encoding from a
            ## |meta| element
            ## <https://www.whatwg.org/specs/web-apps/current-work/#algorithm-for-extracting-a-character-encoding-from-a-meta-element>.
            if (not defined $charset and
                $attr->{value} =~ /[Cc][Hh][Aa][Rr][Ss][Ee][Tt]
                                   [\x09\x0A\x0C\x0D\x20]*=
                                   [\x09\x0A\x0C\x0D\x20]*(?>"([^"]*)"|'([^']*)'|
                                   ([^"'\x09\x0A\x0C\x0D\x20]
                                    [^\x09\x0A\x0C\x0D\x20\x3B]*))/x) {
              $charset = encoding_label_to_name
                  (defined $1 ? $1 : defined $2 ? $2 : $3);
              $need_pragma = 1;
            }
          } elsif ($attr->{name} eq 'charset') {
            $charset = encoding_label_to_name $attr->{value};
            $need_pragma = 0;
          }
  
          # 10.
          return undef if pos $_[0] >= length $_[0];
          redo ATTRS;
        } # ATTRS
  
        # 11. Processing, 12.
        if (not defined $need_pragma or
            ($need_pragma and not $got_pragma)) {
          #
        } elsif (defined $charset) {
          # 13.-14.
          $charset = fixup_html_meta_encoding_name $charset;
  
          # 15.-16.
          return $charset if defined $charset;
        }
      } elsif ($_[0] =~ m{\G</?[A-Za-z][^\x09\x0A\x0C\x0D\x20>]*}gc) {
        {
          _get_attr ($_[0]) and redo;
        }
      } elsif ($_[0] =~ m{\G<[!/?][^>]*}gc) {
        #
      }
  
      # 3. Next byte
      $_[0] =~ /\G[^<]+/gc || $_[0] =~ /\G</gc;
      return undef if pos $_[0] >= length $_[0];
      redo LOOP;
    } # LOOP
  } # _prescan_byte_stream
  
  ## override  - override encoding label (valid or invalid) or undef
  ## transport - transport encoding label (valid or invalid) or undef
  ## reference - reference's encoding label (valid or invalid) or undef
  ## embed     - embedding context's encoding or undef
  ## locale    - user's locale's language tag in lowercase or undef
  sub detect ($$;%) {
    my ($self, undef, %args) = @_;
  
    ## BOM
    if ($_[1] =~ /^\xFE\xFF/) {
      $self->{encoding} = 'utf-16be';
      $self->{confident} = 1;
      $self->{source} = 'bom';
      return;
    } elsif ($_[1] =~ /^\xFF\xFE/) {
      $self->{encoding} = 'utf-16le';
      $self->{confident} = 1;
      $self->{source} = 'bom';
      return;
    } elsif ($_[1] =~ /^\xEF\xBB\xBF/) {
      $self->{encoding} = 'utf-8';
      $self->{confident} = 1;
      $self->{source} = 'bom';
      return;
    }
  
    ## Override
    if (defined $args{override}) {
      my $name = encoding_label_to_name $args{override};
      if (defined $name) {
        $self->{encoding} = $name;
        $self->{confident} = 1;
        $self->{source} = 'override';
        return;
      }
    } else {
  
      ## HTTP charset
      if (defined $args{transport}) {
        my $name = encoding_label_to_name $args{transport};
        if (defined $name) {
          $self->{encoding} = $name;
          $self->{confident} = 1;
          $self->{source} = 'transport';
          return;
        }
      }
  
      ## Prescan xml
      if ($self->{context} eq 'html' or
          $self->{context} eq 'responsehtml' or
          $self->{context} eq 'xml') {
        my $name = _prescan_xml $_[1];
        if (defined $name) {
          $self->{encoding} = $name;
          if ($self->{context} eq 'responsehtml') {
            $self->{confident} = 1;
          } else {
            delete $self->{confident};
          }
          $self->{source} = 'xml';
          return;
        }
      }
  
      ## Prescan html
      if ($self->{context} eq 'html' or
          $self->{context} eq 'responsehtml') {
        my $name = _prescan_byte_stream $_[1];
        if (defined $name) {
          $self->{encoding} = $name;
          if ($self->{context} eq 'responsehtml') {
            $self->{confident} = 1;
          } else {
            delete $self->{confident};
          }
          $self->{source} = 'html';
          return;
        }
      }
  
      if ($self->{context} eq 'css') {
        ## <https://drafts.csswg.org/css-syntax/#determine-the-fallback-encoding>
        if ($_[1] =~ /\A\x40\x63\x68\x61\x72\x73\x65\x74\x20\x22([\x00-\x21\x23-\x7F]*)\x22\x3B/) {
          my $name = encoding_label_to_name $1;
          if (defined $name) {
            $name = 'utf-8' if is_utf16_encoding_key $name;
            $self->{encoding} = $name;
            delete $self->{confident}; # in fact, irrelevant
            $self->{source} = 'css';
            return;
          }
        }
      }
  
      ## Environment - explicit
      if (defined $args{reference}) {
        my $name = encoding_label_to_name $args{reference};
        if (defined $name) {
          $self->{encoding} = $name;
          delete $self->{confident}; # in fact, irrelevant
          $self->{source} = 'reference';
          return;
        }
      }
  
      ## Environment - implicit
      if (defined $args{embed}) {
        $self->{encoding} = $args{embed};
        delete $self->{confident};
        $self->{source} = 'embed';
        return;
      }
  
      if ($self->{context} eq 'html' or $self->{context} eq 'text') {
        ## UNIVCHARDET
        require Web::Encoding::UnivCharDet;
        my $det = Web::Encoding::UnivCharDet->new;
        # XXX locale-dependent configuration
        my $name = encoding_label_to_name $det->detect_byte_string ($_[1]);
        if ($name) {
          $self->{encoding} = $name;
          delete $self->{confident};
          $self->{source} = 'univchardet';
          return;
        }
  
        ## Locale
        if (defined $args{locale}) {
          my $name = encoding_label_to_name (
            locale_default_encoding_name $args{locale} ||
            locale_default_encoding_name [split /-/, $args{locale}, 2]->[0]
          );
          $name = 'windows-1252' if not defined $name;
  
          $self->{encoding} = $name;
          delete $self->{confident};
          $self->{source} = 'locale';
          return;
        } else {
          $self->{encoding} = 'windows-1252';
          delete $self->{confident};
          $self->{source} = 'locale';
          return;
        }
      } # context = html | text
    }
  
    ## The encoding
    $self->{encoding} = 'utf-8';
    if ($self->{context} eq 'responsehtml') {
      $self->{confident} = 1;
    } else {
      delete $self->{confident};
    }
    $self->{source} = 'default';
    return;
  } # detect
  
  1;
  
  =head1 LICENSE
  
  Copyright 2007-2017 Wakaba <wakaba@suikawiki.org>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
WEB_ENCODING_SNIFFER

$fatpacked{"Web/Encoding/_Defs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WEB_ENCODING__DEFS';
  $Web::Encoding::_Defs = {
            "encodings" => {
                             "big5" => {
                                         "ascii_compat" => 1,
                                         "compat_name" => "Big5",
                                         "html_conformance" => "avoid",
                                         "html_decl_mapped" => "big5",
                                         "key" => "big5",
                                         "labels" => {
                                                       "big5" => {},
                                                       "big5-hkscs" => {},
                                                       "cn-big5" => {},
                                                       "csbig5" => {},
                                                       "x-x-big5" => {}
                                                     },
                                         "name" => "Big5",
                                         "output" => "big5"
                                       },
                             "euc-jp" => {
                                           "ascii_compat" => 1,
                                           "compat_name" => "EUC-JP",
                                           "html_conformance" => "avoid",
                                           "html_decl_mapped" => "euc-jp",
                                           "key" => "euc-jp",
                                           "labels" => {
                                                         "cseucpkdfmtjapanese" => {},
                                                         "euc-jp" => {},
                                                         "x-euc-jp" => {}
                                                       },
                                           "name" => "EUC-JP",
                                           "output" => "euc-jp"
                                         },
                             "euc-kr" => {
                                           "ascii_compat" => 1,
                                           "compat_name" => "EUC-KR",
                                           "html_conformance" => "avoid",
                                           "html_decl_mapped" => "euc-kr",
                                           "key" => "euc-kr",
                                           "labels" => {
                                                         "cseuckr" => {},
                                                         "csksc56011987" => {},
                                                         "euc-kr" => {},
                                                         "iso-ir-149" => {},
                                                         "korean" => {},
                                                         "ks_c_5601-1987" => {},
                                                         "ks_c_5601-1989" => {},
                                                         "ksc5601" => {},
                                                         "ksc_5601" => {},
                                                         "windows-949" => {}
                                                       },
                                           "name" => "EUC-KR",
                                           "output" => "euc-kr"
                                         },
                             "gb18030" => {
                                            "ascii_compat" => 1,
                                            "compat_name" => "gb18030",
                                            "html_conformance" => "avoid",
                                            "html_decl_mapped" => "gb18030",
                                            "key" => "gb18030",
                                            "labels" => {
                                                          "gb18030" => {}
                                                        },
                                            "name" => "gb18030",
                                            "output" => "gb18030"
                                          },
                             "gbk" => {
                                        "ascii_compat" => 1,
                                        "compat_name" => "GBK",
                                        "html_conformance" => "avoid",
                                        "html_decl_mapped" => "gbk",
                                        "key" => "gbk",
                                        "labels" => {
                                                      "chinese" => {},
                                                      "csgb2312" => {},
                                                      "csiso58gb231280" => {},
                                                      "gb2312" => {},
                                                      "gb_2312" => {},
                                                      "gb_2312-80" => {},
                                                      "gbk" => {},
                                                      "iso-ir-58" => {},
                                                      "x-gbk" => {}
                                                    },
                                        "name" => "GBK",
                                        "output" => "gbk"
                                      },
                             "ibm866" => {
                                           "ascii_compat" => 1,
                                           "compat_name" => "IBM866",
                                           "html_conformance" => "avoid",
                                           "html_decl_mapped" => "ibm866",
                                           "key" => "ibm866",
                                           "labels" => {
                                                         "866" => {},
                                                         "cp866" => {},
                                                         "csibm866" => {},
                                                         "ibm866" => {}
                                                       },
                                           "name" => "IBM866",
                                           "output" => "ibm866",
                                           "single_byte" => 1
                                         },
                             "iso-2022-jp" => {
                                                "ascii_compat" => 1,
                                                "compat_name" => "ISO-2022-JP",
                                                "html_conformance" => "bad",
                                                "html_decl_mapped" => "iso-2022-jp",
                                                "key" => "iso-2022-jp",
                                                "labels" => {
                                                              "csiso2022jp" => {},
                                                              "iso-2022-jp" => {}
                                                            },
                                                "name" => "ISO-2022-JP",
                                                "output" => "iso-2022-jp"
                                              },
                             "iso-8859-10" => {
                                                "ascii_compat" => 1,
                                                "compat_name" => "ISO-8859-10",
                                                "html_conformance" => "avoid",
                                                "html_decl_mapped" => "iso-8859-10",
                                                "key" => "iso-8859-10",
                                                "labels" => {
                                                              "csisolatin6" => {},
                                                              "iso-8859-10" => {},
                                                              "iso-ir-157" => {},
                                                              "iso8859-10" => {},
                                                              "iso885910" => {},
                                                              "l6" => {},
                                                              "latin6" => {}
                                                            },
                                                "name" => "ISO-8859-10",
                                                "output" => "iso-8859-10",
                                                "single_byte" => 1
                                              },
                             "iso-8859-13" => {
                                                "ascii_compat" => 1,
                                                "compat_name" => "ISO-8859-13",
                                                "html_conformance" => "avoid",
                                                "html_decl_mapped" => "iso-8859-13",
                                                "key" => "iso-8859-13",
                                                "labels" => {
                                                              "iso-8859-13" => {},
                                                              "iso8859-13" => {},
                                                              "iso885913" => {}
                                                            },
                                                "name" => "ISO-8859-13",
                                                "output" => "iso-8859-13",
                                                "single_byte" => 1
                                              },
                             "iso-8859-14" => {
                                                "ascii_compat" => 1,
                                                "compat_name" => "ISO-8859-14",
                                                "html_conformance" => "avoid",
                                                "html_decl_mapped" => "iso-8859-14",
                                                "key" => "iso-8859-14",
                                                "labels" => {
                                                              "iso-8859-14" => {},
                                                              "iso8859-14" => {},
                                                              "iso885914" => {}
                                                            },
                                                "name" => "ISO-8859-14",
                                                "output" => "iso-8859-14",
                                                "single_byte" => 1
                                              },
                             "iso-8859-15" => {
                                                "ascii_compat" => 1,
                                                "compat_name" => "ISO-8859-15",
                                                "html_conformance" => "avoid",
                                                "html_decl_mapped" => "iso-8859-15",
                                                "key" => "iso-8859-15",
                                                "labels" => {
                                                              "csisolatin9" => {},
                                                              "iso-8859-15" => {},
                                                              "iso8859-15" => {},
                                                              "iso885915" => {},
                                                              "iso_8859-15" => {},
                                                              "l9" => {}
                                                            },
                                                "name" => "ISO-8859-15",
                                                "output" => "iso-8859-15",
                                                "single_byte" => 1
                                              },
                             "iso-8859-16" => {
                                                "ascii_compat" => 1,
                                                "compat_name" => "ISO-8859-16",
                                                "html_conformance" => "avoid",
                                                "html_decl_mapped" => "iso-8859-16",
                                                "key" => "iso-8859-16",
                                                "labels" => {
                                                              "iso-8859-16" => {}
                                                            },
                                                "name" => "ISO-8859-16",
                                                "output" => "iso-8859-16",
                                                "single_byte" => 1
                                              },
                             "iso-8859-2" => {
                                               "ascii_compat" => 1,
                                               "compat_name" => "ISO-8859-2",
                                               "html_conformance" => "avoid",
                                               "html_decl_mapped" => "iso-8859-2",
                                               "key" => "iso-8859-2",
                                               "labels" => {
                                                             "csisolatin2" => {},
                                                             "iso-8859-2" => {},
                                                             "iso-ir-101" => {},
                                                             "iso8859-2" => {},
                                                             "iso88592" => {},
                                                             "iso_8859-2" => {},
                                                             "iso_8859-2:1987" => {},
                                                             "l2" => {},
                                                             "latin2" => {}
                                                           },
                                               "name" => "ISO-8859-2",
                                               "output" => "iso-8859-2",
                                               "single_byte" => 1
                                             },
                             "iso-8859-3" => {
                                               "ascii_compat" => 1,
                                               "compat_name" => "ISO-8859-3",
                                               "html_conformance" => "avoid",
                                               "html_decl_mapped" => "iso-8859-3",
                                               "key" => "iso-8859-3",
                                               "labels" => {
                                                             "csisolatin3" => {},
                                                             "iso-8859-3" => {},
                                                             "iso-ir-109" => {},
                                                             "iso8859-3" => {},
                                                             "iso88593" => {},
                                                             "iso_8859-3" => {},
                                                             "iso_8859-3:1988" => {},
                                                             "l3" => {},
                                                             "latin3" => {}
                                                           },
                                               "name" => "ISO-8859-3",
                                               "output" => "iso-8859-3",
                                               "single_byte" => 1
                                             },
                             "iso-8859-4" => {
                                               "ascii_compat" => 1,
                                               "compat_name" => "ISO-8859-4",
                                               "html_conformance" => "avoid",
                                               "html_decl_mapped" => "iso-8859-4",
                                               "key" => "iso-8859-4",
                                               "labels" => {
                                                             "csisolatin4" => {},
                                                             "iso-8859-4" => {},
                                                             "iso-ir-110" => {},
                                                             "iso8859-4" => {},
                                                             "iso88594" => {},
                                                             "iso_8859-4" => {},
                                                             "iso_8859-4:1988" => {},
                                                             "l4" => {},
                                                             "latin4" => {}
                                                           },
                                               "name" => "ISO-8859-4",
                                               "output" => "iso-8859-4",
                                               "single_byte" => 1
                                             },
                             "iso-8859-5" => {
                                               "ascii_compat" => 1,
                                               "compat_name" => "ISO-8859-5",
                                               "html_conformance" => "avoid",
                                               "html_decl_mapped" => "iso-8859-5",
                                               "key" => "iso-8859-5",
                                               "labels" => {
                                                             "csisolatincyrillic" => {},
                                                             "cyrillic" => {},
                                                             "iso-8859-5" => {},
                                                             "iso-ir-144" => {},
                                                             "iso8859-5" => {},
                                                             "iso88595" => {},
                                                             "iso_8859-5" => {},
                                                             "iso_8859-5:1988" => {}
                                                           },
                                               "name" => "ISO-8859-5",
                                               "output" => "iso-8859-5",
                                               "single_byte" => 1
                                             },
                             "iso-8859-6" => {
                                               "ascii_compat" => 1,
                                               "compat_name" => "ISO-8859-6",
                                               "html_conformance" => "avoid",
                                               "html_decl_mapped" => "iso-8859-6",
                                               "key" => "iso-8859-6",
                                               "labels" => {
                                                             "arabic" => {},
                                                             "asmo-708" => {},
                                                             "csiso88596e" => {},
                                                             "csiso88596i" => {},
                                                             "csisolatinarabic" => {},
                                                             "ecma-114" => {},
                                                             "iso-8859-6" => {},
                                                             "iso-8859-6-e" => {},
                                                             "iso-8859-6-i" => {},
                                                             "iso-ir-127" => {},
                                                             "iso8859-6" => {},
                                                             "iso88596" => {},
                                                             "iso_8859-6" => {},
                                                             "iso_8859-6:1987" => {}
                                                           },
                                               "name" => "ISO-8859-6",
                                               "output" => "iso-8859-6",
                                               "single_byte" => 1
                                             },
                             "iso-8859-7" => {
                                               "ascii_compat" => 1,
                                               "compat_name" => "ISO-8859-7",
                                               "html_conformance" => "avoid",
                                               "html_decl_mapped" => "iso-8859-7",
                                               "key" => "iso-8859-7",
                                               "labels" => {
                                                             "csisolatingreek" => {},
                                                             "ecma-118" => {},
                                                             "elot_928" => {},
                                                             "greek" => {},
                                                             "greek8" => {},
                                                             "iso-8859-7" => {},
                                                             "iso-ir-126" => {},
                                                             "iso8859-7" => {},
                                                             "iso88597" => {},
                                                             "iso_8859-7" => {},
                                                             "iso_8859-7:1987" => {},
                                                             "sun_eu_greek" => {}
                                                           },
                                               "name" => "ISO-8859-7",
                                               "output" => "iso-8859-7",
                                               "single_byte" => 1
                                             },
                             "iso-8859-8" => {
                                               "ascii_compat" => 1,
                                               "compat_name" => "ISO-8859-8",
                                               "html_conformance" => "avoid",
                                               "html_decl_mapped" => "iso-8859-8",
                                               "key" => "iso-8859-8",
                                               "labels" => {
                                                             "csiso88598e" => {},
                                                             "csisolatinhebrew" => {},
                                                             "hebrew" => {},
                                                             "iso-8859-8" => {},
                                                             "iso-8859-8-e" => {},
                                                             "iso-ir-138" => {},
                                                             "iso8859-8" => {},
                                                             "iso88598" => {},
                                                             "iso_8859-8" => {},
                                                             "iso_8859-8:1988" => {},
                                                             "visual" => {}
                                                           },
                                               "name" => "ISO-8859-8",
                                               "output" => "iso-8859-8",
                                               "single_byte" => 1
                                             },
                             "iso-8859-8-i" => {
                                                 "ascii_compat" => 1,
                                                 "compat_name" => "ISO-8859-8-I",
                                                 "html_conformance" => "avoid",
                                                 "html_decl_mapped" => "iso-8859-8-i",
                                                 "key" => "iso-8859-8-i",
                                                 "labels" => {
                                                               "csiso88598i" => {},
                                                               "iso-8859-8-i" => {},
                                                               "logical" => {}
                                                             },
                                                 "name" => "ISO-8859-8-I",
                                                 "output" => "iso-8859-8-i",
                                                 "single_byte" => 1
                                               },
                             "koi8-r" => {
                                           "ascii_compat" => 1,
                                           "compat_name" => "KOI8-R",
                                           "html_conformance" => "avoid",
                                           "html_decl_mapped" => "koi8-r",
                                           "key" => "koi8-r",
                                           "labels" => {
                                                         "cskoi8r" => {},
                                                         "koi" => {},
                                                         "koi8" => {},
                                                         "koi8-r" => {},
                                                         "koi8_r" => {}
                                                       },
                                           "name" => "KOI8-R",
                                           "output" => "koi8-r",
                                           "single_byte" => 1
                                         },
                             "koi8-u" => {
                                           "ascii_compat" => 1,
                                           "compat_name" => "KOI8-U",
                                           "html_conformance" => "avoid",
                                           "html_decl_mapped" => "koi8-u",
                                           "key" => "koi8-u",
                                           "labels" => {
                                                         "koi8-ru" => {},
                                                         "koi8-u" => {}
                                                       },
                                           "name" => "KOI8-U",
                                           "output" => "koi8-u",
                                           "single_byte" => 1
                                         },
                             "macintosh" => {
                                              "ascii_compat" => 1,
                                              "compat_name" => "macintosh",
                                              "html_conformance" => "avoid",
                                              "html_decl_mapped" => "macintosh",
                                              "key" => "macintosh",
                                              "labels" => {
                                                            "csmacintosh" => {},
                                                            "mac" => {},
                                                            "macintosh" => {},
                                                            "x-mac-roman" => {}
                                                          },
                                              "name" => "macintosh",
                                              "output" => "macintosh",
                                              "single_byte" => 1
                                            },
                             "replacement" => {
                                                "ascii_compat" => 1,
                                                "compat_name" => "replacement",
                                                "html_conformance" => "broken",
                                                "html_decl_mapped" => "replacement",
                                                "key" => "replacement",
                                                "labels" => {
                                                              "csiso2022kr" => {},
                                                              "hz-gb-2312" => {},
                                                              "iso-2022-cn" => {},
                                                              "iso-2022-cn-ext" => {},
                                                              "iso-2022-kr" => {},
                                                              "replacement" => {}
                                                            },
                                                "name" => "replacement",
                                                "output" => "utf-8"
                                              },
                             "shift_jis" => {
                                              "ascii_compat" => 1,
                                              "compat_name" => "Shift_JIS",
                                              "html_conformance" => "avoid",
                                              "html_decl_mapped" => "shift_jis",
                                              "key" => "shift_jis",
                                              "labels" => {
                                                            "csshiftjis" => {},
                                                            "ms932" => {},
                                                            "ms_kanji" => {},
                                                            "shift-jis" => {},
                                                            "shift_jis" => {},
                                                            "sjis" => {},
                                                            "windows-31j" => {},
                                                            "x-sjis" => {}
                                                          },
                                              "name" => "Shift_JIS",
                                              "output" => "shift_jis"
                                            },
                             "utf-16be" => {
                                             "ascii_compat" => 0,
                                             "compat_name" => "UTF-16BE",
                                             "html_conformance" => "avoid",
                                             "html_decl_mapped" => "utf-8",
                                             "key" => "utf-16be",
                                             "labels" => {
                                                           "unicodefffe" => {},
                                                           "utf-16be" => {}
                                                         },
                                             "name" => "UTF-16BE",
                                             "output" => "utf-8",
                                             "utf16" => 1
                                           },
                             "utf-16le" => {
                                             "ascii_compat" => 0,
                                             "compat_name" => "UTF-16LE",
                                             "html_conformance" => "avoid",
                                             "html_decl_mapped" => "utf-8",
                                             "key" => "utf-16le",
                                             "labels" => {
                                                           "csunicode" => {},
                                                           "iso-10646-ucs-2" => {},
                                                           "ucs-2" => {},
                                                           "unicode" => {},
                                                           "unicodefeff" => {},
                                                           "utf-16" => {},
                                                           "utf-16le" => {}
                                                         },
                                             "name" => "UTF-16LE",
                                             "output" => "utf-8",
                                             "utf16" => 1
                                           },
                             "utf-8" => {
                                          "ascii_compat" => 1,
                                          "compat_name" => "UTF-8",
                                          "conforming" => 1,
                                          "html_conformance" => "good",
                                          "html_decl_mapped" => "utf-8",
                                          "key" => "utf-8",
                                          "labels" => {
                                                        "unicode-1-1-utf-8" => {},
                                                        "unicode11utf8" => {},
                                                        "unicode20utf8" => {},
                                                        "utf-8" => {
                                                                     "conforming" => 1
                                                                   },
                                                        "utf8" => {},
                                                        "x-unicode20utf8" => {}
                                                      },
                                          "name" => "UTF-8",
                                          "output" => "utf-8"
                                        },
                             "windows-1250" => {
                                                 "ascii_compat" => 1,
                                                 "compat_name" => "windows-1250",
                                                 "html_conformance" => "avoid",
                                                 "html_decl_mapped" => "windows-1250",
                                                 "key" => "windows-1250",
                                                 "labels" => {
                                                               "cp1250" => {},
                                                               "windows-1250" => {},
                                                               "x-cp1250" => {}
                                                             },
                                                 "name" => "windows-1250",
                                                 "output" => "windows-1250",
                                                 "single_byte" => 1
                                               },
                             "windows-1251" => {
                                                 "ascii_compat" => 1,
                                                 "compat_name" => "windows-1251",
                                                 "html_conformance" => "avoid",
                                                 "html_decl_mapped" => "windows-1251",
                                                 "key" => "windows-1251",
                                                 "labels" => {
                                                               "cp1251" => {},
                                                               "windows-1251" => {},
                                                               "x-cp1251" => {}
                                                             },
                                                 "name" => "windows-1251",
                                                 "output" => "windows-1251",
                                                 "single_byte" => 1
                                               },
                             "windows-1252" => {
                                                 "ascii_compat" => 1,
                                                 "compat_name" => "windows-1252",
                                                 "html_conformance" => "avoid",
                                                 "html_decl_mapped" => "windows-1252",
                                                 "key" => "windows-1252",
                                                 "labels" => {
                                                               "ansi_x3.4-1968" => {},
                                                               "ascii" => {},
                                                               "cp1252" => {},
                                                               "cp819" => {},
                                                               "csisolatin1" => {},
                                                               "ibm819" => {},
                                                               "iso-8859-1" => {},
                                                               "iso-ir-100" => {},
                                                               "iso8859-1" => {},
                                                               "iso88591" => {},
                                                               "iso_8859-1" => {},
                                                               "iso_8859-1:1987" => {},
                                                               "l1" => {},
                                                               "latin1" => {},
                                                               "us-ascii" => {},
                                                               "windows-1252" => {},
                                                               "x-cp1252" => {}
                                                             },
                                                 "name" => "windows-1252",
                                                 "output" => "windows-1252",
                                                 "single_byte" => 1
                                               },
                             "windows-1253" => {
                                                 "ascii_compat" => 1,
                                                 "compat_name" => "windows-1253",
                                                 "html_conformance" => "avoid",
                                                 "html_decl_mapped" => "windows-1253",
                                                 "key" => "windows-1253",
                                                 "labels" => {
                                                               "cp1253" => {},
                                                               "windows-1253" => {},
                                                               "x-cp1253" => {}
                                                             },
                                                 "name" => "windows-1253",
                                                 "output" => "windows-1253",
                                                 "single_byte" => 1
                                               },
                             "windows-1254" => {
                                                 "ascii_compat" => 1,
                                                 "compat_name" => "windows-1254",
                                                 "html_conformance" => "avoid",
                                                 "html_decl_mapped" => "windows-1254",
                                                 "key" => "windows-1254",
                                                 "labels" => {
                                                               "cp1254" => {},
                                                               "csisolatin5" => {},
                                                               "iso-8859-9" => {},
                                                               "iso-ir-148" => {},
                                                               "iso8859-9" => {},
                                                               "iso88599" => {},
                                                               "iso_8859-9" => {},
                                                               "iso_8859-9:1989" => {},
                                                               "l5" => {},
                                                               "latin5" => {},
                                                               "windows-1254" => {},
                                                               "x-cp1254" => {}
                                                             },
                                                 "name" => "windows-1254",
                                                 "output" => "windows-1254",
                                                 "single_byte" => 1
                                               },
                             "windows-1255" => {
                                                 "ascii_compat" => 1,
                                                 "compat_name" => "windows-1255",
                                                 "html_conformance" => "avoid",
                                                 "html_decl_mapped" => "windows-1255",
                                                 "key" => "windows-1255",
                                                 "labels" => {
                                                               "cp1255" => {},
                                                               "windows-1255" => {},
                                                               "x-cp1255" => {}
                                                             },
                                                 "name" => "windows-1255",
                                                 "output" => "windows-1255",
                                                 "single_byte" => 1
                                               },
                             "windows-1256" => {
                                                 "ascii_compat" => 1,
                                                 "compat_name" => "windows-1256",
                                                 "html_conformance" => "avoid",
                                                 "html_decl_mapped" => "windows-1256",
                                                 "key" => "windows-1256",
                                                 "labels" => {
                                                               "cp1256" => {},
                                                               "windows-1256" => {},
                                                               "x-cp1256" => {}
                                                             },
                                                 "name" => "windows-1256",
                                                 "output" => "windows-1256",
                                                 "single_byte" => 1
                                               },
                             "windows-1257" => {
                                                 "ascii_compat" => 1,
                                                 "compat_name" => "windows-1257",
                                                 "html_conformance" => "avoid",
                                                 "html_decl_mapped" => "windows-1257",
                                                 "key" => "windows-1257",
                                                 "labels" => {
                                                               "cp1257" => {},
                                                               "windows-1257" => {},
                                                               "x-cp1257" => {}
                                                             },
                                                 "name" => "windows-1257",
                                                 "output" => "windows-1257",
                                                 "single_byte" => 1
                                               },
                             "windows-1258" => {
                                                 "ascii_compat" => 1,
                                                 "compat_name" => "windows-1258",
                                                 "html_conformance" => "avoid",
                                                 "html_decl_mapped" => "windows-1258",
                                                 "key" => "windows-1258",
                                                 "labels" => {
                                                               "cp1258" => {},
                                                               "windows-1258" => {},
                                                               "x-cp1258" => {}
                                                             },
                                                 "name" => "windows-1258",
                                                 "output" => "windows-1258",
                                                 "single_byte" => 1
                                               },
                             "windows-874" => {
                                                "ascii_compat" => 1,
                                                "compat_name" => "windows-874",
                                                "html_conformance" => "avoid",
                                                "html_decl_mapped" => "windows-874",
                                                "key" => "windows-874",
                                                "labels" => {
                                                              "dos-874" => {},
                                                              "iso-8859-11" => {},
                                                              "iso8859-11" => {},
                                                              "iso885911" => {},
                                                              "tis-620" => {},
                                                              "windows-874" => {}
                                                            },
                                                "name" => "windows-874",
                                                "output" => "windows-874",
                                                "single_byte" => 1
                                              },
                             "x-mac-cyrillic" => {
                                                   "ascii_compat" => 1,
                                                   "compat_name" => "x-mac-cyrillic",
                                                   "html_conformance" => "avoid",
                                                   "html_decl_mapped" => "x-mac-cyrillic",
                                                   "key" => "x-mac-cyrillic",
                                                   "labels" => {
                                                                 "x-mac-cyrillic" => {},
                                                                 "x-mac-ukrainian" => {}
                                                               },
                                                   "name" => "x-mac-cyrillic",
                                                   "output" => "x-mac-cyrillic",
                                                   "single_byte" => 1
                                                 },
                             "x-user-defined" => {
                                                   "ascii_compat" => 1,
                                                   "compat_name" => "x-user-defined",
                                                   "html_conformance" => "avoid",
                                                   "html_decl_mapped" => "windows-1252",
                                                   "key" => "x-user-defined",
                                                   "labels" => {
                                                                 "x-user-defined" => {}
                                                               },
                                                   "name" => "x-user-defined",
                                                   "output" => "x-user-defined",
                                                   "single_byte" => 1
                                                 }
                           },
            "html_decl_map" => {
                                 "utf-16be" => "utf-8",
                                 "utf-16le" => "utf-8",
                                 "x-user-defined" => "windows-1252"
                               },
            "locale_default" => {
                                  "*" => "windows-1252",
                                  "ar" => "windows-1256",
                                  "ba" => "windows-1251",
                                  "be" => "windows-1251",
                                  "bg" => "windows-1251",
                                  "cs" => "windows-1250",
                                  "el" => "iso-8859-7",
                                  "et" => "windows-1257",
                                  "fa" => "windows-1256",
                                  "he" => "windows-1255",
                                  "hr" => "windows-1250",
                                  "hu" => "iso-8859-2",
                                  "ja" => "shift_jis",
                                  "kk" => "windows-1251",
                                  "ko" => "euc-kr",
                                  "ku" => "windows-1254",
                                  "ky" => "windows-1251",
                                  "lt" => "windows-1257",
                                  "lv" => "windows-1257",
                                  "mk" => "windows-1251",
                                  "pl" => "iso-8859-2",
                                  "ru" => "windows-1251",
                                  "sah" => "windows-1251",
                                  "sk" => "windows-1250",
                                  "sl" => "iso-8859-2",
                                  "sr" => "windows-1251",
                                  "tg" => "windows-1251",
                                  "th" => "windows-874",
                                  "tr" => "windows-1254",
                                  "tt" => "windows-1251",
                                  "uk" => "windows-1251",
                                  "vi" => "windows-1258",
                                  "zh-cn" => "gb18030",
                                  "zh-tw" => "big5"
                                },
            "names" => [
                         "utf-8",
                         "big5",
                         "euc-jp",
                         "euc-kr",
                         "gb18030",
                         "gbk",
                         "ibm866",
                         "iso-2022-jp",
                         "iso-8859-10",
                         "iso-8859-13",
                         "iso-8859-14",
                         "iso-8859-15",
                         "iso-8859-16",
                         "iso-8859-2",
                         "iso-8859-3",
                         "iso-8859-4",
                         "iso-8859-5",
                         "iso-8859-6",
                         "iso-8859-7",
                         "iso-8859-8",
                         "iso-8859-8-i",
                         "koi8-r",
                         "koi8-u",
                         "macintosh",
                         "shift_jis",
                         "utf-16be",
                         "utf-16le",
                         "windows-1250",
                         "windows-1251",
                         "windows-1252",
                         "windows-1253",
                         "windows-1254",
                         "windows-1255",
                         "windows-1256",
                         "windows-1257",
                         "windows-1258",
                         "windows-874",
                         "x-mac-cyrillic",
                         "x-user-defined",
                         "replacement"
                       ],
            "supported_labels" => {
                                    "866" => "ibm866",
                                    "ansi_x3.4-1968" => "windows-1252",
                                    "arabic" => "iso-8859-6",
                                    "ascii" => "windows-1252",
                                    "asmo-708" => "iso-8859-6",
                                    "big5" => "big5",
                                    "big5-hkscs" => "big5",
                                    "chinese" => "gbk",
                                    "cn-big5" => "big5",
                                    "cp1250" => "windows-1250",
                                    "cp1251" => "windows-1251",
                                    "cp1252" => "windows-1252",
                                    "cp1253" => "windows-1253",
                                    "cp1254" => "windows-1254",
                                    "cp1255" => "windows-1255",
                                    "cp1256" => "windows-1256",
                                    "cp1257" => "windows-1257",
                                    "cp1258" => "windows-1258",
                                    "cp819" => "windows-1252",
                                    "cp866" => "ibm866",
                                    "csbig5" => "big5",
                                    "cseuckr" => "euc-kr",
                                    "cseucpkdfmtjapanese" => "euc-jp",
                                    "csgb2312" => "gbk",
                                    "csibm866" => "ibm866",
                                    "csiso2022jp" => "iso-2022-jp",
                                    "csiso2022kr" => "replacement",
                                    "csiso58gb231280" => "gbk",
                                    "csiso88596e" => "iso-8859-6",
                                    "csiso88596i" => "iso-8859-6",
                                    "csiso88598e" => "iso-8859-8",
                                    "csiso88598i" => "iso-8859-8-i",
                                    "csisolatin1" => "windows-1252",
                                    "csisolatin2" => "iso-8859-2",
                                    "csisolatin3" => "iso-8859-3",
                                    "csisolatin4" => "iso-8859-4",
                                    "csisolatin5" => "windows-1254",
                                    "csisolatin6" => "iso-8859-10",
                                    "csisolatin9" => "iso-8859-15",
                                    "csisolatinarabic" => "iso-8859-6",
                                    "csisolatincyrillic" => "iso-8859-5",
                                    "csisolatingreek" => "iso-8859-7",
                                    "csisolatinhebrew" => "iso-8859-8",
                                    "cskoi8r" => "koi8-r",
                                    "csksc56011987" => "euc-kr",
                                    "csmacintosh" => "macintosh",
                                    "csshiftjis" => "shift_jis",
                                    "csunicode" => "utf-16le",
                                    "cyrillic" => "iso-8859-5",
                                    "dos-874" => "windows-874",
                                    "ecma-114" => "iso-8859-6",
                                    "ecma-118" => "iso-8859-7",
                                    "elot_928" => "iso-8859-7",
                                    "euc-jp" => "euc-jp",
                                    "euc-kr" => "euc-kr",
                                    "gb18030" => "gb18030",
                                    "gb2312" => "gbk",
                                    "gb_2312" => "gbk",
                                    "gb_2312-80" => "gbk",
                                    "gbk" => "gbk",
                                    "greek" => "iso-8859-7",
                                    "greek8" => "iso-8859-7",
                                    "hebrew" => "iso-8859-8",
                                    "hz-gb-2312" => "replacement",
                                    "ibm819" => "windows-1252",
                                    "ibm866" => "ibm866",
                                    "iso-10646-ucs-2" => "utf-16le",
                                    "iso-2022-cn" => "replacement",
                                    "iso-2022-cn-ext" => "replacement",
                                    "iso-2022-jp" => "iso-2022-jp",
                                    "iso-2022-kr" => "replacement",
                                    "iso-8859-1" => "windows-1252",
                                    "iso-8859-10" => "iso-8859-10",
                                    "iso-8859-11" => "windows-874",
                                    "iso-8859-13" => "iso-8859-13",
                                    "iso-8859-14" => "iso-8859-14",
                                    "iso-8859-15" => "iso-8859-15",
                                    "iso-8859-16" => "iso-8859-16",
                                    "iso-8859-2" => "iso-8859-2",
                                    "iso-8859-3" => "iso-8859-3",
                                    "iso-8859-4" => "iso-8859-4",
                                    "iso-8859-5" => "iso-8859-5",
                                    "iso-8859-6" => "iso-8859-6",
                                    "iso-8859-6-e" => "iso-8859-6",
                                    "iso-8859-6-i" => "iso-8859-6",
                                    "iso-8859-7" => "iso-8859-7",
                                    "iso-8859-8" => "iso-8859-8",
                                    "iso-8859-8-e" => "iso-8859-8",
                                    "iso-8859-8-i" => "iso-8859-8-i",
                                    "iso-8859-9" => "windows-1254",
                                    "iso-ir-100" => "windows-1252",
                                    "iso-ir-101" => "iso-8859-2",
                                    "iso-ir-109" => "iso-8859-3",
                                    "iso-ir-110" => "iso-8859-4",
                                    "iso-ir-126" => "iso-8859-7",
                                    "iso-ir-127" => "iso-8859-6",
                                    "iso-ir-138" => "iso-8859-8",
                                    "iso-ir-144" => "iso-8859-5",
                                    "iso-ir-148" => "windows-1254",
                                    "iso-ir-149" => "euc-kr",
                                    "iso-ir-157" => "iso-8859-10",
                                    "iso-ir-58" => "gbk",
                                    "iso8859-1" => "windows-1252",
                                    "iso8859-10" => "iso-8859-10",
                                    "iso8859-11" => "windows-874",
                                    "iso8859-13" => "iso-8859-13",
                                    "iso8859-14" => "iso-8859-14",
                                    "iso8859-15" => "iso-8859-15",
                                    "iso8859-2" => "iso-8859-2",
                                    "iso8859-3" => "iso-8859-3",
                                    "iso8859-4" => "iso-8859-4",
                                    "iso8859-5" => "iso-8859-5",
                                    "iso8859-6" => "iso-8859-6",
                                    "iso8859-7" => "iso-8859-7",
                                    "iso8859-8" => "iso-8859-8",
                                    "iso8859-9" => "windows-1254",
                                    "iso88591" => "windows-1252",
                                    "iso885910" => "iso-8859-10",
                                    "iso885911" => "windows-874",
                                    "iso885913" => "iso-8859-13",
                                    "iso885914" => "iso-8859-14",
                                    "iso885915" => "iso-8859-15",
                                    "iso88592" => "iso-8859-2",
                                    "iso88593" => "iso-8859-3",
                                    "iso88594" => "iso-8859-4",
                                    "iso88595" => "iso-8859-5",
                                    "iso88596" => "iso-8859-6",
                                    "iso88597" => "iso-8859-7",
                                    "iso88598" => "iso-8859-8",
                                    "iso88599" => "windows-1254",
                                    "iso_8859-1" => "windows-1252",
                                    "iso_8859-15" => "iso-8859-15",
                                    "iso_8859-1:1987" => "windows-1252",
                                    "iso_8859-2" => "iso-8859-2",
                                    "iso_8859-2:1987" => "iso-8859-2",
                                    "iso_8859-3" => "iso-8859-3",
                                    "iso_8859-3:1988" => "iso-8859-3",
                                    "iso_8859-4" => "iso-8859-4",
                                    "iso_8859-4:1988" => "iso-8859-4",
                                    "iso_8859-5" => "iso-8859-5",
                                    "iso_8859-5:1988" => "iso-8859-5",
                                    "iso_8859-6" => "iso-8859-6",
                                    "iso_8859-6:1987" => "iso-8859-6",
                                    "iso_8859-7" => "iso-8859-7",
                                    "iso_8859-7:1987" => "iso-8859-7",
                                    "iso_8859-8" => "iso-8859-8",
                                    "iso_8859-8:1988" => "iso-8859-8",
                                    "iso_8859-9" => "windows-1254",
                                    "iso_8859-9:1989" => "windows-1254",
                                    "koi" => "koi8-r",
                                    "koi8" => "koi8-r",
                                    "koi8-r" => "koi8-r",
                                    "koi8-ru" => "koi8-u",
                                    "koi8-u" => "koi8-u",
                                    "koi8_r" => "koi8-r",
                                    "korean" => "euc-kr",
                                    "ks_c_5601-1987" => "euc-kr",
                                    "ks_c_5601-1989" => "euc-kr",
                                    "ksc5601" => "euc-kr",
                                    "ksc_5601" => "euc-kr",
                                    "l1" => "windows-1252",
                                    "l2" => "iso-8859-2",
                                    "l3" => "iso-8859-3",
                                    "l4" => "iso-8859-4",
                                    "l5" => "windows-1254",
                                    "l6" => "iso-8859-10",
                                    "l9" => "iso-8859-15",
                                    "latin1" => "windows-1252",
                                    "latin2" => "iso-8859-2",
                                    "latin3" => "iso-8859-3",
                                    "latin4" => "iso-8859-4",
                                    "latin5" => "windows-1254",
                                    "latin6" => "iso-8859-10",
                                    "logical" => "iso-8859-8-i",
                                    "mac" => "macintosh",
                                    "macintosh" => "macintosh",
                                    "ms932" => "shift_jis",
                                    "ms_kanji" => "shift_jis",
                                    "replacement" => "replacement",
                                    "shift-jis" => "shift_jis",
                                    "shift_jis" => "shift_jis",
                                    "sjis" => "shift_jis",
                                    "sun_eu_greek" => "iso-8859-7",
                                    "tis-620" => "windows-874",
                                    "ucs-2" => "utf-16le",
                                    "unicode" => "utf-16le",
                                    "unicode-1-1-utf-8" => "utf-8",
                                    "unicode11utf8" => "utf-8",
                                    "unicode20utf8" => "utf-8",
                                    "unicodefeff" => "utf-16le",
                                    "unicodefffe" => "utf-16be",
                                    "us-ascii" => "windows-1252",
                                    "utf-16" => "utf-16le",
                                    "utf-16be" => "utf-16be",
                                    "utf-16le" => "utf-16le",
                                    "utf-8" => "utf-8",
                                    "utf8" => "utf-8",
                                    "visual" => "iso-8859-8",
                                    "windows-1250" => "windows-1250",
                                    "windows-1251" => "windows-1251",
                                    "windows-1252" => "windows-1252",
                                    "windows-1253" => "windows-1253",
                                    "windows-1254" => "windows-1254",
                                    "windows-1255" => "windows-1255",
                                    "windows-1256" => "windows-1256",
                                    "windows-1257" => "windows-1257",
                                    "windows-1258" => "windows-1258",
                                    "windows-31j" => "shift_jis",
                                    "windows-874" => "windows-874",
                                    "windows-949" => "euc-kr",
                                    "x-cp1250" => "windows-1250",
                                    "x-cp1251" => "windows-1251",
                                    "x-cp1252" => "windows-1252",
                                    "x-cp1253" => "windows-1253",
                                    "x-cp1254" => "windows-1254",
                                    "x-cp1255" => "windows-1255",
                                    "x-cp1256" => "windows-1256",
                                    "x-cp1257" => "windows-1257",
                                    "x-cp1258" => "windows-1258",
                                    "x-euc-jp" => "euc-jp",
                                    "x-gbk" => "gbk",
                                    "x-mac-cyrillic" => "x-mac-cyrillic",
                                    "x-mac-roman" => "macintosh",
                                    "x-mac-ukrainian" => "x-mac-cyrillic",
                                    "x-sjis" => "shift_jis",
                                    "x-unicode20utf8" => "utf-8",
                                    "x-user-defined" => "x-user-defined",
                                    "x-x-big5" => "big5"
                                  }
          };
  
WEB_ENCODING__DEFS

$fatpacked{"Web/HTML/Parser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WEB_HTML_PARSER';
  
      package Web::HTML::Parser;
      use strict;
      use warnings;
      no warnings 'utf8';
      use warnings FATAL => 'recursion';
      use warnings FATAL => 'redefine';
      use warnings FATAL => 'uninitialized';
      use utf8;
      our $VERSION = '9.0';
      use Carp qw(croak);
      
      use Web::Encoding;
      use Web::Encoding::Sniffer;
      use Web::Encoding::Decoder;
      use Web::HTML::ParserData;
      use Web::HTML::_SyntaxDefs;
  
      
      sub HTMLNS () { 1 }
      sub SVGNS () { 2 }
      sub MATHMLNS () { 3 }
      my $NSToURL = [
        undef,
        'http://www.w3.org/1999/xhtml',
        'http://www.w3.org/2000/svg',
        'http://www.w3.org/1998/Math/MathML',
      ];
      my $ForeignAttrMap = [
        undef, undef,
        $Web::HTML::ParserData::ForeignAttrNameToArgs->{'http://www.w3.org/2000/svg'},
        $Web::HTML::ParserData::ForeignAttrNameToArgs->{'http://www.w3.org/1998/Math/MathML'},
      ];
        
      my $TagName2Group = {};
  
      ## ------ Common handlers ------
  
      sub new ($) {
        return bless {
          ## Input parameters
          # Scripting IframeSrcdoc DI known_definite_encoding locale_tag
          # di_data_set is_sub_parser is_xhr
  
          ## Callbacks
          # onerror onerrors onappcacheselection onscript
          # onelementspopped onrestartwithencoding
          # onextentref onparsed
  
          ## Parser internal states
          # input_stream input_encoding saved_states saved_lists saved_maps
          # nodes document can_restart restart
          # parse_bytes_started transport_encoding_label
          # byte_bufer byte_buffer_orig
          # decoder
        }, $_[0];
      } # new
  
  my $GetDefaultErrorHandler = sub {
    my $dids = $_[0]->di_data_set;
    return sub {
      my $error = {@_};
      require Web::HTML::SourceMap;
      my ($di, $index) = Web::HTML::SourceMap::resolve_index_pair ($dids, $error->{di}, $error->{index});
      my $text = defined $error->{text} ? qq{ - $error->{text}} : '';
      my $value = defined $error->{value} ? qq{ "$error->{value}"} : '';
      my $level = {
        m => 'Parse error',
        s => 'SHOULD-level error',
        w => 'Warning',
        i => 'Information',
      }->{$error->{level} || ''} || $error->{level};
      my $doc = 'document #' . $error->{di};
      if (not $di == -1) {
        my $did = $dids->[$di];
        if (defined $did->{name}) {
          $doc = $did->{name};
        } elsif (defined $did->{url}) {
          $doc = 'document <' . $did->{url} . '>';
        }
      }
      warn "$level ($error->{type}$text) at $doc index $index$value\n";
    };
  }; # $GetDefaultErrorHandler
  
  sub onerror ($;$) {
    if (@_ > 1) {
      $_[0]->{onerror} = $_[1];
    }
    return $_[0]->{onerror} ||= $GetDefaultErrorHandler->($_[0]);
  } # onerror
  
  sub onerrors ($;$) {
    if (@_ > 1) {
      $_[0]->{onerrors} = $_[1];
    }
    return $_[0]->{onerrors} || sub {
      my $onerror = $_[0]->onerror;
      $onerror->(%$_) for @{$_[1]};
    };
  } # onerrors
  
  sub onappcacheselection ($;$) {
    if (@_ > 1) {
      $_[0]->{onappcacheselection} = $_[1];
    }
    return $_[0]->{onappcacheselection} || sub { };
  } # onappcacheselection
  
  sub onscript ($;$) {
    if (@_ > 1) {
      $_[0]->{onscript} = $_[1];
    }
    return $_[0]->{onscript} || sub { };
  } # onscript
  
  sub onextentref ($;$) {
    if (@_ > 1) {
      $_[0]->{onextentref} = $_[1];
    }
    return $_[0]->{onextentref} || sub {
      my ($self, $data, $sub) = @_;
      $self->cant_expand_extentref ($data, $sub);
    };
  } # onextentref
  
  sub max_entity_depth ($;$) {
    if (@_ > 1) {
      $_[0]->{max_entity_depth} = $_[1];
    }
    return $_[0]->{max_entity_depth} || 10;
  } # max_entity_depth
  
  sub max_entity_expansions ($;$) {
    if (@_ > 1) {
      return $_[0]->{max_entity_expansions} = $_[1];
    }
    return $_[0]->{max_entity_expansions} || 1000;
  } # max_entity_expansions
  
  sub onelementspopped ($;$) {
    if (@_ > 1) {
      $_[0]->{onelementspopped} = $_[1];
    }
    return $_[0]->{onelementspopped} || sub { };
  } # onelementspopped
  
  sub onrestartwithencoding ($;$) {
    if (@_ > 1) {
      $_[0]->{onrestartwithencoding} = $_[1];
    }
    return $_[0]->{onrestartwithencoding} || sub {
      my ($self, $encoding) = @_;
      $self->known_definite_encoding ($encoding);
      $self->restart;
    };
  } # onrestartwithencoding
  
      sub throw ($$) { $_[1]->() }
  
      sub restart ($) {
        unless ($_[0]->{can_restart}) {
          croak "The current parsing method can't restart the parser";
        }
        $_[0]->{restart} = 1;
      } # restart
  
      sub scripting ($;$) {
        if (@_ > 1) {
          $_[0]->{Scripting} = $_[1];
        }
        return $_[0]->{Scripting};
      } # scripting
  
      sub onparsed ($;$) {
        if (@_ > 1) {
          $_[0]->{onparsed} = $_[1];
        }
        return $_[0]->{onparsed} || sub { };
      } # onparsed
  
      sub _cleanup_states ($) {
        my $self = $_[0];
        delete $self->{input_stream};
        delete $self->{input_stream_offset};
        delete $self->{input_encoding};
        delete $self->{saved_states};
        delete $self->{saved_lists};
        delete $self->{saved_maps};
        delete $self->{nodes};
        delete $self->{document};
        delete $self->{can_restart};
        delete $self->{restart};
        delete $self->{pause};
        delete $self->{main_parser};
      } # _cleanup_states
  
      ## ------ Common defs ------
      our $AFE;our $AnchoredIndex;our $Attr;our $CONTEXT;our $Callbacks;our $Confident;our $DI;our $EOF;our $Errors;our $FORM_ELEMENT;our $FRAMESET_OK;our $HEAD_ELEMENT;our $IM;our $IframeSrcdoc;our $InForeign;our $Input;our $LastStartTagName;our $NEXT_ID;our $OE;our $OP;our $ORIGINAL_IM;our $Offset;our $QUIRKS;our $Scripting;our $State;our $TABLE_CHARS;our $TEMPLATE_IMS;our $Temp;our $TempIndex;our $Token;our $Tokens;
      ## ------ Tokenizer defs ------
      my $InvalidCharRefs = $Web::HTML::_SyntaxDefs->{charref_invalid};
  sub DOCTYPE_TOKEN () { 1 }
  sub COMMENT_TOKEN () { 2 }
  sub END_TAG_TOKEN () { 3 }
  sub END_OF_FILE_TOKEN () { 4 }
  sub START_TAG_TOKEN () { 5 }
  sub TEXT_TOKEN () { 6 }
  sub CDATA_SECTION_BRACKET_STATE () { 1 }
  sub CDATA_SECTION_END_STATE () { 2 }
  sub CDATA_SECTION_STATE () { 3 }
  sub CDATA_SECTION_STATE_CR () { 4 }
  sub DOCTYPE_NAME_STATE () { 5 }
  sub DOCTYPE_PUBLIC_ID__DQ__STATE () { 6 }
  sub DOCTYPE_PUBLIC_ID__DQ__STATE_CR () { 7 }
  sub DOCTYPE_PUBLIC_ID__SQ__STATE () { 8 }
  sub DOCTYPE_PUBLIC_ID__SQ__STATE_CR () { 9 }
  sub DOCTYPE_STATE () { 10 }
  sub DOCTYPE_SYSTEM_ID__DQ__STATE () { 11 }
  sub DOCTYPE_SYSTEM_ID__DQ__STATE_CR () { 12 }
  sub DOCTYPE_SYSTEM_ID__SQ__STATE () { 13 }
  sub DOCTYPE_SYSTEM_ID__SQ__STATE_CR () { 14 }
  sub PLAINTEXT_STATE () { 15 }
  sub PLAINTEXT_STATE_CR () { 16 }
  sub RAWTEXT_END_TAG_NAME_STATE () { 17 }
  sub RAWTEXT_END_TAG_OPEN_STATE () { 18 }
  sub RAWTEXT_LESS_THAN_SIGN_STATE () { 19 }
  sub RAWTEXT_STATE () { 20 }
  sub RAWTEXT_STATE_CR () { 21 }
  sub RCDATA_END_TAG_NAME_STATE () { 22 }
  sub RCDATA_END_TAG_OPEN_STATE () { 23 }
  sub RCDATA_LESS_THAN_SIGN_STATE () { 24 }
  sub RCDATA_STATE () { 25 }
  sub RCDATA_STATE___CHARREF_BEFORE_HEX_NUM_STATE () { 26 }
  sub RCDATA_STATE___CHARREF_DECIMAL_NUM_STATE () { 27 }
  sub RCDATA_STATE___CHARREF_HEX_NUM_STATE () { 28 }
  sub RCDATA_STATE___CHARREF_NAME_STATE () { 29 }
  sub RCDATA_STATE___CHARREF_NUM_STATE () { 30 }
  sub RCDATA_STATE___CHARREF_STATE () { 31 }
  sub RCDATA_STATE___CHARREF_STATE_CR () { 32 }
  sub RCDATA_STATE_CR () { 33 }
  sub A_DOCTYPE_NAME_STATE () { 34 }
  sub A_DOCTYPE_NAME_STATE_P () { 35 }
  sub A_DOCTYPE_NAME_STATE_PU () { 36 }
  sub A_DOCTYPE_NAME_STATE_PUB () { 37 }
  sub A_DOCTYPE_NAME_STATE_PUBL () { 38 }
  sub A_DOCTYPE_NAME_STATE_PUBLI () { 39 }
  sub A_DOCTYPE_NAME_STATE_S () { 40 }
  sub A_DOCTYPE_NAME_STATE_SY () { 41 }
  sub A_DOCTYPE_NAME_STATE_SYS () { 42 }
  sub A_DOCTYPE_NAME_STATE_SYST () { 43 }
  sub A_DOCTYPE_NAME_STATE_SYSTE () { 44 }
  sub A_DOCTYPE_PUBLIC_ID_STATE () { 45 }
  sub A_DOCTYPE_PUBLIC_KWD_STATE () { 46 }
  sub A_DOCTYPE_SYSTEM_ID_STATE () { 47 }
  sub A_DOCTYPE_SYSTEM_KWD_STATE () { 48 }
  sub A_ATTR_NAME_STATE () { 49 }
  sub A_ATTR_VALUE__QUOTED__STATE () { 50 }
  sub ATTR_NAME_STATE () { 51 }
  sub ATTR_VALUE__DQ__STATE () { 52 }
  sub ATTR_VALUE__DQ__STATE___CHARREF_BEFORE_HEX_NUM_STATE () { 53 }
  sub ATTR_VALUE__DQ__STATE___CHARREF_DECIMAL_NUM_STATE () { 54 }
  sub ATTR_VALUE__DQ__STATE___CHARREF_HEX_NUM_STATE () { 55 }
  sub ATTR_VALUE__DQ__STATE___CHARREF_NAME_STATE () { 56 }
  sub ATTR_VALUE__DQ__STATE___CHARREF_NUM_STATE () { 57 }
  sub ATTR_VALUE__DQ__STATE___CHARREF_STATE () { 58 }
  sub ATTR_VALUE__DQ__STATE_CR () { 59 }
  sub ATTR_VALUE__SQ__STATE () { 60 }
  sub ATTR_VALUE__SQ__STATE___CHARREF_BEFORE_HEX_NUM_STATE () { 61 }
  sub ATTR_VALUE__SQ__STATE___CHARREF_DECIMAL_NUM_STATE () { 62 }
  sub ATTR_VALUE__SQ__STATE___CHARREF_HEX_NUM_STATE () { 63 }
  sub ATTR_VALUE__SQ__STATE___CHARREF_NAME_STATE () { 64 }
  sub ATTR_VALUE__SQ__STATE___CHARREF_NUM_STATE () { 65 }
  sub ATTR_VALUE__SQ__STATE___CHARREF_STATE () { 66 }
  sub ATTR_VALUE__SQ__STATE_CR () { 67 }
  sub ATTR_VALUE__UNQUOTED__STATE () { 68 }
  sub ATTR_VALUE__UNQUOTED__STATE___CHARREF_BEFORE_HEX_NUM_STATE () { 69 }
  sub ATTR_VALUE__UNQUOTED__STATE___CHARREF_DECIMAL_NUM_STATE () { 70 }
  sub ATTR_VALUE__UNQUOTED__STATE___CHARREF_HEX_NUM_STATE () { 71 }
  sub ATTR_VALUE__UNQUOTED__STATE___CHARREF_NAME_STATE () { 72 }
  sub ATTR_VALUE__UNQUOTED__STATE___CHARREF_NUM_STATE () { 73 }
  sub ATTR_VALUE__UNQUOTED__STATE___CHARREF_STATE () { 74 }
  sub ATTR_VALUE__UNQUOTED__STATE_CR () { 75 }
  sub B_DOCTYPE_NAME_STATE () { 76 }
  sub B_DOCTYPE_PUBLIC_ID_STATE () { 77 }
  sub B_DOCTYPE_SYSTEM_ID_STATE () { 78 }
  sub B_ATTR_NAME_STATE () { 79 }
  sub B_ATTR_VALUE_STATE () { 80 }
  sub BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDS_STATE () { 81 }
  sub BOGUS_DOCTYPE_STATE () { 82 }
  sub BOGUS_COMMENT_STATE () { 83 }
  sub BOGUS_COMMENT_STATE_CR () { 84 }
  sub CHARREF_IN_RCDATA_STATE () { 85 }
  sub CHARREF_IN_DATA_STATE () { 86 }
  sub COMMENT_END_BANG_STATE () { 87 }
  sub COMMENT_END_DASH_STATE () { 88 }
  sub COMMENT_END_DASH_STATE_CR () { 89 }
  sub COMMENT_END_STATE () { 90 }
  sub COMMENT_END_STATE_CR () { 91 }
  sub COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH_STATE () { 92 }
  sub COMMENT_LESS_THAN_SIGN_BANG_DASH_STATE () { 93 }
  sub COMMENT_LESS_THAN_SIGN_BANG_STATE () { 94 }
  sub COMMENT_LESS_THAN_SIGN_STATE () { 95 }
  sub COMMENT_START_DASH_STATE () { 96 }
  sub COMMENT_START_STATE () { 97 }
  sub COMMENT_STATE () { 98 }
  sub COMMENT_STATE_CR () { 99 }
  sub DATA_STATE () { 100 }
  sub DATA_STATE___CHARREF_BEFORE_HEX_NUM_STATE () { 101 }
  sub DATA_STATE___CHARREF_DECIMAL_NUM_STATE () { 102 }
  sub DATA_STATE___CHARREF_HEX_NUM_STATE () { 103 }
  sub DATA_STATE___CHARREF_NAME_STATE () { 104 }
  sub DATA_STATE___CHARREF_NUM_STATE () { 105 }
  sub DATA_STATE___CHARREF_STATE () { 106 }
  sub DATA_STATE___CHARREF_STATE_CR () { 107 }
  sub DATA_STATE_CR () { 108 }
  sub END_TAG_OPEN_STATE () { 109 }
  sub MDO_STATE () { 110 }
  sub MDO_STATE__ () { 111 }
  sub MDO_STATE_D () { 112 }
  sub MDO_STATE_DO () { 113 }
  sub MDO_STATE_DOC () { 114 }
  sub MDO_STATE_DOCT () { 115 }
  sub MDO_STATE_DOCTY () { 116 }
  sub MDO_STATE_DOCTYP () { 117 }
  sub MDO_STATE__5B () { 118 }
  sub MDO_STATE__5BC () { 119 }
  sub MDO_STATE__5BCD () { 120 }
  sub MDO_STATE__5BCDA () { 121 }
  sub MDO_STATE__5BCDAT () { 122 }
  sub MDO_STATE__5BCDATA () { 123 }
  sub SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE () { 124 }
  sub SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE_CR () { 125 }
  sub SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE () { 126 }
  sub SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE_CR () { 127 }
  sub SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE () { 128 }
  sub SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE () { 129 }
  sub SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE () { 130 }
  sub SCRIPT_DATA_DOUBLE_ESCAPED_STATE () { 131 }
  sub SCRIPT_DATA_DOUBLE_ESCAPED_STATE_CR () { 132 }
  sub SCRIPT_DATA_END_TAG_NAME_STATE () { 133 }
  sub SCRIPT_DATA_END_TAG_OPEN_STATE () { 134 }
  sub SCRIPT_DATA_ESCAPE_START_DASH_STATE () { 135 }
  sub SCRIPT_DATA_ESCAPE_START_STATE () { 136 }
  sub SCRIPT_DATA_ESCAPED_DASH_DASH_STATE () { 137 }
  sub SCRIPT_DATA_ESCAPED_DASH_STATE () { 138 }
  sub SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE () { 139 }
  sub SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE () { 140 }
  sub SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE () { 141 }
  sub SCRIPT_DATA_ESCAPED_STATE () { 142 }
  sub SCRIPT_DATA_ESCAPED_STATE_CR () { 143 }
  sub SCRIPT_DATA_LESS_THAN_SIGN_STATE () { 144 }
  sub SCRIPT_DATA_STATE () { 145 }
  sub SCRIPT_DATA_STATE_CR () { 146 }
  sub SELF_CLOSING_START_TAG_STATE () { 147 }
  sub TAG_NAME_STATE () { 148 }
  sub TAG_OPEN_STATE () { 149 }
   sub cant_expand_extentref ($$$) { } 
  
  my $TokenizerAbortingTagNames = {
    title => 1,
    textarea => 1,
    plaintext => 1,
    style => 1,
    script => 1,
    xmp => 1,
    iframe => 1,
    noembed => 1,
    noframes => 1,
    noscript => 1,
  
    #html => 1, # for <html manifest> -> see the line with "first start tag"
    #meta => 1, # for <meta charset>
  };
    
  
  
  sub strict_checker ($;$) {
    if (@_ > 1) {
      $_[0]->{strict_checker} = $_[1];
    }
    return $_[0]->{strict_checker} || 'Web::XML::Parser::MinimumChecker';
  } # strict_checker
  
    
      ## ------ Tree constructor defs ------
      my $Element2Type = [];
  my $ProcessIM = [];
  sub TAG_NAME_A () { 1 }
  $TagName2Group->{q@a@} = 1;
  sub TAG_NAME_ADDRESS_ARTICLE_ASIDE_DETAILS_DIALOG_DIR_FIGCAPTION_FIGURE_FOOTER_HEADER_HGROUP_MAIN_NAV_SECTION_SUMMARY () { 2 }
  $TagName2Group->{q@address@} = 2;
  $TagName2Group->{q@article@} = 2;
  $TagName2Group->{q@aside@} = 2;
  $TagName2Group->{q@details@} = 2;
  $TagName2Group->{q@dialog@} = 2;
  $TagName2Group->{q@dir@} = 2;
  $TagName2Group->{q@figcaption@} = 2;
  $TagName2Group->{q@figure@} = 2;
  $TagName2Group->{q@footer@} = 2;
  $TagName2Group->{q@header@} = 2;
  $TagName2Group->{q@hgroup@} = 2;
  $TagName2Group->{q@main@} = 2;
  $TagName2Group->{q@nav@} = 2;
  $TagName2Group->{q@section@} = 2;
  $TagName2Group->{q@summary@} = 2;
  sub TAG_NAME_APPLET_MARQUEE () { 3 }
  $TagName2Group->{q@applet@} = 3;
  $TagName2Group->{q@marquee@} = 3;
  sub TAG_NAME_AREA_WBR () { 4 }
  $TagName2Group->{q@area@} = 4;
  $TagName2Group->{q@wbr@} = 4;
  sub TAG_NAME_B_BIG_CODE_EM_I_S_SMALL_STRIKE_STRONG_TT_U () { 5 }
  $TagName2Group->{q@b@} = 5;
  $TagName2Group->{q@big@} = 5;
  $TagName2Group->{q@code@} = 5;
  $TagName2Group->{q@em@} = 5;
  $TagName2Group->{q@i@} = 5;
  $TagName2Group->{q@s@} = 5;
  $TagName2Group->{q@small@} = 5;
  $TagName2Group->{q@strike@} = 5;
  $TagName2Group->{q@strong@} = 5;
  $TagName2Group->{q@tt@} = 5;
  $TagName2Group->{q@u@} = 5;
  sub TAG_NAME_BASE () { 6 }
  $TagName2Group->{q@base@} = 6;
  sub TAG_NAME_BASEFONT_BGSOUND_LINK () { 7 }
  $TagName2Group->{q@basefont@} = 7;
  $TagName2Group->{q@bgsound@} = 7;
  $TagName2Group->{q@link@} = 7;
  sub TAG_NAME_BLOCKQUOTE_CENTER_DIV_DL_MENU_OL_UL () { 8 }
  $TagName2Group->{q@blockquote@} = 8;
  $TagName2Group->{q@center@} = 8;
  $TagName2Group->{q@div@} = 8;
  $TagName2Group->{q@dl@} = 8;
  $TagName2Group->{q@menu@} = 8;
  $TagName2Group->{q@ol@} = 8;
  $TagName2Group->{q@ul@} = 8;
  sub TAG_NAME_BODY () { 9 }
  $TagName2Group->{q@body@} = 9;
  sub TAG_NAME_BR () { 10 }
  $TagName2Group->{q@br@} = 10;
  sub TAG_NAME_BUTTON () { 11 }
  $TagName2Group->{q@button@} = 11;
  sub TAG_NAME_CAPTION () { 12 }
  $TagName2Group->{q@caption@} = 12;
  sub TAG_NAME_COL () { 13 }
  $TagName2Group->{q@col@} = 13;
  sub TAG_NAME_COLGROUP () { 14 }
  $TagName2Group->{q@colgroup@} = 14;
  sub TAG_NAME_DD_DT () { 15 }
  $TagName2Group->{q@dd@} = 15;
  $TagName2Group->{q@dt@} = 15;
  sub TAG_NAME_EMBED () { 16 }
  $TagName2Group->{q@embed@} = 16;
  sub TAG_NAME_FIELDSET () { 17 }
  $TagName2Group->{q@fieldset@} = 17;
  sub TAG_NAME_FONT () { 18 }
  $TagName2Group->{q@font@} = 18;
  sub TAG_NAME_FORM () { 19 }
  $TagName2Group->{q@form@} = 19;
  sub TAG_NAME_FRAME () { 20 }
  $TagName2Group->{q@frame@} = 20;
  sub TAG_NAME_FRAMESET () { 21 }
  $TagName2Group->{q@frameset@} = 21;
  sub TAG_NAME_H1_H2_H3_H4_H5_H6 () { 22 }
  $TagName2Group->{q@h1@} = 22;
  $TagName2Group->{q@h2@} = 22;
  $TagName2Group->{q@h3@} = 22;
  $TagName2Group->{q@h4@} = 22;
  $TagName2Group->{q@h5@} = 22;
  $TagName2Group->{q@h6@} = 22;
  sub TAG_NAME_HEAD () { 23 }
  $TagName2Group->{q@head@} = 23;
  sub TAG_NAME_HR () { 24 }
  $TagName2Group->{q@hr@} = 24;
  sub TAG_NAME_HTML () { 25 }
  $TagName2Group->{q@html@} = 25;
  sub TAG_NAME_IFRAME () { 26 }
  $TagName2Group->{q@iframe@} = 26;
  sub TAG_NAME_IMAGE () { 27 }
  $TagName2Group->{q@image@} = 27;
  sub TAG_NAME_IMG () { 28 }
  $TagName2Group->{q@img@} = 28;
  sub TAG_NAME_INPUT () { 29 }
  $TagName2Group->{q@input@} = 29;
  sub TAG_NAME_KEYGEN () { 30 }
  $TagName2Group->{q@keygen@} = 30;
  sub TAG_NAME_LI () { 31 }
  $TagName2Group->{q@li@} = 31;
  sub TAG_NAME_LISTING_PRE () { 32 }
  $TagName2Group->{q@listing@} = 32;
  $TagName2Group->{q@pre@} = 32;
  sub TAG_NAME_MALIGNMARK_MGLYPH () { 33 }
  $TagName2Group->{q@malignmark@} = 33;
  $TagName2Group->{q@mglyph@} = 33;
  sub TAG_NAME_MATH () { 34 }
  $TagName2Group->{q@math@} = 34;
  sub TAG_NAME_META () { 35 }
  $TagName2Group->{q@meta@} = 35;
  sub TAG_NAME_NOBR () { 36 }
  $TagName2Group->{q@nobr@} = 36;
  sub TAG_NAME_NOEMBED () { 37 }
  $TagName2Group->{q@noembed@} = 37;
  sub TAG_NAME_NOFRAMES () { 38 }
  $TagName2Group->{q@noframes@} = 38;
  sub TAG_NAME_NOSCRIPT () { 39 }
  $TagName2Group->{q@noscript@} = 39;
  sub TAG_NAME_OBJECT () { 40 }
  $TagName2Group->{q@object@} = 40;
  sub TAG_NAME_OPTGROUP () { 41 }
  $TagName2Group->{q@optgroup@} = 41;
  sub TAG_NAME_OPTION () { 42 }
  $TagName2Group->{q@option@} = 42;
  sub TAG_NAME_OUTPUT () { 43 }
  $TagName2Group->{q@output@} = 43;
  sub TAG_NAME_P () { 44 }
  $TagName2Group->{q@p@} = 44;
  sub TAG_NAME_PARAM_SOURCE_TRACK () { 45 }
  $TagName2Group->{q@param@} = 45;
  $TagName2Group->{q@source@} = 45;
  $TagName2Group->{q@track@} = 45;
  sub TAG_NAME_PLAINTEXT () { 46 }
  $TagName2Group->{q@plaintext@} = 46;
  sub TAG_NAME_RB_RTC () { 47 }
  $TagName2Group->{q@rb@} = 47;
  $TagName2Group->{q@rtc@} = 47;
  sub TAG_NAME_RP_RT () { 48 }
  $TagName2Group->{q@rp@} = 48;
  $TagName2Group->{q@rt@} = 48;
  sub TAG_NAME_RUBY_SPAN_SUB_SUP_VAR () { 49 }
  $TagName2Group->{q@ruby@} = 49;
  $TagName2Group->{q@span@} = 49;
  $TagName2Group->{q@sub@} = 49;
  $TagName2Group->{q@sup@} = 49;
  $TagName2Group->{q@var@} = 49;
  sub TAG_NAME_SARCASM () { 50 }
  $TagName2Group->{q@sarcasm@} = 50;
  sub TAG_NAME_SCRIPT () { 51 }
  $TagName2Group->{q@script@} = 51;
  sub TAG_NAME_SELECT () { 52 }
  $TagName2Group->{q@select@} = 52;
  sub TAG_NAME_STYLE () { 53 }
  $TagName2Group->{q@style@} = 53;
  sub TAG_NAME_SVG () { 54 }
  $TagName2Group->{q@svg@} = 54;
  sub TAG_NAME_TABLE () { 55 }
  $TagName2Group->{q@table@} = 55;
  sub TAG_NAME_TBODY_TFOOT_THEAD () { 56 }
  $TagName2Group->{q@tbody@} = 56;
  $TagName2Group->{q@tfoot@} = 56;
  $TagName2Group->{q@thead@} = 56;
  sub TAG_NAME_TD_TH () { 57 }
  $TagName2Group->{q@td@} = 57;
  $TagName2Group->{q@th@} = 57;
  sub TAG_NAME_TEMPLATE () { 58 }
  $TagName2Group->{q@template@} = 58;
  sub TAG_NAME_TEXTAREA () { 59 }
  $TagName2Group->{q@textarea@} = 59;
  sub TAG_NAME_TITLE () { 60 }
  $TagName2Group->{q@title@} = 60;
  sub TAG_NAME_TR () { 61 }
  $TagName2Group->{q@tr@} = 61;
  sub TAG_NAME_XMP () { 62 }
  $TagName2Group->{q@xmp@} = 62;
  
          ## HTML:*
          sub HTML_NS_ELS () { 1 }
        
  
          ## HTML:a,HTML:b,HTML:big,HTML:code,HTML:em,HTML:font,HTML:i,HTML:nobr,HTML:s,HTML:small,HTML:strike,HTML:strong,HTML:tt,HTML:u
          sub ABBCEFINSSSSTU_ELS () { 2 }
        
  
          ## HTML:address,HTML:div
          sub ADD_DIV_ELS () { 4 }
        
  
          ## HTML:applet,HTML:marquee,MathML:annotation-xml
          sub APP_MAR_M_ANN_ELS () { 8 }
        
  
          ## HTML:area,HTML:article,HTML:aside,HTML:base,HTML:basefont,HTML:bgsound,HTML:blockquote,HTML:br,HTML:center,HTML:col,HTML:details,HTML:dir,HTML:dl,HTML:embed,HTML:figcaption,HTML:figure,HTML:footer,HTML:form,HTML:frame,HTML:frameset,HTML:head,HTML:header,HTML:hgroup,HTML:hr,HTML:iframe,HTML:keygen,HTML:link,HTML:listing,HTML:main,HTML:menu,HTML:meta,HTML:nav,HTML:noembed,HTML:noframes,HTML:noscript,HTML:param,HTML:plaintext,HTML:pre,HTML:script,HTML:section,HTML:source,HTML:summary,HTML:title,HTML:track,HTML:wbr,HTML:xmp
          sub AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS () { 16 }
        
  
          ## HTML:audio,HTML:video
          sub AUD_VID_ELS () { 32 }
        
  
          ## HTML:body
          sub BOD_ELS () { 64 }
        
  
          ## HTML:button
          sub BUT_ELS () { 128 }
        
  
          ## HTML:caption
          sub CAP_ELS () { 256 }
        
  
          ## HTML:colgroup
          sub COL_ELS () { 512 }
        
  
          ## HTML:dd
          sub DD_ELS () { 1024 }
        
  
          ## HTML:dt
          sub DT_ELS () { 2048 }
        
  
          ## HTML:fieldset,HTML:input,HTML:select
          sub FIE_INP_SEL_ELS () { 4096 }
        
  
          ## HTML:h1,HTML:h2,HTML:h3,HTML:h4,HTML:h5,HTML:h6
          sub HHHHHH_ELS () { 8192 }
        
  
          ## HTML:html
          sub HTM_ELS () { 16384 }
        
  
          ## HTML:img
          sub IMG_ELS () { 32768 }
        
  
          ## HTML:li
          sub LI_ELS () { 65536 }
        
  
          ## HTML:object
          sub OBJ_ELS () { 131072 }
        
  
          ## HTML:ol,HTML:ul
          sub OL_UL_ELS () { 262144 }
        
  
          ## HTML:optgroup,HTML:option
          sub OPT_OPT_ELS () { 524288 }
        
  
          ## HTML:output
          sub OUT_ELS () { 1048576 }
        
  
          ## HTML:p
          sub P_ELS () { 2097152 }
        
  
          ## HTML:rb,HTML:rp,HTML:rt
          sub RB_RP_RT_ELS () { 4194304 }
        
  
          ## HTML:rtc
          sub RTC_ELS () { 8388608 }
        
  
          ## HTML:ruby
          sub RUB_ELS () { 16777216 }
        
  
          ## HTML:style
          sub STY_ELS () { 33554432 }
        
  
          ## HTML:table
          sub TAB_ELS () { 67108864 }
        
  
          ## HTML:tbody,HTML:tfoot,HTML:thead
          sub TBO_TFO_THE_ELS () { 134217728 }
        
  
          ## HTML:td,HTML:th
          sub TD_TH_ELS () { 268435456 }
        
  
          ## HTML:template
          sub TEM_ELS () { 536870912 }
        
  
          ## HTML:textarea
          sub TEX_ELS () { 1073741824 }
        
  
          ## HTML:tr
          sub TR_ELS () { 2147483648 }
        
  
          ## MathML:*
          sub MATHML_NS_ELS () { 4294967296 }
        
  
          ## MathML:annotation-xml
          sub M_ANN_ELS () { 8589934592 }
        
  
          ## MathML:annotation-xml@encoding=application/xhtml+xml,MathML:annotation-xml@encoding=text/html
          sub M_ANN_M_ANN_ELS () { 17179869184 }
        
  
          ## MathML:mi,MathML:mn,MathML:mo,MathML:ms,MathML:mtext
          sub M_MI_M_MN_M_MO_M_MS_M_MTE_ELS () { 34359738368 }
        
  
          ## SVG:*
          sub SVG_NS_ELS () { 68719476736 }
        
  
          ## SVG:desc,SVG:foreignObject,SVG:title
          sub S_DES_S_FOR_S_TIT_ELS () { 137438953472 }
        
  $Element2Type->[HTMLNS]->{q@*@} = HTML_NS_ELS;
  sub A_EL () { HTML_NS_ELS | ABBCEFINSSSSTU_ELS | 274877906944 } $Element2Type->[HTMLNS]->{q@a@} = A_EL;
  sub ADDRESS_EL () { HTML_NS_ELS | ADD_DIV_ELS | 274877906944 } $Element2Type->[HTMLNS]->{q@address@} = ADDRESS_EL;
  sub APPLET_EL () { HTML_NS_ELS | APP_MAR_M_ANN_ELS | 274877906944 } $Element2Type->[HTMLNS]->{q@applet@} = APPLET_EL;
  $Element2Type->[HTMLNS]->{q@area@} = HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS;
  sub ARTICLE_EL () { HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS | 274877906944 } $Element2Type->[HTMLNS]->{q@article@} = ARTICLE_EL;
  sub ASIDE_EL () { HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS | 549755813888 } $Element2Type->[HTMLNS]->{q@aside@} = ASIDE_EL;
  $Element2Type->[HTMLNS]->{q@audio@} = HTML_NS_ELS | AUD_VID_ELS;
  $Element2Type->[HTMLNS]->{q@b@} = HTML_NS_ELS | ABBCEFINSSSSTU_ELS;
  $Element2Type->[HTMLNS]->{q@base@} = HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS;
  $Element2Type->[HTMLNS]->{q@basefont@} = HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS;
  $Element2Type->[HTMLNS]->{q@bgsound@} = HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS;
  $Element2Type->[HTMLNS]->{q@big@} = HTML_NS_ELS | ABBCEFINSSSSTU_ELS;
  sub BLOCKQUOTE_EL () { HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS | 824633720832 } $Element2Type->[HTMLNS]->{q@blockquote@} = BLOCKQUOTE_EL;
  sub BODY_EL () { HTML_NS_ELS | BOD_ELS } $Element2Type->[HTMLNS]->{q@body@} = BODY_EL;
  $Element2Type->[HTMLNS]->{q@br@} = HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS;
  sub BUTTON_EL () { HTML_NS_ELS | BUT_ELS } $Element2Type->[HTMLNS]->{q@button@} = BUTTON_EL;
  sub CAPTION_EL () { HTML_NS_ELS | CAP_ELS } $Element2Type->[HTMLNS]->{q@caption@} = CAPTION_EL;
  sub CENTER_EL () { HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS | 1099511627776 } $Element2Type->[HTMLNS]->{q@center@} = CENTER_EL;
  $Element2Type->[HTMLNS]->{q@code@} = HTML_NS_ELS | ABBCEFINSSSSTU_ELS;
  $Element2Type->[HTMLNS]->{q@col@} = HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS;
  sub COLGROUP_EL () { HTML_NS_ELS | COL_ELS } $Element2Type->[HTMLNS]->{q@colgroup@} = COLGROUP_EL;
  sub DD_EL () { HTML_NS_ELS | DD_ELS } $Element2Type->[HTMLNS]->{q@dd@} = DD_EL;
  sub DETAILS_EL () { HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS | 1374389534720 } $Element2Type->[HTMLNS]->{q@details@} = DETAILS_EL;
  sub DIALOG_EL () { HTML_NS_ELS | 274877906944 } $Element2Type->[HTMLNS]->{q@dialog@} = DIALOG_EL;
  sub DIR_EL () { HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS | 1649267441664 } $Element2Type->[HTMLNS]->{q@dir@} = DIR_EL;
  sub DIV_EL () { HTML_NS_ELS | ADD_DIV_ELS | 549755813888 } $Element2Type->[HTMLNS]->{q@div@} = DIV_EL;
  sub DL_EL () { HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS | 1924145348608 } $Element2Type->[HTMLNS]->{q@dl@} = DL_EL;
  sub DT_EL () { HTML_NS_ELS | DT_ELS } $Element2Type->[HTMLNS]->{q@dt@} = DT_EL;
  $Element2Type->[HTMLNS]->{q@em@} = HTML_NS_ELS | ABBCEFINSSSSTU_ELS;
  $Element2Type->[HTMLNS]->{q@embed@} = HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS;
  sub FIELDSET_EL () { HTML_NS_ELS | FIE_INP_SEL_ELS | 274877906944 } $Element2Type->[HTMLNS]->{q@fieldset@} = FIELDSET_EL;
  sub FIGCAPTION_EL () { HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS | 2199023255552 } $Element2Type->[HTMLNS]->{q@figcaption@} = FIGCAPTION_EL;
  sub FIGURE_EL () { HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS | 2473901162496 } $Element2Type->[HTMLNS]->{q@figure@} = FIGURE_EL;
  $Element2Type->[HTMLNS]->{q@font@} = HTML_NS_ELS | ABBCEFINSSSSTU_ELS;
  sub FOOTER_EL () { HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS | 2748779069440 } $Element2Type->[HTMLNS]->{q@footer@} = FOOTER_EL;
  sub FORM_EL () { HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS | 3023656976384 } $Element2Type->[HTMLNS]->{q@form@} = FORM_EL;
  $Element2Type->[HTMLNS]->{q@frame@} = HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS;
  sub FRAMESET_EL () { HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS | 3298534883328 } $Element2Type->[HTMLNS]->{q@frameset@} = FRAMESET_EL;
  sub H1_EL () { HTML_NS_ELS | HHHHHH_ELS | 274877906944 } $Element2Type->[HTMLNS]->{q@h1@} = H1_EL;
  sub H2_EL () { HTML_NS_ELS | HHHHHH_ELS | 549755813888 } $Element2Type->[HTMLNS]->{q@h2@} = H2_EL;
  sub H3_EL () { HTML_NS_ELS | HHHHHH_ELS | 824633720832 } $Element2Type->[HTMLNS]->{q@h3@} = H3_EL;
  sub H4_EL () { HTML_NS_ELS | HHHHHH_ELS | 1099511627776 } $Element2Type->[HTMLNS]->{q@h4@} = H4_EL;
  sub H5_EL () { HTML_NS_ELS | HHHHHH_ELS | 1374389534720 } $Element2Type->[HTMLNS]->{q@h5@} = H5_EL;
  sub H6_EL () { HTML_NS_ELS | HHHHHH_ELS | 1649267441664 } $Element2Type->[HTMLNS]->{q@h6@} = H6_EL;
  sub HEAD_EL () { HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS | 3573412790272 } $Element2Type->[HTMLNS]->{q@head@} = HEAD_EL;
  sub HEADER_EL () { HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS | 3848290697216 } $Element2Type->[HTMLNS]->{q@header@} = HEADER_EL;
  sub HGROUP_EL () { HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS | 4123168604160 } $Element2Type->[HTMLNS]->{q@hgroup@} = HGROUP_EL;
  $Element2Type->[HTMLNS]->{q@hr@} = HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS;
  sub HTML_EL () { HTML_NS_ELS | HTM_ELS } $Element2Type->[HTMLNS]->{q@html@} = HTML_EL;
  $Element2Type->[HTMLNS]->{q@i@} = HTML_NS_ELS | ABBCEFINSSSSTU_ELS;
  $Element2Type->[HTMLNS]->{q@iframe@} = HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS;
  $Element2Type->[HTMLNS]->{q@img@} = HTML_NS_ELS | IMG_ELS;
  $Element2Type->[HTMLNS]->{q@input@} = HTML_NS_ELS | FIE_INP_SEL_ELS;
  $Element2Type->[HTMLNS]->{q@keygen@} = HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS;
  sub LI_EL () { HTML_NS_ELS | LI_ELS } $Element2Type->[HTMLNS]->{q@li@} = LI_EL;
  $Element2Type->[HTMLNS]->{q@link@} = HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS;
  sub LISTING_EL () { HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS | 4398046511104 } $Element2Type->[HTMLNS]->{q@listing@} = LISTING_EL;
  sub MAIN_EL () { HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS | 4672924418048 } $Element2Type->[HTMLNS]->{q@main@} = MAIN_EL;
  sub MARQUEE_EL () { HTML_NS_ELS | APP_MAR_M_ANN_ELS | 549755813888 } $Element2Type->[HTMLNS]->{q@marquee@} = MARQUEE_EL;
  sub MENU_EL () { HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS | 4947802324992 } $Element2Type->[HTMLNS]->{q@menu@} = MENU_EL;
  $Element2Type->[HTMLNS]->{q@meta@} = HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS;
  sub NAV_EL () { HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS | 5222680231936 } $Element2Type->[HTMLNS]->{q@nav@} = NAV_EL;
  sub NOBR_EL () { HTML_NS_ELS | ABBCEFINSSSSTU_ELS | 549755813888 } $Element2Type->[HTMLNS]->{q@nobr@} = NOBR_EL;
  $Element2Type->[HTMLNS]->{q@noembed@} = HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS;
  $Element2Type->[HTMLNS]->{q@noframes@} = HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS;
  $Element2Type->[HTMLNS]->{q@noscript@} = HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS;
  sub OBJECT_EL () { HTML_NS_ELS | OBJ_ELS } $Element2Type->[HTMLNS]->{q@object@} = OBJECT_EL;
  sub OL_EL () { HTML_NS_ELS | OL_UL_ELS | 274877906944 } $Element2Type->[HTMLNS]->{q@ol@} = OL_EL;
  sub OPTGROUP_EL () { HTML_NS_ELS | OPT_OPT_ELS | 274877906944 } $Element2Type->[HTMLNS]->{q@optgroup@} = OPTGROUP_EL;
  sub OPTION_EL () { HTML_NS_ELS | OPT_OPT_ELS | 549755813888 } $Element2Type->[HTMLNS]->{q@option@} = OPTION_EL;
  $Element2Type->[HTMLNS]->{q@output@} = HTML_NS_ELS | OUT_ELS;
  sub P_EL () { HTML_NS_ELS | P_ELS } $Element2Type->[HTMLNS]->{q@p@} = P_EL;
  $Element2Type->[HTMLNS]->{q@param@} = HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS;
  $Element2Type->[HTMLNS]->{q@plaintext@} = HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS;
  sub PRE_EL () { HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS | 5497558138880 } $Element2Type->[HTMLNS]->{q@pre@} = PRE_EL;
  $Element2Type->[HTMLNS]->{q@rb@} = HTML_NS_ELS | RB_RP_RT_ELS;
  $Element2Type->[HTMLNS]->{q@rp@} = HTML_NS_ELS | RB_RP_RT_ELS;
  $Element2Type->[HTMLNS]->{q@rt@} = HTML_NS_ELS | RB_RP_RT_ELS;
  $Element2Type->[HTMLNS]->{q@rtc@} = HTML_NS_ELS | RTC_ELS;
  sub RUBY_EL () { HTML_NS_ELS | RUB_ELS } $Element2Type->[HTMLNS]->{q@ruby@} = RUBY_EL;
  $Element2Type->[HTMLNS]->{q@s@} = HTML_NS_ELS | ABBCEFINSSSSTU_ELS;
  sub SARCASM_EL () { HTML_NS_ELS | 549755813888 } $Element2Type->[HTMLNS]->{q@sarcasm@} = SARCASM_EL;
  sub SCRIPT_EL () { HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS | 5772436045824 } $Element2Type->[HTMLNS]->{q@script@} = SCRIPT_EL;
  sub SECTION_EL () { HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS | 6047313952768 } $Element2Type->[HTMLNS]->{q@section@} = SECTION_EL;
  sub SELECT_EL () { HTML_NS_ELS | FIE_INP_SEL_ELS | 549755813888 } $Element2Type->[HTMLNS]->{q@select@} = SELECT_EL;
  $Element2Type->[HTMLNS]->{q@small@} = HTML_NS_ELS | ABBCEFINSSSSTU_ELS;
  $Element2Type->[HTMLNS]->{q@source@} = HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS;
  $Element2Type->[HTMLNS]->{q@strike@} = HTML_NS_ELS | ABBCEFINSSSSTU_ELS;
  $Element2Type->[HTMLNS]->{q@strong@} = HTML_NS_ELS | ABBCEFINSSSSTU_ELS;
  $Element2Type->[HTMLNS]->{q@style@} = HTML_NS_ELS | STY_ELS;
  sub SUMMARY_EL () { HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS | 6322191859712 } $Element2Type->[HTMLNS]->{q@summary@} = SUMMARY_EL;
  sub TABLE_EL () { HTML_NS_ELS | TAB_ELS } $Element2Type->[HTMLNS]->{q@table@} = TABLE_EL;
  sub TBODY_EL () { HTML_NS_ELS | TBO_TFO_THE_ELS | 274877906944 } $Element2Type->[HTMLNS]->{q@tbody@} = TBODY_EL;
  sub TD_EL () { HTML_NS_ELS | TD_TH_ELS | 274877906944 } $Element2Type->[HTMLNS]->{q@td@} = TD_EL;
  sub TEMPLATE_EL () { HTML_NS_ELS | TEM_ELS } $Element2Type->[HTMLNS]->{q@template@} = TEMPLATE_EL;
  $Element2Type->[HTMLNS]->{q@textarea@} = HTML_NS_ELS | TEX_ELS;
  sub TFOOT_EL () { HTML_NS_ELS | TBO_TFO_THE_ELS | 549755813888 } $Element2Type->[HTMLNS]->{q@tfoot@} = TFOOT_EL;
  sub TH_EL () { HTML_NS_ELS | TD_TH_ELS | 549755813888 } $Element2Type->[HTMLNS]->{q@th@} = TH_EL;
  sub THEAD_EL () { HTML_NS_ELS | TBO_TFO_THE_ELS | 824633720832 } $Element2Type->[HTMLNS]->{q@thead@} = THEAD_EL;
  $Element2Type->[HTMLNS]->{q@title@} = HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS;
  sub TR_EL () { HTML_NS_ELS | TR_ELS } $Element2Type->[HTMLNS]->{q@tr@} = TR_EL;
  $Element2Type->[HTMLNS]->{q@track@} = HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS;
  $Element2Type->[HTMLNS]->{q@tt@} = HTML_NS_ELS | ABBCEFINSSSSTU_ELS;
  $Element2Type->[HTMLNS]->{q@u@} = HTML_NS_ELS | ABBCEFINSSSSTU_ELS;
  sub UL_EL () { HTML_NS_ELS | OL_UL_ELS | 549755813888 } $Element2Type->[HTMLNS]->{q@ul@} = UL_EL;
  $Element2Type->[HTMLNS]->{q@video@} = HTML_NS_ELS | AUD_VID_ELS;
  $Element2Type->[HTMLNS]->{q@wbr@} = HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS;
  $Element2Type->[HTMLNS]->{q@xmp@} = HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS;
  $Element2Type->[MATHMLNS]->{q@*@} = MATHML_NS_ELS;
  $Element2Type->[MATHMLNS]->{q@annotation-xml@} = MATHML_NS_ELS | APP_MAR_M_ANN_ELS | M_ANN_ELS;
  $Element2Type->[MATHMLNS]->{q@mi@} = MATHML_NS_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS;
  $Element2Type->[MATHMLNS]->{q@mn@} = MATHML_NS_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS;
  $Element2Type->[MATHMLNS]->{q@mo@} = MATHML_NS_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS;
  $Element2Type->[MATHMLNS]->{q@ms@} = MATHML_NS_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS;
  $Element2Type->[MATHMLNS]->{q@mtext@} = MATHML_NS_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS;
  $Element2Type->[SVGNS]->{q@*@} = SVG_NS_ELS;
  $Element2Type->[SVGNS]->{q@desc@} = SVG_NS_ELS | S_DES_S_FOR_S_TIT_ELS;
  $Element2Type->[SVGNS]->{q@foreignObject@} = SVG_NS_ELS | S_DES_S_FOR_S_TIT_ELS;
  sub SVG_SCRIPT_EL () { SVG_NS_ELS | 274877906944 } $Element2Type->[SVGNS]->{q@script@} = SVG_SCRIPT_EL;
  $Element2Type->[SVGNS]->{q@title@} = SVG_NS_ELS | S_DES_S_FOR_S_TIT_ELS;
  sub AFTER_AFTER_BODY_IM () { 1 }
  sub AFTER_AFTER_FRAMESET_IM () { 2 }
  sub AFTER_BODY_IM () { 3 }
  sub AFTER_FRAMESET_IM () { 4 }
  sub AFTER_HEAD_IM () { 5 }
  sub BEFORE_HEAD_IM () { 6 }
  sub BEFORE_HTML_IM () { 7 }
  sub BEFORE_IGNORED_NEWLINE_IM () { 8 }
  sub BEFORE_IGNORED_NEWLINE_AND_TEXT_IM () { 9 }
  sub IN_BODY_IM () { 10 }
  sub IN_CAPTION_IM () { 11 }
  sub IN_CELL_IM () { 12 }
  sub IN_COLUMN_GROUP_IM () { 13 }
  sub IN_FOREIGN_CONTENT_IM () { 14 }
  sub IN_FRAMESET_IM () { 15 }
  sub IN_HEAD_IM () { 16 }
  sub IN_HEAD_NOSCRIPT_IM () { 17 }
  sub IN_ROW_IM () { 18 }
  sub IN_SELECT_IM () { 19 }
  sub IN_SELECT_IN_TABLE_IM () { 20 }
  sub IN_TABLE_IM () { 21 }
  sub IN_TABLE_BODY_IM () { 22 }
  sub IN_TABLE_TEXT_IM () { 23 }
  sub IN_TEMPLATE_IM () { 24 }
  sub INITIAL_IM () { 25 }
  sub TEXT_IM () { 26 }
  my $QPublicIDPrefixPattern = qr{(?:(?:-(?://(?:S(?:OFTQUAD(?: SOFTWARE//DTD HOTMETAL PRO 6\.0::19990601|//DTD HOTMETAL PRO 4\.0::19971010)::EXTENSIONS TO HTML 4\.0|UN MICROSYSTEMS CORP\.//DTD HOTJAVA(?: STRICT)? HTML|Q//DTD HTML 2\.0 HOTMETAL \+ EXTENSIONS|PYGLASS//DTD HTML 2\.0 EXTENDED)|W(?:3(?:C//DTD HTML (?:3\.2(?: (?:DRAFT|FINAL)|S DRAFT)?|4\.0 (?:TRANSITIONAL|FRAMESET))|O//DTD W3 HTML 3\.0)|EBTECHS//DTD MOZILLA HTML 2\.0)|IETF//DTD HTML (?:2\.(?:0(?: (?:STRICT(?: LEVEL [12])?|LEVEL [12]))?|1E)|3\.(?:2(?: FINAL)?|0))|MICROSOFT//DTD INTERNET EXPLORER [23]\.0 (?:HTML(?: STRICT)?|TABLES)|O'REILLY AND ASSOCIATES//DTD HTML (?:EXTEND(?:ED RELAX)?ED 1|2)\.0|A(?:DVASOFT LTD|S)//DTD HTML 3\.0 ASWEDIT \+ EXTENSIONS|NETSCAPE COMM\. CORP\.//DTD(?: STRICT)? HTML)//|//(?:W(?:3C//DTD (?:HTML (?:EXPERIMENTAL (?:19960712|970421)|3 1995-03-24)|W3 HTML)|EBTECHS//DTD MOZILLA HTML)|IETF//DTD HTML(?: (?:STRICT(?: LEVEL [0123])?|LEVEL [0123]|3))?|METRIUS//DTD METRIUS PRESENTATIONAL)//)|\+//SILMARIL//DTD HTML PRO V0R11 19970101//))};
  my $LQPublicIDPrefixPattern = qr{(?:-//W3C//DTD XHTML 1\.0 (?:TRANSITIONAL|FRAMESET)//)};
  my $QorLQPublicIDPrefixPattern = qr{(?:-//W3C//DTD HTML 4\.01 (?:TRANSITIONAL|FRAMESET)//)};
  my $QPublicIDs = {q<-//W3O//DTD W3 HTML STRICT 3.0//EN//> => 1, q<-/W3C/DTD HTML 4.0 TRANSITIONAL/EN> => 1, q<HTML> => 1};
  my $QSystemIDs = {q<HTTP://WWW.IBM.COM/DATA/DTD/V11/IBMXHTML1-TRANSITIONAL.DTD> => 1};
  
        my $TCA = [undef,
          ## [1] after after body;COMMENT
          sub {
            my $token = $_;
  
              push @$OP, ['comment', $token => 0];
            
          },
        ,
          ## [2] after after body;END-ELSE
          sub {
            my $token = $_;
  push @$Errors, {type => 'after-after-body-else',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  
            $IM = IN_BODY_IM;
            #warn "Insertion mode changed to |in body| ($IM)";
          
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
          },
        ,
          ## [3] after after body;EOF
          sub {
            push @$OP, ['stop-parsing'];
          },
        ,
          ## [4] after after body;START-ELSE
          sub {
            my $token = $_;
  push @$Errors, {type => 'after-after-body-else',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  
            $IM = IN_BODY_IM;
            #warn "Insertion mode changed to |in body| ($IM)";
          
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
          },
        ,
          ## [5] after after body;TEXT
          sub {
            my $token = $_;
  
          if ($token->{value} =~ s/^([\x09\x0A\x0C\x20]+)//) {
            &reconstruct_afe if @$AFE and ref $AFE->[-1];
  
        push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
      
            $token->{index} += length $1;
          }
          if (length $token->{value}) {
            push @$Errors, {type => 'after-after-body-else',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  
            $IM = IN_BODY_IM;
            #warn "Insertion mode changed to |in body| ($IM)";
          
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
          }
        
          },
        ,
          ## [6] after after frameset;COMMENT
          sub {
            my $token = $_;
  
              push @$OP, ['comment', $token => 0];
            
          },
        ,
          ## [7] after after frameset;END-ELSE
          sub {
            my $token = $_;
  push @$Errors, {type => 'after-after-body-else',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  return;
          },
        ,
          ## [8] after after frameset;EOF
          sub {
            push @$OP, ['stop-parsing'];
          },
        ,
          ## [9] after after frameset;START-ELSE
          sub {
            my $token = $_;
  push @$Errors, {type => 'after-after-body-else',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  return;
          },
        ,
          ## [10] after after frameset;TEXT
          sub {
            my $token = $_;
  
            while (length $token->{value}) {
              if ($token->{value} =~ s/^([^\x09\x0A\x0C\x20]+)//) {
                
              my $value = $1;
              while ($value =~ /(.)/gs) {
                push @$Errors, {type => 'after-after-body-else',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index} + $-[1]};
              }
              
            
                $token->{index} += length $1;
              }
              if ($token->{value} =~ s/^([\x09\x0A\x0C\x20]+)//) {
                &reconstruct_afe if @$AFE and ref $AFE->[-1];
  
        push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
      
                $token->{index} += length $1;
              }
            }
          
          },
        ,
          ## [11] after body;COMMENT
          sub {
            my $token = $_;
  
              push @$OP, ['comment', $token => $OE->[0]->{id}];
            
          },
        ,
          ## [12] after body;DOCTYPE
          sub {
            my $token = $_;
  push @$Errors, {type => 'doctype:bad context',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  return;
          },
        ,
          ## [13] after body;END-ELSE
          sub {
            my $token = $_;
  push @$Errors, {type => 'after-body-else',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  
            $IM = IN_BODY_IM;
            #warn "Insertion mode changed to |in body| ($IM)";
          
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
          },
        ,
          ## [14] after body;END:html
          sub {
            my $token = $_;
  
            if (defined $CONTEXT) {
              push @$Errors, {type => 'stray end tag',
                                              level => 'm',
                                              value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
  return;
            } else {
              
            $IM = AFTER_AFTER_BODY_IM;
            #warn "Insertion mode changed to |after after body| ($IM)";
          
            }
          
          },
        ,
          ## [15] after body;EOF
          sub {
            push @$OP, ['stop-parsing'];
          },
        ,
          ## [16] after body;START-ELSE
          sub {
            my $token = $_;
  push @$Errors, {type => 'after-body-else',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  
            $IM = IN_BODY_IM;
            #warn "Insertion mode changed to |in body| ($IM)";
          
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
          },
        ,
          ## [17] after body;TEXT
          sub {
            my $token = $_;
  
          if ($token->{value} =~ s/^([\x09\x0A\x0C\x20]+)//) {
            &reconstruct_afe if @$AFE and ref $AFE->[-1];
  
        push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
      
            $token->{index} += length $1;
          }
          if (length $token->{value}) {
            push @$Errors, {type => 'after-body-else',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  
            $IM = IN_BODY_IM;
            #warn "Insertion mode changed to |in body| ($IM)";
          
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
          }
        
          },
        ,
          ## [18] after frameset;COMMENT
          sub {
            my $token = $_;
  
            push @$OP, ['comment', $token => $OE->[-1]->{id}];
          
          },
        ,
          ## [19] after frameset;DOCTYPE
          sub {
            my $token = $_;
  push @$Errors, {type => 'doctype:bad context',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  return;
          },
        ,
          ## [20] after frameset;END-ELSE
          sub {
            my $token = $_;
  push @$Errors, {type => 'after-body-else',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  return;
          },
        ,
          ## [21] after frameset;END:html
          sub {
            
            $IM = AFTER_AFTER_FRAMESET_IM;
            #warn "Insertion mode changed to |after after frameset| ($IM)";
          
          },
        ,
          ## [22] after frameset;EOF
          sub {
            push @$OP, ['stop-parsing'];
          },
        ,
          ## [23] after frameset;START-ELSE
          sub {
            my $token = $_;
  push @$Errors, {type => 'after-body-else',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  return;
          },
        ,
          ## [24] after frameset;TEXT
          sub {
            my $token = $_;
  
            while (length $token->{value}) {
              if ($token->{value} =~ s/^([^\x09\x0A\x0C\x20]+)//) {
                
              my $value = $1;
              while ($value =~ /(.)/gs) {
                push @$Errors, {type => 'after-body-else',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index} + $-[1]};
              }
              
            
                $token->{index} += length $1;
              }
              if ($token->{value} =~ s/^([\x09\x0A\x0C\x20]+)//) {
                
        push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
      
                $token->{index} += length $1;
              }
            }
          
          },
        ,
          ## [25] after head;COMMENT
          sub {
            my $token = $_;
  
            push @$OP, ['comment', $token => $OE->[-1]->{id}];
          
          },
        ,
          ## [26] after head;DOCTYPE
          sub {
            my $token = $_;
  push @$Errors, {type => 'doctype:bad context',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  return;
          },
        ,
          ## [27] after head;END-ELSE
          sub {
            my $token = $_;
  push @$Errors, {type => 'stray end tag',
                                              level => 'm',
                                              value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
  return;
          },
        ,
          ## [28] after head;END:body,br,html
          sub {
            my $token = $_;
  
          my $node_body = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'body',
                   attr_list => [],
                   et => (BODY_EL), aet => (BODY_EL) };
        
  
        push @$OP, ['insert', $node_body => $OE->[-1]->{id}];
      
  
  push @$OE, $node_body;
  
            $IM = IN_BODY_IM;
            #warn "Insertion mode changed to |in body| ($IM)";
          
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
          },
        ,
          ## [29] after head;EOF
          sub {
            my $token = $_;
  
          my $node_body = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'body',
                   attr_list => [],
                   et => (BODY_EL), aet => (BODY_EL) };
        
  
        push @$OP, ['insert', $node_body => $OE->[-1]->{id}];
      
  
  push @$OE, $node_body;
  
            $IM = IN_BODY_IM;
            #warn "Insertion mode changed to |in body| ($IM)";
          
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
          },
        ,
          ## [30] after head;START-ELSE
          sub {
            my $token = $_;
  
          my $node_body = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'body',
                   attr_list => [],
                   et => (BODY_EL), aet => (BODY_EL) };
        
  
        push @$OP, ['insert', $node_body => $OE->[-1]->{id}];
      
  
  push @$OE, $node_body;
  
            $IM = IN_BODY_IM;
            #warn "Insertion mode changed to |in body| ($IM)";
          
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
          },
        ,
          ## [31] after head;START:base,basefont bgsound link
          sub {
            my $token = $_;
  push @$Errors, {type => 'after head',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  push @$OE, $HEAD_ELEMENT;
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => $token->{tag_name},
                   attr_list => $token->{attr_list},
                   et => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}, aet => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'} };
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  
  
            if (delete $token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc', level => 'w',
                              text => $token->{tag_name},
                              di => $token->{di}, index => $token->{index}};
            }
          
  @$OE = grep { $_ ne $HEAD_ELEMENT } @$OE;
          },
        ,
          ## [32] after head;START:body
          sub {
            my $token = $_;
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'body',
                   attr_list => $token->{attr_list},
                   et => (BODY_EL), aet => (BODY_EL) };
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  
  push @$OE, $node;
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  
          $FRAMESET_OK = 0;
        
  
            $IM = IN_BODY_IM;
            #warn "Insertion mode changed to |in body| ($IM)";
          
          },
        ,
          ## [33] after head;START:frameset
          sub {
            my $token = $_;
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'frameset',
                   attr_list => $token->{attr_list},
                   et => (FRAMESET_EL), aet => (FRAMESET_EL) };
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  
  push @$OE, $node;
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  
            $IM = IN_FRAMESET_IM;
            #warn "Insertion mode changed to |in frameset| ($IM)";
          
          },
        ,
          ## [34] after head;START:head
          sub {
            my $token = $_;
  push @$Errors, {type => 'after head',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  return;
          },
        ,
          ## [35] after head;START:meta
          sub {
            my $token = $_;
  push @$Errors, {type => 'after head',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  push @$OE, $HEAD_ELEMENT;
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'meta',
                   attr_list => $token->{attr_list},
                   et => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS), aet => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS) };
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  
  
            if (delete $token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc', level => 'w',
                              text => $token->{tag_name},
                              di => $token->{di}, index => $token->{index}};
            }
          
  
          if (defined $token->{attrs}->{charset}) {
            push @$OP, ['change-the-encoding',
                        (join '', map { $_->[0] } @{$token->{attrs}->{charset}->{value}}), # IndexedString
                        $token->{attrs}->{charset}];
          } elsif (defined $token->{attrs}->{'http-equiv'} and
                   defined $token->{attrs}->{content}) {
            # IndexedString
            if ((join '', map { $_->[0] } @{$token->{attrs}->{'http-equiv'}->{value}})
                    =~ /\A[Cc][Oo][Nn][Tt][Ee][Nn][Tt]-[Tt][Yy][Pp][Ee]\z/ and
                (join '', map { $_->[0] } @{$token->{attrs}->{content}->{value}})
                    =~ /[Cc][Hh][Aa][Rr][Ss][Ee][Tt]
                          [\x09\x0A\x0C\x0D\x20]*=
                          [\x09\x0A\x0C\x0D\x20]*(?>"([^"]*)"|'([^']*)'|
                          ([^"'\x09\x0A\x0C\x0D\x20]
                           [^\x09\x0A\x0C\x0D\x20\x3B]*))/x) {
              push @$OP, ['change-the-encoding',
                          defined $1 ? $1 : defined $2 ? $2 : $3,
                          $token->{attrs}->{content}];
            }
          }
        
  @$OE = grep { $_ ne $HEAD_ELEMENT } @$OE;
          },
        ,
          ## [36] after head;START:noframes,style
          sub {
            my $token = $_;
  push @$Errors, {type => 'after head',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  push @$OE, $HEAD_ELEMENT;
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => $token->{tag_name},
                   attr_list => $token->{attr_list},
                   et => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}, aet => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'} };
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  
  push @$OE, $node;
  $State = RAWTEXT_STATE;
  $ORIGINAL_IM = $IM;
  
            $IM = TEXT_IM;
            #warn "Insertion mode changed to |text| ($IM)";
          
  @$OE = grep { $_ ne $HEAD_ELEMENT } @$OE;
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
          },
        ,
          ## [37] after head;START:script
          sub {
            my $token = $_;
  push @$Errors, {type => 'after head',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  push @$OE, $HEAD_ELEMENT;
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'script',
                   attr_list => $token->{attr_list},
                   et => (SCRIPT_EL), aet => (SCRIPT_EL) , script_flags => 1};
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  
  push @$OE, $node;
  $State = SCRIPT_DATA_STATE;
  $ORIGINAL_IM = $IM;
  
            $IM = TEXT_IM;
            #warn "Insertion mode changed to |text| ($IM)";
          
  @$OE = grep { $_ ne $HEAD_ELEMENT } @$OE;
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
          },
        ,
          ## [38] after head;START:template
          sub {
            my $token = $_;
  push @$Errors, {type => 'after head',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  push @$OE, $HEAD_ELEMENT;
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'template',
                   attr_list => $token->{attr_list},
                   et => (TEMPLATE_EL), aet => (TEMPLATE_EL) };
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  
  push @$OE, $node;
  push @$AFE, '#marker';
  
          $FRAMESET_OK = 0;
        
  
            $IM = IN_TEMPLATE_IM;
            #warn "Insertion mode changed to |in template| ($IM)";
          
  
          push @$TEMPLATE_IMS, IN_TEMPLATE_IM;
        
  @$OE = grep { $_ ne $HEAD_ELEMENT } @$OE;
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
          },
        ,
          ## [39] after head;START:title
          sub {
            my $token = $_;
  push @$Errors, {type => 'after head',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  push @$OE, $HEAD_ELEMENT;
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'title',
                   attr_list => $token->{attr_list},
                   et => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS), aet => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS) };
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  
  push @$OE, $node;
  $State = RCDATA_STATE;
  $ORIGINAL_IM = $IM;
  
            $IM = TEXT_IM;
            #warn "Insertion mode changed to |text| ($IM)";
          
  @$OE = grep { $_ ne $HEAD_ELEMENT } @$OE;
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
          },
        ,
          ## [40] after head;TEXT
          sub {
            my $token = $_;
  
          if ($token->{value} =~ s/^([\x09\x0A\x0C\x20]+)//) {
            
        push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
      
            $token->{index} += length $1;
          }
          if (length $token->{value}) {
            
          my $node_body = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'body',
                   attr_list => [],
                   et => (BODY_EL), aet => (BODY_EL) };
        
  
        push @$OP, ['insert', $node_body => $OE->[-1]->{id}];
      
  
  push @$OE, $node_body;
  
            $IM = IN_BODY_IM;
            #warn "Insertion mode changed to |in body| ($IM)";
          
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
          }
        
          },
        ,
          ## [41] before head;COMMENT
          sub {
            my $token = $_;
  
            push @$OP, ['comment', $token => $OE->[-1]->{id}];
          
          },
        ,
          ## [42] before head;DOCTYPE
          sub {
            my $token = $_;
  push @$Errors, {type => 'doctype:bad context',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  return;
          },
        ,
          ## [43] before head;END-ELSE
          sub {
            my $token = $_;
  push @$Errors, {type => 'stray end tag',
                                              level => 'm',
                                              value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
  return;
          },
        ,
          ## [44] before head;END:body,br,head,html
          sub {
            my $token = $_;
  
          my $node_head = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'head',
                   attr_list => [],
                   et => (HEAD_EL), aet => (HEAD_EL) };
        
  
        push @$OP, ['insert', $node_head => $OE->[-1]->{id}];
      
  
  push @$OE, $node_head;
  $HEAD_ELEMENT = $node_head;
  
            $IM = IN_HEAD_IM;
            #warn "Insertion mode changed to |in head| ($IM)";
          
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
          },
        ,
          ## [45] before head;EOF
          sub {
            my $token = $_;
  
          my $node_head = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'head',
                   attr_list => [],
                   et => (HEAD_EL), aet => (HEAD_EL) };
        
  
        push @$OP, ['insert', $node_head => $OE->[-1]->{id}];
      
  
  push @$OE, $node_head;
  $HEAD_ELEMENT = $node_head;
  
            $IM = IN_HEAD_IM;
            #warn "Insertion mode changed to |in head| ($IM)";
          
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
          },
        ,
          ## [46] before head;START-ELSE
          sub {
            my $token = $_;
  
          my $node_head = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'head',
                   attr_list => [],
                   et => (HEAD_EL), aet => (HEAD_EL) };
        
  
        push @$OP, ['insert', $node_head => $OE->[-1]->{id}];
      
  
  push @$OE, $node_head;
  $HEAD_ELEMENT = $node_head;
  
            $IM = IN_HEAD_IM;
            #warn "Insertion mode changed to |in head| ($IM)";
          
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
          },
        ,
          ## [47] before head;START:head
          sub {
            my $token = $_;
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'head',
                   attr_list => $token->{attr_list},
                   et => (HEAD_EL), aet => (HEAD_EL) };
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  
  push @$OE, $node;
  $HEAD_ELEMENT = $node;
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  
            $IM = IN_HEAD_IM;
            #warn "Insertion mode changed to |in head| ($IM)";
          
          },
        ,
          ## [48] before head;TEXT
          sub {
            my $token = $_;
  
          if ($token->{value} =~ s/^([\x09\x0A\x0C\x20]+)//) {
            
            $token->{index} += length $1;
          }
          if (length $token->{value}) {
            
          my $node_head = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'head',
                   attr_list => [],
                   et => (HEAD_EL), aet => (HEAD_EL) };
        
  
        push @$OP, ['insert', $node_head => $OE->[-1]->{id}];
      
  
  push @$OE, $node_head;
  $HEAD_ELEMENT = $node_head;
  
            $IM = IN_HEAD_IM;
            #warn "Insertion mode changed to |in head| ($IM)";
          
  push @$OP, ['popped', [pop @$OE]];
  
            $IM = AFTER_HEAD_IM;
            #warn "Insertion mode changed to |after head| ($IM)";
          
  
          my $node_body = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'body',
                   attr_list => [],
                   et => (BODY_EL), aet => (BODY_EL) };
        
  
        push @$OP, ['insert', $node_body => $OE->[-1]->{id}];
      
  
  push @$OE, $node_body;
  
            $IM = IN_BODY_IM;
            #warn "Insertion mode changed to |in body| ($IM)";
          
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
          }
        
          },
        ,
          ## [49] before html;COMMENT
          sub {
            my $token = $_;
  
              push @$OP, ['comment', $token => 0];
            
          },
        ,
          ## [50] before html;DOCTYPE
          sub {
            my $token = $_;
  push @$Errors, {type => 'doctype:bad context',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  return;
          },
        ,
          ## [51] before html;END-ELSE
          sub {
            my $token = $_;
  push @$Errors, {type => 'stray end tag',
                                              level => 'm',
                                              value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
  return;
          },
        ,
          ## [52] before html;END:body,br,head,html
          sub {
            my $token = $_;
  
          my $node = {id => $NEXT_ID++,
                      token => $token,
                      di => $token->{di}, index => $token->{index},
                      ns => HTMLNS,
                      local_name => 'html',
                      attr_list => [],
                      et => (HTML_EL), aet => (HTML_EL)};
        
  push @$OP, ['insert', $node => 0];
  push @$OE, $node;
  push @$OP, ['appcache'];
  
            $IM = BEFORE_HEAD_IM;
            #warn "Insertion mode changed to |before head| ($IM)";
          
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
          },
        ,
          ## [53] before html;EOF
          sub {
            my $token = $_;
  
          my $node = {id => $NEXT_ID++,
                      token => $token,
                      di => $token->{di}, index => $token->{index},
                      ns => HTMLNS,
                      local_name => 'html',
                      attr_list => [],
                      et => (HTML_EL), aet => (HTML_EL)};
        
  push @$OP, ['insert', $node => 0];
  push @$OE, $node;
  push @$OP, ['appcache'];
  
            $IM = BEFORE_HEAD_IM;
            #warn "Insertion mode changed to |before head| ($IM)";
          
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
          },
        ,
          ## [54] before html;START-ELSE
          sub {
            my $token = $_;
  
          my $node = {id => $NEXT_ID++,
                      token => $token,
                      di => $token->{di}, index => $token->{index},
                      ns => HTMLNS,
                      local_name => 'html',
                      attr_list => [],
                      et => (HTML_EL), aet => (HTML_EL)};
        
  push @$OP, ['insert', $node => 0];
  push @$OE, $node;
  push @$OP, ['appcache'];
  
            $IM = BEFORE_HEAD_IM;
            #warn "Insertion mode changed to |before head| ($IM)";
          
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
          },
        ,
          ## [55] before html;START:html
          sub {
            my $token = $_;
  
          my $node = {id => $NEXT_ID++,
                      token => $token,
                      di => $token->{di}, index => $token->{index},
                      ns => HTMLNS,
                      local_name => 'html',
                      attr_list => $token->{attr_list},
                      et => (HTML_EL), aet => (HTML_EL)};
        
  push @$OP, ['insert', $node => 0];
  push @$OE, $node;
  push @$OP, ['appcache', $token->{attrs}->{manifest}];
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  
            $IM = BEFORE_HEAD_IM;
            #warn "Insertion mode changed to |before head| ($IM)";
          
          },
        ,
          ## [56] before html;TEXT
          sub {
            my $token = $_;
  
          if ($token->{value} =~ s/^([\x09\x0A\x0C\x20]+)//) {
            
            $token->{index} += length $1;
          }
          if (length $token->{value}) {
            
          my $node = {id => $NEXT_ID++,
                      token => $token,
                      di => $token->{di}, index => $token->{index},
                      ns => HTMLNS,
                      local_name => 'html',
                      attr_list => [],
                      et => (HTML_EL), aet => (HTML_EL)};
        
  push @$OP, ['insert', $node => 0];
  push @$OE, $node;
  push @$OP, ['appcache'];
  
            $IM = BEFORE_HEAD_IM;
            #warn "Insertion mode changed to |before head| ($IM)";
          
  
          my $node_head = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'head',
                   attr_list => [],
                   et => (HEAD_EL), aet => (HEAD_EL) };
        
  
        push @$OP, ['insert', $node_head => $OE->[-1]->{id}];
      
  
  push @$OE, $node_head;
  $HEAD_ELEMENT = $node_head;
  
            $IM = IN_HEAD_IM;
            #warn "Insertion mode changed to |in head| ($IM)";
          
  push @$OP, ['popped', [pop @$OE]];
  
            $IM = AFTER_HEAD_IM;
            #warn "Insertion mode changed to |after head| ($IM)";
          
  
          my $node_body = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'body',
                   attr_list => [],
                   et => (BODY_EL), aet => (BODY_EL) };
        
  
        push @$OP, ['insert', $node_body => $OE->[-1]->{id}];
      
  
  push @$OE, $node_body;
  
            $IM = IN_BODY_IM;
            #warn "Insertion mode changed to |in body| ($IM)";
          
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
          }
        
          },
        ,
          ## [57] before ignored newline and text;ELSE
          sub {
            
        $IM = TEXT_IM;
        goto &{$ProcessIM->[$IM]->[$_->{type}]->[$_->{tn}]};
      
          },
        ,
          ## [58] before ignored newline and text;TEXT
          sub {
            
        $_->{index}++ if $_->{value} =~ s/^\x0A//;
        $IM = TEXT_IM;
        goto &{$ProcessIM->[$IM]->[$_->{type}]->[0]} if length $_->{value};
      
          },
        ,
          ## [59] before ignored newline;ELSE
          sub {
            
      $IM = $ORIGINAL_IM;
      goto &{$ProcessIM->[$IM]->[$_->{type}]->[$_->{tn}]};
    
          },
        ,
          ## [60] before ignored newline;TEXT
          sub {
            
      $_->{index}++ if $_->{value} =~ s/^\x0A//;
      $IM = $ORIGINAL_IM;
      goto &{$ProcessIM->[$IM]->[$_->{type}]->[0]} if length $_->{value};
    
          },
        ,
          ## [61] in body;COMMENT
          sub {
            my $token = $_;
  
            push @$OP, ['comment', $token => $OE->[-1]->{id}];
          
          },
        ,
          ## [62] in body;DOCTYPE
          sub {
            my $token = $_;
  push @$Errors, {type => 'doctype:bad context',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  return;
          },
        ,
          ## [63] in body;END-ELSE
          sub {
            my $token = $_;
  
            for my $i (reverse 0..$#$OE) {
              my $_node = $OE->[$i];
              
            if ($_node->{ns} == HTMLNS and $_node->{local_name} eq $token->{tag_name}) {
              {
              my @popped;
              push @popped, pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | OPT_OPT_ELS | P_ELS | RB_RP_RT_ELS | RTC_ELS) and not ($OE->[-1]->{ns} == HTMLNS and $OE->[-1]->{local_name} eq $token->{tag_name});
              push @$OP, ['popped', \@popped];
            }
  
            if (not ($OE->[-1] eq $_node)) {
              push @$Errors, {type => 'not closed before ancestor end tag',
                                              level => 'm',
                                              text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1] eq $_node);
            push @popped, pop @$OE;
            push @$OP, ['popped', \@popped];
          }
  return;
            } else {
              
            if ($_node->{et} & (ADD_DIV_ELS | APP_MAR_M_ANN_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS | BOD_ELS | BUT_ELS | CAP_ELS | COL_ELS | DD_ELS | DT_ELS | FIE_INP_SEL_ELS | HHHHHH_ELS | HTM_ELS | IMG_ELS | LI_ELS | OBJ_ELS | OL_UL_ELS | P_ELS | STY_ELS | TAB_ELS | TBO_TFO_THE_ELS | TD_TH_ELS | TEM_ELS | TEX_ELS | TR_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) {
              push @$Errors, {type => 'stray end tag',
                                              level => 'm',
                                              value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
  return;
  return;
            }
          
            }
          
            }
          
          },
        ,
          ## [64] in body;END:a,b big code em i s small strike strong tt u,font,nobr
          sub {
            my $token = $_;
  aaa ($token, $token->{tag_name});
          },
        ,
          ## [65] in body;END:address article aside details dialog dir figcaption figure footer header hgroup main nav section summary,blockquote center div dl menu ol ul,button,fieldset,listing pre
          sub {
            my $token = $_;
  
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} & HTML_NS_ELS and $_->{local_name} eq $token->{tag_name}) {
              $result = 1;
              last;
            } elsif ($_->{et} & (APP_MAR_M_ANN_ELS | CAP_ELS | HTM_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
            }
          }
          not $result;
        }
      ) {
              push @$Errors, {type => 'stray end tag',
                                              level => 'm',
                                              value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
  return;
            } else {
              pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | OPT_OPT_ELS | P_ELS | RB_RP_RT_ELS | RTC_ELS);
  
            if (not ($OE->[-1]->{et} & HTML_NS_ELS and $OE->[-1]->{local_name} eq $token->{tag_name})) {
              push @$Errors, {type => 'not closed before ancestor end tag',
                                              level => 'm',
                                              text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} & HTML_NS_ELS and $OE->[-1]->{local_name} eq $token->{tag_name});
            push @popped, pop @$OE;
            push @$OP, ['popped', \@popped];
          }
            }
          
          },
        ,
          ## [66] in body;END:applet marquee,object
          sub {
            my $token = $_;
  
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} & HTML_NS_ELS and $_->{local_name} eq $token->{tag_name}) {
              $result = 1;
              last;
            } elsif ($_->{et} & (APP_MAR_M_ANN_ELS | CAP_ELS | HTM_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
            }
          }
          not $result;
        }
      ) {
              push @$Errors, {type => 'stray end tag',
                                              level => 'm',
                                              value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
  return;
            } else {
              pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | OPT_OPT_ELS | P_ELS | RB_RP_RT_ELS | RTC_ELS);
  
            if (not ($OE->[-1]->{et} & HTML_NS_ELS and $OE->[-1]->{local_name} eq $token->{tag_name})) {
              push @$Errors, {type => 'not closed before ancestor end tag',
                                              level => 'm',
                                              text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} & HTML_NS_ELS and $OE->[-1]->{local_name} eq $token->{tag_name});
            push @popped, pop @$OE;
            push @$OP, ['popped', \@popped];
          }
  
          pop @$AFE while ref $AFE->[-1];
          pop @$AFE; # #marker
        
            }
          
          },
        ,
          ## [67] in body;END:body
          sub {
            my $token = $_;
  
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} & (BOD_ELS)) {
              $result = 1;
              last;
            } elsif ($_->{et} & (APP_MAR_M_ANN_ELS | CAP_ELS | HTM_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
            }
          }
          not $result;
        }
      ) {
              push @$Errors, {type => 'stray end tag',
                                              level => 'm',
                                              value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
  return;
            } else {
              
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            unless ($_->{et} & (BOD_ELS | DD_ELS | DT_ELS | HTM_ELS | LI_ELS | OPT_OPT_ELS | P_ELS | RB_RP_RT_ELS | RTC_ELS | TBO_TFO_THE_ELS | TD_TH_ELS | TR_ELS)) {
              $result = 1;
              last;
            
            }
          }
           $result;
        }
      ) {
              push @$Errors, {type => 'not closed before ancestor end tag',
                                              level => 'm',
                                              text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  
            $IM = AFTER_BODY_IM;
            #warn "Insertion mode changed to |after body| ($IM)";
          
            }
          
          },
        ,
          ## [68] in body;END:br
          sub {
            my $token = $_;
  push @$Errors, {type => '</br>',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  &reconstruct_afe if @$AFE and ref $AFE->[-1];
  
          my $node_br = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'br',
                   attr_list => [],
                   et => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS), aet => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS) };
        
  
        push @$OP, ['insert', $node_br => $OE->[-1]->{id}];
      
  
  
            if (delete $token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc', level => 'w',
                              text => $token->{tag_name},
                              di => $token->{di}, index => $token->{index}};
            }
          
  
          $FRAMESET_OK = 0;
        
          },
        ,
          ## [69] in body;END:dd dt
          sub {
            my $token = $_;
  
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} & HTML_NS_ELS and $_->{local_name} eq $token->{tag_name}) {
              $result = 1;
              last;
            } elsif ($_->{et} & (APP_MAR_M_ANN_ELS | CAP_ELS | HTM_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
            }
          }
          not $result;
        }
      ) {
              push @$Errors, {type => 'stray end tag',
                                              level => 'm',
                                              value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
  return;
            } else {
              {
              my @popped;
              push @popped, pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | OPT_OPT_ELS | P_ELS | RB_RP_RT_ELS | RTC_ELS) and not ($OE->[-1]->{ns} == HTMLNS and $OE->[-1]->{local_name} eq $token->{tag_name});
              push @$OP, ['popped', \@popped];
            }
  
            if (not ($OE->[-1]->{et} & HTML_NS_ELS and $OE->[-1]->{local_name} eq $token->{tag_name})) {
              push @$Errors, {type => 'not closed before ancestor end tag',
                                              level => 'm',
                                              text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} & HTML_NS_ELS and $OE->[-1]->{local_name} eq $token->{tag_name});
            push @popped, pop @$OE;
            push @$OP, ['popped', \@popped];
          }
            }
          
          },
        ,
          ## [70] in body;END:form
          sub {
            my $token = $_;
  
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} & (TEM_ELS)) {
              $result = 1;
              last;
            
            }
          }
          not $result;
        }
      ) {
              my $_node = $FORM_ELEMENT;
  $FORM_ELEMENT = undef;
  
            if ((not defined $_node) or 
  (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_ eq $_node) {
              $result = 1;
              last;
            
            }
          }
          not $result;
        }
      )) {
              push @$Errors, {type => 'stray end tag',
                                              level => 'm',
                                              value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
  return;
  return;
            }
          
  pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | OPT_OPT_ELS | P_ELS | RB_RP_RT_ELS | RTC_ELS);
  
            if (not ($OE->[-1] eq $_node)) {
              push @$Errors, {type => 'not closed before ancestor end tag',
                                              level => 'm',
                                              text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  @$OE = grep { $_ ne $_node } @$OE;
            }
          
  
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} & (TEM_ELS)) {
              $result = 1;
              last;
            
            }
          }
           $result;
        }
      ) {
              
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} == FORM_EL) {
              $result = 1;
              last;
            } elsif ($_->{et} & (APP_MAR_M_ANN_ELS | CAP_ELS | HTM_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
            }
          }
          not $result;
        }
      ) {
              push @$Errors, {type => 'stray end tag',
                                              level => 'm',
                                              value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
  return;
  return;
            }
          
  pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | OPT_OPT_ELS | P_ELS | RB_RP_RT_ELS | RTC_ELS);
  
            if (not ($OE->[-1]->{et} == FORM_EL)) {
              push @$Errors, {type => 'not closed before ancestor end tag',
                                              level => 'm',
                                              text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} == FORM_EL);
            push @popped, pop @$OE;
            push @$OP, ['popped', \@popped];
          }
            }
          
          },
        ,
          ## [71] in body;END:h1 h2 h3 h4 h5 h6
          sub {
            my $token = $_;
  
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} & (HHHHHH_ELS)) {
              $result = 1;
              last;
            } elsif ($_->{et} & (APP_MAR_M_ANN_ELS | CAP_ELS | HTM_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
            }
          }
          not $result;
        }
      ) {
              push @$Errors, {type => 'stray end tag',
                                              level => 'm',
                                              value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
  return;
            } else {
              pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | OPT_OPT_ELS | P_ELS | RB_RP_RT_ELS | RTC_ELS);
  
            if (not ($OE->[-1]->{et} & HTML_NS_ELS and $OE->[-1]->{local_name} eq $token->{tag_name})) {
              push @$Errors, {type => 'not closed before ancestor end tag',
                                              level => 'm',
                                              text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} & (HHHHHH_ELS));
            push @popped, pop @$OE;
            push @$OP, ['popped', \@popped];
          }
            }
          
          },
        ,
          ## [72] in body;END:html
          sub {
            my $token = $_;
  
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} & (BOD_ELS)) {
              $result = 1;
              last;
            } elsif ($_->{et} & (APP_MAR_M_ANN_ELS | CAP_ELS | HTM_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
            }
          }
          not $result;
        }
      ) {
              push @$Errors, {type => 'stray end tag',
                                              level => 'm',
                                              value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
  return;
            } else {
              
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            unless ($_->{et} & (BOD_ELS | DD_ELS | DT_ELS | HTM_ELS | LI_ELS | OPT_OPT_ELS | P_ELS | RB_RP_RT_ELS | RTC_ELS | TBO_TFO_THE_ELS | TD_TH_ELS | TR_ELS)) {
              $result = 1;
              last;
            
            }
          }
           $result;
        }
      ) {
              push @$Errors, {type => 'not closed before ancestor end tag',
                                              level => 'm',
                                              text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  
            $IM = AFTER_BODY_IM;
            #warn "Insertion mode changed to |after body| ($IM)";
          
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
            }
          
          },
        ,
          ## [73] in body;END:li
          sub {
            my $token = $_;
  
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} & (LI_ELS)) {
              $result = 1;
              last;
            } elsif ($_->{et} & (APP_MAR_M_ANN_ELS | CAP_ELS | HTM_ELS | OBJ_ELS | OL_UL_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
            }
          }
          not $result;
        }
      ) {
              push @$Errors, {type => 'stray end tag',
                                              level => 'm',
                                              value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
  return;
            } else {
              pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | OPT_OPT_ELS | P_ELS | RB_RP_RT_ELS | RTC_ELS);
  
            if (not ($OE->[-1]->{et} & (LI_ELS))) {
              push @$Errors, {type => 'not closed before ancestor end tag',
                                              level => 'm',
                                              text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} & (LI_ELS));
            push @popped, pop @$OE;
            push @$OP, ['popped', \@popped];
          }
            }
          
          },
        ,
          ## [74] in body;END:p
          sub {
            my $token = $_;
  
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} & (P_ELS)) {
              $result = 1;
              last;
            } elsif ($_->{et} & (APP_MAR_M_ANN_ELS | BUT_ELS | CAP_ELS | HTM_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
            }
          }
          not $result;
        }
      ) {
              push @$Errors, {type => '</p>',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  
          my $node_p = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'p',
                   attr_list => [],
                   et => (P_EL), aet => (P_EL) };
        
  
        push @$OP, ['insert', $node_p => $OE->[-1]->{id}];
      
  
  push @$OE, $node_p;
            }
          
  pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | OPT_OPT_ELS | RB_RP_RT_ELS | RTC_ELS);
  
            if (not ($OE->[-1]->{et} & (P_ELS))) {
              push @$Errors, {type => 'not closed before ancestor end tag',
                                              level => 'm',
                                              text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} & (P_ELS));
            push @popped, pop @$OE;
            push @$OP, ['popped', \@popped];
          }
          },
        ,
          ## [75] in body;END:sarcasm
          sub {
            my $token = $_;
  
          ## Take a deep breath!
        
  
            for my $i (reverse 0..$#$OE) {
              my $_node = $OE->[$i];
              
            if ($_node->{et} & HTML_NS_ELS and $_node->{local_name} eq $token->{tag_name}) {
              {
              my @popped;
              push @popped, pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | OPT_OPT_ELS | P_ELS | RB_RP_RT_ELS | RTC_ELS) and not ($OE->[-1]->{ns} == HTMLNS and $OE->[-1]->{local_name} eq $token->{tag_name});
              push @$OP, ['popped', \@popped];
            }
  
            if (not ($OE->[-1] eq $_node)) {
              push @$Errors, {type => 'not closed before ancestor end tag',
                                              level => 'm',
                                              text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1] eq $_node);
            push @popped, pop @$OE;
            push @$OP, ['popped', \@popped];
          }
  return;
            } else {
              
            if ($_node->{et} & (ADD_DIV_ELS | APP_MAR_M_ANN_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS | BOD_ELS | BUT_ELS | CAP_ELS | COL_ELS | DD_ELS | DT_ELS | FIE_INP_SEL_ELS | HHHHHH_ELS | HTM_ELS | IMG_ELS | LI_ELS | OBJ_ELS | OL_UL_ELS | P_ELS | STY_ELS | TAB_ELS | TBO_TFO_THE_ELS | TD_TH_ELS | TEM_ELS | TEX_ELS | TR_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) {
              push @$Errors, {type => 'stray end tag',
                                              level => 'm',
                                              value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
  return;
  return;
            }
          
            }
          
            }
          
          },
        ,
          ## [76] in body;EOF
          sub {
            my $token = $_;
  
            if (@$TEMPLATE_IMS) {
              
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} & (TEM_ELS)) {
              $result = 1;
              last;
            
            }
          }
          not $result;
        }
      ) {
              push @$OP, ['stop-parsing'];
            } else {
              push @$Errors, {type => 'in body:#eof',
                                              level => 'm',
                                              text => $OE->[-1]->{local_name},di => $token->{di},
                                  index => $token->{index}};
  {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} & (TEM_ELS));
            push @popped, pop @$OE;
            push @$OP, ['popped', \@popped];
          }
  
          pop @$AFE while ref $AFE->[-1];
          pop @$AFE; # #marker
        
  pop @$TEMPLATE_IMS;
  &reset_im;
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
            }
          
            } else {
              
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            unless ($_->{et} & (BOD_ELS | DD_ELS | DT_ELS | HTM_ELS | LI_ELS | OPT_OPT_ELS | P_ELS | RB_RP_RT_ELS | RTC_ELS | TBO_TFO_THE_ELS | TD_TH_ELS | TR_ELS)) {
              $result = 1;
              last;
            
            }
          }
           $result;
        }
      ) {
              push @$Errors, {type => 'in body:#eof',
                                              level => 'm',
                                              text => $OE->[-1]->{local_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  push @$OP, ['stop-parsing'];
            }
          
          },
        ,
          ## [77] in body;START-ELSE
          sub {
            my $token = $_;
  &reconstruct_afe if @$AFE and ref $AFE->[-1];
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => $token->{tag_name},
                   attr_list => $token->{attr_list},
                   et => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}, aet => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'} };
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  
              if ($node->{et} & (BUT_ELS | FIE_INP_SEL_ELS | IMG_ELS | OBJ_ELS | OUT_ELS | TEX_ELS)) {
                
            if (defined $FORM_ELEMENT) {
              FORM: {
                last FORM if defined $token->{attrs}->{form} and
                             ($node->{et} & ()); # reassociateable
                for my $oe (@$OE) {
                  if ($oe->{et} & (TEM_ELS)) { # template
                    last FORM;
                  }
                }
                #last FORM unless $FORM_ELEMENT and $OE->[-1] (intended parent) same home subtree - should be checked later
                $node->{form} = $FORM_ELEMENT->{id};
              } # FORM
            }
          
              }
            
  push @$OE, $node;
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
          },
        ,
          ## [78] in body;START:a
          sub {
            my $token = $_;
  
            if (
        do {
          my $result = 0;
          for (reverse @$AFE) {
            last if not ref $_;
            if ($_->{et} == A_EL) {
              $result = 1;
              last;
            }
          }
          $result;
        }
      ) {
              push @$Errors, {type => 'parser:element not nestable',
                                              level => 'm',
                                              value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
  aaa ($token, $token->{tag_name}, remove_from_afe_and_oe => 1);
            }
          
  &reconstruct_afe if @$AFE and ref $AFE->[-1];
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'a',
                   attr_list => $token->{attr_list},
                   et => (A_EL), aet => (A_EL) };
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  
  push @$OE, $node;
  
          ## Noah's Ark
          my $found = 0;
          AFE: for my $i (reverse 0..$#$AFE) {
            if (not ref $AFE->[$i]) { # marker
              last;
            } elsif ($node->{local_name} eq $AFE->[$i]->{local_name}
                     #and $node->{ns} == $AFE->[$i]->{ns}
            ) {
              ## Note that elements in $AFE are always HTML elements.
              for (keys %{$node->{token}->{attrs} or {}}) {
                my $attr = $AFE->[$i]->{token}->{attrs}->{$_};
                next AFE unless defined $attr;
                #next AFE unless $attr->{ns} == $node->{token}->{attrs}->{$_}->{ns};
                # IndexedString
                next AFE unless (join '', map { $_->[0] } @{$attr->{value}}) eq
                                (join '', map { $_->[0] } @{$node->{token}->{attrs}->{$_}->{value}});
              }
              next AFE unless (keys %{$node->{token}->{attrs} or {}}) == (keys %{$AFE->[$i]->{token}->{attrs} or {}});
  
              $found++;
              if ($found == 3) {
                splice @$AFE, $i, 1, ();
                last AFE;
              }
            }
          } # AFE
  
          push @$AFE, $node;
        
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
          },
        ,
          ## [79] in body;START:address article aside details dialog dir figcaption figure footer header hgroup main nav section summary,blockquote center div dl menu ol ul,fieldset,p
          sub {
            my $token = $_;
  
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} & (P_ELS)) {
              $result = 1;
              last;
            } elsif ($_->{et} & (APP_MAR_M_ANN_ELS | BUT_ELS | CAP_ELS | HTM_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
            }
          }
           $result;
        }
      ) {
              pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | OPT_OPT_ELS | RB_RP_RT_ELS | RTC_ELS);
  
            if (not ($OE->[-1]->{et} & (P_ELS))) {
              push @$Errors, {type => 'not closed before ancestor end tag',
                                              level => 'm',
                                              text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} & (P_ELS));
            push @popped, pop @$OE;
            push @$OP, ['popped', \@popped];
          }
            }
          
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => $token->{tag_name},
                   attr_list => $token->{attr_list},
                   et => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}, aet => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'} };
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  
              if ($node->{et} & (BUT_ELS | FIE_INP_SEL_ELS | IMG_ELS | OBJ_ELS | OUT_ELS | TEX_ELS)) {
                
            if (defined $FORM_ELEMENT) {
              FORM: {
                last FORM if defined $token->{attrs}->{form} and
                             ($node->{et} & ()); # reassociateable
                for my $oe (@$OE) {
                  if ($oe->{et} & (TEM_ELS)) { # template
                    last FORM;
                  }
                }
                #last FORM unless $FORM_ELEMENT and $OE->[-1] (intended parent) same home subtree - should be checked later
                $node->{form} = $FORM_ELEMENT->{id};
              } # FORM
            }
          
              }
            
  push @$OE, $node;
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
          },
        ,
          ## [80] in body;START:applet marquee,object
          sub {
            my $token = $_;
  &reconstruct_afe if @$AFE and ref $AFE->[-1];
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => $token->{tag_name},
                   attr_list => $token->{attr_list},
                   et => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}, aet => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'} };
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  
              if ($node->{et} & (BUT_ELS | FIE_INP_SEL_ELS | IMG_ELS | OBJ_ELS | OUT_ELS | TEX_ELS)) {
                
            if (defined $FORM_ELEMENT) {
              FORM: {
                last FORM if defined $token->{attrs}->{form} and
                             ($node->{et} & ()); # reassociateable
                for my $oe (@$OE) {
                  if ($oe->{et} & (TEM_ELS)) { # template
                    last FORM;
                  }
                }
                #last FORM unless $FORM_ELEMENT and $OE->[-1] (intended parent) same home subtree - should be checked later
                $node->{form} = $FORM_ELEMENT->{id};
              } # FORM
            }
          
              }
            
  push @$OE, $node;
  push @$AFE, '#marker';
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  
          $FRAMESET_OK = 0;
        
          },
        ,
          ## [81] in body;START:area wbr,br,embed,img,keygen
          sub {
            my $token = $_;
  &reconstruct_afe if @$AFE and ref $AFE->[-1];
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => $token->{tag_name},
                   attr_list => $token->{attr_list},
                   et => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}, aet => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'} };
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  
              if ($node->{et} & (BUT_ELS | FIE_INP_SEL_ELS | IMG_ELS | OBJ_ELS | OUT_ELS | TEX_ELS)) {
                
            if (defined $FORM_ELEMENT) {
              FORM: {
                last FORM if defined $token->{attrs}->{form} and
                             ($node->{et} & ()); # reassociateable
                for my $oe (@$OE) {
                  if ($oe->{et} & (TEM_ELS)) { # template
                    last FORM;
                  }
                }
                #last FORM unless $FORM_ELEMENT and $OE->[-1] (intended parent) same home subtree - should be checked later
                $node->{form} = $FORM_ELEMENT->{id};
              } # FORM
            }
          
              }
            
  
            if (delete $token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc', level => 'w',
                              text => $token->{tag_name},
                              di => $token->{di}, index => $token->{index}};
            }
          
  
          $FRAMESET_OK = 0;
        
          },
        ,
          ## [82] in body;START:b big code em i s small strike strong tt u,font
          sub {
            my $token = $_;
  &reconstruct_afe if @$AFE and ref $AFE->[-1];
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => $token->{tag_name},
                   attr_list => $token->{attr_list},
                   et => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}, aet => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'} };
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  
  push @$OE, $node;
  
          ## Noah's Ark
          my $found = 0;
          AFE: for my $i (reverse 0..$#$AFE) {
            if (not ref $AFE->[$i]) { # marker
              last;
            } elsif ($node->{local_name} eq $AFE->[$i]->{local_name}
                     #and $node->{ns} == $AFE->[$i]->{ns}
            ) {
              ## Note that elements in $AFE are always HTML elements.
              for (keys %{$node->{token}->{attrs} or {}}) {
                my $attr = $AFE->[$i]->{token}->{attrs}->{$_};
                next AFE unless defined $attr;
                #next AFE unless $attr->{ns} == $node->{token}->{attrs}->{$_}->{ns};
                # IndexedString
                next AFE unless (join '', map { $_->[0] } @{$attr->{value}}) eq
                                (join '', map { $_->[0] } @{$node->{token}->{attrs}->{$_}->{value}});
              }
              next AFE unless (keys %{$node->{token}->{attrs} or {}}) == (keys %{$AFE->[$i]->{token}->{attrs} or {}});
  
              $found++;
              if ($found == 3) {
                splice @$AFE, $i, 1, ();
                last AFE;
              }
            }
          } # AFE
  
          push @$AFE, $node;
        
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
          },
        ,
          ## [83] in body;START:body
          sub {
            my $token = $_;
  push @$Errors, {type => 'duplicate body/html tag',
                                              level => 'm',
                                              value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
  
            if ((@$OE >= 2 and not ($OE->[1]->{et} & (BOD_ELS))) or 
  ($OE->[-1]->{et} & (HTM_ELS)) or 
  (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} & (TEM_ELS)) {
              $result = 1;
              last;
            
            }
          }
           $result;
        }
      )) {
              return;
            } else {
              
          $FRAMESET_OK = 0;
        
  
          push @$OP, ['set-if-missing', $token->{attr_list} => $OE->[1]->{id}]
              if @{$token->{attr_list} or []};
        
            }
          
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
          },
        ,
          ## [84] in body;START:button
          sub {
            my $token = $_;
  
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} & (BUT_ELS)) {
              $result = 1;
              last;
            } elsif ($_->{et} & (APP_MAR_M_ANN_ELS | CAP_ELS | HTM_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
            }
          }
           $result;
        }
      ) {
              push @$Errors, {type => 'parser:element not nestable',
                                              level => 'm',
                                              value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
  pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | OPT_OPT_ELS | P_ELS | RB_RP_RT_ELS | RTC_ELS);
  {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} & (BUT_ELS));
            push @popped, pop @$OE;
            push @$OP, ['popped', \@popped];
          }
            }
          
  &reconstruct_afe if @$AFE and ref $AFE->[-1];
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'button',
                   attr_list => $token->{attr_list},
                   et => (BUTTON_EL), aet => (BUTTON_EL) };
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  
            if (defined $FORM_ELEMENT) {
              FORM: {
                last FORM if defined $token->{attrs}->{form} and
                             ($node->{et} & ()); # reassociateable
                for my $oe (@$OE) {
                  if ($oe->{et} & (TEM_ELS)) { # template
                    last FORM;
                  }
                }
                #last FORM unless $FORM_ELEMENT and $OE->[-1] (intended parent) same home subtree - should be checked later
                $node->{form} = $FORM_ELEMENT->{id};
              } # FORM
            }
          
  push @$OE, $node;
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  
          $FRAMESET_OK = 0;
        
          },
        ,
          ## [85] in body;START:caption,col,colgroup,frame,head,tbody tfoot thead,td th,tr
          sub {
            my $token = $_;
  push @$Errors, {type => 'in body',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  return;
          },
        ,
          ## [86] in body;START:dd dt
          sub {
            my $token = $_;
  
          $FRAMESET_OK = 0;
        
  
            for my $i (reverse 0..$#$OE) {
              my $_node = $OE->[$i];
              
            if ($_node->{et} & (DD_ELS)) {
              pop @$OE while $OE->[-1]->{et} & (DT_ELS | LI_ELS | OPT_OPT_ELS | P_ELS | RB_RP_RT_ELS | RTC_ELS);
  
            if (not ($OE->[-1]->{et} & (DD_ELS))) {
              push @$Errors, {type => 'element not closed before implied ancestor end tag',
                                              level => 'm',
                                              text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} & (DD_ELS));
            push @popped, pop @$OE;
            push @$OP, ['popped', \@popped];
          }
  last;
            } else {
              
            if ($_node->{et} & (DT_ELS)) {
              pop @$OE while $OE->[-1]->{et} & (DD_ELS | LI_ELS | OPT_OPT_ELS | P_ELS | RB_RP_RT_ELS | RTC_ELS);
  
            if (not ($OE->[-1]->{et} & (DT_ELS))) {
              push @$Errors, {type => 'element not closed before implied ancestor end tag',
                                              level => 'm',
                                              text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} & (DT_ELS));
            push @popped, pop @$OE;
            push @$OP, ['popped', \@popped];
          }
  last;
            } else {
              
            if ($_node->{et} & (APP_MAR_M_ANN_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS | BOD_ELS | BUT_ELS | CAP_ELS | COL_ELS | DD_ELS | DT_ELS | FIE_INP_SEL_ELS | HHHHHH_ELS | HTM_ELS | IMG_ELS | LI_ELS | OBJ_ELS | OL_UL_ELS | STY_ELS | TAB_ELS | TBO_TFO_THE_ELS | TD_TH_ELS | TEM_ELS | TEX_ELS | TR_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) {
              last;
            } else {
              
            }
          
            }
          
            }
          
            }
          
  
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} & (P_ELS)) {
              $result = 1;
              last;
            } elsif ($_->{et} & (APP_MAR_M_ANN_ELS | BUT_ELS | CAP_ELS | HTM_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
            }
          }
           $result;
        }
      ) {
              pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | OPT_OPT_ELS | RB_RP_RT_ELS | RTC_ELS);
  
            if (not ($OE->[-1]->{et} & (P_ELS))) {
              push @$Errors, {type => 'not closed before ancestor end tag',
                                              level => 'm',
                                              text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} & (P_ELS));
            push @popped, pop @$OE;
            push @$OP, ['popped', \@popped];
          }
            }
          
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => $token->{tag_name},
                   attr_list => $token->{attr_list},
                   et => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}, aet => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'} };
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  
  push @$OE, $node;
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
          },
        ,
          ## [87] in body;START:form
          sub {
            my $token = $_;
  
            if ((defined $FORM_ELEMENT) and 
  (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} & (TEM_ELS)) {
              $result = 1;
              last;
            
            }
          }
          not $result;
        }
      )) {
              push @$Errors, {type => 'parser:element not nestable',
                                              level => 'm',
                                              value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            } else {
              
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} & (P_ELS)) {
              $result = 1;
              last;
            } elsif ($_->{et} & (APP_MAR_M_ANN_ELS | BUT_ELS | CAP_ELS | HTM_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
            }
          }
           $result;
        }
      ) {
              pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | OPT_OPT_ELS | RB_RP_RT_ELS | RTC_ELS);
  
            if (not ($OE->[-1]->{et} & (P_ELS))) {
              push @$Errors, {type => 'not closed before ancestor end tag',
                                              level => 'm',
                                              text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} & (P_ELS));
            push @popped, pop @$OE;
            push @$OP, ['popped', \@popped];
          }
            }
          
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'form',
                   attr_list => $token->{attr_list},
                   et => (FORM_EL), aet => (FORM_EL) };
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  
  push @$OE, $node;
  
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} & (TEM_ELS)) {
              $result = 1;
              last;
            
            }
          }
          not $result;
        }
      ) {
              $FORM_ELEMENT = $node;
            }
          
            }
          
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
          },
        ,
          ## [88] in body;START:frameset
          sub {
            my $token = $_;
  push @$Errors, {type => 'in body',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  
            if (($OE->[-1]->{et} & (HTM_ELS)) or 
  (@$OE >= 2 and not ($OE->[1]->{et} & (BOD_ELS)))) {
              return;
            }
          
  
            if (not $FRAMESET_OK) {
              return;
            } else {
              
          push @$OP, ['remove', $OE->[1]->{id}];
        
  {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1] eq $OE->[1]);
            push @popped, pop @$OE;
            push @$OP, ['popped', \@popped];
          }
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'frameset',
                   attr_list => $token->{attr_list},
                   et => (FRAMESET_EL), aet => (FRAMESET_EL) };
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  
  push @$OE, $node;
  
            $IM = IN_FRAMESET_IM;
            #warn "Insertion mode changed to |in frameset| ($IM)";
          
            }
          
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
          },
        ,
          ## [89] in body;START:h1 h2 h3 h4 h5 h6
          sub {
            my $token = $_;
  
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} & (P_ELS)) {
              $result = 1;
              last;
            } elsif ($_->{et} & (APP_MAR_M_ANN_ELS | BUT_ELS | CAP_ELS | HTM_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
            }
          }
           $result;
        }
      ) {
              pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | OPT_OPT_ELS | RB_RP_RT_ELS | RTC_ELS);
  
            if (not ($OE->[-1]->{et} & (P_ELS))) {
              push @$Errors, {type => 'not closed before ancestor end tag',
                                              level => 'm',
                                              text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} & (P_ELS));
            push @popped, pop @$OE;
            push @$OP, ['popped', \@popped];
          }
            }
          
  
            if ($OE->[-1]->{et} & (HHHHHH_ELS)) {
              push @$Errors, {type => 'in hn:hn',
                                              level => 'm',
                                              text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
  push @$OP, ['popped', [pop @$OE]];
            }
          
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => $token->{tag_name},
                   attr_list => $token->{attr_list},
                   et => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}, aet => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'} };
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  
  push @$OE, $node;
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
          },
        ,
          ## [90] in body;START:hr
          sub {
            my $token = $_;
  
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} & (P_ELS)) {
              $result = 1;
              last;
            } elsif ($_->{et} & (APP_MAR_M_ANN_ELS | BUT_ELS | CAP_ELS | HTM_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
            }
          }
           $result;
        }
      ) {
              pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | OPT_OPT_ELS | RB_RP_RT_ELS | RTC_ELS);
  
            if (not ($OE->[-1]->{et} & (P_ELS))) {
              push @$Errors, {type => 'not closed before ancestor end tag',
                                              level => 'm',
                                              text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} & (P_ELS));
            push @popped, pop @$OE;
            push @$OP, ['popped', \@popped];
          }
            }
          
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'hr',
                   attr_list => $token->{attr_list},
                   et => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS), aet => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS) };
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  
  
            if (delete $token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc', level => 'w',
                              text => $token->{tag_name},
                              di => $token->{di}, index => $token->{index}};
            }
          
  
          $FRAMESET_OK = 0;
        
          },
        ,
          ## [91] in body;START:html
          sub {
            my $token = $_;
  push @$Errors, {type => 'duplicate body/html tag',
                                              level => 'm',
                                              value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
  
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} & (TEM_ELS)) {
              $result = 1;
              last;
            
            }
          }
           $result;
        }
      ) {
              return;
            } else {
              
          push @$OP, ['set-if-missing', $token->{attr_list} => $OE->[0]->{id}]
              if @{$token->{attr_list} or []};
        
            }
          
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
          },
        ,
          ## [92] in body;START:iframe
          sub {
            my $token = $_;
  
          $FRAMESET_OK = 0;
        
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'iframe',
                   attr_list => $token->{attr_list},
                   et => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS), aet => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS) };
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  
  push @$OE, $node;
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  $State = RAWTEXT_STATE;
  $ORIGINAL_IM = $IM;
  
            $IM = TEXT_IM;
            #warn "Insertion mode changed to |text| ($IM)";
          
          },
        ,
          ## [93] in body;START:image
          sub {
            my $token = $_;
  push @$Errors, {type => 'image',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  &reconstruct_afe if @$AFE and ref $AFE->[-1];
  
          my $node_img = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'img',
                   attr_list => $token->{attr_list},
                   et => (HTML_NS_ELS | IMG_ELS), aet => (HTML_NS_ELS | IMG_ELS) };
        
  
        push @$OP, ['insert', $node_img => $OE->[-1]->{id}];
      
  
  
            if (delete $token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc', level => 'w',
                              text => $token->{tag_name},
                              di => $token->{di}, index => $token->{index}};
            }
          
  
          $FRAMESET_OK = 0;
        
          },
        ,
          ## [94] in body;START:input
          sub {
            my $token = $_;
  &reconstruct_afe if @$AFE and ref $AFE->[-1];
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'input',
                   attr_list => $token->{attr_list},
                   et => (HTML_NS_ELS | FIE_INP_SEL_ELS), aet => (HTML_NS_ELS | FIE_INP_SEL_ELS) };
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  
            if (defined $FORM_ELEMENT) {
              FORM: {
                last FORM if defined $token->{attrs}->{form} and
                             ($node->{et} & ()); # reassociateable
                for my $oe (@$OE) {
                  if ($oe->{et} & (TEM_ELS)) { # template
                    last FORM;
                  }
                }
                #last FORM unless $FORM_ELEMENT and $OE->[-1] (intended parent) same home subtree - should be checked later
                $node->{form} = $FORM_ELEMENT->{id};
              } # FORM
            }
          
  
            if (delete $token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc', level => 'w',
                              text => $token->{tag_name},
                              di => $token->{di}, index => $token->{index}};
            }
          
  
            if (
        not (
          defined $token->{attrs}->{type} and
          do {
            my $value = join '', map { $_->[0] } @{$token->{attrs}->{type}->{value}}; # IndexedString
            $value =~ tr/A-Z/a-z/; ## ASCII case-insensitive
            $value eq q@hidden@;
          }
        )
      ) {
              
          $FRAMESET_OK = 0;
        
            }
          
          },
        ,
          ## [95] in body;START:li
          sub {
            my $token = $_;
  
          $FRAMESET_OK = 0;
        
  
            for my $i (reverse 0..$#$OE) {
              my $_node = $OE->[$i];
              
            if ($_node->{et} & (LI_ELS)) {
              pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | OPT_OPT_ELS | P_ELS | RB_RP_RT_ELS | RTC_ELS);
  
            if (not ($OE->[-1]->{et} & (LI_ELS))) {
              push @$Errors, {type => 'element not closed before implied ancestor end tag',
                                              level => 'm',
                                              text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} & (LI_ELS));
            push @popped, pop @$OE;
            push @$OP, ['popped', \@popped];
          }
  last;
            } else {
              
            if ($_node->{et} & (APP_MAR_M_ANN_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS | BOD_ELS | BUT_ELS | CAP_ELS | COL_ELS | DD_ELS | DT_ELS | FIE_INP_SEL_ELS | HHHHHH_ELS | HTM_ELS | IMG_ELS | LI_ELS | OBJ_ELS | OL_UL_ELS | STY_ELS | TAB_ELS | TBO_TFO_THE_ELS | TD_TH_ELS | TEM_ELS | TEX_ELS | TR_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) {
              last;
            } else {
              
            }
          
            }
          
            }
          
  
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} & (P_ELS)) {
              $result = 1;
              last;
            } elsif ($_->{et} & (APP_MAR_M_ANN_ELS | BUT_ELS | CAP_ELS | HTM_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
            }
          }
           $result;
        }
      ) {
              pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | OPT_OPT_ELS | RB_RP_RT_ELS | RTC_ELS);
  
            if (not ($OE->[-1]->{et} & (P_ELS))) {
              push @$Errors, {type => 'not closed before ancestor end tag',
                                              level => 'm',
                                              text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} & (P_ELS));
            push @popped, pop @$OE;
            push @$OP, ['popped', \@popped];
          }
            }
          
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'li',
                   attr_list => $token->{attr_list},
                   et => (LI_EL), aet => (LI_EL) };
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  
  push @$OE, $node;
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
          },
        ,
          ## [96] in body;START:listing pre
          sub {
            my $token = $_;
  
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} & (P_ELS)) {
              $result = 1;
              last;
            } elsif ($_->{et} & (APP_MAR_M_ANN_ELS | BUT_ELS | CAP_ELS | HTM_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
            }
          }
           $result;
        }
      ) {
              pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | OPT_OPT_ELS | RB_RP_RT_ELS | RTC_ELS);
  
            if (not ($OE->[-1]->{et} & (P_ELS))) {
              push @$Errors, {type => 'not closed before ancestor end tag',
                                              level => 'm',
                                              text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} & (P_ELS));
            push @popped, pop @$OE;
            push @$OP, ['popped', \@popped];
          }
            }
          
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => $token->{tag_name},
                   attr_list => $token->{attr_list},
                   et => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}, aet => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'} };
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  
  push @$OE, $node;
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  
          $FRAMESET_OK = 0;
        
  
          $ORIGINAL_IM = $IM;
          $IM = BEFORE_IGNORED_NEWLINE_IM;
        
          },
        ,
          ## [97] in body;START:math
          sub {
            my $token = $_;
  &reconstruct_afe if @$AFE and ref $AFE->[-1];
  my $ns = MATHMLNS;
  
          my $node = {id => $NEXT_ID++,
                      token => $token,
                      di => $token->{di}, index => $token->{index},
                      ns => $ns,
                      local_name => $token->{tag_name},
                      attr_list => $token->{attr_list},
                      et => $Element2Type->[$ns]->{$token->{tag_name}} || $Element2Type->[$ns]->{'*'} || 0,
                      aet => $Element2Type->[$ns]->{$token->{tag_name}} || $Element2Type->[$ns]->{'*'} || 0};
        
  
          if (defined $token->{attrs}->{xmlns}) {
            # IndexedString
            my $xmlns = join '', map { $_->[0] } @{$token->{attrs}->{xmlns}->{value}};
            if ($ns == SVGNS and $xmlns eq 'http://www.w3.org/2000/svg') {
              #
            } elsif ($ns == MATHMLNS and $xmlns eq 'http://www.w3.org/1998/Math/MathML') {
              #
            } else {
              push @$Errors, {type => 'foreign:bad xmlns value',
                              level => 'm',
                              value => $xmlns,
                              di => $token->{attrs}->{xmlns}->{di},
                              index => $token->{attrs}->{xmlns}->{index}};
            }
          }
          if (defined $token->{attrs}->{'xmlns:xlink'}) {
            # IndexedString
            my $xmlns = join '', map { $_->[0] } @{$token->{attrs}->{'xmlns:xlink'}->{value}};
            unless ($xmlns eq 'http://www.w3.org/1999/xlink') {
              push @$Errors, {type => 'foreign:bad xmlns value',
                              level => 'm',
                              value => $xmlns,
                              di => $token->{attrs}->{'xmlns:xlink'}->{di},
                              index => $token->{attrs}->{'xmlns:xlink'}->{index}};
            }
          }
  
          ## Adjust foreign attributes
          ## Adjust SVG attributes
          ## Adjust MathML attributes
          my $map = $ForeignAttrMap->[$ns];
          for my $attr (@{$token->{attr_list} or []}) {
            $attr->{name_args} = $map->{$attr->{name}} || [undef, [undef, $attr->{name}]];
          }
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  push @$OE, $node;
  
            if ($token->{self_closing_flag}) {
              push @$OP, ['popped', [pop @$OE]];
  delete $token->{self_closing_flag};
            }
          
          },
        ,
          ## [98] in body;START:nobr
          sub {
            my $token = $_;
  &reconstruct_afe if @$AFE and ref $AFE->[-1];
  
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} == NOBR_EL) {
              $result = 1;
              last;
            } elsif ($_->{et} & (APP_MAR_M_ANN_ELS | CAP_ELS | HTM_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
            }
          }
           $result;
        }
      ) {
              push @$Errors, {type => 'parser:element not nestable',
                                              level => 'm',
                                              value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
  aaa ($token, $token->{tag_name});
  &reconstruct_afe if @$AFE and ref $AFE->[-1];
            }
          
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'nobr',
                   attr_list => $token->{attr_list},
                   et => (NOBR_EL), aet => (NOBR_EL) };
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  
  push @$OE, $node;
  
          ## Noah's Ark
          my $found = 0;
          AFE: for my $i (reverse 0..$#$AFE) {
            if (not ref $AFE->[$i]) { # marker
              last;
            } elsif ($node->{local_name} eq $AFE->[$i]->{local_name}
                     #and $node->{ns} == $AFE->[$i]->{ns}
            ) {
              ## Note that elements in $AFE are always HTML elements.
              for (keys %{$node->{token}->{attrs} or {}}) {
                my $attr = $AFE->[$i]->{token}->{attrs}->{$_};
                next AFE unless defined $attr;
                #next AFE unless $attr->{ns} == $node->{token}->{attrs}->{$_}->{ns};
                # IndexedString
                next AFE unless (join '', map { $_->[0] } @{$attr->{value}}) eq
                                (join '', map { $_->[0] } @{$node->{token}->{attrs}->{$_}->{value}});
              }
              next AFE unless (keys %{$node->{token}->{attrs} or {}}) == (keys %{$AFE->[$i]->{token}->{attrs} or {}});
  
              $found++;
              if ($found == 3) {
                splice @$AFE, $i, 1, ();
                last AFE;
              }
            }
          } # AFE
  
          push @$AFE, $node;
        
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
          },
        ,
          ## [99] in body;START:noembed
          sub {
            my $token = $_;
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'noembed',
                   attr_list => $token->{attr_list},
                   et => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS), aet => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS) };
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  
  push @$OE, $node;
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  $State = RAWTEXT_STATE;
  $ORIGINAL_IM = $IM;
  
            $IM = TEXT_IM;
            #warn "Insertion mode changed to |text| ($IM)";
          
          },
        ,
          ## [100] in body;START:noscript
          sub {
            my $token = $_;
  
            if ($Scripting) {
              
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'noscript',
                   attr_list => $token->{attr_list},
                   et => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS), aet => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS) };
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  
  push @$OE, $node;
  $State = RAWTEXT_STATE;
  $ORIGINAL_IM = $IM;
  
            $IM = TEXT_IM;
            #warn "Insertion mode changed to |text| ($IM)";
          
            } else {
              &reconstruct_afe if @$AFE and ref $AFE->[-1];
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'noscript',
                   attr_list => $token->{attr_list},
                   et => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS), aet => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS) };
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  
  push @$OE, $node;
            }
          
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
          },
        ,
          ## [101] in body;START:optgroup,option
          sub {
            my $token = $_;
  
            if ($OE->[-1]->{et} == OPTION_EL) {
              push @$OP, ['popped', [pop @$OE]];
            }
          
  &reconstruct_afe if @$AFE and ref $AFE->[-1];
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => $token->{tag_name},
                   attr_list => $token->{attr_list},
                   et => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}, aet => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'} };
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  
  push @$OE, $node;
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
          },
        ,
          ## [102] in body;START:param source track
          sub {
            my $token = $_;
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => $token->{tag_name},
                   attr_list => $token->{attr_list},
                   et => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}, aet => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'} };
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  
  
            if (delete $token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc', level => 'w',
                              text => $token->{tag_name},
                              di => $token->{di}, index => $token->{index}};
            }
          
          },
        ,
          ## [103] in body;START:plaintext
          sub {
            my $token = $_;
  
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} & (P_ELS)) {
              $result = 1;
              last;
            } elsif ($_->{et} & (APP_MAR_M_ANN_ELS | BUT_ELS | CAP_ELS | HTM_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
            }
          }
           $result;
        }
      ) {
              pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | OPT_OPT_ELS | RB_RP_RT_ELS | RTC_ELS);
  
            if (not ($OE->[-1]->{et} & (P_ELS))) {
              push @$Errors, {type => 'not closed before ancestor end tag',
                                              level => 'm',
                                              text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} & (P_ELS));
            push @popped, pop @$OE;
            push @$OP, ['popped', \@popped];
          }
            }
          
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'plaintext',
                   attr_list => $token->{attr_list},
                   et => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS), aet => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS) };
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  
  push @$OE, $node;
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  $State = PLAINTEXT_STATE;
          },
        ,
          ## [104] in body;START:rb rtc
          sub {
            my $token = $_;
  
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} & (RUB_ELS)) {
              $result = 1;
              last;
            } elsif ($_->{et} & (APP_MAR_M_ANN_ELS | CAP_ELS | HTM_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
            }
          }
           $result;
        }
      ) {
              pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | OPT_OPT_ELS | P_ELS | RB_RP_RT_ELS | RTC_ELS);
  
            if (not ($OE->[-1]->{et} & (RUB_ELS))) {
              push @$Errors, {type => 'in body',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
            }
          
            }
          
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => $token->{tag_name},
                   attr_list => $token->{attr_list},
                   et => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}, aet => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'} };
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  
  push @$OE, $node;
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
          },
        ,
          ## [105] in body;START:rp rt
          sub {
            my $token = $_;
  
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} & (RUB_ELS)) {
              $result = 1;
              last;
            } elsif ($_->{et} & (APP_MAR_M_ANN_ELS | CAP_ELS | HTM_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
            }
          }
           $result;
        }
      ) {
              pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | OPT_OPT_ELS | P_ELS | RB_RP_RT_ELS);
  
            if (not ($OE->[-1]->{et} & (RTC_ELS | RUB_ELS))) {
              push @$Errors, {type => 'element not closed before implied ancestor end tag',
                                              level => 'm',
                                              text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
            }
          
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => $token->{tag_name},
                   attr_list => $token->{attr_list},
                   et => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}, aet => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'} };
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  
  push @$OE, $node;
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
          },
        ,
          ## [106] in body;START:select
          sub {
            my $token = $_;
  &reconstruct_afe if @$AFE and ref $AFE->[-1];
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'select',
                   attr_list => $token->{attr_list},
                   et => (SELECT_EL), aet => (SELECT_EL) };
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  
            if (defined $FORM_ELEMENT) {
              FORM: {
                last FORM if defined $token->{attrs}->{form} and
                             ($node->{et} & ()); # reassociateable
                for my $oe (@$OE) {
                  if ($oe->{et} & (TEM_ELS)) { # template
                    last FORM;
                  }
                }
                #last FORM unless $FORM_ELEMENT and $OE->[-1] (intended parent) same home subtree - should be checked later
                $node->{form} = $FORM_ELEMENT->{id};
              } # FORM
            }
          
  push @$OE, $node;
  
          $FRAMESET_OK = 0;
        
  
            if ($IM == IN_TABLE_IM or $IM == IN_CAPTION_IM or $IM == IN_TABLE_BODY_IM or $IM == IN_ROW_IM or $IM == IN_CELL_IM) {
              
            $IM = IN_SELECT_IN_TABLE_IM;
            #warn "Insertion mode changed to |in select in table| ($IM)";
          
            } else {
              
            $IM = IN_SELECT_IM;
            #warn "Insertion mode changed to |in select| ($IM)";
          
            }
          
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
          },
        ,
          ## [107] in body;START:svg
          sub {
            my $token = $_;
  &reconstruct_afe if @$AFE and ref $AFE->[-1];
  my $ns = SVGNS;
  
          my $node = {id => $NEXT_ID++,
                      token => $token,
                      di => $token->{di}, index => $token->{index},
                      ns => $ns,
                      local_name => $token->{tag_name},
                      attr_list => $token->{attr_list},
                      et => $Element2Type->[$ns]->{$token->{tag_name}} || $Element2Type->[$ns]->{'*'} || 0,
                      aet => $Element2Type->[$ns]->{$token->{tag_name}} || $Element2Type->[$ns]->{'*'} || 0};
        
  
          if (defined $token->{attrs}->{xmlns}) {
            # IndexedString
            my $xmlns = join '', map { $_->[0] } @{$token->{attrs}->{xmlns}->{value}};
            if ($ns == SVGNS and $xmlns eq 'http://www.w3.org/2000/svg') {
              #
            } elsif ($ns == MATHMLNS and $xmlns eq 'http://www.w3.org/1998/Math/MathML') {
              #
            } else {
              push @$Errors, {type => 'foreign:bad xmlns value',
                              level => 'm',
                              value => $xmlns,
                              di => $token->{attrs}->{xmlns}->{di},
                              index => $token->{attrs}->{xmlns}->{index}};
            }
          }
          if (defined $token->{attrs}->{'xmlns:xlink'}) {
            # IndexedString
            my $xmlns = join '', map { $_->[0] } @{$token->{attrs}->{'xmlns:xlink'}->{value}};
            unless ($xmlns eq 'http://www.w3.org/1999/xlink') {
              push @$Errors, {type => 'foreign:bad xmlns value',
                              level => 'm',
                              value => $xmlns,
                              di => $token->{attrs}->{'xmlns:xlink'}->{di},
                              index => $token->{attrs}->{'xmlns:xlink'}->{index}};
            }
          }
  
          ## Adjust foreign attributes
          ## Adjust SVG attributes
          ## Adjust MathML attributes
          my $map = $ForeignAttrMap->[$ns];
          for my $attr (@{$token->{attr_list} or []}) {
            $attr->{name_args} = $map->{$attr->{name}} || [undef, [undef, $attr->{name}]];
          }
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  push @$OE, $node;
  
            if ($token->{self_closing_flag}) {
              push @$OP, ['popped', [pop @$OE]];
  delete $token->{self_closing_flag};
            }
          
          },
        ,
          ## [108] in body;START:table
          sub {
            my $token = $_;
  
            if ((not $QUIRKS) and 
  (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} & (P_ELS)) {
              $result = 1;
              last;
            } elsif ($_->{et} & (APP_MAR_M_ANN_ELS | BUT_ELS | CAP_ELS | HTM_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
            }
          }
           $result;
        }
      )) {
              pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | OPT_OPT_ELS | RB_RP_RT_ELS | RTC_ELS);
  
            if (not ($OE->[-1]->{et} & (P_ELS))) {
              push @$Errors, {type => 'not closed before ancestor end tag',
                                              level => 'm',
                                              text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} & (P_ELS));
            push @popped, pop @$OE;
            push @$OP, ['popped', \@popped];
          }
            }
          
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'table',
                   attr_list => $token->{attr_list},
                   et => (TABLE_EL), aet => (TABLE_EL) };
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  
  push @$OE, $node;
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  
          $FRAMESET_OK = 0;
        
  
            $IM = IN_TABLE_IM;
            #warn "Insertion mode changed to |in table| ($IM)";
          
          },
        ,
          ## [109] in body;START:textarea
          sub {
            my $token = $_;
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'textarea',
                   attr_list => $token->{attr_list},
                   et => (HTML_NS_ELS | TEX_ELS), aet => (HTML_NS_ELS | TEX_ELS) };
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  
            if (defined $FORM_ELEMENT) {
              FORM: {
                last FORM if defined $token->{attrs}->{form} and
                             ($node->{et} & ()); # reassociateable
                for my $oe (@$OE) {
                  if ($oe->{et} & (TEM_ELS)) { # template
                    last FORM;
                  }
                }
                #last FORM unless $FORM_ELEMENT and $OE->[-1] (intended parent) same home subtree - should be checked later
                $node->{form} = $FORM_ELEMENT->{id};
              } # FORM
            }
          
  push @$OE, $node;
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  $State = RCDATA_STATE;
  $ORIGINAL_IM = $IM;
  
          $FRAMESET_OK = 0;
        
  
            $IM = TEXT_IM;
            #warn "Insertion mode changed to |text| ($IM)";
          
  
          $IM = BEFORE_IGNORED_NEWLINE_AND_TEXT_IM;
        
          },
        ,
          ## [110] in body;START:xmp
          sub {
            my $token = $_;
  
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} & (P_ELS)) {
              $result = 1;
              last;
            } elsif ($_->{et} & (APP_MAR_M_ANN_ELS | BUT_ELS | CAP_ELS | HTM_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
            }
          }
           $result;
        }
      ) {
              pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | OPT_OPT_ELS | RB_RP_RT_ELS | RTC_ELS);
  
            if (not ($OE->[-1]->{et} & (P_ELS))) {
              push @$Errors, {type => 'not closed before ancestor end tag',
                                              level => 'm',
                                              text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} & (P_ELS));
            push @popped, pop @$OE;
            push @$OP, ['popped', \@popped];
          }
            }
          
  &reconstruct_afe if @$AFE and ref $AFE->[-1];
  
          $FRAMESET_OK = 0;
        
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'xmp',
                   attr_list => $token->{attr_list},
                   et => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS), aet => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS) };
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  
  push @$OE, $node;
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  $State = RAWTEXT_STATE;
  $ORIGINAL_IM = $IM;
  
            $IM = TEXT_IM;
            #warn "Insertion mode changed to |text| ($IM)";
          
          },
        ,
          ## [111] in body;TEXT
          sub {
            my $token = $_;
  
              if (index ($token->{value}, "\x00") > -1) {
                pos ($token->{value}) = 0;
                while (pos $token->{value} < length $token->{value}) {
                  if ($token->{value} =~ /\G([^\x00\x09\x0A\x0C\x20]+)/gc) {
                    &reconstruct_afe if @$AFE and ref $AFE->[-1];
  
        push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
      
  
          $FRAMESET_OK = 0;
        
                    $token->{index} += length $1;
                  }
                  if ($token->{value} =~ /\G([\x09\x0A\x0C\x20]+)/gc) {
                    &reconstruct_afe if @$AFE and ref $AFE->[-1];
  
        push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
      
                    $token->{index} += length $1;
                  }
                  if ($token->{value} =~ /\G([\x00]+)/gc) {
                    
              my $value = $1;
              while ($value =~ /(.)/gs) {
                push @$Errors, {type => 'parser:NULL',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index} + $-[1]};
              }
              
            
                    $token->{index} += length $1;
                  }
                }
              } else {
                &reconstruct_afe if @$AFE and ref $AFE->[-1];
  
        push @$OP, ['text', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
      
                $FRAMESET_OK = 0 if $FRAMESET_OK and $token->{value} =~ /[^\x09\x0A\x0C\x20]/;
              }
            
          },
        ,
          ## [112] in caption;END:body,col,colgroup,html,tbody tfoot thead,td th,tr
          sub {
            my $token = $_;
  push @$Errors, {type => 'stray end tag',
                                              level => 'm',
                                              value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
  return;
          },
        ,
          ## [113] in caption;END:caption
          sub {
            my $token = $_;
  
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} & (CAP_ELS)) {
              $result = 1;
              last;
            } elsif ($_->{et} & (HTM_ELS | TAB_ELS | TEM_ELS)) { last; 
            }
          }
          not $result;
        }
      ) {
              push @$Errors, {type => 'stray end tag',
                                              level => 'm',
                                              value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
  return;
            } else {
              pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | OPT_OPT_ELS | P_ELS | RB_RP_RT_ELS | RTC_ELS);
  
            if (not ($OE->[-1]->{et} & (CAP_ELS))) {
              push @$Errors, {type => 'not closed before ancestor end tag',
                                              level => 'm',
                                              text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} & (CAP_ELS));
            push @popped, pop @$OE;
            push @$OP, ['popped', \@popped];
          }
  
          pop @$AFE while ref $AFE->[-1];
          pop @$AFE; # #marker
        
  
            $IM = IN_TABLE_IM;
            #warn "Insertion mode changed to |in table| ($IM)";
          
            }
          
          },
        ,
          ## [114] in caption;END:table
          sub {
            my $token = $_;
  
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} & (CAP_ELS)) {
              $result = 1;
              last;
            } elsif ($_->{et} & (HTM_ELS | TAB_ELS | TEM_ELS)) { last; 
            }
          }
          not $result;
        }
      ) {
              push @$Errors, {type => 'stray end tag',
                                              level => 'm',
                                              value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
  return;
            } else {
              pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | OPT_OPT_ELS | P_ELS | RB_RP_RT_ELS | RTC_ELS);
  
            if (not ($OE->[-1]->{et} & (CAP_ELS))) {
              push @$Errors, {type => 'not closed before ancestor end tag',
                                              level => 'm',
                                              text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} & (CAP_ELS));
            push @popped, pop @$OE;
            push @$OP, ['popped', \@popped];
          }
  
          pop @$AFE while ref $AFE->[-1];
          pop @$AFE; # #marker
        
  
            $IM = IN_TABLE_IM;
            #warn "Insertion mode changed to |in table| ($IM)";
          
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
            }
          
          },
        ,
          ## [115] in caption;START:caption,col,colgroup,tbody tfoot thead,td th,tr
          sub {
            my $token = $_;
  
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} & (CAP_ELS)) {
              $result = 1;
              last;
            } elsif ($_->{et} & (HTM_ELS | TAB_ELS | TEM_ELS)) { last; 
            }
          }
          not $result;
        }
      ) {
              push @$Errors, {type => 'in caption',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  return;
            } else {
              pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | OPT_OPT_ELS | P_ELS | RB_RP_RT_ELS | RTC_ELS);
  
            if (not ($OE->[-1]->{et} & (CAP_ELS))) {
              push @$Errors, {type => 'element not closed before implied ancestor end tag',
                                              level => 'm',
                                              text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} & (CAP_ELS));
            push @popped, pop @$OE;
            push @$OP, ['popped', \@popped];
          }
  
          pop @$AFE while ref $AFE->[-1];
          pop @$AFE; # #marker
        
  
            $IM = IN_TABLE_IM;
            #warn "Insertion mode changed to |in table| ($IM)";
          
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
            }
          
          },
        ,
          ## [116] in caption;TEXT
          sub {
            my $token = $_;
  
              if (index ($token->{value}, "\x00") > -1) {
                pos ($token->{value}) = 0;
                while (pos $token->{value} < length $token->{value}) {
                  if ($token->{value} =~ /\G([^\x00\x09\x0A\x0C\x20]+)/gc) {
                    &reconstruct_afe if @$AFE and ref $AFE->[-1];
  
        push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
      
  
          $FRAMESET_OK = 0;
        
                    $token->{index} += length $1;
                  }
                  if ($token->{value} =~ /\G([\x09\x0A\x0C\x20]+)/gc) {
                    &reconstruct_afe if @$AFE and ref $AFE->[-1];
  
        push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
      
                    $token->{index} += length $1;
                  }
                  if ($token->{value} =~ /\G([\x00]+)/gc) {
                    
              my $value = $1;
              while ($value =~ /(.)/gs) {
                push @$Errors, {type => 'parser:NULL',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index} + $-[1]};
              }
              
            
                    $token->{index} += length $1;
                  }
                }
              } else {
                &reconstruct_afe if @$AFE and ref $AFE->[-1];
  
        push @$OP, ['text', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
      
                $FRAMESET_OK = 0 if $FRAMESET_OK and $token->{value} =~ /[^\x09\x0A\x0C\x20]/;
              }
            
          },
        ,
          ## [117] in cell;END:body,caption,col,colgroup,html
          sub {
            my $token = $_;
  push @$Errors, {type => 'stray end tag',
                                              level => 'm',
                                              value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
  return;
          },
        ,
          ## [118] in cell;END:table,tbody tfoot thead,tr
          sub {
            my $token = $_;
  
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} & HTML_NS_ELS and $_->{local_name} eq $token->{tag_name}) {
              $result = 1;
              last;
            } elsif ($_->{et} & (HTM_ELS | TAB_ELS | TEM_ELS)) { last; 
            }
          }
          not $result;
        }
      ) {
              push @$Errors, {type => 'stray end tag',
                                              level => 'm',
                                              value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
  return;
            } else {
              pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | OPT_OPT_ELS | P_ELS | RB_RP_RT_ELS | RTC_ELS);
  
            if (not ($OE->[-1]->{et} & (TD_TH_ELS))) {
              push @$Errors, {type => 'not closed before ancestor end tag',
                                              level => 'm',
                                              text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} & (TD_TH_ELS));
            push @popped, pop @$OE;
            push @$OP, ['popped', \@popped];
          }
  
          pop @$AFE while ref $AFE->[-1];
          pop @$AFE; # #marker
        
  
            $IM = IN_ROW_IM;
            #warn "Insertion mode changed to |in row| ($IM)";
          
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
            }
          
          },
        ,
          ## [119] in cell;END:td th
          sub {
            my $token = $_;
  
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} & HTML_NS_ELS and $_->{local_name} eq $token->{tag_name}) {
              $result = 1;
              last;
            } elsif ($_->{et} & (HTM_ELS | TAB_ELS | TEM_ELS)) { last; 
            }
          }
          not $result;
        }
      ) {
              push @$Errors, {type => 'stray end tag',
                                              level => 'm',
                                              value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
  return;
            } else {
              pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | OPT_OPT_ELS | P_ELS | RB_RP_RT_ELS | RTC_ELS);
  
            if (not ($OE->[-1]->{et} & HTML_NS_ELS and $OE->[-1]->{local_name} eq $token->{tag_name})) {
              push @$Errors, {type => 'not closed before ancestor end tag',
                                              level => 'm',
                                              text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} & HTML_NS_ELS and $OE->[-1]->{local_name} eq $token->{tag_name});
            push @popped, pop @$OE;
            push @$OP, ['popped', \@popped];
          }
  
          pop @$AFE while ref $AFE->[-1];
          pop @$AFE; # #marker
        
  
            $IM = IN_ROW_IM;
            #warn "Insertion mode changed to |in row| ($IM)";
          
            }
          
          },
        ,
          ## [120] in cell;START:caption,col,colgroup,tbody tfoot thead,td th,tr
          sub {
            my $token = $_;
  
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} & (TD_TH_ELS)) {
              $result = 1;
              last;
            } elsif ($_->{et} & (HTM_ELS | TAB_ELS | TEM_ELS)) { last; 
            }
          }
          not $result;
        }
      ) {
              push @$Errors, {type => 'in cell',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  return;
            } else {
              pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | OPT_OPT_ELS | P_ELS | RB_RP_RT_ELS | RTC_ELS);
  
            if (not ($OE->[-1]->{et} & (TD_TH_ELS))) {
              push @$Errors, {type => 'not closed before ancestor end tag',
                                              level => 'm',
                                              text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} & (TD_TH_ELS));
            push @popped, pop @$OE;
            push @$OP, ['popped', \@popped];
          }
  
          pop @$AFE while ref $AFE->[-1];
          pop @$AFE; # #marker
        
  
            $IM = IN_ROW_IM;
            #warn "Insertion mode changed to |in row| ($IM)";
          
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
            }
          
          },
        ,
          ## [121] in cell;TEXT
          sub {
            my $token = $_;
  
              if (index ($token->{value}, "\x00") > -1) {
                pos ($token->{value}) = 0;
                while (pos $token->{value} < length $token->{value}) {
                  if ($token->{value} =~ /\G([^\x00\x09\x0A\x0C\x20]+)/gc) {
                    &reconstruct_afe if @$AFE and ref $AFE->[-1];
  
        push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
      
  
          $FRAMESET_OK = 0;
        
                    $token->{index} += length $1;
                  }
                  if ($token->{value} =~ /\G([\x09\x0A\x0C\x20]+)/gc) {
                    &reconstruct_afe if @$AFE and ref $AFE->[-1];
  
        push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
      
                    $token->{index} += length $1;
                  }
                  if ($token->{value} =~ /\G([\x00]+)/gc) {
                    
              my $value = $1;
              while ($value =~ /(.)/gs) {
                push @$Errors, {type => 'parser:NULL',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index} + $-[1]};
              }
              
            
                    $token->{index} += length $1;
                  }
                }
              } else {
                &reconstruct_afe if @$AFE and ref $AFE->[-1];
  
        push @$OP, ['text', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
      
                $FRAMESET_OK = 0 if $FRAMESET_OK and $token->{value} =~ /[^\x09\x0A\x0C\x20]/;
              }
            
          },
        ,
          ## [122] in column group;COMMENT
          sub {
            my $token = $_;
  
            push @$OP, ['comment', $token => $OE->[-1]->{id}];
          
          },
        ,
          ## [123] in column group;DOCTYPE
          sub {
            my $token = $_;
  push @$Errors, {type => 'doctype:bad context',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  return;
          },
        ,
          ## [124] in column group;END-ELSE
          sub {
            my $token = $_;
  
            if (not ($OE->[-1]->{et} & (COL_ELS))) {
              push @$Errors, {type => 'in colgroup',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  return;
            } else {
              push @$OP, ['popped', [pop @$OE]];
  
            $IM = IN_TABLE_IM;
            #warn "Insertion mode changed to |in table| ($IM)";
          
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
            }
          
          },
        ,
          ## [125] in column group;END:col
          sub {
            my $token = $_;
  push @$Errors, {type => 'stray end tag',
                                              level => 'm',
                                              value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
  return;
          },
        ,
          ## [126] in column group;END:colgroup
          sub {
            my $token = $_;
  
            if (not ($OE->[-1]->{et} & (COL_ELS))) {
              push @$Errors, {type => 'stray end tag',
                                              level => 'm',
                                              value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
  return;
            } else {
              push @$OP, ['popped', [pop @$OE]];
  
            $IM = IN_TABLE_IM;
            #warn "Insertion mode changed to |in table| ($IM)";
          
            }
          
          },
        ,
          ## [127] in column group;START-ELSE
          sub {
            my $token = $_;
  
            if (not ($OE->[-1]->{et} & (COL_ELS))) {
              push @$Errors, {type => 'in colgroup',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  return;
            } else {
              push @$OP, ['popped', [pop @$OE]];
  
            $IM = IN_TABLE_IM;
            #warn "Insertion mode changed to |in table| ($IM)";
          
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
            }
          
          },
        ,
          ## [128] in column group;START:col
          sub {
            my $token = $_;
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'col',
                   attr_list => $token->{attr_list},
                   et => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS), aet => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS) };
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  
  
            if (delete $token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc', level => 'w',
                              text => $token->{tag_name},
                              di => $token->{di}, index => $token->{index}};
            }
          
          },
        ,
          ## [129] in column group;TEXT
          sub {
            my $token = $_;
  
            if (not ($OE->[-1]->{et} & (COL_ELS))) {
              
            while (length $token->{value}) {
              if ($token->{value} =~ s/^([^\x09\x0A\x0C\x20]+)//) {
                
              my $value = $1;
              while ($value =~ /(.)/gs) {
                push @$Errors, {type => 'in colgroup',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index} + $-[1]};
              }
              
            
                $token->{index} += length $1;
              }
              if ($token->{value} =~ s/^([\x09\x0A\x0C\x20]+)//) {
                
        push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
      
                $token->{index} += length $1;
              }
            }
          
            } else {
              
          if ($token->{value} =~ s/^([\x09\x0A\x0C\x20]+)//) {
            
        push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
      
            $token->{index} += length $1;
          }
          if (length $token->{value}) {
            push @$OP, ['popped', [pop @$OE]];
  
            $IM = IN_TABLE_IM;
            #warn "Insertion mode changed to |in table| ($IM)";
          
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
          }
        
            }
          
          },
        ,
          ## [130] in foreign content;COMMENT
          sub {
            my $token = $_;
  
            push @$OP, ['comment', $token => $OE->[-1]->{id}];
          
          },
        ,
          ## [131] in foreign content;DOCTYPE
          sub {
            my $token = $_;
  push @$Errors, {type => 'doctype:bad context',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  return;
          },
        ,
          ## [132] in foreign content;END-ELSE
          sub {
            my $token = $_;
  
            if (not ((
          $OE->[-1]->{local_name} eq $token->{tag_name} or
          do {
            my $ln = $OE->[-1]->{local_name};
            $ln =~ tr/A-Z/a-z/; ## ASCII case-insensitive.
            $ln eq $token->{tag_name};
          }
        ))) {
              push @$Errors, {type => 'not closed before ancestor end tag',
                                              level => 'm',
                                              text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  
            my $_node_i = $#$OE;
            my $_node = $OE->[$_node_i];
            {
              
            if ($_node->{et} & (HTM_ELS)) {
              return;
            }
          
  
            if ((
          $_node->{local_name} eq $token->{tag_name} or
          do {
            my $ln = $_node->{local_name};
            $ln =~ tr/A-Z/a-z/; ## ASCII case-insensitive.
            $ln eq $token->{tag_name};
          }
        )) {
              {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1] eq $_node);
            push @popped, pop @$OE;
            push @$OP, ['popped', \@popped];
          }
  return;
            }
          
              $_node_i--;
              $_node = $OE->[$_node_i];
              
            if (not ($_node->{et} & (HTML_NS_ELS))) {
              
            } else {
              
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
  last;
            }
          
              redo;
            }
          
          },
        ,
          ## [133] in foreign content;END:script
          sub {
            my $token = $_;
  
            if ($OE->[-1]->{et} == SVG_SCRIPT_EL) {
              my $script = $OE->[-1];
  push @$OP, ['popped', [pop @$OE]];
  push @$OP, ['script', $script->{id}];
            } else {
              
            if (not ((
          $OE->[-1]->{local_name} eq $token->{tag_name} or
          do {
            my $ln = $OE->[-1]->{local_name};
            $ln =~ tr/A-Z/a-z/; ## ASCII case-insensitive.
            $ln eq $token->{tag_name};
          }
        ))) {
              push @$Errors, {type => 'not closed before ancestor end tag',
                                              level => 'm',
                                              text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  
            my $_node_i = $#$OE;
            my $_node = $OE->[$_node_i];
            {
              
            if ($_node->{et} & (HTM_ELS)) {
              return;
            }
          
  
            if ((
          $_node->{local_name} eq $token->{tag_name} or
          do {
            my $ln = $_node->{local_name};
            $ln =~ tr/A-Z/a-z/; ## ASCII case-insensitive.
            $ln eq $token->{tag_name};
          }
        )) {
              {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1] eq $_node);
            push @popped, pop @$OE;
            push @$OP, ['popped', \@popped];
          }
  return;
            }
          
              $_node_i--;
              $_node = $OE->[$_node_i];
              
            if (not ($_node->{et} & (HTML_NS_ELS))) {
              
            } else {
              
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
  last;
            }
          
              redo;
            }
          
            }
          
          },
        ,
          ## [134] in foreign content;EOF
          sub {
            
          },
        ,
          ## [135] in foreign content;START-ELSE
          sub {
            my $token = $_;
  
            if ($OE->[-1]->{aet} & (SVG_NS_ELS)) {
              
          $token->{tag_name} = $Web::HTML::ParserData::SVGElementNameFixup->{$token->{tag_name}} || $token->{tag_name};
        
            }
          
  
            ## Adjusted current node
            my $ns = ((defined $CONTEXT and @$OE == 1) ? $CONTEXT : $OE->[-1])->{ns};
          
  
          my $node = {id => $NEXT_ID++,
                      token => $token,
                      di => $token->{di}, index => $token->{index},
                      ns => $ns,
                      local_name => $token->{tag_name},
                      attr_list => $token->{attr_list},
                      et => $Element2Type->[$ns]->{$token->{tag_name}} || $Element2Type->[$ns]->{'*'} || 0,
                      aet => $Element2Type->[$ns]->{$token->{tag_name}} || $Element2Type->[$ns]->{'*'} || 0};
        
  
            if ($ns == MATHMLNS and $node->{local_name} eq 'annotation-xml' and
                defined $token->{attrs}->{encoding}) {
              my $encoding = join '', map { $_->[0] } @{$token->{attrs}->{encoding}->{value}}; # IndexedString
              $encoding =~ tr/A-Z/a-z/; ## ASCII case-insensitive.
              if ($encoding eq 'text/html' or
                  $encoding eq 'application/xhtml+xml') {
                $node->{aet} |= M_ANN_M_ANN_ELS;
                $node->{et} |= M_ANN_M_ANN_ELS;
              }
            }
          
  
          if (defined $token->{attrs}->{xmlns}) {
            # IndexedString
            my $xmlns = join '', map { $_->[0] } @{$token->{attrs}->{xmlns}->{value}};
            if ($ns == SVGNS and $xmlns eq 'http://www.w3.org/2000/svg') {
              #
            } elsif ($ns == MATHMLNS and $xmlns eq 'http://www.w3.org/1998/Math/MathML') {
              #
            } else {
              push @$Errors, {type => 'foreign:bad xmlns value',
                              level => 'm',
                              value => $xmlns,
                              di => $token->{attrs}->{xmlns}->{di},
                              index => $token->{attrs}->{xmlns}->{index}};
            }
          }
          if (defined $token->{attrs}->{'xmlns:xlink'}) {
            # IndexedString
            my $xmlns = join '', map { $_->[0] } @{$token->{attrs}->{'xmlns:xlink'}->{value}};
            unless ($xmlns eq 'http://www.w3.org/1999/xlink') {
              push @$Errors, {type => 'foreign:bad xmlns value',
                              level => 'm',
                              value => $xmlns,
                              di => $token->{attrs}->{'xmlns:xlink'}->{di},
                              index => $token->{attrs}->{'xmlns:xlink'}->{index}};
            }
          }
  
          ## Adjust foreign attributes
          ## Adjust SVG attributes
          ## Adjust MathML attributes
          my $map = $ForeignAttrMap->[$ns];
          for my $attr (@{$token->{attr_list} or []}) {
            $attr->{name_args} = $map->{$attr->{name}} || [undef, [undef, $attr->{name}]];
          }
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  push @$OE, $node;
  
            if ($token->{self_closing_flag}) {
              
            if (($token->{tag_name} eq q@script@) and 
  ($OE->[-1]->{et} & (SVG_NS_ELS))) {
              delete $token->{self_closing_flag};
  my $script = $OE->[-1];
  push @$OP, ['popped', [pop @$OE]];
  push @$OP, ['script', $script->{id}];
            } else {
              push @$OP, ['popped', [pop @$OE]];
  delete $token->{self_closing_flag};
            }
          
            }
          
          },
        ,
          ## [136] in foreign content;START:b big code em i s small strike strong tt u,blockquote center div dl menu ol ul,body,br,dd dt,embed,h1 h2 h3 h4 h5 h6,head,hr,img,li,listing pre,meta,nobr,p,ruby span sub sup var,table
          sub {
            my $token = $_;
  push @$Errors, {type => 'element not closed before implied ancestor end tag',
                                              level => 'm',
                                              text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
  
            if (defined $CONTEXT) {
              
            if ($OE->[-1]->{aet} & (SVG_NS_ELS)) {
              
          $token->{tag_name} = $Web::HTML::ParserData::SVGElementNameFixup->{$token->{tag_name}} || $token->{tag_name};
        
            }
          
  
            ## Adjusted current node
            my $ns = ((defined $CONTEXT and @$OE == 1) ? $CONTEXT : $OE->[-1])->{ns};
          
  
          my $node = {id => $NEXT_ID++,
                      token => $token,
                      di => $token->{di}, index => $token->{index},
                      ns => $ns,
                      local_name => $token->{tag_name},
                      attr_list => $token->{attr_list},
                      et => $Element2Type->[$ns]->{$token->{tag_name}} || $Element2Type->[$ns]->{'*'} || 0,
                      aet => $Element2Type->[$ns]->{$token->{tag_name}} || $Element2Type->[$ns]->{'*'} || 0};
        
  
            if ($ns == MATHMLNS and $node->{local_name} eq 'annotation-xml' and
                defined $token->{attrs}->{encoding}) {
              my $encoding = join '', map { $_->[0] } @{$token->{attrs}->{encoding}->{value}}; # IndexedString
              $encoding =~ tr/A-Z/a-z/; ## ASCII case-insensitive.
              if ($encoding eq 'text/html' or
                  $encoding eq 'application/xhtml+xml') {
                $node->{aet} |= M_ANN_M_ANN_ELS;
                $node->{et} |= M_ANN_M_ANN_ELS;
              }
            }
          
  
          if (defined $token->{attrs}->{xmlns}) {
            # IndexedString
            my $xmlns = join '', map { $_->[0] } @{$token->{attrs}->{xmlns}->{value}};
            if ($ns == SVGNS and $xmlns eq 'http://www.w3.org/2000/svg') {
              #
            } elsif ($ns == MATHMLNS and $xmlns eq 'http://www.w3.org/1998/Math/MathML') {
              #
            } else {
              push @$Errors, {type => 'foreign:bad xmlns value',
                              level => 'm',
                              value => $xmlns,
                              di => $token->{attrs}->{xmlns}->{di},
                              index => $token->{attrs}->{xmlns}->{index}};
            }
          }
          if (defined $token->{attrs}->{'xmlns:xlink'}) {
            # IndexedString
            my $xmlns = join '', map { $_->[0] } @{$token->{attrs}->{'xmlns:xlink'}->{value}};
            unless ($xmlns eq 'http://www.w3.org/1999/xlink') {
              push @$Errors, {type => 'foreign:bad xmlns value',
                              level => 'm',
                              value => $xmlns,
                              di => $token->{attrs}->{'xmlns:xlink'}->{di},
                              index => $token->{attrs}->{'xmlns:xlink'}->{index}};
            }
          }
  
          ## Adjust foreign attributes
          ## Adjust SVG attributes
          ## Adjust MathML attributes
          my $map = $ForeignAttrMap->[$ns];
          for my $attr (@{$token->{attr_list} or []}) {
            $attr->{name_args} = $map->{$attr->{name}} || [undef, [undef, $attr->{name}]];
          }
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  push @$OE, $node;
  
            if ($token->{self_closing_flag}) {
              
            if (($token->{tag_name} eq q@script@) and 
  ($OE->[-1]->{et} & (SVG_NS_ELS))) {
              delete $token->{self_closing_flag};
  my $script = $OE->[-1];
  push @$OP, ['popped', [pop @$OE]];
  push @$OP, ['script', $script->{id}];
            } else {
              push @$OP, ['popped', [pop @$OE]];
  delete $token->{self_closing_flag};
            }
          
            }
          
            } else {
              push @$OP, ['popped', [pop @$OE]];
  {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} & (HTML_NS_ELS | M_ANN_M_ANN_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS));
            push @$OP, ['popped', \@popped];
          }
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
            }
          
          },
        ,
          ## [137] in foreign content;START:font
          sub {
            my $token = $_;
  
            if ($token->{attrs}->{q@color@} or 
  $token->{attrs}->{q@face@} or 
  $token->{attrs}->{q@size@}) {
              push @$Errors, {type => 'element not closed before implied ancestor end tag',
                                              level => 'm',
                                              text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
  
            if (defined $CONTEXT) {
              
            if ($OE->[-1]->{aet} & (SVG_NS_ELS)) {
              
          $token->{tag_name} = $Web::HTML::ParserData::SVGElementNameFixup->{$token->{tag_name}} || $token->{tag_name};
        
            }
          
  
            ## Adjusted current node
            my $ns = ((defined $CONTEXT and @$OE == 1) ? $CONTEXT : $OE->[-1])->{ns};
          
  
          my $node = {id => $NEXT_ID++,
                      token => $token,
                      di => $token->{di}, index => $token->{index},
                      ns => $ns,
                      local_name => $token->{tag_name},
                      attr_list => $token->{attr_list},
                      et => $Element2Type->[$ns]->{$token->{tag_name}} || $Element2Type->[$ns]->{'*'} || 0,
                      aet => $Element2Type->[$ns]->{$token->{tag_name}} || $Element2Type->[$ns]->{'*'} || 0};
        
  
            if ($ns == MATHMLNS and $node->{local_name} eq 'annotation-xml' and
                defined $token->{attrs}->{encoding}) {
              my $encoding = join '', map { $_->[0] } @{$token->{attrs}->{encoding}->{value}}; # IndexedString
              $encoding =~ tr/A-Z/a-z/; ## ASCII case-insensitive.
              if ($encoding eq 'text/html' or
                  $encoding eq 'application/xhtml+xml') {
                $node->{aet} |= M_ANN_M_ANN_ELS;
                $node->{et} |= M_ANN_M_ANN_ELS;
              }
            }
          
  
          if (defined $token->{attrs}->{xmlns}) {
            # IndexedString
            my $xmlns = join '', map { $_->[0] } @{$token->{attrs}->{xmlns}->{value}};
            if ($ns == SVGNS and $xmlns eq 'http://www.w3.org/2000/svg') {
              #
            } elsif ($ns == MATHMLNS and $xmlns eq 'http://www.w3.org/1998/Math/MathML') {
              #
            } else {
              push @$Errors, {type => 'foreign:bad xmlns value',
                              level => 'm',
                              value => $xmlns,
                              di => $token->{attrs}->{xmlns}->{di},
                              index => $token->{attrs}->{xmlns}->{index}};
            }
          }
          if (defined $token->{attrs}->{'xmlns:xlink'}) {
            # IndexedString
            my $xmlns = join '', map { $_->[0] } @{$token->{attrs}->{'xmlns:xlink'}->{value}};
            unless ($xmlns eq 'http://www.w3.org/1999/xlink') {
              push @$Errors, {type => 'foreign:bad xmlns value',
                              level => 'm',
                              value => $xmlns,
                              di => $token->{attrs}->{'xmlns:xlink'}->{di},
                              index => $token->{attrs}->{'xmlns:xlink'}->{index}};
            }
          }
  
          ## Adjust foreign attributes
          ## Adjust SVG attributes
          ## Adjust MathML attributes
          my $map = $ForeignAttrMap->[$ns];
          for my $attr (@{$token->{attr_list} or []}) {
            $attr->{name_args} = $map->{$attr->{name}} || [undef, [undef, $attr->{name}]];
          }
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  push @$OE, $node;
  
            if ($token->{self_closing_flag}) {
              
            if (($token->{tag_name} eq q@script@) and 
  ($OE->[-1]->{et} & (SVG_NS_ELS))) {
              delete $token->{self_closing_flag};
  my $script = $OE->[-1];
  push @$OP, ['popped', [pop @$OE]];
  push @$OP, ['script', $script->{id}];
            } else {
              push @$OP, ['popped', [pop @$OE]];
  delete $token->{self_closing_flag};
            }
          
            }
          
            } else {
              push @$OP, ['popped', [pop @$OE]];
  {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} & (HTML_NS_ELS | M_ANN_M_ANN_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS));
            push @$OP, ['popped', \@popped];
          }
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
            }
          
            } else {
              
            if ($OE->[-1]->{aet} & (SVG_NS_ELS)) {
              
          $token->{tag_name} = $Web::HTML::ParserData::SVGElementNameFixup->{$token->{tag_name}} || $token->{tag_name};
        
            }
          
  
            ## Adjusted current node
            my $ns = ((defined $CONTEXT and @$OE == 1) ? $CONTEXT : $OE->[-1])->{ns};
          
  
          my $node = {id => $NEXT_ID++,
                      token => $token,
                      di => $token->{di}, index => $token->{index},
                      ns => $ns,
                      local_name => $token->{tag_name},
                      attr_list => $token->{attr_list},
                      et => $Element2Type->[$ns]->{$token->{tag_name}} || $Element2Type->[$ns]->{'*'} || 0,
                      aet => $Element2Type->[$ns]->{$token->{tag_name}} || $Element2Type->[$ns]->{'*'} || 0};
        
  
            if ($ns == MATHMLNS and $node->{local_name} eq 'annotation-xml' and
                defined $token->{attrs}->{encoding}) {
              my $encoding = join '', map { $_->[0] } @{$token->{attrs}->{encoding}->{value}}; # IndexedString
              $encoding =~ tr/A-Z/a-z/; ## ASCII case-insensitive.
              if ($encoding eq 'text/html' or
                  $encoding eq 'application/xhtml+xml') {
                $node->{aet} |= M_ANN_M_ANN_ELS;
                $node->{et} |= M_ANN_M_ANN_ELS;
              }
            }
          
  
          if (defined $token->{attrs}->{xmlns}) {
            # IndexedString
            my $xmlns = join '', map { $_->[0] } @{$token->{attrs}->{xmlns}->{value}};
            if ($ns == SVGNS and $xmlns eq 'http://www.w3.org/2000/svg') {
              #
            } elsif ($ns == MATHMLNS and $xmlns eq 'http://www.w3.org/1998/Math/MathML') {
              #
            } else {
              push @$Errors, {type => 'foreign:bad xmlns value',
                              level => 'm',
                              value => $xmlns,
                              di => $token->{attrs}->{xmlns}->{di},
                              index => $token->{attrs}->{xmlns}->{index}};
            }
          }
          if (defined $token->{attrs}->{'xmlns:xlink'}) {
            # IndexedString
            my $xmlns = join '', map { $_->[0] } @{$token->{attrs}->{'xmlns:xlink'}->{value}};
            unless ($xmlns eq 'http://www.w3.org/1999/xlink') {
              push @$Errors, {type => 'foreign:bad xmlns value',
                              level => 'm',
                              value => $xmlns,
                              di => $token->{attrs}->{'xmlns:xlink'}->{di},
                              index => $token->{attrs}->{'xmlns:xlink'}->{index}};
            }
          }
  
          ## Adjust foreign attributes
          ## Adjust SVG attributes
          ## Adjust MathML attributes
          my $map = $ForeignAttrMap->[$ns];
          for my $attr (@{$token->{attr_list} or []}) {
            $attr->{name_args} = $map->{$attr->{name}} || [undef, [undef, $attr->{name}]];
          }
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  push @$OE, $node;
  
            if ($token->{self_closing_flag}) {
              
            if (($token->{tag_name} eq q@script@) and 
  ($OE->[-1]->{et} & (SVG_NS_ELS))) {
              delete $token->{self_closing_flag};
  my $script = $OE->[-1];
  push @$OP, ['popped', [pop @$OE]];
  push @$OP, ['script', $script->{id}];
            } else {
              push @$OP, ['popped', [pop @$OE]];
  delete $token->{self_closing_flag};
            }
          
            }
          
            }
          
          },
        ,
          ## [138] in foreign content;TEXT
          sub {
            my $token = $_;
  
              if (index ($token->{value}, "\x00") > -1) {
                pos ($token->{value}) = 0;
                while (pos $token->{value} < length $token->{value}) {
                  if ($token->{value} =~ /\G([^\x00\x09\x0A\x0C\x20]+)/gc) {
                    
        push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
      
  
          $FRAMESET_OK = 0;
        
                    $token->{index} += length $1;
                  }
                  if ($token->{value} =~ /\G([\x09\x0A\x0C\x20]+)/gc) {
                    
        push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
      
                    $token->{index} += length $1;
                  }
                  if ($token->{value} =~ /\G([\x00]+)/gc) {
                    
              my $value = $1;
              while ($value =~ /(.)/gs) {
                push @$Errors, {type => 'parser:NULL',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index} + $-[1]};
  
        push @$OP, ['text', [[q@@, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
      
              }
              
            
                    $token->{index} += length $1;
                  }
                }
              } else {
                
        push @$OP, ['text', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
      
                $FRAMESET_OK = 0 if $FRAMESET_OK and $token->{value} =~ /[^\x09\x0A\x0C\x20]/;
              }
            
          },
        ,
          ## [139] in frameset;COMMENT
          sub {
            my $token = $_;
  
            push @$OP, ['comment', $token => $OE->[-1]->{id}];
          
          },
        ,
          ## [140] in frameset;DOCTYPE
          sub {
            my $token = $_;
  push @$Errors, {type => 'doctype:bad context',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  return;
          },
        ,
          ## [141] in frameset;END-ELSE
          sub {
            my $token = $_;
  push @$Errors, {type => 'in frameset',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  return;
          },
        ,
          ## [142] in frameset;END:frameset
          sub {
            my $token = $_;
  
            if ($OE->[-1]->{et} & (HTM_ELS)) {
              push @$Errors, {type => 'stray end tag',
                                              level => 'm',
                                              value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
  return;
            } else {
              push @$OP, ['popped', [pop @$OE]];
  
            if ((not defined $CONTEXT) and 
  (not ($OE->[-1]->{et} == FRAMESET_EL))) {
              
            $IM = AFTER_FRAMESET_IM;
            #warn "Insertion mode changed to |after frameset| ($IM)";
          
            }
          
            }
          
          },
        ,
          ## [143] in frameset;EOF
          sub {
            my $token = $_;
  
            if (not ($OE->[-1]->{et} & (HTM_ELS))) {
              push @$Errors, {type => 'in body:#eof',
                                              level => 'm',
                                              text => $OE->[-1]->{local_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  push @$OP, ['stop-parsing'];
          },
        ,
          ## [144] in frameset;START-ELSE
          sub {
            my $token = $_;
  push @$Errors, {type => 'in frameset',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  return;
          },
        ,
          ## [145] in frameset;START:frame
          sub {
            my $token = $_;
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'frame',
                   attr_list => $token->{attr_list},
                   et => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS), aet => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS) };
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  
  
            if (delete $token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc', level => 'w',
                              text => $token->{tag_name},
                              di => $token->{di}, index => $token->{index}};
            }
          
          },
        ,
          ## [146] in frameset;START:frameset
          sub {
            my $token = $_;
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'frameset',
                   attr_list => $token->{attr_list},
                   et => (FRAMESET_EL), aet => (FRAMESET_EL) };
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  
  push @$OE, $node;
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
          },
        ,
          ## [147] in frameset;TEXT
          sub {
            my $token = $_;
  
            while (length $token->{value}) {
              if ($token->{value} =~ s/^([^\x09\x0A\x0C\x20]+)//) {
                
              my $value = $1;
              while ($value =~ /(.)/gs) {
                push @$Errors, {type => 'in frameset',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index} + $-[1]};
              }
              
            
                $token->{index} += length $1;
              }
              if ($token->{value} =~ s/^([\x09\x0A\x0C\x20]+)//) {
                
        push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
      
                $token->{index} += length $1;
              }
            }
          
          },
        ,
          ## [148] in head noscript;DOCTYPE
          sub {
            my $token = $_;
  push @$Errors, {type => 'doctype:bad context',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  return;
          },
        ,
          ## [149] in head noscript;END-ELSE
          sub {
            my $token = $_;
  push @$Errors, {type => 'stray end tag',
                                              level => 'm',
                                              value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
  return;
          },
        ,
          ## [150] in head noscript;END:br
          sub {
            my $token = $_;
  push @$Errors, {type => 'in noscript',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  push @$OP, ['popped', [pop @$OE]];
  
            $IM = IN_HEAD_IM;
            #warn "Insertion mode changed to |in head| ($IM)";
          
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
          },
        ,
          ## [151] in head noscript;END:noscript
          sub {
            push @$OP, ['popped', [pop @$OE]];
  
            $IM = IN_HEAD_IM;
            #warn "Insertion mode changed to |in head| ($IM)";
          
          },
        ,
          ## [152] in head noscript;EOF
          sub {
            my $token = $_;
  push @$Errors, {type => 'in noscript',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  push @$OP, ['popped', [pop @$OE]];
  
            $IM = IN_HEAD_IM;
            #warn "Insertion mode changed to |in head| ($IM)";
          
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
          },
        ,
          ## [153] in head noscript;START-ELSE
          sub {
            my $token = $_;
  push @$Errors, {type => 'in noscript',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  push @$OP, ['popped', [pop @$OE]];
  
            $IM = IN_HEAD_IM;
            #warn "Insertion mode changed to |in head| ($IM)";
          
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
          },
        ,
          ## [154] in head noscript;START:head,noscript
          sub {
            my $token = $_;
  push @$Errors, {type => 'in noscript',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  return;
          },
        ,
          ## [155] in head noscript;TEXT
          sub {
            my $token = $_;
  
          if ($token->{value} =~ s/^([\x09\x0A\x0C\x20]+)//) {
            
        push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
      
            $token->{index} += length $1;
          }
          if (length $token->{value}) {
            push @$Errors, {type => 'in noscript',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  push @$OP, ['popped', [pop @$OE]];
  
            $IM = IN_HEAD_IM;
            #warn "Insertion mode changed to |in head| ($IM)";
          
  push @$OP, ['popped', [pop @$OE]];
  
            $IM = AFTER_HEAD_IM;
            #warn "Insertion mode changed to |after head| ($IM)";
          
  
          my $node_body = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'body',
                   attr_list => [],
                   et => (BODY_EL), aet => (BODY_EL) };
        
  
        push @$OP, ['insert', $node_body => $OE->[-1]->{id}];
      
  
  push @$OE, $node_body;
  
            $IM = IN_BODY_IM;
            #warn "Insertion mode changed to |in body| ($IM)";
          
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
          }
        
          },
        ,
          ## [156] in head;COMMENT
          sub {
            my $token = $_;
  
            push @$OP, ['comment', $token => $OE->[-1]->{id}];
          
          },
        ,
          ## [157] in head;DOCTYPE
          sub {
            my $token = $_;
  push @$Errors, {type => 'doctype:bad context',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  return;
          },
        ,
          ## [158] in head;END-ELSE
          sub {
            my $token = $_;
  push @$Errors, {type => 'stray end tag',
                                              level => 'm',
                                              value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
  return;
          },
        ,
          ## [159] in head;END:body,br,html
          sub {
            my $token = $_;
  push @$OP, ['popped', [pop @$OE]];
  
            $IM = AFTER_HEAD_IM;
            #warn "Insertion mode changed to |after head| ($IM)";
          
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
          },
        ,
          ## [160] in head;END:head
          sub {
            push @$OP, ['popped', [pop @$OE]];
  
            $IM = AFTER_HEAD_IM;
            #warn "Insertion mode changed to |after head| ($IM)";
          
          },
        ,
          ## [161] in head;END:template
          sub {
            my $token = $_;
  
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} & (TEM_ELS)) {
              $result = 1;
              last;
            
            }
          }
          not $result;
        }
      ) {
              push @$Errors, {type => 'stray end tag',
                                              level => 'm',
                                              value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
  return;
            } else {
              pop @$OE while $OE->[-1]->{et} & (CAP_ELS | COL_ELS | DD_ELS | DT_ELS | LI_ELS | OPT_OPT_ELS | P_ELS | RB_RP_RT_ELS | RTC_ELS | TBO_TFO_THE_ELS | TD_TH_ELS | TR_ELS);
  
            if (not ($OE->[-1]->{et} & (TEM_ELS))) {
              push @$Errors, {type => 'not closed before ancestor end tag',
                                              level => 'm',
                                              text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} & (TEM_ELS));
            push @popped, pop @$OE;
            push @$OP, ['popped', \@popped];
          }
  
          pop @$AFE while ref $AFE->[-1];
          pop @$AFE; # #marker
        
  pop @$TEMPLATE_IMS;
  &reset_im;
            }
          
          },
        ,
          ## [162] in head;EOF
          sub {
            my $token = $_;
  push @$OP, ['popped', [pop @$OE]];
  
            $IM = AFTER_HEAD_IM;
            #warn "Insertion mode changed to |after head| ($IM)";
          
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
          },
        ,
          ## [163] in head;START-ELSE
          sub {
            my $token = $_;
  push @$OP, ['popped', [pop @$OE]];
  
            $IM = AFTER_HEAD_IM;
            #warn "Insertion mode changed to |after head| ($IM)";
          
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
          },
        ,
          ## [164] in head;START:base,basefont bgsound link
          sub {
            my $token = $_;
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => $token->{tag_name},
                   attr_list => $token->{attr_list},
                   et => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}, aet => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'} };
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  
  
            if (delete $token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc', level => 'w',
                              text => $token->{tag_name},
                              di => $token->{di}, index => $token->{index}};
            }
          
          },
        ,
          ## [165] in head;START:head
          sub {
            my $token = $_;
  push @$Errors, {type => 'in head:head',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  return;
          },
        ,
          ## [166] in head;START:meta
          sub {
            my $token = $_;
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'meta',
                   attr_list => $token->{attr_list},
                   et => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS), aet => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS) };
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  
  
            if (delete $token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc', level => 'w',
                              text => $token->{tag_name},
                              di => $token->{di}, index => $token->{index}};
            }
          
  
          if (defined $token->{attrs}->{charset}) {
            push @$OP, ['change-the-encoding',
                        (join '', map { $_->[0] } @{$token->{attrs}->{charset}->{value}}), # IndexedString
                        $token->{attrs}->{charset}];
          } elsif (defined $token->{attrs}->{'http-equiv'} and
                   defined $token->{attrs}->{content}) {
            # IndexedString
            if ((join '', map { $_->[0] } @{$token->{attrs}->{'http-equiv'}->{value}})
                    =~ /\A[Cc][Oo][Nn][Tt][Ee][Nn][Tt]-[Tt][Yy][Pp][Ee]\z/ and
                (join '', map { $_->[0] } @{$token->{attrs}->{content}->{value}})
                    =~ /[Cc][Hh][Aa][Rr][Ss][Ee][Tt]
                          [\x09\x0A\x0C\x0D\x20]*=
                          [\x09\x0A\x0C\x0D\x20]*(?>"([^"]*)"|'([^']*)'|
                          ([^"'\x09\x0A\x0C\x0D\x20]
                           [^\x09\x0A\x0C\x0D\x20\x3B]*))/x) {
              push @$OP, ['change-the-encoding',
                          defined $1 ? $1 : defined $2 ? $2 : $3,
                          $token->{attrs}->{content}];
            }
          }
        
          },
        ,
          ## [167] in head;START:noframes,style
          sub {
            my $token = $_;
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => $token->{tag_name},
                   attr_list => $token->{attr_list},
                   et => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}, aet => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'} };
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  
  push @$OE, $node;
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  $State = RAWTEXT_STATE;
  $ORIGINAL_IM = $IM;
  
            $IM = TEXT_IM;
            #warn "Insertion mode changed to |text| ($IM)";
          
          },
        ,
          ## [168] in head;START:noscript
          sub {
            my $token = $_;
  
            if ($Scripting) {
              
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'noscript',
                   attr_list => $token->{attr_list},
                   et => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS), aet => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS) };
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  
  push @$OE, $node;
  $State = RAWTEXT_STATE;
  $ORIGINAL_IM = $IM;
  
            $IM = TEXT_IM;
            #warn "Insertion mode changed to |text| ($IM)";
          
            } else {
              
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'noscript',
                   attr_list => $token->{attr_list},
                   et => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS), aet => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS) };
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  
  push @$OE, $node;
  
            $IM = IN_HEAD_NOSCRIPT_IM;
            #warn "Insertion mode changed to |in head noscript| ($IM)";
          
            }
          
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
          },
        ,
          ## [169] in head;START:script
          sub {
            my $token = $_;
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'script',
                   attr_list => $token->{attr_list},
                   et => (SCRIPT_EL), aet => (SCRIPT_EL) , script_flags => 1};
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  
  push @$OE, $node;
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  $State = SCRIPT_DATA_STATE;
  $ORIGINAL_IM = $IM;
  
            $IM = TEXT_IM;
            #warn "Insertion mode changed to |text| ($IM)";
          
          },
        ,
          ## [170] in head;START:template
          sub {
            my $token = $_;
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'template',
                   attr_list => $token->{attr_list},
                   et => (TEMPLATE_EL), aet => (TEMPLATE_EL) };
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  
  push @$OE, $node;
  push @$AFE, '#marker';
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  
          $FRAMESET_OK = 0;
        
  
            $IM = IN_TEMPLATE_IM;
            #warn "Insertion mode changed to |in template| ($IM)";
          
  
          push @$TEMPLATE_IMS, IN_TEMPLATE_IM;
        
          },
        ,
          ## [171] in head;START:title
          sub {
            my $token = $_;
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'title',
                   attr_list => $token->{attr_list},
                   et => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS), aet => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS) };
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  
  push @$OE, $node;
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  $State = RCDATA_STATE;
  $ORIGINAL_IM = $IM;
  
            $IM = TEXT_IM;
            #warn "Insertion mode changed to |text| ($IM)";
          
          },
        ,
          ## [172] in head;TEXT
          sub {
            my $token = $_;
  
          if ($token->{value} =~ s/^([\x09\x0A\x0C\x20]+)//) {
            
        push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
      
            $token->{index} += length $1;
          }
          if (length $token->{value}) {
            push @$OP, ['popped', [pop @$OE]];
  
            $IM = AFTER_HEAD_IM;
            #warn "Insertion mode changed to |after head| ($IM)";
          
  
          my $node_body = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'body',
                   attr_list => [],
                   et => (BODY_EL), aet => (BODY_EL) };
        
  
        push @$OP, ['insert', $node_body => $OE->[-1]->{id}];
      
  
  push @$OE, $node_body;
  
            $IM = IN_BODY_IM;
            #warn "Insertion mode changed to |in body| ($IM)";
          
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
          }
        
          },
        ,
          ## [173] in row;END:body,caption,col,colgroup,html,td th
          sub {
            my $token = $_;
  push @$Errors, {type => 'stray end tag',
                                              level => 'm',
                                              value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
  return;
          },
        ,
          ## [174] in row;END:table
          sub {
            my $token = $_;
  
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} & (TR_ELS)) {
              $result = 1;
              last;
            } elsif ($_->{et} & (HTM_ELS | TAB_ELS | TEM_ELS)) { last; 
            }
          }
          not $result;
        }
      ) {
              push @$Errors, {type => 'stray end tag',
                                              level => 'm',
                                              value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
  return;
            } else {
              {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} & (HTM_ELS | TEM_ELS | TR_ELS));
            push @$OP, ['popped', \@popped];
          }
  push @$OP, ['popped', [pop @$OE]];
  
            $IM = IN_TABLE_BODY_IM;
            #warn "Insertion mode changed to |in table body| ($IM)";
          
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
            }
          
          },
        ,
          ## [175] in row;END:tbody tfoot thead
          sub {
            my $token = $_;
  
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} & HTML_NS_ELS and $_->{local_name} eq $token->{tag_name}) {
              $result = 1;
              last;
            } elsif ($_->{et} & (HTM_ELS | TAB_ELS | TEM_ELS)) { last; 
            }
          }
          not $result;
        }
      ) {
              push @$Errors, {type => 'stray end tag',
                                              level => 'm',
                                              value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
  return;
            }
          
  
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} & (TR_ELS)) {
              $result = 1;
              last;
            } elsif ($_->{et} & (HTM_ELS | TAB_ELS | TEM_ELS)) { last; 
            }
          }
          not $result;
        }
      ) {
              return;
            } else {
              {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} & (HTM_ELS | TEM_ELS | TR_ELS));
            push @$OP, ['popped', \@popped];
          }
  push @$OP, ['popped', [pop @$OE]];
  
            $IM = IN_TABLE_BODY_IM;
            #warn "Insertion mode changed to |in table body| ($IM)";
          
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
            }
          
          },
        ,
          ## [176] in row;END:tr
          sub {
            my $token = $_;
  
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} & (TR_ELS)) {
              $result = 1;
              last;
            } elsif ($_->{et} & (HTM_ELS | TAB_ELS | TEM_ELS)) { last; 
            }
          }
          not $result;
        }
      ) {
              push @$Errors, {type => 'stray end tag',
                                              level => 'm',
                                              value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
  return;
            } else {
              {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} & (HTM_ELS | TEM_ELS | TR_ELS));
            push @$OP, ['popped', \@popped];
          }
  push @$OP, ['popped', [pop @$OE]];
  
            $IM = IN_TABLE_BODY_IM;
            #warn "Insertion mode changed to |in table body| ($IM)";
          
            }
          
          },
        ,
          ## [177] in row;START:caption,col,colgroup,tbody tfoot thead,tr
          sub {
            my $token = $_;
  
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} & (TR_ELS)) {
              $result = 1;
              last;
            } elsif ($_->{et} & (HTM_ELS | TAB_ELS | TEM_ELS)) { last; 
            }
          }
          not $result;
        }
      ) {
              push @$Errors, {type => 'in table row',
                                              level => 'm',
                                              value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  return;
            } else {
              {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} & (HTM_ELS | TEM_ELS | TR_ELS));
            push @$OP, ['popped', \@popped];
          }
  push @$OP, ['popped', [pop @$OE]];
  
            $IM = IN_TABLE_BODY_IM;
            #warn "Insertion mode changed to |in table body| ($IM)";
          
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
            }
          
          },
        ,
          ## [178] in row;START:td th
          sub {
            my $token = $_;
  {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} & (HTM_ELS | TEM_ELS | TR_ELS));
            push @$OP, ['popped', \@popped];
          }
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => $token->{tag_name},
                   attr_list => $token->{attr_list},
                   et => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}, aet => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'} };
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  
  push @$OE, $node;
  
            $IM = IN_CELL_IM;
            #warn "Insertion mode changed to |in cell| ($IM)";
          
  push @$AFE, '#marker';
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
          },
        ,
          ## [179] in row;TEXT
          sub {
            my $token = $_;
  
            if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) {
              @$TABLE_CHARS = ();
  $ORIGINAL_IM = $IM;
  
            $IM = IN_TABLE_TEXT_IM;
            #warn "Insertion mode changed to |in table text| ($IM)";
          
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
            } else {
              push @$Errors, {type => 'in table:#text',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  
              if (index ($token->{value}, "\x00") > -1) {
                pos ($token->{value}) = 0;
                while (pos $token->{value} < length $token->{value}) {
                  if ($token->{value} =~ /\G([^\x00\x09\x0A\x0C\x20]+)/gc) {
                    &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];
  
        if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
          FOSTER: {
            for my $i (reverse 1..$#$OE) {
              if ($OE->[$i]->{et} & (TAB_ELS)) { # table
                push @$OP, ['text-foster', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
                last FOSTER;
              } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
                push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}];
                last FOSTER;
              }
            }
            push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[0]->{id}];
          } # FOSTER
        } else {
          push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
        }
      
  
          $FRAMESET_OK = 0;
        
                    $token->{index} += length $1;
                  }
                  if ($token->{value} =~ /\G([\x09\x0A\x0C\x20]+)/gc) {
                    &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];
  
        if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
          FOSTER: {
            for my $i (reverse 1..$#$OE) {
              if ($OE->[$i]->{et} & (TAB_ELS)) { # table
                push @$OP, ['text-foster', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
                last FOSTER;
              } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
                push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}];
                last FOSTER;
              }
            }
            push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[0]->{id}];
          } # FOSTER
        } else {
          push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
        }
      
                    $token->{index} += length $1;
                  }
                  if ($token->{value} =~ /\G([\x00]+)/gc) {
                    
              my $value = $1;
              while ($value =~ /(.)/gs) {
                push @$Errors, {type => 'parser:NULL',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index} + $-[1]};
              }
              
            
                    $token->{index} += length $1;
                  }
                }
              } else {
                &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];
  
        if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
          FOSTER: {
            for my $i (reverse 1..$#$OE) {
              if ($OE->[$i]->{et} & (TAB_ELS)) { # table
                push @$OP, ['text-foster', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
                last FOSTER;
              } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
                push @$OP, ['text', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[$i]->{id}];
                last FOSTER;
              }
            }
            push @$OP, ['text', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[0]->{id}];
          } # FOSTER
        } else {
          push @$OP, ['text', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
        }
      
                $FRAMESET_OK = 0 if $FRAMESET_OK and $token->{value} =~ /[^\x09\x0A\x0C\x20]/;
              }
            
            }
          
          },
        ,
          ## [180] in select in table;END:caption,table,tbody tfoot thead,td th,tr
          sub {
            my $token = $_;
  push @$Errors, {type => 'in select in table:end tag',
                                              level => 'm',
                                              value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
  
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} & HTML_NS_ELS and $_->{local_name} eq $token->{tag_name}) {
              $result = 1;
              last;
            } elsif ($_->{et} & (HTM_ELS | TAB_ELS | TEM_ELS)) { last; 
            }
          }
          not $result;
        }
      ) {
              return;
            } else {
              {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} == SELECT_EL);
            push @popped, pop @$OE;
            push @$OP, ['popped', \@popped];
          }
  &reset_im;
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
            }
          
          },
        ,
          ## [181] in select in table;START:caption,table,tbody tfoot thead,td th,tr
          sub {
            my $token = $_;
  push @$Errors, {type => 'in select in table:start tag',
                                              level => 'm',
                                              value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
  {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} == SELECT_EL);
            push @popped, pop @$OE;
            push @$OP, ['popped', \@popped];
          }
  &reset_im;
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
          },
        ,
          ## [182] in select in table;TEXT
          sub {
            my $token = $_;
  
            while (length $token->{value}) {
              if ($token->{value} =~ s/^([^\x00]+)//) {
                
        push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
      
                $token->{index} += length $1;
              }
              if ($token->{value} =~ s/^([\x00]+)//) {
                
              my $value = $1;
              while ($value =~ /(.)/gs) {
                push @$Errors, {type => 'parser:NULL',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index} + $-[1]};
              }
              
            
                $token->{index} += length $1;
              }
            }
          
          },
        ,
          ## [183] in select;COMMENT
          sub {
            my $token = $_;
  
            push @$OP, ['comment', $token => $OE->[-1]->{id}];
          
          },
        ,
          ## [184] in select;DOCTYPE
          sub {
            my $token = $_;
  push @$Errors, {type => 'doctype:bad context',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  return;
          },
        ,
          ## [185] in select;END-ELSE
          sub {
            my $token = $_;
  push @$Errors, {type => 'in select',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  return;
          },
        ,
          ## [186] in select;END:optgroup
          sub {
            my $token = $_;
  
            if (($OE->[-1]->{et} == OPTION_EL) and 
  (@$OE >= 2 and $OE->[-2]->{et} == OPTGROUP_EL)) {
              push @$OP, ['popped', [pop @$OE]];
            }
          
  
            if ($OE->[-1]->{et} == OPTGROUP_EL) {
              push @$OP, ['popped', [pop @$OE]];
            } else {
              push @$Errors, {type => 'stray end tag',
                                              level => 'm',
                                              value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
  return;
            }
          
          },
        ,
          ## [187] in select;END:option
          sub {
            my $token = $_;
  
            if ($OE->[-1]->{et} == OPTION_EL) {
              push @$OP, ['popped', [pop @$OE]];
            } else {
              push @$Errors, {type => 'stray end tag',
                                              level => 'm',
                                              value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
  return;
            }
          
          },
        ,
          ## [188] in select;END:select
          sub {
            my $token = $_;
  
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} == SELECT_EL) {
              $result = 1;
              last;
            } elsif (not ($_->{et} & (OPT_OPT_ELS))) { last; 
            }
          }
          not $result;
        }
      ) {
              push @$Errors, {type => 'stray end tag',
                                              level => 'm',
                                              value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
  return;
            } else {
              {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} == SELECT_EL);
            push @popped, pop @$OE;
            push @$OP, ['popped', \@popped];
          }
  &reset_im;
            }
          
          },
        ,
          ## [189] in select;START-ELSE
          sub {
            my $token = $_;
  push @$Errors, {type => 'in select',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  return;
          },
        ,
          ## [190] in select;START:input,keygen,textarea
          sub {
            my $token = $_;
  push @$Errors, {type => 'element not closed before implied ancestor end tag',
                                              level => 'm',
                                              text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
  
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} == SELECT_EL) {
              $result = 1;
              last;
            } elsif (not ($_->{et} & (OPT_OPT_ELS))) { last; 
            }
          }
          not $result;
        }
      ) {
              
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  return;
            } else {
              {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} == SELECT_EL);
            push @popped, pop @$OE;
            push @$OP, ['popped', \@popped];
          }
  &reset_im;
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
            }
          
          },
        ,
          ## [191] in select;START:optgroup
          sub {
            my $token = $_;
  
            if ($OE->[-1]->{et} == OPTION_EL) {
              push @$OP, ['popped', [pop @$OE]];
            }
          
  
            if ($OE->[-1]->{et} == OPTGROUP_EL) {
              push @$OP, ['popped', [pop @$OE]];
            }
          
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'optgroup',
                   attr_list => $token->{attr_list},
                   et => (OPTGROUP_EL), aet => (OPTGROUP_EL) };
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  
  push @$OE, $node;
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
          },
        ,
          ## [192] in select;START:option
          sub {
            my $token = $_;
  
            if ($OE->[-1]->{et} == OPTION_EL) {
              push @$OP, ['popped', [pop @$OE]];
            }
          
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'option',
                   attr_list => $token->{attr_list},
                   et => (OPTION_EL), aet => (OPTION_EL) };
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  
  push @$OE, $node;
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
          },
        ,
          ## [193] in select;START:select
          sub {
            my $token = $_;
  push @$Errors, {type => 'parser:element not nestable',
                                              level => 'm',
                                              value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
  
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} == SELECT_EL) {
              $result = 1;
              last;
            } elsif (not ($_->{et} & (OPT_OPT_ELS))) { last; 
            }
          }
          not $result;
        }
      ) {
              return;
            } else {
              {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} == SELECT_EL);
            push @popped, pop @$OE;
            push @$OP, ['popped', \@popped];
          }
  &reset_im;
            }
          
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
          },
        ,
          ## [194] in select;TEXT
          sub {
            my $token = $_;
  
            while (length $token->{value}) {
              if ($token->{value} =~ s/^([^\x00]+)//) {
                
        push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
      
                $token->{index} += length $1;
              }
              if ($token->{value} =~ s/^([\x00]+)//) {
                
              my $value = $1;
              while ($value =~ /(.)/gs) {
                push @$Errors, {type => 'parser:NULL',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index} + $-[1]};
              }
              
            
                $token->{index} += length $1;
              }
            }
          
          },
        ,
          ## [195] in table body;END:body,caption,col,colgroup,html,td th,tr
          sub {
            my $token = $_;
  push @$Errors, {type => 'stray end tag',
                                              level => 'm',
                                              value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
  return;
          },
        ,
          ## [196] in table body;END:table
          sub {
            my $token = $_;
  
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} & (TBO_TFO_THE_ELS)) {
              $result = 1;
              last;
            } elsif ($_->{et} & (HTM_ELS | TAB_ELS | TEM_ELS)) { last; 
            }
          }
          not $result;
        }
      ) {
              push @$Errors, {type => 'stray end tag',
                                              level => 'm',
                                              value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
  return;
            } else {
              {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} & (HTM_ELS | TBO_TFO_THE_ELS | TEM_ELS));
            push @$OP, ['popped', \@popped];
          }
  push @$OP, ['popped', [pop @$OE]];
  
            $IM = IN_TABLE_IM;
            #warn "Insertion mode changed to |in table| ($IM)";
          
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
            }
          
          },
        ,
          ## [197] in table body;END:tbody tfoot thead
          sub {
            my $token = $_;
  
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} & HTML_NS_ELS and $_->{local_name} eq $token->{tag_name}) {
              $result = 1;
              last;
            } elsif ($_->{et} & (HTM_ELS | TAB_ELS | TEM_ELS)) { last; 
            }
          }
          not $result;
        }
      ) {
              push @$Errors, {type => 'stray end tag',
                                              level => 'm',
                                              value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
  return;
            } else {
              {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} & (HTM_ELS | TBO_TFO_THE_ELS | TEM_ELS));
            push @$OP, ['popped', \@popped];
          }
  push @$OP, ['popped', [pop @$OE]];
  
            $IM = IN_TABLE_IM;
            #warn "Insertion mode changed to |in table| ($IM)";
          
            }
          
          },
        ,
          ## [198] in table body;START:caption,col,colgroup,tbody tfoot thead
          sub {
            my $token = $_;
  
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} & (TBO_TFO_THE_ELS)) {
              $result = 1;
              last;
            } elsif ($_->{et} & (HTM_ELS | TAB_ELS | TEM_ELS)) { last; 
            }
          }
          not $result;
        }
      ) {
              push @$Errors, {type => 'in table body',
                                              level => 'm',
                                              value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  return;
            } else {
              {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} & (HTM_ELS | TBO_TFO_THE_ELS | TEM_ELS));
            push @$OP, ['popped', \@popped];
          }
  push @$OP, ['popped', [pop @$OE]];
  
            $IM = IN_TABLE_IM;
            #warn "Insertion mode changed to |in table| ($IM)";
          
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
            }
          
          },
        ,
          ## [199] in table body;START:td th
          sub {
            my $token = $_;
  push @$Errors, {type => 'no <tr>',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} & (HTM_ELS | TBO_TFO_THE_ELS | TEM_ELS));
            push @$OP, ['popped', \@popped];
          }
  
          my $node_tr = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'tr',
                   attr_list => [],
                   et => (TR_EL), aet => (TR_EL) };
        
  
        push @$OP, ['insert', $node_tr => $OE->[-1]->{id}];
      
  
  push @$OE, $node_tr;
  
            $IM = IN_ROW_IM;
            #warn "Insertion mode changed to |in row| ($IM)";
          
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
          },
        ,
          ## [200] in table body;START:tr
          sub {
            my $token = $_;
  {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} & (HTM_ELS | TBO_TFO_THE_ELS | TEM_ELS));
            push @$OP, ['popped', \@popped];
          }
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'tr',
                   attr_list => $token->{attr_list},
                   et => (TR_EL), aet => (TR_EL) };
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  
  push @$OE, $node;
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  
            $IM = IN_ROW_IM;
            #warn "Insertion mode changed to |in row| ($IM)";
          
          },
        ,
          ## [201] in table body;TEXT
          sub {
            my $token = $_;
  
            if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) {
              @$TABLE_CHARS = ();
  $ORIGINAL_IM = $IM;
  
            $IM = IN_TABLE_TEXT_IM;
            #warn "Insertion mode changed to |in table text| ($IM)";
          
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
            } else {
              push @$Errors, {type => 'in table:#text',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  
              if (index ($token->{value}, "\x00") > -1) {
                pos ($token->{value}) = 0;
                while (pos $token->{value} < length $token->{value}) {
                  if ($token->{value} =~ /\G([^\x00\x09\x0A\x0C\x20]+)/gc) {
                    &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];
  
        if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
          FOSTER: {
            for my $i (reverse 1..$#$OE) {
              if ($OE->[$i]->{et} & (TAB_ELS)) { # table
                push @$OP, ['text-foster', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
                last FOSTER;
              } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
                push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}];
                last FOSTER;
              }
            }
            push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[0]->{id}];
          } # FOSTER
        } else {
          push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
        }
      
  
          $FRAMESET_OK = 0;
        
                    $token->{index} += length $1;
                  }
                  if ($token->{value} =~ /\G([\x09\x0A\x0C\x20]+)/gc) {
                    &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];
  
        if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
          FOSTER: {
            for my $i (reverse 1..$#$OE) {
              if ($OE->[$i]->{et} & (TAB_ELS)) { # table
                push @$OP, ['text-foster', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
                last FOSTER;
              } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
                push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}];
                last FOSTER;
              }
            }
            push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[0]->{id}];
          } # FOSTER
        } else {
          push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
        }
      
                    $token->{index} += length $1;
                  }
                  if ($token->{value} =~ /\G([\x00]+)/gc) {
                    
              my $value = $1;
              while ($value =~ /(.)/gs) {
                push @$Errors, {type => 'parser:NULL',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index} + $-[1]};
              }
              
            
                    $token->{index} += length $1;
                  }
                }
              } else {
                &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];
  
        if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
          FOSTER: {
            for my $i (reverse 1..$#$OE) {
              if ($OE->[$i]->{et} & (TAB_ELS)) { # table
                push @$OP, ['text-foster', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
                last FOSTER;
              } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
                push @$OP, ['text', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[$i]->{id}];
                last FOSTER;
              }
            }
            push @$OP, ['text', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[0]->{id}];
          } # FOSTER
        } else {
          push @$OP, ['text', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
        }
      
                $FRAMESET_OK = 0 if $FRAMESET_OK and $token->{value} =~ /[^\x09\x0A\x0C\x20]/;
              }
            
            }
          
          },
        ,
          ## [202] in table text;COMMENT
          sub {
            my $token = $_;
  
            if (grep { $_->{value} =~ /[^\x09\x0A\x0C\x20]/ } @$TABLE_CHARS) {
              push @$Errors, {type => 'in table:#text',
                                              level => 'm',
                                              di => $TABLE_CHARS->[0]->{di},
                          index => $TABLE_CHARS->[0]->{index}};
  
            for my $token (@$TABLE_CHARS) {
              
              if (index ($token->{value}, "\x00") > -1) {
                pos ($token->{value}) = 0;
                while (pos $token->{value} < length $token->{value}) {
                  if ($token->{value} =~ /\G([^\x00\x09\x0A\x0C\x20]+)/gc) {
                    &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];
  
        if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
          FOSTER: {
            for my $i (reverse 1..$#$OE) {
              if ($OE->[$i]->{et} & (TAB_ELS)) { # table
                push @$OP, ['text-foster', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
                last FOSTER;
              } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
                push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}];
                last FOSTER;
              }
            }
            push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[0]->{id}];
          } # FOSTER
        } else {
          push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
        }
      
  
          $FRAMESET_OK = 0;
        
                    $token->{index} += length $1;
                  }
                  if ($token->{value} =~ /\G([\x09\x0A\x0C\x20]+)/gc) {
                    &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];
  
        if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
          FOSTER: {
            for my $i (reverse 1..$#$OE) {
              if ($OE->[$i]->{et} & (TAB_ELS)) { # table
                push @$OP, ['text-foster', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
                last FOSTER;
              } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
                push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}];
                last FOSTER;
              }
            }
            push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[0]->{id}];
          } # FOSTER
        } else {
          push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
        }
      
                    $token->{index} += length $1;
                  }
                  if ($token->{value} =~ /\G([\x00]+)/gc) {
                    
              my $value = $1;
              while ($value =~ /(.)/gs) {
                push @$Errors, {type => 'parser:NULL',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index} + $-[1]};
              }
              
            
                    $token->{index} += length $1;
                  }
                }
              } else {
                &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];
  
        if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
          FOSTER: {
            for my $i (reverse 1..$#$OE) {
              if ($OE->[$i]->{et} & (TAB_ELS)) { # table
                push @$OP, ['text-foster', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
                last FOSTER;
              } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
                push @$OP, ['text', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[$i]->{id}];
                last FOSTER;
              }
            }
            push @$OP, ['text', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[0]->{id}];
          } # FOSTER
        } else {
          push @$OP, ['text', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
        }
      
                $FRAMESET_OK = 0 if $FRAMESET_OK and $token->{value} =~ /[^\x09\x0A\x0C\x20]/;
              }
            
            }
          
            } else {
              
        push @$OP, ['text', [map { [$_->{value}, $_->{di}, $_->{index}] } @$TABLE_CHARS] => $OE->[-1]->{id}];
      
            }
          
  
              $IM = $ORIGINAL_IM;
            
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
          },
        ,
          ## [203] in table text;DOCTYPE
          sub {
            my $token = $_;
  
            if (grep { $_->{value} =~ /[^\x09\x0A\x0C\x20]/ } @$TABLE_CHARS) {
              push @$Errors, {type => 'in table:#text',
                                              level => 'm',
                                              di => $TABLE_CHARS->[0]->{di},
                          index => $TABLE_CHARS->[0]->{index}};
  
            for my $token (@$TABLE_CHARS) {
              
              if (index ($token->{value}, "\x00") > -1) {
                pos ($token->{value}) = 0;
                while (pos $token->{value} < length $token->{value}) {
                  if ($token->{value} =~ /\G([^\x00\x09\x0A\x0C\x20]+)/gc) {
                    &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];
  
        if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
          FOSTER: {
            for my $i (reverse 1..$#$OE) {
              if ($OE->[$i]->{et} & (TAB_ELS)) { # table
                push @$OP, ['text-foster', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
                last FOSTER;
              } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
                push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}];
                last FOSTER;
              }
            }
            push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[0]->{id}];
          } # FOSTER
        } else {
          push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
        }
      
  
          $FRAMESET_OK = 0;
        
                    $token->{index} += length $1;
                  }
                  if ($token->{value} =~ /\G([\x09\x0A\x0C\x20]+)/gc) {
                    &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];
  
        if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
          FOSTER: {
            for my $i (reverse 1..$#$OE) {
              if ($OE->[$i]->{et} & (TAB_ELS)) { # table
                push @$OP, ['text-foster', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
                last FOSTER;
              } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
                push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}];
                last FOSTER;
              }
            }
            push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[0]->{id}];
          } # FOSTER
        } else {
          push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
        }
      
                    $token->{index} += length $1;
                  }
                  if ($token->{value} =~ /\G([\x00]+)/gc) {
                    
              my $value = $1;
              while ($value =~ /(.)/gs) {
                push @$Errors, {type => 'parser:NULL',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index} + $-[1]};
              }
              
            
                    $token->{index} += length $1;
                  }
                }
              } else {
                &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];
  
        if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
          FOSTER: {
            for my $i (reverse 1..$#$OE) {
              if ($OE->[$i]->{et} & (TAB_ELS)) { # table
                push @$OP, ['text-foster', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
                last FOSTER;
              } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
                push @$OP, ['text', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[$i]->{id}];
                last FOSTER;
              }
            }
            push @$OP, ['text', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[0]->{id}];
          } # FOSTER
        } else {
          push @$OP, ['text', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
        }
      
                $FRAMESET_OK = 0 if $FRAMESET_OK and $token->{value} =~ /[^\x09\x0A\x0C\x20]/;
              }
            
            }
          
            } else {
              
        push @$OP, ['text', [map { [$_->{value}, $_->{di}, $_->{index}] } @$TABLE_CHARS] => $OE->[-1]->{id}];
      
            }
          
  
              $IM = $ORIGINAL_IM;
            
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
          },
        ,
          ## [204] in table text;END-ELSE
          sub {
            my $token = $_;
  
            if (grep { $_->{value} =~ /[^\x09\x0A\x0C\x20]/ } @$TABLE_CHARS) {
              push @$Errors, {type => 'in table:#text',
                                              level => 'm',
                                              di => $TABLE_CHARS->[0]->{di},
                          index => $TABLE_CHARS->[0]->{index}};
  
            for my $token (@$TABLE_CHARS) {
              
              if (index ($token->{value}, "\x00") > -1) {
                pos ($token->{value}) = 0;
                while (pos $token->{value} < length $token->{value}) {
                  if ($token->{value} =~ /\G([^\x00\x09\x0A\x0C\x20]+)/gc) {
                    &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];
  
        if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
          FOSTER: {
            for my $i (reverse 1..$#$OE) {
              if ($OE->[$i]->{et} & (TAB_ELS)) { # table
                push @$OP, ['text-foster', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
                last FOSTER;
              } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
                push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}];
                last FOSTER;
              }
            }
            push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[0]->{id}];
          } # FOSTER
        } else {
          push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
        }
      
  
          $FRAMESET_OK = 0;
        
                    $token->{index} += length $1;
                  }
                  if ($token->{value} =~ /\G([\x09\x0A\x0C\x20]+)/gc) {
                    &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];
  
        if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
          FOSTER: {
            for my $i (reverse 1..$#$OE) {
              if ($OE->[$i]->{et} & (TAB_ELS)) { # table
                push @$OP, ['text-foster', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
                last FOSTER;
              } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
                push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}];
                last FOSTER;
              }
            }
            push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[0]->{id}];
          } # FOSTER
        } else {
          push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
        }
      
                    $token->{index} += length $1;
                  }
                  if ($token->{value} =~ /\G([\x00]+)/gc) {
                    
              my $value = $1;
              while ($value =~ /(.)/gs) {
                push @$Errors, {type => 'parser:NULL',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index} + $-[1]};
              }
              
            
                    $token->{index} += length $1;
                  }
                }
              } else {
                &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];
  
        if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
          FOSTER: {
            for my $i (reverse 1..$#$OE) {
              if ($OE->[$i]->{et} & (TAB_ELS)) { # table
                push @$OP, ['text-foster', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
                last FOSTER;
              } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
                push @$OP, ['text', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[$i]->{id}];
                last FOSTER;
              }
            }
            push @$OP, ['text', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[0]->{id}];
          } # FOSTER
        } else {
          push @$OP, ['text', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
        }
      
                $FRAMESET_OK = 0 if $FRAMESET_OK and $token->{value} =~ /[^\x09\x0A\x0C\x20]/;
              }
            
            }
          
            } else {
              
        push @$OP, ['text', [map { [$_->{value}, $_->{di}, $_->{index}] } @$TABLE_CHARS] => $OE->[-1]->{id}];
      
            }
          
  
              $IM = $ORIGINAL_IM;
            
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
          },
        ,
          ## [205] in table text;EOF
          sub {
            my $token = $_;
  
            if (grep { $_->{value} =~ /[^\x09\x0A\x0C\x20]/ } @$TABLE_CHARS) {
              push @$Errors, {type => 'in table:#text',
                                              level => 'm',
                                              di => $TABLE_CHARS->[0]->{di},
                          index => $TABLE_CHARS->[0]->{index}};
  
            for my $token (@$TABLE_CHARS) {
              
              if (index ($token->{value}, "\x00") > -1) {
                pos ($token->{value}) = 0;
                while (pos $token->{value} < length $token->{value}) {
                  if ($token->{value} =~ /\G([^\x00\x09\x0A\x0C\x20]+)/gc) {
                    &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];
  
        if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
          FOSTER: {
            for my $i (reverse 1..$#$OE) {
              if ($OE->[$i]->{et} & (TAB_ELS)) { # table
                push @$OP, ['text-foster', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
                last FOSTER;
              } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
                push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}];
                last FOSTER;
              }
            }
            push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[0]->{id}];
          } # FOSTER
        } else {
          push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
        }
      
  
          $FRAMESET_OK = 0;
        
                    $token->{index} += length $1;
                  }
                  if ($token->{value} =~ /\G([\x09\x0A\x0C\x20]+)/gc) {
                    &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];
  
        if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
          FOSTER: {
            for my $i (reverse 1..$#$OE) {
              if ($OE->[$i]->{et} & (TAB_ELS)) { # table
                push @$OP, ['text-foster', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
                last FOSTER;
              } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
                push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}];
                last FOSTER;
              }
            }
            push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[0]->{id}];
          } # FOSTER
        } else {
          push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
        }
      
                    $token->{index} += length $1;
                  }
                  if ($token->{value} =~ /\G([\x00]+)/gc) {
                    
              my $value = $1;
              while ($value =~ /(.)/gs) {
                push @$Errors, {type => 'parser:NULL',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index} + $-[1]};
              }
              
            
                    $token->{index} += length $1;
                  }
                }
              } else {
                &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];
  
        if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
          FOSTER: {
            for my $i (reverse 1..$#$OE) {
              if ($OE->[$i]->{et} & (TAB_ELS)) { # table
                push @$OP, ['text-foster', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
                last FOSTER;
              } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
                push @$OP, ['text', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[$i]->{id}];
                last FOSTER;
              }
            }
            push @$OP, ['text', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[0]->{id}];
          } # FOSTER
        } else {
          push @$OP, ['text', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
        }
      
                $FRAMESET_OK = 0 if $FRAMESET_OK and $token->{value} =~ /[^\x09\x0A\x0C\x20]/;
              }
            
            }
          
            } else {
              
        push @$OP, ['text', [map { [$_->{value}, $_->{di}, $_->{index}] } @$TABLE_CHARS] => $OE->[-1]->{id}];
      
            }
          
  
              $IM = $ORIGINAL_IM;
            
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
          },
        ,
          ## [206] in table text;START-ELSE
          sub {
            my $token = $_;
  
            if (grep { $_->{value} =~ /[^\x09\x0A\x0C\x20]/ } @$TABLE_CHARS) {
              push @$Errors, {type => 'in table:#text',
                                              level => 'm',
                                              di => $TABLE_CHARS->[0]->{di},
                          index => $TABLE_CHARS->[0]->{index}};
  
            for my $token (@$TABLE_CHARS) {
              
              if (index ($token->{value}, "\x00") > -1) {
                pos ($token->{value}) = 0;
                while (pos $token->{value} < length $token->{value}) {
                  if ($token->{value} =~ /\G([^\x00\x09\x0A\x0C\x20]+)/gc) {
                    &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];
  
        if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
          FOSTER: {
            for my $i (reverse 1..$#$OE) {
              if ($OE->[$i]->{et} & (TAB_ELS)) { # table
                push @$OP, ['text-foster', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
                last FOSTER;
              } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
                push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}];
                last FOSTER;
              }
            }
            push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[0]->{id}];
          } # FOSTER
        } else {
          push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
        }
      
  
          $FRAMESET_OK = 0;
        
                    $token->{index} += length $1;
                  }
                  if ($token->{value} =~ /\G([\x09\x0A\x0C\x20]+)/gc) {
                    &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];
  
        if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
          FOSTER: {
            for my $i (reverse 1..$#$OE) {
              if ($OE->[$i]->{et} & (TAB_ELS)) { # table
                push @$OP, ['text-foster', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
                last FOSTER;
              } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
                push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}];
                last FOSTER;
              }
            }
            push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[0]->{id}];
          } # FOSTER
        } else {
          push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
        }
      
                    $token->{index} += length $1;
                  }
                  if ($token->{value} =~ /\G([\x00]+)/gc) {
                    
              my $value = $1;
              while ($value =~ /(.)/gs) {
                push @$Errors, {type => 'parser:NULL',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index} + $-[1]};
              }
              
            
                    $token->{index} += length $1;
                  }
                }
              } else {
                &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];
  
        if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
          FOSTER: {
            for my $i (reverse 1..$#$OE) {
              if ($OE->[$i]->{et} & (TAB_ELS)) { # table
                push @$OP, ['text-foster', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
                last FOSTER;
              } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
                push @$OP, ['text', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[$i]->{id}];
                last FOSTER;
              }
            }
            push @$OP, ['text', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[0]->{id}];
          } # FOSTER
        } else {
          push @$OP, ['text', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
        }
      
                $FRAMESET_OK = 0 if $FRAMESET_OK and $token->{value} =~ /[^\x09\x0A\x0C\x20]/;
              }
            
            }
          
            } else {
              
        push @$OP, ['text', [map { [$_->{value}, $_->{di}, $_->{index}] } @$TABLE_CHARS] => $OE->[-1]->{id}];
      
            }
          
  
              $IM = $ORIGINAL_IM;
            
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
          },
        ,
          ## [207] in table text;TEXT
          sub {
            my $token = $_;
  
            while (length $token->{value}) {
              if ($token->{value} =~ s/^([^\x00]+)//) {
                push @$TABLE_CHARS, {%$token, value => $1};
                $token->{index} += length $1;
              }
              if ($token->{value} =~ s/^([\x00]+)//) {
                
              my $value = $1;
              while ($value =~ /(.)/gs) {
                push @$Errors, {type => 'parser:NULL',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index} + $-[1]};
              }
              
            
                $token->{index} += length $1;
              }
            }
          
          },
        ,
          ## [208] in table;COMMENT
          sub {
            my $token = $_;
  
            push @$OP, ['comment', $token => $OE->[-1]->{id}];
          
          },
        ,
          ## [209] in table;DOCTYPE
          sub {
            my $token = $_;
  push @$Errors, {type => 'doctype:bad context',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  return;
          },
        ,
          ## [210] in table;END-ELSE
          sub {
            my $token = $_;
  push @$Errors, {type => 'in table',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  
          goto &{$ProcessIM->[IN_BODY_IM]->[$token->{type}]->[$token->{tn}]};
        
          },
        ,
          ## [211] in table;END:a,b big code em i s small strike strong tt u,font,nobr
          sub {
            my $token = $_;
  push @$Errors, {type => 'in table',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  aaa_foster ($token, $token->{tag_name});
          },
        ,
          ## [212] in table;END:body,caption,col,colgroup,html,tbody tfoot thead,td th,tr
          sub {
            my $token = $_;
  push @$Errors, {type => 'stray end tag',
                                              level => 'm',
                                              value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
  return;
          },
        ,
          ## [213] in table;END:br
          sub {
            my $token = $_;
  push @$Errors, {type => 'in table',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  push @$Errors, {type => '</br>',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];
  
          my $node_br = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'br',
                   attr_list => [],
                   et => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS), aet => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS) };
        
  
        if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
          FOSTER: {
            for my $i (reverse 1..$#$OE) {
              if ($OE->[$i]->{et} & (TAB_ELS)) { # table
                push @$OP, ['insert-foster', $node_br => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
                last FOSTER;
              } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
                push @$OP, ['insert', $node_br => $OE->[$i]->{id}];
                last FOSTER;
              }
            }
            push @$OP, ['insert', $node_br => $OE->[0]->{id}];
          } # FOSTER
        } else {
          push @$OP, ['insert', $node_br => $OE->[-1]->{id}];
        }
      
  
  
            if (delete $token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc', level => 'w',
                              text => $token->{tag_name},
                              di => $token->{di}, index => $token->{index}};
            }
          
  
          $FRAMESET_OK = 0;
        
          },
        ,
          ## [214] in table;END:p
          sub {
            my $token = $_;
  push @$Errors, {type => 'in table',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} & (P_ELS)) {
              $result = 1;
              last;
            } elsif ($_->{et} & (APP_MAR_M_ANN_ELS | BUT_ELS | CAP_ELS | HTM_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
            }
          }
          not $result;
        }
      ) {
              push @$Errors, {type => '</p>',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  
          my $node_p = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'p',
                   attr_list => [],
                   et => (P_EL), aet => (P_EL) };
        
  
        if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
          FOSTER: {
            for my $i (reverse 1..$#$OE) {
              if ($OE->[$i]->{et} & (TAB_ELS)) { # table
                push @$OP, ['insert-foster', $node_p => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
                last FOSTER;
              } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
                push @$OP, ['insert', $node_p => $OE->[$i]->{id}];
                last FOSTER;
              }
            }
            push @$OP, ['insert', $node_p => $OE->[0]->{id}];
          } # FOSTER
        } else {
          push @$OP, ['insert', $node_p => $OE->[-1]->{id}];
        }
      
  
  push @$OE, $node_p;
            }
          
  pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | OPT_OPT_ELS | RB_RP_RT_ELS | RTC_ELS);
  
            if (not ($OE->[-1]->{et} & (P_ELS))) {
              push @$Errors, {type => 'not closed before ancestor end tag',
                                              level => 'm',
                                              text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} & (P_ELS));
            push @popped, pop @$OE;
            push @$OP, ['popped', \@popped];
          }
          },
        ,
          ## [215] in table;END:table
          sub {
            my $token = $_;
  
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} & (TAB_ELS)) {
              $result = 1;
              last;
            } elsif ($_->{et} & (HTM_ELS | TAB_ELS | TEM_ELS)) { last; 
            }
          }
          not $result;
        }
      ) {
              push @$Errors, {type => 'stray end tag',
                                              level => 'm',
                                              value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
  return;
            } else {
              {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} & (TAB_ELS));
            push @popped, pop @$OE;
            push @$OP, ['popped', \@popped];
          }
  &reset_im;
            }
          
          },
        ,
          ## [216] in table;START-ELSE
          sub {
            my $token = $_;
  push @$Errors, {type => 'in table',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => $token->{tag_name},
                   attr_list => $token->{attr_list},
                   et => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}, aet => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'} };
        
  
        if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
          FOSTER: {
            for my $i (reverse 1..$#$OE) {
              if ($OE->[$i]->{et} & (TAB_ELS)) { # table
                push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
                last FOSTER;
              } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
                push @$OP, ['insert', $node => $OE->[$i]->{id}];
                last FOSTER;
              }
            }
            push @$OP, ['insert', $node => $OE->[0]->{id}];
          } # FOSTER
        } else {
          push @$OP, ['insert', $node => $OE->[-1]->{id}];
        }
      
  
              if ($node->{et} & (BUT_ELS | FIE_INP_SEL_ELS | IMG_ELS | OBJ_ELS | OUT_ELS | TEX_ELS)) {
                
            if (defined $FORM_ELEMENT) {
              FORM: {
                last FORM if defined $token->{attrs}->{form} and
                             ($node->{et} & ()); # reassociateable
                for my $oe (@$OE) {
                  if ($oe->{et} & (TEM_ELS)) { # template
                    last FORM;
                  }
                }
                #last FORM unless $FORM_ELEMENT and $OE->[-1] (intended parent) same home subtree - should be checked later
                $node->{form} = $FORM_ELEMENT->{id};
              } # FORM
            }
          
              }
            
  push @$OE, $node;
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
          },
        ,
          ## [217] in table;START:a
          sub {
            my $token = $_;
  push @$Errors, {type => 'in table',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  
            if (
        do {
          my $result = 0;
          for (reverse @$AFE) {
            last if not ref $_;
            if ($_->{et} == A_EL) {
              $result = 1;
              last;
            }
          }
          $result;
        }
      ) {
              push @$Errors, {type => 'parser:element not nestable',
                                              level => 'm',
                                              value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
  aaa_foster ($token, $token->{tag_name}, remove_from_afe_and_oe => 1);
            }
          
  &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'a',
                   attr_list => $token->{attr_list},
                   et => (A_EL), aet => (A_EL) };
        
  
        if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
          FOSTER: {
            for my $i (reverse 1..$#$OE) {
              if ($OE->[$i]->{et} & (TAB_ELS)) { # table
                push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
                last FOSTER;
              } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
                push @$OP, ['insert', $node => $OE->[$i]->{id}];
                last FOSTER;
              }
            }
            push @$OP, ['insert', $node => $OE->[0]->{id}];
          } # FOSTER
        } else {
          push @$OP, ['insert', $node => $OE->[-1]->{id}];
        }
      
  
  push @$OE, $node;
  
          ## Noah's Ark
          my $found = 0;
          AFE: for my $i (reverse 0..$#$AFE) {
            if (not ref $AFE->[$i]) { # marker
              last;
            } elsif ($node->{local_name} eq $AFE->[$i]->{local_name}
                     #and $node->{ns} == $AFE->[$i]->{ns}
            ) {
              ## Note that elements in $AFE are always HTML elements.
              for (keys %{$node->{token}->{attrs} or {}}) {
                my $attr = $AFE->[$i]->{token}->{attrs}->{$_};
                next AFE unless defined $attr;
                #next AFE unless $attr->{ns} == $node->{token}->{attrs}->{$_}->{ns};
                # IndexedString
                next AFE unless (join '', map { $_->[0] } @{$attr->{value}}) eq
                                (join '', map { $_->[0] } @{$node->{token}->{attrs}->{$_}->{value}});
              }
              next AFE unless (keys %{$node->{token}->{attrs} or {}}) == (keys %{$AFE->[$i]->{token}->{attrs} or {}});
  
              $found++;
              if ($found == 3) {
                splice @$AFE, $i, 1, ();
                last AFE;
              }
            }
          } # AFE
  
          push @$AFE, $node;
        
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
          },
        ,
          ## [218] in table;START:address article aside details dialog dir figcaption figure footer header hgroup main nav section summary,blockquote center div dl menu ol ul,fieldset,p
          sub {
            my $token = $_;
  push @$Errors, {type => 'in table',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} & (P_ELS)) {
              $result = 1;
              last;
            } elsif ($_->{et} & (APP_MAR_M_ANN_ELS | BUT_ELS | CAP_ELS | HTM_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
            }
          }
           $result;
        }
      ) {
              pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | OPT_OPT_ELS | RB_RP_RT_ELS | RTC_ELS);
  
            if (not ($OE->[-1]->{et} & (P_ELS))) {
              push @$Errors, {type => 'not closed before ancestor end tag',
                                              level => 'm',
                                              text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} & (P_ELS));
            push @popped, pop @$OE;
            push @$OP, ['popped', \@popped];
          }
            }
          
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => $token->{tag_name},
                   attr_list => $token->{attr_list},
                   et => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}, aet => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'} };
        
  
        if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
          FOSTER: {
            for my $i (reverse 1..$#$OE) {
              if ($OE->[$i]->{et} & (TAB_ELS)) { # table
                push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
                last FOSTER;
              } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
                push @$OP, ['insert', $node => $OE->[$i]->{id}];
                last FOSTER;
              }
            }
            push @$OP, ['insert', $node => $OE->[0]->{id}];
          } # FOSTER
        } else {
          push @$OP, ['insert', $node => $OE->[-1]->{id}];
        }
      
  
              if ($node->{et} & (BUT_ELS | FIE_INP_SEL_ELS | IMG_ELS | OBJ_ELS | OUT_ELS | TEX_ELS)) {
                
            if (defined $FORM_ELEMENT) {
              FORM: {
                last FORM if defined $token->{attrs}->{form} and
                             ($node->{et} & ()); # reassociateable
                for my $oe (@$OE) {
                  if ($oe->{et} & (TEM_ELS)) { # template
                    last FORM;
                  }
                }
                #last FORM unless $FORM_ELEMENT and $OE->[-1] (intended parent) same home subtree - should be checked later
                $node->{form} = $FORM_ELEMENT->{id};
              } # FORM
            }
          
              }
            
  push @$OE, $node;
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
          },
        ,
          ## [219] in table;START:applet marquee,object
          sub {
            my $token = $_;
  push @$Errors, {type => 'in table',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => $token->{tag_name},
                   attr_list => $token->{attr_list},
                   et => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}, aet => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'} };
        
  
        if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
          FOSTER: {
            for my $i (reverse 1..$#$OE) {
              if ($OE->[$i]->{et} & (TAB_ELS)) { # table
                push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
                last FOSTER;
              } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
                push @$OP, ['insert', $node => $OE->[$i]->{id}];
                last FOSTER;
              }
            }
            push @$OP, ['insert', $node => $OE->[0]->{id}];
          } # FOSTER
        } else {
          push @$OP, ['insert', $node => $OE->[-1]->{id}];
        }
      
  
              if ($node->{et} & (BUT_ELS | FIE_INP_SEL_ELS | IMG_ELS | OBJ_ELS | OUT_ELS | TEX_ELS)) {
                
            if (defined $FORM_ELEMENT) {
              FORM: {
                last FORM if defined $token->{attrs}->{form} and
                             ($node->{et} & ()); # reassociateable
                for my $oe (@$OE) {
                  if ($oe->{et} & (TEM_ELS)) { # template
                    last FORM;
                  }
                }
                #last FORM unless $FORM_ELEMENT and $OE->[-1] (intended parent) same home subtree - should be checked later
                $node->{form} = $FORM_ELEMENT->{id};
              } # FORM
            }
          
              }
            
  push @$OE, $node;
  push @$AFE, '#marker';
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  
          $FRAMESET_OK = 0;
        
          },
        ,
          ## [220] in table;START:area wbr,br,embed,img,keygen
          sub {
            my $token = $_;
  push @$Errors, {type => 'in table',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => $token->{tag_name},
                   attr_list => $token->{attr_list},
                   et => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}, aet => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'} };
        
  
        if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
          FOSTER: {
            for my $i (reverse 1..$#$OE) {
              if ($OE->[$i]->{et} & (TAB_ELS)) { # table
                push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
                last FOSTER;
              } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
                push @$OP, ['insert', $node => $OE->[$i]->{id}];
                last FOSTER;
              }
            }
            push @$OP, ['insert', $node => $OE->[0]->{id}];
          } # FOSTER
        } else {
          push @$OP, ['insert', $node => $OE->[-1]->{id}];
        }
      
  
              if ($node->{et} & (BUT_ELS | FIE_INP_SEL_ELS | IMG_ELS | OBJ_ELS | OUT_ELS | TEX_ELS)) {
                
            if (defined $FORM_ELEMENT) {
              FORM: {
                last FORM if defined $token->{attrs}->{form} and
                             ($node->{et} & ()); # reassociateable
                for my $oe (@$OE) {
                  if ($oe->{et} & (TEM_ELS)) { # template
                    last FORM;
                  }
                }
                #last FORM unless $FORM_ELEMENT and $OE->[-1] (intended parent) same home subtree - should be checked later
                $node->{form} = $FORM_ELEMENT->{id};
              } # FORM
            }
          
              }
            
  
            if (delete $token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc', level => 'w',
                              text => $token->{tag_name},
                              di => $token->{di}, index => $token->{index}};
            }
          
  
          $FRAMESET_OK = 0;
        
          },
        ,
          ## [221] in table;START:b big code em i s small strike strong tt u,font
          sub {
            my $token = $_;
  push @$Errors, {type => 'in table',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => $token->{tag_name},
                   attr_list => $token->{attr_list},
                   et => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}, aet => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'} };
        
  
        if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
          FOSTER: {
            for my $i (reverse 1..$#$OE) {
              if ($OE->[$i]->{et} & (TAB_ELS)) { # table
                push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
                last FOSTER;
              } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
                push @$OP, ['insert', $node => $OE->[$i]->{id}];
                last FOSTER;
              }
            }
            push @$OP, ['insert', $node => $OE->[0]->{id}];
          } # FOSTER
        } else {
          push @$OP, ['insert', $node => $OE->[-1]->{id}];
        }
      
  
  push @$OE, $node;
  
          ## Noah's Ark
          my $found = 0;
          AFE: for my $i (reverse 0..$#$AFE) {
            if (not ref $AFE->[$i]) { # marker
              last;
            } elsif ($node->{local_name} eq $AFE->[$i]->{local_name}
                     #and $node->{ns} == $AFE->[$i]->{ns}
            ) {
              ## Note that elements in $AFE are always HTML elements.
              for (keys %{$node->{token}->{attrs} or {}}) {
                my $attr = $AFE->[$i]->{token}->{attrs}->{$_};
                next AFE unless defined $attr;
                #next AFE unless $attr->{ns} == $node->{token}->{attrs}->{$_}->{ns};
                # IndexedString
                next AFE unless (join '', map { $_->[0] } @{$attr->{value}}) eq
                                (join '', map { $_->[0] } @{$node->{token}->{attrs}->{$_}->{value}});
              }
              next AFE unless (keys %{$node->{token}->{attrs} or {}}) == (keys %{$AFE->[$i]->{token}->{attrs} or {}});
  
              $found++;
              if ($found == 3) {
                splice @$AFE, $i, 1, ();
                last AFE;
              }
            }
          } # AFE
  
          push @$AFE, $node;
        
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
          },
        ,
          ## [222] in table;START:base,basefont bgsound link
          sub {
            my $token = $_;
  push @$Errors, {type => 'in table',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => $token->{tag_name},
                   attr_list => $token->{attr_list},
                   et => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}, aet => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'} };
        
  
        if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
          FOSTER: {
            for my $i (reverse 1..$#$OE) {
              if ($OE->[$i]->{et} & (TAB_ELS)) { # table
                push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
                last FOSTER;
              } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
                push @$OP, ['insert', $node => $OE->[$i]->{id}];
                last FOSTER;
              }
            }
            push @$OP, ['insert', $node => $OE->[0]->{id}];
          } # FOSTER
        } else {
          push @$OP, ['insert', $node => $OE->[-1]->{id}];
        }
      
  
  
            if (delete $token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc', level => 'w',
                              text => $token->{tag_name},
                              di => $token->{di}, index => $token->{index}};
            }
          
          },
        ,
          ## [223] in table;START:body
          sub {
            my $token = $_;
  push @$Errors, {type => 'in table',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  push @$Errors, {type => 'duplicate body/html tag',
                                              level => 'm',
                                              value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
  
            if ((@$OE >= 2 and not ($OE->[1]->{et} & (BOD_ELS))) or 
  ($OE->[-1]->{et} & (HTM_ELS)) or 
  (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} & (TEM_ELS)) {
              $result = 1;
              last;
            
            }
          }
           $result;
        }
      )) {
              return;
            } else {
              
          $FRAMESET_OK = 0;
        
  
          push @$OP, ['set-if-missing', $token->{attr_list} => $OE->[1]->{id}]
              if @{$token->{attr_list} or []};
        
            }
          
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
          },
        ,
          ## [224] in table;START:button
          sub {
            my $token = $_;
  push @$Errors, {type => 'in table',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} & (BUT_ELS)) {
              $result = 1;
              last;
            } elsif ($_->{et} & (APP_MAR_M_ANN_ELS | CAP_ELS | HTM_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
            }
          }
           $result;
        }
      ) {
              push @$Errors, {type => 'parser:element not nestable',
                                              level => 'm',
                                              value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
  pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | OPT_OPT_ELS | P_ELS | RB_RP_RT_ELS | RTC_ELS);
  {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} & (BUT_ELS));
            push @popped, pop @$OE;
            push @$OP, ['popped', \@popped];
          }
            }
          
  &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'button',
                   attr_list => $token->{attr_list},
                   et => (BUTTON_EL), aet => (BUTTON_EL) };
        
  
        if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
          FOSTER: {
            for my $i (reverse 1..$#$OE) {
              if ($OE->[$i]->{et} & (TAB_ELS)) { # table
                push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
                last FOSTER;
              } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
                push @$OP, ['insert', $node => $OE->[$i]->{id}];
                last FOSTER;
              }
            }
            push @$OP, ['insert', $node => $OE->[0]->{id}];
          } # FOSTER
        } else {
          push @$OP, ['insert', $node => $OE->[-1]->{id}];
        }
      
  
            if (defined $FORM_ELEMENT) {
              FORM: {
                last FORM if defined $token->{attrs}->{form} and
                             ($node->{et} & ()); # reassociateable
                for my $oe (@$OE) {
                  if ($oe->{et} & (TEM_ELS)) { # template
                    last FORM;
                  }
                }
                #last FORM unless $FORM_ELEMENT and $OE->[-1] (intended parent) same home subtree - should be checked later
                $node->{form} = $FORM_ELEMENT->{id};
              } # FORM
            }
          
  push @$OE, $node;
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  
          $FRAMESET_OK = 0;
        
          },
        ,
          ## [225] in table;START:caption
          sub {
            my $token = $_;
  {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} & (HTM_ELS | TAB_ELS | TEM_ELS));
            push @$OP, ['popped', \@popped];
          }
  push @$AFE, '#marker';
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'caption',
                   attr_list => $token->{attr_list},
                   et => (CAPTION_EL), aet => (CAPTION_EL) };
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  
  push @$OE, $node;
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  
            $IM = IN_CAPTION_IM;
            #warn "Insertion mode changed to |in caption| ($IM)";
          
          },
        ,
          ## [226] in table;START:col
          sub {
            my $token = $_;
  {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} & (HTM_ELS | TAB_ELS | TEM_ELS));
            push @$OP, ['popped', \@popped];
          }
  
          my $node_colgroup = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'colgroup',
                   attr_list => [],
                   et => (COLGROUP_EL), aet => (COLGROUP_EL) };
        
  
        push @$OP, ['insert', $node_colgroup => $OE->[-1]->{id}];
      
  
  push @$OE, $node_colgroup;
  
            $IM = IN_COLUMN_GROUP_IM;
            #warn "Insertion mode changed to |in column group| ($IM)";
          
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
          },
        ,
          ## [227] in table;START:colgroup
          sub {
            my $token = $_;
  {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} & (HTM_ELS | TAB_ELS | TEM_ELS));
            push @$OP, ['popped', \@popped];
          }
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'colgroup',
                   attr_list => $token->{attr_list},
                   et => (COLGROUP_EL), aet => (COLGROUP_EL) };
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  
  push @$OE, $node;
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  
            $IM = IN_COLUMN_GROUP_IM;
            #warn "Insertion mode changed to |in column group| ($IM)";
          
          },
        ,
          ## [228] in table;START:dd dt
          sub {
            my $token = $_;
  push @$Errors, {type => 'in table',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  
          $FRAMESET_OK = 0;
        
  
            for my $i (reverse 0..$#$OE) {
              my $_node = $OE->[$i];
              
            if ($_node->{et} & (DD_ELS)) {
              pop @$OE while $OE->[-1]->{et} & (DT_ELS | LI_ELS | OPT_OPT_ELS | P_ELS | RB_RP_RT_ELS | RTC_ELS);
  
            if (not ($OE->[-1]->{et} & (DD_ELS))) {
              push @$Errors, {type => 'element not closed before implied ancestor end tag',
                                              level => 'm',
                                              text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} & (DD_ELS));
            push @popped, pop @$OE;
            push @$OP, ['popped', \@popped];
          }
  last;
            } else {
              
            if ($_node->{et} & (DT_ELS)) {
              pop @$OE while $OE->[-1]->{et} & (DD_ELS | LI_ELS | OPT_OPT_ELS | P_ELS | RB_RP_RT_ELS | RTC_ELS);
  
            if (not ($OE->[-1]->{et} & (DT_ELS))) {
              push @$Errors, {type => 'element not closed before implied ancestor end tag',
                                              level => 'm',
                                              text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} & (DT_ELS));
            push @popped, pop @$OE;
            push @$OP, ['popped', \@popped];
          }
  last;
            } else {
              
            if ($_node->{et} & (APP_MAR_M_ANN_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS | BOD_ELS | BUT_ELS | CAP_ELS | COL_ELS | DD_ELS | DT_ELS | FIE_INP_SEL_ELS | HHHHHH_ELS | HTM_ELS | IMG_ELS | LI_ELS | OBJ_ELS | OL_UL_ELS | STY_ELS | TAB_ELS | TBO_TFO_THE_ELS | TD_TH_ELS | TEM_ELS | TEX_ELS | TR_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) {
              last;
            } else {
              
            }
          
            }
          
            }
          
            }
          
  
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} & (P_ELS)) {
              $result = 1;
              last;
            } elsif ($_->{et} & (APP_MAR_M_ANN_ELS | BUT_ELS | CAP_ELS | HTM_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
            }
          }
           $result;
        }
      ) {
              pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | OPT_OPT_ELS | RB_RP_RT_ELS | RTC_ELS);
  
            if (not ($OE->[-1]->{et} & (P_ELS))) {
              push @$Errors, {type => 'not closed before ancestor end tag',
                                              level => 'm',
                                              text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} & (P_ELS));
            push @popped, pop @$OE;
            push @$OP, ['popped', \@popped];
          }
            }
          
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => $token->{tag_name},
                   attr_list => $token->{attr_list},
                   et => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}, aet => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'} };
        
  
        if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
          FOSTER: {
            for my $i (reverse 1..$#$OE) {
              if ($OE->[$i]->{et} & (TAB_ELS)) { # table
                push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
                last FOSTER;
              } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
                push @$OP, ['insert', $node => $OE->[$i]->{id}];
                last FOSTER;
              }
            }
            push @$OP, ['insert', $node => $OE->[0]->{id}];
          } # FOSTER
        } else {
          push @$OP, ['insert', $node => $OE->[-1]->{id}];
        }
      
  
  push @$OE, $node;
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
          },
        ,
          ## [229] in table;START:form
          sub {
            my $token = $_;
  push @$Errors, {type => 'in table',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  
            if ((
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} & (TEM_ELS)) {
              $result = 1;
              last;
            
            }
          }
           $result;
        }
      ) or 
  (defined $FORM_ELEMENT)) {
              return;
            } else {
              
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'form',
                   attr_list => $token->{attr_list},
                   et => (FORM_EL), aet => (FORM_EL) };
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  
  push @$OE, $node;
  $FORM_ELEMENT = $node;
  push @$OP, ['popped', [pop @$OE]];
            }
          
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
          },
        ,
          ## [230] in table;START:frame,head
          sub {
            my $token = $_;
  push @$Errors, {type => 'in table',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  push @$Errors, {type => 'in body',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  return;
          },
        ,
          ## [231] in table;START:frameset
          sub {
            my $token = $_;
  push @$Errors, {type => 'in table',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  push @$Errors, {type => 'in body',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  
            if (($OE->[-1]->{et} & (HTM_ELS)) or 
  (@$OE >= 2 and not ($OE->[1]->{et} & (BOD_ELS)))) {
              return;
            }
          
  
            if (not $FRAMESET_OK) {
              return;
            } else {
              
          push @$OP, ['remove', $OE->[1]->{id}];
        
  {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1] eq $OE->[1]);
            push @popped, pop @$OE;
            push @$OP, ['popped', \@popped];
          }
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'frameset',
                   attr_list => $token->{attr_list},
                   et => (FRAMESET_EL), aet => (FRAMESET_EL) };
        
  
        if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
          FOSTER: {
            for my $i (reverse 1..$#$OE) {
              if ($OE->[$i]->{et} & (TAB_ELS)) { # table
                push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
                last FOSTER;
              } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
                push @$OP, ['insert', $node => $OE->[$i]->{id}];
                last FOSTER;
              }
            }
            push @$OP, ['insert', $node => $OE->[0]->{id}];
          } # FOSTER
        } else {
          push @$OP, ['insert', $node => $OE->[-1]->{id}];
        }
      
  
  push @$OE, $node;
  
            $IM = IN_FRAMESET_IM;
            #warn "Insertion mode changed to |in frameset| ($IM)";
          
            }
          
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
          },
        ,
          ## [232] in table;START:h1 h2 h3 h4 h5 h6
          sub {
            my $token = $_;
  push @$Errors, {type => 'in table',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} & (P_ELS)) {
              $result = 1;
              last;
            } elsif ($_->{et} & (APP_MAR_M_ANN_ELS | BUT_ELS | CAP_ELS | HTM_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
            }
          }
           $result;
        }
      ) {
              pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | OPT_OPT_ELS | RB_RP_RT_ELS | RTC_ELS);
  
            if (not ($OE->[-1]->{et} & (P_ELS))) {
              push @$Errors, {type => 'not closed before ancestor end tag',
                                              level => 'm',
                                              text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} & (P_ELS));
            push @popped, pop @$OE;
            push @$OP, ['popped', \@popped];
          }
            }
          
  
            if ($OE->[-1]->{et} & (HHHHHH_ELS)) {
              push @$Errors, {type => 'in hn:hn',
                                              level => 'm',
                                              text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
  push @$OP, ['popped', [pop @$OE]];
            }
          
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => $token->{tag_name},
                   attr_list => $token->{attr_list},
                   et => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}, aet => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'} };
        
  
        if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
          FOSTER: {
            for my $i (reverse 1..$#$OE) {
              if ($OE->[$i]->{et} & (TAB_ELS)) { # table
                push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
                last FOSTER;
              } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
                push @$OP, ['insert', $node => $OE->[$i]->{id}];
                last FOSTER;
              }
            }
            push @$OP, ['insert', $node => $OE->[0]->{id}];
          } # FOSTER
        } else {
          push @$OP, ['insert', $node => $OE->[-1]->{id}];
        }
      
  
  push @$OE, $node;
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
          },
        ,
          ## [233] in table;START:hr
          sub {
            my $token = $_;
  push @$Errors, {type => 'in table',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} & (P_ELS)) {
              $result = 1;
              last;
            } elsif ($_->{et} & (APP_MAR_M_ANN_ELS | BUT_ELS | CAP_ELS | HTM_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
            }
          }
           $result;
        }
      ) {
              pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | OPT_OPT_ELS | RB_RP_RT_ELS | RTC_ELS);
  
            if (not ($OE->[-1]->{et} & (P_ELS))) {
              push @$Errors, {type => 'not closed before ancestor end tag',
                                              level => 'm',
                                              text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} & (P_ELS));
            push @popped, pop @$OE;
            push @$OP, ['popped', \@popped];
          }
            }
          
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'hr',
                   attr_list => $token->{attr_list},
                   et => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS), aet => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS) };
        
  
        if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
          FOSTER: {
            for my $i (reverse 1..$#$OE) {
              if ($OE->[$i]->{et} & (TAB_ELS)) { # table
                push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
                last FOSTER;
              } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
                push @$OP, ['insert', $node => $OE->[$i]->{id}];
                last FOSTER;
              }
            }
            push @$OP, ['insert', $node => $OE->[0]->{id}];
          } # FOSTER
        } else {
          push @$OP, ['insert', $node => $OE->[-1]->{id}];
        }
      
  
  
            if (delete $token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc', level => 'w',
                              text => $token->{tag_name},
                              di => $token->{di}, index => $token->{index}};
            }
          
  
          $FRAMESET_OK = 0;
        
          },
        ,
          ## [234] in table;START:html
          sub {
            my $token = $_;
  push @$Errors, {type => 'in table',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  push @$Errors, {type => 'duplicate body/html tag',
                                              level => 'm',
                                              value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
  
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} & (TEM_ELS)) {
              $result = 1;
              last;
            
            }
          }
           $result;
        }
      ) {
              return;
            } else {
              
          push @$OP, ['set-if-missing', $token->{attr_list} => $OE->[0]->{id}]
              if @{$token->{attr_list} or []};
        
            }
          
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
          },
        ,
          ## [235] in table;START:iframe
          sub {
            my $token = $_;
  push @$Errors, {type => 'in table',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  
          $FRAMESET_OK = 0;
        
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'iframe',
                   attr_list => $token->{attr_list},
                   et => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS), aet => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS) };
        
  
        if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
          FOSTER: {
            for my $i (reverse 1..$#$OE) {
              if ($OE->[$i]->{et} & (TAB_ELS)) { # table
                push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
                last FOSTER;
              } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
                push @$OP, ['insert', $node => $OE->[$i]->{id}];
                last FOSTER;
              }
            }
            push @$OP, ['insert', $node => $OE->[0]->{id}];
          } # FOSTER
        } else {
          push @$OP, ['insert', $node => $OE->[-1]->{id}];
        }
      
  
  push @$OE, $node;
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  $State = RAWTEXT_STATE;
  $ORIGINAL_IM = $IM;
  
            $IM = TEXT_IM;
            #warn "Insertion mode changed to |text| ($IM)";
          
          },
        ,
          ## [236] in table;START:image
          sub {
            my $token = $_;
  push @$Errors, {type => 'in table',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  push @$Errors, {type => 'image',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];
  
          my $node_img = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'img',
                   attr_list => $token->{attr_list},
                   et => (HTML_NS_ELS | IMG_ELS), aet => (HTML_NS_ELS | IMG_ELS) };
        
  
        if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
          FOSTER: {
            for my $i (reverse 1..$#$OE) {
              if ($OE->[$i]->{et} & (TAB_ELS)) { # table
                push @$OP, ['insert-foster', $node_img => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
                last FOSTER;
              } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
                push @$OP, ['insert', $node_img => $OE->[$i]->{id}];
                last FOSTER;
              }
            }
            push @$OP, ['insert', $node_img => $OE->[0]->{id}];
          } # FOSTER
        } else {
          push @$OP, ['insert', $node_img => $OE->[-1]->{id}];
        }
      
  
  
            if (delete $token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc', level => 'w',
                              text => $token->{tag_name},
                              di => $token->{di}, index => $token->{index}};
            }
          
  
          $FRAMESET_OK = 0;
        
          },
        ,
          ## [237] in table;START:input
          sub {
            my $token = $_;
  
            if (
        not (
          defined $token->{attrs}->{type} and
          do {
            my $value = join '', map { $_->[0] } @{$token->{attrs}->{type}->{value}}; # IndexedString
            $value =~ tr/A-Z/a-z/; ## ASCII case-insensitive
            $value eq q@hidden@;
          }
        )
      ) {
              push @$Errors, {type => 'in table',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'input',
                   attr_list => $token->{attr_list},
                   et => (HTML_NS_ELS | FIE_INP_SEL_ELS), aet => (HTML_NS_ELS | FIE_INP_SEL_ELS) };
        
  
        if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
          FOSTER: {
            for my $i (reverse 1..$#$OE) {
              if ($OE->[$i]->{et} & (TAB_ELS)) { # table
                push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
                last FOSTER;
              } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
                push @$OP, ['insert', $node => $OE->[$i]->{id}];
                last FOSTER;
              }
            }
            push @$OP, ['insert', $node => $OE->[0]->{id}];
          } # FOSTER
        } else {
          push @$OP, ['insert', $node => $OE->[-1]->{id}];
        }
      
  
            if (defined $FORM_ELEMENT) {
              FORM: {
                last FORM if defined $token->{attrs}->{form} and
                             ($node->{et} & ()); # reassociateable
                for my $oe (@$OE) {
                  if ($oe->{et} & (TEM_ELS)) { # template
                    last FORM;
                  }
                }
                #last FORM unless $FORM_ELEMENT and $OE->[-1] (intended parent) same home subtree - should be checked later
                $node->{form} = $FORM_ELEMENT->{id};
              } # FORM
            }
          
  
            if (delete $token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc', level => 'w',
                              text => $token->{tag_name},
                              di => $token->{di}, index => $token->{index}};
            }
          
  
            if (
        not (
          defined $token->{attrs}->{type} and
          do {
            my $value = join '', map { $_->[0] } @{$token->{attrs}->{type}->{value}}; # IndexedString
            $value =~ tr/A-Z/a-z/; ## ASCII case-insensitive
            $value eq q@hidden@;
          }
        )
      ) {
              
          $FRAMESET_OK = 0;
        
            }
          
            } else {
              push @$Errors, {type => 'in table',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'input',
                   attr_list => $token->{attr_list},
                   et => (HTML_NS_ELS | FIE_INP_SEL_ELS), aet => (HTML_NS_ELS | FIE_INP_SEL_ELS) };
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  
            if (defined $FORM_ELEMENT) {
              FORM: {
                last FORM if defined $token->{attrs}->{form} and
                             ($node->{et} & ()); # reassociateable
                for my $oe (@$OE) {
                  if ($oe->{et} & (TEM_ELS)) { # template
                    last FORM;
                  }
                }
                #last FORM unless $FORM_ELEMENT and $OE->[-1] (intended parent) same home subtree - should be checked later
                $node->{form} = $FORM_ELEMENT->{id};
              } # FORM
            }
          
  
            if (delete $token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc', level => 'w',
                              text => $token->{tag_name},
                              di => $token->{di}, index => $token->{index}};
            }
          
            }
          
          },
        ,
          ## [238] in table;START:li
          sub {
            my $token = $_;
  push @$Errors, {type => 'in table',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  
          $FRAMESET_OK = 0;
        
  
            for my $i (reverse 0..$#$OE) {
              my $_node = $OE->[$i];
              
            if ($_node->{et} & (LI_ELS)) {
              pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | OPT_OPT_ELS | P_ELS | RB_RP_RT_ELS | RTC_ELS);
  
            if (not ($OE->[-1]->{et} & (LI_ELS))) {
              push @$Errors, {type => 'element not closed before implied ancestor end tag',
                                              level => 'm',
                                              text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} & (LI_ELS));
            push @popped, pop @$OE;
            push @$OP, ['popped', \@popped];
          }
  last;
            } else {
              
            if ($_node->{et} & (APP_MAR_M_ANN_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS | BOD_ELS | BUT_ELS | CAP_ELS | COL_ELS | DD_ELS | DT_ELS | FIE_INP_SEL_ELS | HHHHHH_ELS | HTM_ELS | IMG_ELS | LI_ELS | OBJ_ELS | OL_UL_ELS | STY_ELS | TAB_ELS | TBO_TFO_THE_ELS | TD_TH_ELS | TEM_ELS | TEX_ELS | TR_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) {
              last;
            } else {
              
            }
          
            }
          
            }
          
  
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} & (P_ELS)) {
              $result = 1;
              last;
            } elsif ($_->{et} & (APP_MAR_M_ANN_ELS | BUT_ELS | CAP_ELS | HTM_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
            }
          }
           $result;
        }
      ) {
              pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | OPT_OPT_ELS | RB_RP_RT_ELS | RTC_ELS);
  
            if (not ($OE->[-1]->{et} & (P_ELS))) {
              push @$Errors, {type => 'not closed before ancestor end tag',
                                              level => 'm',
                                              text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} & (P_ELS));
            push @popped, pop @$OE;
            push @$OP, ['popped', \@popped];
          }
            }
          
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'li',
                   attr_list => $token->{attr_list},
                   et => (LI_EL), aet => (LI_EL) };
        
  
        if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
          FOSTER: {
            for my $i (reverse 1..$#$OE) {
              if ($OE->[$i]->{et} & (TAB_ELS)) { # table
                push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
                last FOSTER;
              } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
                push @$OP, ['insert', $node => $OE->[$i]->{id}];
                last FOSTER;
              }
            }
            push @$OP, ['insert', $node => $OE->[0]->{id}];
          } # FOSTER
        } else {
          push @$OP, ['insert', $node => $OE->[-1]->{id}];
        }
      
  
  push @$OE, $node;
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
          },
        ,
          ## [239] in table;START:listing pre
          sub {
            my $token = $_;
  push @$Errors, {type => 'in table',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} & (P_ELS)) {
              $result = 1;
              last;
            } elsif ($_->{et} & (APP_MAR_M_ANN_ELS | BUT_ELS | CAP_ELS | HTM_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
            }
          }
           $result;
        }
      ) {
              pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | OPT_OPT_ELS | RB_RP_RT_ELS | RTC_ELS);
  
            if (not ($OE->[-1]->{et} & (P_ELS))) {
              push @$Errors, {type => 'not closed before ancestor end tag',
                                              level => 'm',
                                              text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} & (P_ELS));
            push @popped, pop @$OE;
            push @$OP, ['popped', \@popped];
          }
            }
          
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => $token->{tag_name},
                   attr_list => $token->{attr_list},
                   et => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}, aet => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'} };
        
  
        if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
          FOSTER: {
            for my $i (reverse 1..$#$OE) {
              if ($OE->[$i]->{et} & (TAB_ELS)) { # table
                push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
                last FOSTER;
              } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
                push @$OP, ['insert', $node => $OE->[$i]->{id}];
                last FOSTER;
              }
            }
            push @$OP, ['insert', $node => $OE->[0]->{id}];
          } # FOSTER
        } else {
          push @$OP, ['insert', $node => $OE->[-1]->{id}];
        }
      
  
  push @$OE, $node;
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  
          $FRAMESET_OK = 0;
        
  
          $ORIGINAL_IM = $IM;
          $IM = BEFORE_IGNORED_NEWLINE_IM;
        
          },
        ,
          ## [240] in table;START:math
          sub {
            my $token = $_;
  push @$Errors, {type => 'in table',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];
  my $ns = MATHMLNS;
  
          my $node = {id => $NEXT_ID++,
                      token => $token,
                      di => $token->{di}, index => $token->{index},
                      ns => $ns,
                      local_name => $token->{tag_name},
                      attr_list => $token->{attr_list},
                      et => $Element2Type->[$ns]->{$token->{tag_name}} || $Element2Type->[$ns]->{'*'} || 0,
                      aet => $Element2Type->[$ns]->{$token->{tag_name}} || $Element2Type->[$ns]->{'*'} || 0};
        
  
          if (defined $token->{attrs}->{xmlns}) {
            # IndexedString
            my $xmlns = join '', map { $_->[0] } @{$token->{attrs}->{xmlns}->{value}};
            if ($ns == SVGNS and $xmlns eq 'http://www.w3.org/2000/svg') {
              #
            } elsif ($ns == MATHMLNS and $xmlns eq 'http://www.w3.org/1998/Math/MathML') {
              #
            } else {
              push @$Errors, {type => 'foreign:bad xmlns value',
                              level => 'm',
                              value => $xmlns,
                              di => $token->{attrs}->{xmlns}->{di},
                              index => $token->{attrs}->{xmlns}->{index}};
            }
          }
          if (defined $token->{attrs}->{'xmlns:xlink'}) {
            # IndexedString
            my $xmlns = join '', map { $_->[0] } @{$token->{attrs}->{'xmlns:xlink'}->{value}};
            unless ($xmlns eq 'http://www.w3.org/1999/xlink') {
              push @$Errors, {type => 'foreign:bad xmlns value',
                              level => 'm',
                              value => $xmlns,
                              di => $token->{attrs}->{'xmlns:xlink'}->{di},
                              index => $token->{attrs}->{'xmlns:xlink'}->{index}};
            }
          }
  
          ## Adjust foreign attributes
          ## Adjust SVG attributes
          ## Adjust MathML attributes
          my $map = $ForeignAttrMap->[$ns];
          for my $attr (@{$token->{attr_list} or []}) {
            $attr->{name_args} = $map->{$attr->{name}} || [undef, [undef, $attr->{name}]];
          }
        
  
        if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
          FOSTER: {
            for my $i (reverse 1..$#$OE) {
              if ($OE->[$i]->{et} & (TAB_ELS)) { # table
                push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
                last FOSTER;
              } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
                push @$OP, ['insert', $node => $OE->[$i]->{id}];
                last FOSTER;
              }
            }
            push @$OP, ['insert', $node => $OE->[0]->{id}];
          } # FOSTER
        } else {
          push @$OP, ['insert', $node => $OE->[-1]->{id}];
        }
      
  push @$OE, $node;
  
            if ($token->{self_closing_flag}) {
              push @$OP, ['popped', [pop @$OE]];
  delete $token->{self_closing_flag};
            }
          
          },
        ,
          ## [241] in table;START:meta
          sub {
            my $token = $_;
  push @$Errors, {type => 'in table',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'meta',
                   attr_list => $token->{attr_list},
                   et => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS), aet => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS) };
        
  
        if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
          FOSTER: {
            for my $i (reverse 1..$#$OE) {
              if ($OE->[$i]->{et} & (TAB_ELS)) { # table
                push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
                last FOSTER;
              } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
                push @$OP, ['insert', $node => $OE->[$i]->{id}];
                last FOSTER;
              }
            }
            push @$OP, ['insert', $node => $OE->[0]->{id}];
          } # FOSTER
        } else {
          push @$OP, ['insert', $node => $OE->[-1]->{id}];
        }
      
  
  
            if (delete $token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc', level => 'w',
                              text => $token->{tag_name},
                              di => $token->{di}, index => $token->{index}};
            }
          
  
          if (defined $token->{attrs}->{charset}) {
            push @$OP, ['change-the-encoding',
                        (join '', map { $_->[0] } @{$token->{attrs}->{charset}->{value}}), # IndexedString
                        $token->{attrs}->{charset}];
          } elsif (defined $token->{attrs}->{'http-equiv'} and
                   defined $token->{attrs}->{content}) {
            # IndexedString
            if ((join '', map { $_->[0] } @{$token->{attrs}->{'http-equiv'}->{value}})
                    =~ /\A[Cc][Oo][Nn][Tt][Ee][Nn][Tt]-[Tt][Yy][Pp][Ee]\z/ and
                (join '', map { $_->[0] } @{$token->{attrs}->{content}->{value}})
                    =~ /[Cc][Hh][Aa][Rr][Ss][Ee][Tt]
                          [\x09\x0A\x0C\x0D\x20]*=
                          [\x09\x0A\x0C\x0D\x20]*(?>"([^"]*)"|'([^']*)'|
                          ([^"'\x09\x0A\x0C\x0D\x20]
                           [^\x09\x0A\x0C\x0D\x20\x3B]*))/x) {
              push @$OP, ['change-the-encoding',
                          defined $1 ? $1 : defined $2 ? $2 : $3,
                          $token->{attrs}->{content}];
            }
          }
        
          },
        ,
          ## [242] in table;START:nobr
          sub {
            my $token = $_;
  push @$Errors, {type => 'in table',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];
  
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} == NOBR_EL) {
              $result = 1;
              last;
            } elsif ($_->{et} & (APP_MAR_M_ANN_ELS | CAP_ELS | HTM_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
            }
          }
           $result;
        }
      ) {
              push @$Errors, {type => 'parser:element not nestable',
                                              level => 'm',
                                              value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
  aaa_foster ($token, $token->{tag_name});
  &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];
            }
          
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'nobr',
                   attr_list => $token->{attr_list},
                   et => (NOBR_EL), aet => (NOBR_EL) };
        
  
        if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
          FOSTER: {
            for my $i (reverse 1..$#$OE) {
              if ($OE->[$i]->{et} & (TAB_ELS)) { # table
                push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
                last FOSTER;
              } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
                push @$OP, ['insert', $node => $OE->[$i]->{id}];
                last FOSTER;
              }
            }
            push @$OP, ['insert', $node => $OE->[0]->{id}];
          } # FOSTER
        } else {
          push @$OP, ['insert', $node => $OE->[-1]->{id}];
        }
      
  
  push @$OE, $node;
  
          ## Noah's Ark
          my $found = 0;
          AFE: for my $i (reverse 0..$#$AFE) {
            if (not ref $AFE->[$i]) { # marker
              last;
            } elsif ($node->{local_name} eq $AFE->[$i]->{local_name}
                     #and $node->{ns} == $AFE->[$i]->{ns}
            ) {
              ## Note that elements in $AFE are always HTML elements.
              for (keys %{$node->{token}->{attrs} or {}}) {
                my $attr = $AFE->[$i]->{token}->{attrs}->{$_};
                next AFE unless defined $attr;
                #next AFE unless $attr->{ns} == $node->{token}->{attrs}->{$_}->{ns};
                # IndexedString
                next AFE unless (join '', map { $_->[0] } @{$attr->{value}}) eq
                                (join '', map { $_->[0] } @{$node->{token}->{attrs}->{$_}->{value}});
              }
              next AFE unless (keys %{$node->{token}->{attrs} or {}}) == (keys %{$AFE->[$i]->{token}->{attrs} or {}});
  
              $found++;
              if ($found == 3) {
                splice @$AFE, $i, 1, ();
                last AFE;
              }
            }
          } # AFE
  
          push @$AFE, $node;
        
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
          },
        ,
          ## [243] in table;START:noembed
          sub {
            my $token = $_;
  push @$Errors, {type => 'in table',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'noembed',
                   attr_list => $token->{attr_list},
                   et => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS), aet => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS) };
        
  
        if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
          FOSTER: {
            for my $i (reverse 1..$#$OE) {
              if ($OE->[$i]->{et} & (TAB_ELS)) { # table
                push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
                last FOSTER;
              } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
                push @$OP, ['insert', $node => $OE->[$i]->{id}];
                last FOSTER;
              }
            }
            push @$OP, ['insert', $node => $OE->[0]->{id}];
          } # FOSTER
        } else {
          push @$OP, ['insert', $node => $OE->[-1]->{id}];
        }
      
  
  push @$OE, $node;
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  $State = RAWTEXT_STATE;
  $ORIGINAL_IM = $IM;
  
            $IM = TEXT_IM;
            #warn "Insertion mode changed to |text| ($IM)";
          
          },
        ,
          ## [244] in table;START:noframes
          sub {
            my $token = $_;
  push @$Errors, {type => 'in table',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'noframes',
                   attr_list => $token->{attr_list},
                   et => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS), aet => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS) };
        
  
        if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
          FOSTER: {
            for my $i (reverse 1..$#$OE) {
              if ($OE->[$i]->{et} & (TAB_ELS)) { # table
                push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
                last FOSTER;
              } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
                push @$OP, ['insert', $node => $OE->[$i]->{id}];
                last FOSTER;
              }
            }
            push @$OP, ['insert', $node => $OE->[0]->{id}];
          } # FOSTER
        } else {
          push @$OP, ['insert', $node => $OE->[-1]->{id}];
        }
      
  
  push @$OE, $node;
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  $State = RAWTEXT_STATE;
  $ORIGINAL_IM = $IM;
  
            $IM = TEXT_IM;
            #warn "Insertion mode changed to |text| ($IM)";
          
          },
        ,
          ## [245] in table;START:noscript
          sub {
            my $token = $_;
  push @$Errors, {type => 'in table',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  
            if ($Scripting) {
              
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'noscript',
                   attr_list => $token->{attr_list},
                   et => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS), aet => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS) };
        
  
        if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
          FOSTER: {
            for my $i (reverse 1..$#$OE) {
              if ($OE->[$i]->{et} & (TAB_ELS)) { # table
                push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
                last FOSTER;
              } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
                push @$OP, ['insert', $node => $OE->[$i]->{id}];
                last FOSTER;
              }
            }
            push @$OP, ['insert', $node => $OE->[0]->{id}];
          } # FOSTER
        } else {
          push @$OP, ['insert', $node => $OE->[-1]->{id}];
        }
      
  
  push @$OE, $node;
  $State = RAWTEXT_STATE;
  $ORIGINAL_IM = $IM;
  
            $IM = TEXT_IM;
            #warn "Insertion mode changed to |text| ($IM)";
          
            } else {
              &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'noscript',
                   attr_list => $token->{attr_list},
                   et => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS), aet => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS) };
        
  
        if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
          FOSTER: {
            for my $i (reverse 1..$#$OE) {
              if ($OE->[$i]->{et} & (TAB_ELS)) { # table
                push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
                last FOSTER;
              } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
                push @$OP, ['insert', $node => $OE->[$i]->{id}];
                last FOSTER;
              }
            }
            push @$OP, ['insert', $node => $OE->[0]->{id}];
          } # FOSTER
        } else {
          push @$OP, ['insert', $node => $OE->[-1]->{id}];
        }
      
  
  push @$OE, $node;
            }
          
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
          },
        ,
          ## [246] in table;START:optgroup,option
          sub {
            my $token = $_;
  push @$Errors, {type => 'in table',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  
            if ($OE->[-1]->{et} == OPTION_EL) {
              push @$OP, ['popped', [pop @$OE]];
            }
          
  &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => $token->{tag_name},
                   attr_list => $token->{attr_list},
                   et => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}, aet => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'} };
        
  
        if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
          FOSTER: {
            for my $i (reverse 1..$#$OE) {
              if ($OE->[$i]->{et} & (TAB_ELS)) { # table
                push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
                last FOSTER;
              } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
                push @$OP, ['insert', $node => $OE->[$i]->{id}];
                last FOSTER;
              }
            }
            push @$OP, ['insert', $node => $OE->[0]->{id}];
          } # FOSTER
        } else {
          push @$OP, ['insert', $node => $OE->[-1]->{id}];
        }
      
  
  push @$OE, $node;
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
          },
        ,
          ## [247] in table;START:param source track
          sub {
            my $token = $_;
  push @$Errors, {type => 'in table',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => $token->{tag_name},
                   attr_list => $token->{attr_list},
                   et => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}, aet => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'} };
        
  
        if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
          FOSTER: {
            for my $i (reverse 1..$#$OE) {
              if ($OE->[$i]->{et} & (TAB_ELS)) { # table
                push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
                last FOSTER;
              } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
                push @$OP, ['insert', $node => $OE->[$i]->{id}];
                last FOSTER;
              }
            }
            push @$OP, ['insert', $node => $OE->[0]->{id}];
          } # FOSTER
        } else {
          push @$OP, ['insert', $node => $OE->[-1]->{id}];
        }
      
  
  
            if (delete $token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc', level => 'w',
                              text => $token->{tag_name},
                              di => $token->{di}, index => $token->{index}};
            }
          
          },
        ,
          ## [248] in table;START:plaintext
          sub {
            my $token = $_;
  push @$Errors, {type => 'in table',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} & (P_ELS)) {
              $result = 1;
              last;
            } elsif ($_->{et} & (APP_MAR_M_ANN_ELS | BUT_ELS | CAP_ELS | HTM_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
            }
          }
           $result;
        }
      ) {
              pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | OPT_OPT_ELS | RB_RP_RT_ELS | RTC_ELS);
  
            if (not ($OE->[-1]->{et} & (P_ELS))) {
              push @$Errors, {type => 'not closed before ancestor end tag',
                                              level => 'm',
                                              text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} & (P_ELS));
            push @popped, pop @$OE;
            push @$OP, ['popped', \@popped];
          }
            }
          
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'plaintext',
                   attr_list => $token->{attr_list},
                   et => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS), aet => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS) };
        
  
        if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
          FOSTER: {
            for my $i (reverse 1..$#$OE) {
              if ($OE->[$i]->{et} & (TAB_ELS)) { # table
                push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
                last FOSTER;
              } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
                push @$OP, ['insert', $node => $OE->[$i]->{id}];
                last FOSTER;
              }
            }
            push @$OP, ['insert', $node => $OE->[0]->{id}];
          } # FOSTER
        } else {
          push @$OP, ['insert', $node => $OE->[-1]->{id}];
        }
      
  
  push @$OE, $node;
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  $State = PLAINTEXT_STATE;
          },
        ,
          ## [249] in table;START:rb rtc
          sub {
            my $token = $_;
  push @$Errors, {type => 'in table',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} & (RUB_ELS)) {
              $result = 1;
              last;
            } elsif ($_->{et} & (APP_MAR_M_ANN_ELS | CAP_ELS | HTM_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
            }
          }
           $result;
        }
      ) {
              pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | OPT_OPT_ELS | P_ELS | RB_RP_RT_ELS | RTC_ELS);
  
            if (not ($OE->[-1]->{et} & (RUB_ELS))) {
              push @$Errors, {type => 'in body',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
            }
          
            }
          
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => $token->{tag_name},
                   attr_list => $token->{attr_list},
                   et => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}, aet => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'} };
        
  
        if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
          FOSTER: {
            for my $i (reverse 1..$#$OE) {
              if ($OE->[$i]->{et} & (TAB_ELS)) { # table
                push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
                last FOSTER;
              } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
                push @$OP, ['insert', $node => $OE->[$i]->{id}];
                last FOSTER;
              }
            }
            push @$OP, ['insert', $node => $OE->[0]->{id}];
          } # FOSTER
        } else {
          push @$OP, ['insert', $node => $OE->[-1]->{id}];
        }
      
  
  push @$OE, $node;
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
          },
        ,
          ## [250] in table;START:rp rt
          sub {
            my $token = $_;
  push @$Errors, {type => 'in table',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} & (RUB_ELS)) {
              $result = 1;
              last;
            } elsif ($_->{et} & (APP_MAR_M_ANN_ELS | CAP_ELS | HTM_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
            }
          }
           $result;
        }
      ) {
              pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | OPT_OPT_ELS | P_ELS | RB_RP_RT_ELS);
  
            if (not ($OE->[-1]->{et} & (RTC_ELS | RUB_ELS))) {
              push @$Errors, {type => 'element not closed before implied ancestor end tag',
                                              level => 'm',
                                              text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
            }
          
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => $token->{tag_name},
                   attr_list => $token->{attr_list},
                   et => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}, aet => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'} };
        
  
        if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
          FOSTER: {
            for my $i (reverse 1..$#$OE) {
              if ($OE->[$i]->{et} & (TAB_ELS)) { # table
                push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
                last FOSTER;
              } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
                push @$OP, ['insert', $node => $OE->[$i]->{id}];
                last FOSTER;
              }
            }
            push @$OP, ['insert', $node => $OE->[0]->{id}];
          } # FOSTER
        } else {
          push @$OP, ['insert', $node => $OE->[-1]->{id}];
        }
      
  
  push @$OE, $node;
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
          },
        ,
          ## [251] in table;START:select
          sub {
            my $token = $_;
  push @$Errors, {type => 'in table',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'select',
                   attr_list => $token->{attr_list},
                   et => (SELECT_EL), aet => (SELECT_EL) };
        
  
        if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
          FOSTER: {
            for my $i (reverse 1..$#$OE) {
              if ($OE->[$i]->{et} & (TAB_ELS)) { # table
                push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
                last FOSTER;
              } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
                push @$OP, ['insert', $node => $OE->[$i]->{id}];
                last FOSTER;
              }
            }
            push @$OP, ['insert', $node => $OE->[0]->{id}];
          } # FOSTER
        } else {
          push @$OP, ['insert', $node => $OE->[-1]->{id}];
        }
      
  
            if (defined $FORM_ELEMENT) {
              FORM: {
                last FORM if defined $token->{attrs}->{form} and
                             ($node->{et} & ()); # reassociateable
                for my $oe (@$OE) {
                  if ($oe->{et} & (TEM_ELS)) { # template
                    last FORM;
                  }
                }
                #last FORM unless $FORM_ELEMENT and $OE->[-1] (intended parent) same home subtree - should be checked later
                $node->{form} = $FORM_ELEMENT->{id};
              } # FORM
            }
          
  push @$OE, $node;
  
          $FRAMESET_OK = 0;
        
  
            if ($IM == IN_TABLE_IM or $IM == IN_CAPTION_IM or $IM == IN_TABLE_BODY_IM or $IM == IN_ROW_IM or $IM == IN_CELL_IM) {
              
            $IM = IN_SELECT_IN_TABLE_IM;
            #warn "Insertion mode changed to |in select in table| ($IM)";
          
            } else {
              
            $IM = IN_SELECT_IM;
            #warn "Insertion mode changed to |in select| ($IM)";
          
            }
          
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
          },
        ,
          ## [252] in table;START:svg
          sub {
            my $token = $_;
  push @$Errors, {type => 'in table',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];
  my $ns = SVGNS;
  
          my $node = {id => $NEXT_ID++,
                      token => $token,
                      di => $token->{di}, index => $token->{index},
                      ns => $ns,
                      local_name => $token->{tag_name},
                      attr_list => $token->{attr_list},
                      et => $Element2Type->[$ns]->{$token->{tag_name}} || $Element2Type->[$ns]->{'*'} || 0,
                      aet => $Element2Type->[$ns]->{$token->{tag_name}} || $Element2Type->[$ns]->{'*'} || 0};
        
  
          if (defined $token->{attrs}->{xmlns}) {
            # IndexedString
            my $xmlns = join '', map { $_->[0] } @{$token->{attrs}->{xmlns}->{value}};
            if ($ns == SVGNS and $xmlns eq 'http://www.w3.org/2000/svg') {
              #
            } elsif ($ns == MATHMLNS and $xmlns eq 'http://www.w3.org/1998/Math/MathML') {
              #
            } else {
              push @$Errors, {type => 'foreign:bad xmlns value',
                              level => 'm',
                              value => $xmlns,
                              di => $token->{attrs}->{xmlns}->{di},
                              index => $token->{attrs}->{xmlns}->{index}};
            }
          }
          if (defined $token->{attrs}->{'xmlns:xlink'}) {
            # IndexedString
            my $xmlns = join '', map { $_->[0] } @{$token->{attrs}->{'xmlns:xlink'}->{value}};
            unless ($xmlns eq 'http://www.w3.org/1999/xlink') {
              push @$Errors, {type => 'foreign:bad xmlns value',
                              level => 'm',
                              value => $xmlns,
                              di => $token->{attrs}->{'xmlns:xlink'}->{di},
                              index => $token->{attrs}->{'xmlns:xlink'}->{index}};
            }
          }
  
          ## Adjust foreign attributes
          ## Adjust SVG attributes
          ## Adjust MathML attributes
          my $map = $ForeignAttrMap->[$ns];
          for my $attr (@{$token->{attr_list} or []}) {
            $attr->{name_args} = $map->{$attr->{name}} || [undef, [undef, $attr->{name}]];
          }
        
  
        if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
          FOSTER: {
            for my $i (reverse 1..$#$OE) {
              if ($OE->[$i]->{et} & (TAB_ELS)) { # table
                push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
                last FOSTER;
              } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
                push @$OP, ['insert', $node => $OE->[$i]->{id}];
                last FOSTER;
              }
            }
            push @$OP, ['insert', $node => $OE->[0]->{id}];
          } # FOSTER
        } else {
          push @$OP, ['insert', $node => $OE->[-1]->{id}];
        }
      
  push @$OE, $node;
  
            if ($token->{self_closing_flag}) {
              push @$OP, ['popped', [pop @$OE]];
  delete $token->{self_closing_flag};
            }
          
          },
        ,
          ## [253] in table;START:table
          sub {
            my $token = $_;
  push @$Errors, {type => 'parser:element not nestable',
                                              level => 'm',
                                              value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
  
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} & (TAB_ELS)) {
              $result = 1;
              last;
            } elsif ($_->{et} & (HTM_ELS | TAB_ELS | TEM_ELS)) { last; 
            }
          }
          not $result;
        }
      ) {
              
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  return;
            } else {
              {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} & (TAB_ELS));
            push @popped, pop @$OE;
            push @$OP, ['popped', \@popped];
          }
  &reset_im;
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
            }
          
          },
        ,
          ## [254] in table;START:tbody tfoot thead
          sub {
            my $token = $_;
  {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} & (HTM_ELS | TAB_ELS | TEM_ELS));
            push @$OP, ['popped', \@popped];
          }
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => $token->{tag_name},
                   attr_list => $token->{attr_list},
                   et => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}, aet => $Element2Type->[HTMLNS]->{$token->{tag_name}} || $Element2Type->[HTMLNS]->{'*'} };
        
  
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
  
  push @$OE, $node;
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  
            $IM = IN_TABLE_BODY_IM;
            #warn "Insertion mode changed to |in table body| ($IM)";
          
          },
        ,
          ## [255] in table;START:td th,tr
          sub {
            my $token = $_;
  {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} & (HTM_ELS | TAB_ELS | TEM_ELS));
            push @$OP, ['popped', \@popped];
          }
  
          my $node_tbody = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'tbody',
                   attr_list => [],
                   et => (TBODY_EL), aet => (TBODY_EL) };
        
  
        push @$OP, ['insert', $node_tbody => $OE->[-1]->{id}];
      
  
  push @$OE, $node_tbody;
  
            $IM = IN_TABLE_BODY_IM;
            #warn "Insertion mode changed to |in table body| ($IM)";
          
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
          },
        ,
          ## [256] in table;START:textarea
          sub {
            my $token = $_;
  push @$Errors, {type => 'in table',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'textarea',
                   attr_list => $token->{attr_list},
                   et => (HTML_NS_ELS | TEX_ELS), aet => (HTML_NS_ELS | TEX_ELS) };
        
  
        if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
          FOSTER: {
            for my $i (reverse 1..$#$OE) {
              if ($OE->[$i]->{et} & (TAB_ELS)) { # table
                push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
                last FOSTER;
              } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
                push @$OP, ['insert', $node => $OE->[$i]->{id}];
                last FOSTER;
              }
            }
            push @$OP, ['insert', $node => $OE->[0]->{id}];
          } # FOSTER
        } else {
          push @$OP, ['insert', $node => $OE->[-1]->{id}];
        }
      
  
            if (defined $FORM_ELEMENT) {
              FORM: {
                last FORM if defined $token->{attrs}->{form} and
                             ($node->{et} & ()); # reassociateable
                for my $oe (@$OE) {
                  if ($oe->{et} & (TEM_ELS)) { # template
                    last FORM;
                  }
                }
                #last FORM unless $FORM_ELEMENT and $OE->[-1] (intended parent) same home subtree - should be checked later
                $node->{form} = $FORM_ELEMENT->{id};
              } # FORM
            }
          
  push @$OE, $node;
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  $State = RCDATA_STATE;
  $ORIGINAL_IM = $IM;
  
          $FRAMESET_OK = 0;
        
  
            $IM = TEXT_IM;
            #warn "Insertion mode changed to |text| ($IM)";
          
  
          $IM = BEFORE_IGNORED_NEWLINE_AND_TEXT_IM;
        
          },
        ,
          ## [257] in table;START:title
          sub {
            my $token = $_;
  push @$Errors, {type => 'in table',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'title',
                   attr_list => $token->{attr_list},
                   et => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS), aet => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS) };
        
  
        if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
          FOSTER: {
            for my $i (reverse 1..$#$OE) {
              if ($OE->[$i]->{et} & (TAB_ELS)) { # table
                push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
                last FOSTER;
              } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
                push @$OP, ['insert', $node => $OE->[$i]->{id}];
                last FOSTER;
              }
            }
            push @$OP, ['insert', $node => $OE->[0]->{id}];
          } # FOSTER
        } else {
          push @$OP, ['insert', $node => $OE->[-1]->{id}];
        }
      
  
  push @$OE, $node;
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  $State = RCDATA_STATE;
  $ORIGINAL_IM = $IM;
  
            $IM = TEXT_IM;
            #warn "Insertion mode changed to |text| ($IM)";
          
          },
        ,
          ## [258] in table;START:xmp
          sub {
            my $token = $_;
  push @$Errors, {type => 'in table',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} & (P_ELS)) {
              $result = 1;
              last;
            } elsif ($_->{et} & (APP_MAR_M_ANN_ELS | BUT_ELS | CAP_ELS | HTM_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) { last; 
            }
          }
           $result;
        }
      ) {
              pop @$OE while $OE->[-1]->{et} & (DD_ELS | DT_ELS | LI_ELS | OPT_OPT_ELS | RB_RP_RT_ELS | RTC_ELS);
  
            if (not ($OE->[-1]->{et} & (P_ELS))) {
              push @$Errors, {type => 'not closed before ancestor end tag',
                                              level => 'm',
                                              text => $OE->[-1]->{local_name},value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} & (P_ELS));
            push @popped, pop @$OE;
            push @$OP, ['popped', \@popped];
          }
            }
          
  &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];
  
          $FRAMESET_OK = 0;
        
  
          my $node = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'xmp',
                   attr_list => $token->{attr_list},
                   et => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS), aet => (HTML_NS_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS) };
        
  
        if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
          FOSTER: {
            for my $i (reverse 1..$#$OE) {
              if ($OE->[$i]->{et} & (TAB_ELS)) { # table
                push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
                last FOSTER;
              } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
                push @$OP, ['insert', $node => $OE->[$i]->{id}];
                last FOSTER;
              }
            }
            push @$OP, ['insert', $node => $OE->[0]->{id}];
          } # FOSTER
        } else {
          push @$OP, ['insert', $node => $OE->[-1]->{id}];
        }
      
  
  push @$OE, $node;
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
  $State = RAWTEXT_STATE;
  $ORIGINAL_IM = $IM;
  
            $IM = TEXT_IM;
            #warn "Insertion mode changed to |text| ($IM)";
          
          },
        ,
          ## [259] in table;TEXT
          sub {
            my $token = $_;
  
            if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) {
              @$TABLE_CHARS = ();
  $ORIGINAL_IM = $IM;
  
            $IM = IN_TABLE_TEXT_IM;
            #warn "Insertion mode changed to |in table text| ($IM)";
          
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
            } else {
              push @$Errors, {type => 'in table:#text',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
  
              if (index ($token->{value}, "\x00") > -1) {
                pos ($token->{value}) = 0;
                while (pos $token->{value} < length $token->{value}) {
                  if ($token->{value} =~ /\G([^\x00\x09\x0A\x0C\x20]+)/gc) {
                    &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];
  
        if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
          FOSTER: {
            for my $i (reverse 1..$#$OE) {
              if ($OE->[$i]->{et} & (TAB_ELS)) { # table
                push @$OP, ['text-foster', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
                last FOSTER;
              } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
                push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}];
                last FOSTER;
              }
            }
            push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[0]->{id}];
          } # FOSTER
        } else {
          push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
        }
      
  
          $FRAMESET_OK = 0;
        
                    $token->{index} += length $1;
                  }
                  if ($token->{value} =~ /\G([\x09\x0A\x0C\x20]+)/gc) {
                    &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];
  
        if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
          FOSTER: {
            for my $i (reverse 1..$#$OE) {
              if ($OE->[$i]->{et} & (TAB_ELS)) { # table
                push @$OP, ['text-foster', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
                last FOSTER;
              } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
                push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[$i]->{id}];
                last FOSTER;
              }
            }
            push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[0]->{id}];
          } # FOSTER
        } else {
          push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
        }
      
                    $token->{index} += length $1;
                  }
                  if ($token->{value} =~ /\G([\x00]+)/gc) {
                    
              my $value = $1;
              while ($value =~ /(.)/gs) {
                push @$Errors, {type => 'parser:NULL',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index} + $-[1]};
              }
              
            
                    $token->{index} += length $1;
                  }
                }
              } else {
                &reconstruct_afe_foster if @$AFE and ref $AFE->[-1];
  
        if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
          FOSTER: {
            for my $i (reverse 1..$#$OE) {
              if ($OE->[$i]->{et} & (TAB_ELS)) { # table
                push @$OP, ['text-foster', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
                last FOSTER;
              } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
                push @$OP, ['text', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[$i]->{id}];
                last FOSTER;
              }
            }
            push @$OP, ['text', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[0]->{id}];
          } # FOSTER
        } else {
          push @$OP, ['text', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
        }
      
                $FRAMESET_OK = 0 if $FRAMESET_OK and $token->{value} =~ /[^\x09\x0A\x0C\x20]/;
              }
            
            }
          
          },
        ,
          ## [260] in template;END-ELSE
          sub {
            my $token = $_;
  push @$Errors, {type => 'stray end tag',
                                              level => 'm',
                                              value => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
  return;
          },
        ,
          ## [261] in template;EOF
          sub {
            my $token = $_;
  
            if (
        do {
          my $result = 0;
          for (reverse @$OE) {
            if ($_->{et} & (TEM_ELS)) {
              $result = 1;
              last;
            
            }
          }
          not $result;
        }
      ) {
              push @$OP, ['stop-parsing'];
            } else {
              push @$Errors, {type => 'in body:#eof',
                                              level => 'm',
                                              text => $OE->[-1]->{local_name},di => $token->{di},
                                  index => $token->{index}};
  {
            my @popped;
            push @popped, pop @$OE while not ($OE->[-1]->{et} & (TEM_ELS));
            push @popped, pop @$OE;
            push @$OP, ['popped', \@popped];
          }
  
          pop @$AFE while ref $AFE->[-1];
          pop @$AFE; # #marker
        
  pop @$TEMPLATE_IMS;
  &reset_im;
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
            }
          
          },
        ,
          ## [262] in template;START-ELSE
          sub {
            my $token = $_;
  pop @$TEMPLATE_IMS;
  
          push @$TEMPLATE_IMS, IN_BODY_IM;
        
  
            $IM = IN_BODY_IM;
            #warn "Insertion mode changed to |in body| ($IM)";
          
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
          },
        ,
          ## [263] in template;START:caption,colgroup,tbody tfoot thead
          sub {
            my $token = $_;
  pop @$TEMPLATE_IMS;
  
          push @$TEMPLATE_IMS, IN_TABLE_IM;
        
  
            $IM = IN_TABLE_IM;
            #warn "Insertion mode changed to |in table| ($IM)";
          
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
          },
        ,
          ## [264] in template;START:col
          sub {
            my $token = $_;
  pop @$TEMPLATE_IMS;
  
          push @$TEMPLATE_IMS, IN_COLUMN_GROUP_IM;
        
  
            $IM = IN_COLUMN_GROUP_IM;
            #warn "Insertion mode changed to |in column group| ($IM)";
          
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
          },
        ,
          ## [265] in template;START:td th
          sub {
            my $token = $_;
  pop @$TEMPLATE_IMS;
  
          push @$TEMPLATE_IMS, IN_ROW_IM;
        
  
            $IM = IN_ROW_IM;
            #warn "Insertion mode changed to |in row| ($IM)";
          
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
          },
        ,
          ## [266] in template;START:tr
          sub {
            my $token = $_;
  pop @$TEMPLATE_IMS;
  
          push @$TEMPLATE_IMS, IN_TABLE_BODY_IM;
        
  
            $IM = IN_TABLE_BODY_IM;
            #warn "Insertion mode changed to |in table body| ($IM)";
          
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
          },
        ,
          ## [267] in template;TEXT
          sub {
            my $token = $_;
  
              if (index ($token->{value}, "\x00") > -1) {
                pos ($token->{value}) = 0;
                while (pos $token->{value} < length $token->{value}) {
                  if ($token->{value} =~ /\G([^\x00\x09\x0A\x0C\x20]+)/gc) {
                    &reconstruct_afe if @$AFE and ref $AFE->[-1];
  
        push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
      
  
          $FRAMESET_OK = 0;
        
                    $token->{index} += length $1;
                  }
                  if ($token->{value} =~ /\G([\x09\x0A\x0C\x20]+)/gc) {
                    &reconstruct_afe if @$AFE and ref $AFE->[-1];
  
        push @$OP, ['text', [[$1, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
      
                    $token->{index} += length $1;
                  }
                  if ($token->{value} =~ /\G([\x00]+)/gc) {
                    
              my $value = $1;
              while ($value =~ /(.)/gs) {
                push @$Errors, {type => 'parser:NULL',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index} + $-[1]};
              }
              
            
                    $token->{index} += length $1;
                  }
                }
              } else {
                &reconstruct_afe if @$AFE and ref $AFE->[-1];
  
        push @$OP, ['text', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
      
                $FRAMESET_OK = 0 if $FRAMESET_OK and $token->{value} =~ /[^\x09\x0A\x0C\x20]/;
              }
            
          },
        ,
          ## [268] initial;COMMENT
          sub {
            my $token = $_;
  
              push @$OP, ['comment', $token => 0];
            
          },
        ,
          ## [269] initial;DOCTYPE
          sub {
            my $token = $_;
  push @$OP, ['doctype', $token => 0]; $NEXT_ID++;
  
          if (not defined $token->{name} or not $token->{name} eq 'html') {
            push @$Errors, {level => 'm',
                            type => 'bad DOCTYPE name',
                            text => 'html',
                            value => $token->{name},
                            di => $token->{di}, index => $token->{index}};
            unless ($IframeSrcdoc) {
              push @$OP, ['set-compat-mode', 'quirks'];
              $QUIRKS = 1;
            }
          } elsif (defined $token->{public_identifier}) {
            push @$Errors, {type => 'obsolete DOCTYPE', level => 'm',
                            di => $token->{di}, index => $token->{index}};
            unless ($IframeSrcdoc) {
              my $pubid = $token->{public_identifier};
              $pubid =~ tr/a-z/A-Z/; ## ASCII case-insensitive.
              if ($QPublicIDs->{$pubid}) {
                push @$OP, ['set-compat-mode', 'quirks'];
                $QUIRKS = 1;
              } elsif ($pubid =~ /^$QPublicIDPrefixPattern/o) {
                push @$OP, ['set-compat-mode', 'quirks'];
                $QUIRKS = 1;
              } elsif (defined $token->{system_identifier} and
                       do {
                         my $sysid = $token->{system_identifier};
                         $sysid =~ tr/a-z/A-Z/; ## ASCII case-insensitive.
                         $QSystemIDs->{$sysid};
                       }) {
                push @$OP, ['set-compat-mode', 'quirks'];
                $QUIRKS = 1;
              } elsif ($pubid =~ /^$LQPublicIDPrefixPattern/o) {
                push @$OP, ['set-compat-mode', 'limited quirks'];
              } elsif ($pubid =~ /^$QorLQPublicIDPrefixPattern/o) {
                if (defined $token->{system_identifier}) {
                  push @$OP, ['set-compat-mode', 'limited quirks'];
                } else {
                  push @$OP, ['set-compat-mode', 'quirks'];
                  $QUIRKS = 1;
                }
              }
            }
          } elsif (defined $token->{system_identifier}) {
            if ($token->{system_identifier} eq 'about:legacy-compat') {
              push @$Errors, {type => 'legacy DOCTYPE', level => 's',
                              di => $token->{di}, index => $token->{index}};
            } else {
              push @$Errors, {type => 'obsolete DOCTYPE', level => 'm',
                              di => $token->{di}, index => $token->{index}};
              unless ($IframeSrcdoc) {
                my $sysid = $token->{system_identifier};
                $sysid =~ tr/a-z/A-Z/; ## ASCII case-insensitive.
                if ($QSystemIDs->{$sysid}) {
                  push @$OP, ['set-compat-mode', 'quirks'];
                  $QUIRKS = 1;
                }
              }
            }
          }
          if ($token->{force_quirks_flag}) {
            unless ($IframeSrcdoc) {
              push @$OP, ['set-compat-mode', 'quirks'];
              $QUIRKS = 1;
            }
          }
        
  
            $IM = BEFORE_HTML_IM;
            #warn "Insertion mode changed to |before html| ($IM)";
          
          },
        ,
          ## [270] initial;END-ELSE
          sub {
            my $token = $_;
  
            unless ($IframeSrcdoc) {
              push @$Errors, {type => 'no DOCTYPE',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
              push @$OP, ['set-compat-mode', 'quirks'];
              $QUIRKS = 1;
            }
          
  
            $IM = BEFORE_HTML_IM;
            #warn "Insertion mode changed to |before html| ($IM)";
          
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
          },
        ,
          ## [271] initial;EOF
          sub {
            my $token = $_;
  
            unless ($IframeSrcdoc) {
              push @$Errors, {type => 'no DOCTYPE',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
              push @$OP, ['set-compat-mode', 'quirks'];
              $QUIRKS = 1;
            }
          
  
            $IM = BEFORE_HTML_IM;
            #warn "Insertion mode changed to |before html| ($IM)";
          
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
          },
        ,
          ## [272] initial;START-ELSE
          sub {
            my $token = $_;
  
            unless ($IframeSrcdoc) {
              push @$Errors, {type => 'no DOCTYPE',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
              push @$OP, ['set-compat-mode', 'quirks'];
              $QUIRKS = 1;
            }
          
  
            $IM = BEFORE_HTML_IM;
            #warn "Insertion mode changed to |before html| ($IM)";
          
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
          },
        ,
          ## [273] initial;TEXT
          sub {
            my $token = $_;
  
          if ($token->{value} =~ s/^([\x09\x0A\x0C\x20]+)//) {
            
            $token->{index} += length $1;
          }
          if (length $token->{value}) {
            
            unless ($IframeSrcdoc) {
              push @$Errors, {type => 'no DOCTYPE',
                                              level => 'm',
                                              di => $token->{di},
                                  index => $token->{index}};
              push @$OP, ['set-compat-mode', 'quirks'];
              $QUIRKS = 1;
            }
          
  
            $IM = BEFORE_HTML_IM;
            #warn "Insertion mode changed to |before html| ($IM)";
          
  
          my $node = {id => $NEXT_ID++,
                      token => $token,
                      di => $token->{di}, index => $token->{index},
                      ns => HTMLNS,
                      local_name => 'html',
                      attr_list => [],
                      et => (HTML_EL), aet => (HTML_EL)};
        
  push @$OP, ['insert', $node => 0];
  push @$OE, $node;
  push @$OP, ['appcache'];
  
            $IM = BEFORE_HEAD_IM;
            #warn "Insertion mode changed to |before head| ($IM)";
          
  
          my $node_head = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'head',
                   attr_list => [],
                   et => (HEAD_EL), aet => (HEAD_EL) };
        
  
        push @$OP, ['insert', $node_head => $OE->[-1]->{id}];
      
  
  push @$OE, $node_head;
  $HEAD_ELEMENT = $node_head;
  
            $IM = IN_HEAD_IM;
            #warn "Insertion mode changed to |in head| ($IM)";
          
  push @$OP, ['popped', [pop @$OE]];
  
            $IM = AFTER_HEAD_IM;
            #warn "Insertion mode changed to |after head| ($IM)";
          
  
          my $node_body = {id => $NEXT_ID++,
                   token => $token,
                   di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'body',
                   attr_list => [],
                   et => (BODY_EL), aet => (BODY_EL) };
        
  
        push @$OP, ['insert', $node_body => $OE->[-1]->{id}];
      
  
  push @$OE, $node_body;
  
            $IM = IN_BODY_IM;
            #warn "Insertion mode changed to |in body| ($IM)";
          
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
          }
        
          },
        ,
          ## [274] text;COMMENT
          sub {
            
          },
        ,
          ## [275] text;DOCTYPE
          sub {
            
          },
        ,
          ## [276] text;END-ELSE
          sub {
            push @$OP, ['popped', [pop @$OE]];
  
              $IM = $ORIGINAL_IM;
            
          },
        ,
          ## [277] text;END:script
          sub {
            my $script = $OE->[-1];
  push @$OP, ['popped', [pop @$OE]];
  
              $IM = $ORIGINAL_IM;
            
  push @$OP, ['script', $script->{id}];
          },
        ,
          ## [278] text;EOF
          sub {
            my $token = $_;
  push @$Errors, {type => 'in body:#eof',
                                              level => 'm',
                                              text => $OE->[-1]->{local_name},di => $token->{di},
                                  index => $token->{index}};
  
            if ($OE->[-1]->{et} == SCRIPT_EL) {
              push @$OP, ['ignore-script', $OE->[-1]->{id}];
            }
          
  push @$OP, ['popped', [pop @$OE]];
  
              $IM = $ORIGINAL_IM;
            
  
          goto &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
        
          },
        ,
          ## [279] text;START-ELSE
          sub {
            my $token = $_;
  
            if ($token->{self_closing_flag}) {
              push @$Errors, {type => 'nestc',
                                              level => 'm',
                                              text => $token->{tag_name},di => $token->{di},
                                  index => $token->{index}};
            }
          
          },
        ,
          ## [280] text;TEXT
          sub {
            my $token = $_;
  
        push @$OP, ['text', [[$token->{value}, $token->{di}, $token->{index}]] => $OE->[-1]->{id}];
      
          },
        ];
      
  $ProcessIM = [undef,
  [undef, [$TCA->[62]], [$TCA->[1]], [$TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2], $TCA->[2]], [$TCA->[3]], [$TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[91], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4], $TCA->[4]], [$TCA->[5]]],
  [undef, [$TCA->[62]], [$TCA->[6]], [$TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7], $TCA->[7]], [$TCA->[8]], [$TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[91], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[167], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9], $TCA->[9]], [$TCA->[10]]],
  [undef, [$TCA->[12]], [$TCA->[11]], [$TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[14], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13], $TCA->[13]], [$TCA->[15]], [$TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[91], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16], $TCA->[16]], [$TCA->[17]]],
  [undef, [$TCA->[19]], [$TCA->[18]], [$TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[21], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20], $TCA->[20]], [$TCA->[22]], [$TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[91], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[167], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23], $TCA->[23]], [$TCA->[24]]],
  [undef, [$TCA->[26]], [$TCA->[25]], [$TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[28], $TCA->[28], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[28], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[161], $TCA->[27], $TCA->[27], $TCA->[27], $TCA->[27]], [$TCA->[29]], [$TCA->[30], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[31], $TCA->[31], $TCA->[30], $TCA->[32], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[33], $TCA->[30], $TCA->[34], $TCA->[30], $TCA->[91], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[35], $TCA->[30], $TCA->[30], $TCA->[36], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[37], $TCA->[30], $TCA->[36], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[30], $TCA->[38], $TCA->[30], $TCA->[39], $TCA->[30], $TCA->[30]], [$TCA->[40]]],
  [undef, [$TCA->[42]], [$TCA->[41]], [$TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[44], $TCA->[44], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[44], $TCA->[43], $TCA->[44], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43], $TCA->[43]], [$TCA->[45]], [$TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[47], $TCA->[46], $TCA->[91], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46], $TCA->[46]], [$TCA->[48]]],
  [undef, [$TCA->[50]], [$TCA->[49]], [$TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[52], $TCA->[52], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[52], $TCA->[51], $TCA->[52], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51], $TCA->[51]], [$TCA->[53]], [$TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[55], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54], $TCA->[54]], [$TCA->[56]]],
  [undef, [$TCA->[59]], [$TCA->[59]], [$TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59]], [$TCA->[59]], [$TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59], $TCA->[59]], [$TCA->[60]]],
  [undef, [$TCA->[57]], [$TCA->[57]], [$TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57]], [$TCA->[57]], [$TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57], $TCA->[57]], [$TCA->[58]]],
  [undef, [$TCA->[62]], [$TCA->[61]], [$TCA->[63], $TCA->[64], $TCA->[65], $TCA->[66], $TCA->[63], $TCA->[64], $TCA->[63], $TCA->[63], $TCA->[65], $TCA->[67], $TCA->[68], $TCA->[65], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[69], $TCA->[63], $TCA->[65], $TCA->[64], $TCA->[70], $TCA->[63], $TCA->[63], $TCA->[71], $TCA->[63], $TCA->[63], $TCA->[72], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[73], $TCA->[65], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[64], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[66], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[74], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[75], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[161], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[63]], [$TCA->[76]], [$TCA->[77], $TCA->[78], $TCA->[79], $TCA->[80], $TCA->[81], $TCA->[82], $TCA->[164], $TCA->[164], $TCA->[79], $TCA->[83], $TCA->[81], $TCA->[84], $TCA->[85], $TCA->[85], $TCA->[85], $TCA->[86], $TCA->[81], $TCA->[79], $TCA->[82], $TCA->[87], $TCA->[85], $TCA->[88], $TCA->[89], $TCA->[85], $TCA->[90], $TCA->[91], $TCA->[92], $TCA->[93], $TCA->[81], $TCA->[94], $TCA->[81], $TCA->[95], $TCA->[96], $TCA->[77], $TCA->[97], $TCA->[166], $TCA->[98], $TCA->[99], $TCA->[167], $TCA->[100], $TCA->[80], $TCA->[101], $TCA->[101], $TCA->[77], $TCA->[79], $TCA->[102], $TCA->[103], $TCA->[104], $TCA->[105], $TCA->[77], $TCA->[77], $TCA->[169], $TCA->[106], $TCA->[167], $TCA->[107], $TCA->[108], $TCA->[85], $TCA->[85], $TCA->[170], $TCA->[109], $TCA->[171], $TCA->[85], $TCA->[110]], [$TCA->[111]]],
  [undef, [$TCA->[62]], [$TCA->[61]], [$TCA->[63], $TCA->[64], $TCA->[65], $TCA->[66], $TCA->[63], $TCA->[64], $TCA->[63], $TCA->[63], $TCA->[65], $TCA->[112], $TCA->[68], $TCA->[65], $TCA->[113], $TCA->[112], $TCA->[112], $TCA->[69], $TCA->[63], $TCA->[65], $TCA->[64], $TCA->[70], $TCA->[63], $TCA->[63], $TCA->[71], $TCA->[63], $TCA->[63], $TCA->[112], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[73], $TCA->[65], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[64], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[66], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[74], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[75], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[114], $TCA->[112], $TCA->[112], $TCA->[161], $TCA->[63], $TCA->[63], $TCA->[112], $TCA->[63]], [$TCA->[76]], [$TCA->[77], $TCA->[78], $TCA->[79], $TCA->[80], $TCA->[81], $TCA->[82], $TCA->[164], $TCA->[164], $TCA->[79], $TCA->[83], $TCA->[81], $TCA->[84], $TCA->[115], $TCA->[115], $TCA->[115], $TCA->[86], $TCA->[81], $TCA->[79], $TCA->[82], $TCA->[87], $TCA->[85], $TCA->[88], $TCA->[89], $TCA->[85], $TCA->[90], $TCA->[91], $TCA->[92], $TCA->[93], $TCA->[81], $TCA->[94], $TCA->[81], $TCA->[95], $TCA->[96], $TCA->[77], $TCA->[97], $TCA->[166], $TCA->[98], $TCA->[99], $TCA->[167], $TCA->[100], $TCA->[80], $TCA->[101], $TCA->[101], $TCA->[77], $TCA->[79], $TCA->[102], $TCA->[103], $TCA->[104], $TCA->[105], $TCA->[77], $TCA->[77], $TCA->[169], $TCA->[106], $TCA->[167], $TCA->[107], $TCA->[108], $TCA->[115], $TCA->[115], $TCA->[170], $TCA->[109], $TCA->[171], $TCA->[115], $TCA->[110]], [$TCA->[116]]],
  [undef, [$TCA->[62]], [$TCA->[61]], [$TCA->[63], $TCA->[64], $TCA->[65], $TCA->[66], $TCA->[63], $TCA->[64], $TCA->[63], $TCA->[63], $TCA->[65], $TCA->[117], $TCA->[68], $TCA->[65], $TCA->[117], $TCA->[117], $TCA->[117], $TCA->[69], $TCA->[63], $TCA->[65], $TCA->[64], $TCA->[70], $TCA->[63], $TCA->[63], $TCA->[71], $TCA->[63], $TCA->[63], $TCA->[117], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[73], $TCA->[65], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[64], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[66], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[74], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[75], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[63], $TCA->[118], $TCA->[118], $TCA->[119], $TCA->[161], $TCA->[63], $TCA->[63], $TCA->[118], $TCA->[63]], [$TCA->[76]], [$TCA->[77], $TCA->[78], $TCA->[79], $TCA->[80], $TCA->[81], $TCA->[82], $TCA->[164], $TCA->[164], $TCA->[79], $TCA->[83], $TCA->[81], $TCA->[84], $TCA->[120], $TCA->[120], $TCA->[120], $TCA->[86], $TCA->[81], $TCA->[79], $TCA->[82], $TCA->[87], $TCA->[85], $TCA->[88], $TCA->[89], $TCA->[85], $TCA->[90], $TCA->[91], $TCA->[92], $TCA->[93], $TCA->[81], $TCA->[94], $TCA->[81], $TCA->[95], $TCA->[96], $TCA->[77], $TCA->[97], $TCA->[166], $TCA->[98], $TCA->[99], $TCA->[167], $TCA->[100], $TCA->[80], $TCA->[101], $TCA->[101], $TCA->[77], $TCA->[79], $TCA->[102], $TCA->[103], $TCA->[104], $TCA->[105], $TCA->[77], $TCA->[77], $TCA->[169], $TCA->[106], $TCA->[167], $TCA->[107], $TCA->[108], $TCA->[120], $TCA->[120], $TCA->[170], $TCA->[109], $TCA->[171], $TCA->[120], $TCA->[110]], [$TCA->[121]]],
  [undef, [$TCA->[123]], [$TCA->[122]], [$TCA->[124], $TCA->[124], $TCA->[124], $TCA->[124], $TCA->[124], $TCA->[124], $TCA->[124], $TCA->[124], $TCA->[124], $TCA->[124], $TCA->[124], $TCA->[124], $TCA->[124], $TCA->[125], $TCA->[126], $TCA->[124], $TCA->[124], $TCA->[124], $TCA->[124], $TCA->[124], $TCA->[124], $TCA->[124], $TCA->[124], $TCA->[124], $TCA->[124], $TCA->[124], $TCA->[124], $TCA->[124], $TCA->[124], $TCA->[124], $TCA->[124], $TCA->[124], $TCA->[124], $TCA->[124], $TCA->[124], $TCA->[124], $TCA->[124], $TCA->[124], $TCA->[124], $TCA->[124], $TCA->[124], $TCA->[124], $TCA->[124], $TCA->[124], $TCA->[124], $TCA->[124], $TCA->[124], $TCA->[124], $TCA->[124], $TCA->[124], $TCA->[124], $TCA->[124], $TCA->[124], $TCA->[124], $TCA->[124], $TCA->[124], $TCA->[124], $TCA->[124], $TCA->[161], $TCA->[124], $TCA->[124], $TCA->[124], $TCA->[124]], [$TCA->[76]], [$TCA->[127], $TCA->[127], $TCA->[127], $TCA->[127], $TCA->[127], $TCA->[127], $TCA->[127], $TCA->[127], $TCA->[127], $TCA->[127], $TCA->[127], $TCA->[127], $TCA->[127], $TCA->[128], $TCA->[127], $TCA->[127], $TCA->[127], $TCA->[127], $TCA->[127], $TCA->[127], $TCA->[127], $TCA->[127], $TCA->[127], $TCA->[127], $TCA->[127], $TCA->[91], $TCA->[127], $TCA->[127], $TCA->[127], $TCA->[127], $TCA->[127], $TCA->[127], $TCA->[127], $TCA->[127], $TCA->[127], $TCA->[127], $TCA->[127], $TCA->[127], $TCA->[127], $TCA->[127], $TCA->[127], $TCA->[127], $TCA->[127], $TCA->[127], $TCA->[127], $TCA->[127], $TCA->[127], $TCA->[127], $TCA->[127], $TCA->[127], $TCA->[127], $TCA->[127], $TCA->[127], $TCA->[127], $TCA->[127], $TCA->[127], $TCA->[127], $TCA->[127], $TCA->[170], $TCA->[127], $TCA->[127], $TCA->[127], $TCA->[127]], [$TCA->[129]]],
  [undef, [$TCA->[131]], [$TCA->[130]], [$TCA->[132], $TCA->[132], $TCA->[132], $TCA->[132], $TCA->[132], $TCA->[132], $TCA->[132], $TCA->[132], $TCA->[132], $TCA->[132], $TCA->[132], $TCA->[132], $TCA->[132], $TCA->[132], $TCA->[132], $TCA->[132], $TCA->[132], $TCA->[132], $TCA->[132], $TCA->[132], $TCA->[132], $TCA->[132], $TCA->[132], $TCA->[132], $TCA->[132], $TCA->[132], $TCA->[132], $TCA->[132], $TCA->[132], $TCA->[132], $TCA->[132], $TCA->[132], $TCA->[132], $TCA->[132], $TCA->[132], $TCA->[132], $TCA->[132], $TCA->[132], $TCA->[132], $TCA->[132], $TCA->[132], $TCA->[132], $TCA->[132], $TCA->[132], $TCA->[132], $TCA->[132], $TCA->[132], $TCA->[132], $TCA->[132], $TCA->[132], $TCA->[132], $TCA->[133], $TCA->[132], $TCA->[132], $TCA->[132], $TCA->[132], $TCA->[132], $TCA->[132], $TCA->[132], $TCA->[132], $TCA->[132], $TCA->[132], $TCA->[132]], [$TCA->[134]], [$TCA->[135], $TCA->[135], $TCA->[135], $TCA->[135], $TCA->[135], $TCA->[136], $TCA->[135], $TCA->[135], $TCA->[136], $TCA->[136], $TCA->[136], $TCA->[135], $TCA->[135], $TCA->[135], $TCA->[135], $TCA->[136], $TCA->[136], $TCA->[135], $TCA->[137], $TCA->[135], $TCA->[135], $TCA->[135], $TCA->[136], $TCA->[136], $TCA->[136], $TCA->[135], $TCA->[135], $TCA->[135], $TCA->[136], $TCA->[135], $TCA->[135], $TCA->[136], $TCA->[136], $TCA->[135], $TCA->[135], $TCA->[136], $TCA->[136], $TCA->[135], $TCA->[135], $TCA->[135], $TCA->[135], $TCA->[135], $TCA->[135], $TCA->[135], $TCA->[136], $TCA->[135], $TCA->[135], $TCA->[135], $TCA->[135], $TCA->[136], $TCA->[135], $TCA->[135], $TCA->[135], $TCA->[135], $TCA->[135], $TCA->[136], $TCA->[135], $TCA->[135], $TCA->[135], $TCA->[135], $TCA->[135], $TCA->[135], $TCA->[135]], [$TCA->[138]]],
  [undef, [$TCA->[140]], [$TCA->[139]], [$TCA->[141], $TCA->[141], $TCA->[141], $TCA->[141], $TCA->[141], $TCA->[141], $TCA->[141], $TCA->[141], $TCA->[141], $TCA->[141], $TCA->[141], $TCA->[141], $TCA->[141], $TCA->[141], $TCA->[141], $TCA->[141], $TCA->[141], $TCA->[141], $TCA->[141], $TCA->[141], $TCA->[141], $TCA->[142], $TCA->[141], $TCA->[141], $TCA->[141], $TCA->[141], $TCA->[141], $TCA->[141], $TCA->[141], $TCA->[141], $TCA->[141], $TCA->[141], $TCA->[141], $TCA->[141], $TCA->[141], $TCA->[141], $TCA->[141], $TCA->[141], $TCA->[141], $TCA->[141], $TCA->[141], $TCA->[141], $TCA->[141], $TCA->[141], $TCA->[141], $TCA->[141], $TCA->[141], $TCA->[141], $TCA->[141], $TCA->[141], $TCA->[141], $TCA->[141], $TCA->[141], $TCA->[141], $TCA->[141], $TCA->[141], $TCA->[141], $TCA->[141], $TCA->[141], $TCA->[141], $TCA->[141], $TCA->[141], $TCA->[141]], [$TCA->[143]], [$TCA->[144], $TCA->[144], $TCA->[144], $TCA->[144], $TCA->[144], $TCA->[144], $TCA->[144], $TCA->[144], $TCA->[144], $TCA->[144], $TCA->[144], $TCA->[144], $TCA->[144], $TCA->[144], $TCA->[144], $TCA->[144], $TCA->[144], $TCA->[144], $TCA->[144], $TCA->[144], $TCA->[145], $TCA->[146], $TCA->[144], $TCA->[144], $TCA->[144], $TCA->[91], $TCA->[144], $TCA->[144], $TCA->[144], $TCA->[144], $TCA->[144], $TCA->[144], $TCA->[144], $TCA->[144], $TCA->[144], $TCA->[144], $TCA->[144], $TCA->[144], $TCA->[167], $TCA->[144], $TCA->[144], $TCA->[144], $TCA->[144], $TCA->[144], $TCA->[144], $TCA->[144], $TCA->[144], $TCA->[144], $TCA->[144], $TCA->[144], $TCA->[144], $TCA->[144], $TCA->[144], $TCA->[144], $TCA->[144], $TCA->[144], $TCA->[144], $TCA->[144], $TCA->[144], $TCA->[144], $TCA->[144], $TCA->[144], $TCA->[144]], [$TCA->[147]]],
  [undef, [$TCA->[157]], [$TCA->[156]], [$TCA->[158], $TCA->[158], $TCA->[158], $TCA->[158], $TCA->[158], $TCA->[158], $TCA->[158], $TCA->[158], $TCA->[158], $TCA->[159], $TCA->[159], $TCA->[158], $TCA->[158], $TCA->[158], $TCA->[158], $TCA->[158], $TCA->[158], $TCA->[158], $TCA->[158], $TCA->[158], $TCA->[158], $TCA->[158], $TCA->[158], $TCA->[160], $TCA->[158], $TCA->[159], $TCA->[158], $TCA->[158], $TCA->[158], $TCA->[158], $TCA->[158], $TCA->[158], $TCA->[158], $TCA->[158], $TCA->[158], $TCA->[158], $TCA->[158], $TCA->[158], $TCA->[158], $TCA->[158], $TCA->[158], $TCA->[158], $TCA->[158], $TCA->[158], $TCA->[158], $TCA->[158], $TCA->[158], $TCA->[158], $TCA->[158], $TCA->[158], $TCA->[158], $TCA->[158], $TCA->[158], $TCA->[158], $TCA->[158], $TCA->[158], $TCA->[158], $TCA->[158], $TCA->[161], $TCA->[158], $TCA->[158], $TCA->[158], $TCA->[158]], [$TCA->[162]], [$TCA->[163], $TCA->[163], $TCA->[163], $TCA->[163], $TCA->[163], $TCA->[163], $TCA->[164], $TCA->[164], $TCA->[163], $TCA->[163], $TCA->[163], $TCA->[163], $TCA->[163], $TCA->[163], $TCA->[163], $TCA->[163], $TCA->[163], $TCA->[163], $TCA->[163], $TCA->[163], $TCA->[163], $TCA->[163], $TCA->[163], $TCA->[165], $TCA->[163], $TCA->[91], $TCA->[163], $TCA->[163], $TCA->[163], $TCA->[163], $TCA->[163], $TCA->[163], $TCA->[163], $TCA->[163], $TCA->[163], $TCA->[166], $TCA->[163], $TCA->[163], $TCA->[167], $TCA->[168], $TCA->[163], $TCA->[163], $TCA->[163], $TCA->[163], $TCA->[163], $TCA->[163], $TCA->[163], $TCA->[163], $TCA->[163], $TCA->[163], $TCA->[163], $TCA->[169], $TCA->[163], $TCA->[167], $TCA->[163], $TCA->[163], $TCA->[163], $TCA->[163], $TCA->[170], $TCA->[163], $TCA->[171], $TCA->[163], $TCA->[163]], [$TCA->[172]]],
  [undef, [$TCA->[148]], [$TCA->[156]], [$TCA->[149], $TCA->[149], $TCA->[149], $TCA->[149], $TCA->[149], $TCA->[149], $TCA->[149], $TCA->[149], $TCA->[149], $TCA->[149], $TCA->[150], $TCA->[149], $TCA->[149], $TCA->[149], $TCA->[149], $TCA->[149], $TCA->[149], $TCA->[149], $TCA->[149], $TCA->[149], $TCA->[149], $TCA->[149], $TCA->[149], $TCA->[149], $TCA->[149], $TCA->[149], $TCA->[149], $TCA->[149], $TCA->[149], $TCA->[149], $TCA->[149], $TCA->[149], $TCA->[149], $TCA->[149], $TCA->[149], $TCA->[149], $TCA->[149], $TCA->[149], $TCA->[149], $TCA->[151], $TCA->[149], $TCA->[149], $TCA->[149], $TCA->[149], $TCA->[149], $TCA->[149], $TCA->[149], $TCA->[149], $TCA->[149], $TCA->[149], $TCA->[149], $TCA->[149], $TCA->[149], $TCA->[149], $TCA->[149], $TCA->[149], $TCA->[149], $TCA->[149], $TCA->[149], $TCA->[149], $TCA->[149], $TCA->[149], $TCA->[149]], [$TCA->[152]], [$TCA->[153], $TCA->[153], $TCA->[153], $TCA->[153], $TCA->[153], $TCA->[153], $TCA->[153], $TCA->[164], $TCA->[153], $TCA->[153], $TCA->[153], $TCA->[153], $TCA->[153], $TCA->[153], $TCA->[153], $TCA->[153], $TCA->[153], $TCA->[153], $TCA->[153], $TCA->[153], $TCA->[153], $TCA->[153], $TCA->[153], $TCA->[154], $TCA->[153], $TCA->[91], $TCA->[153], $TCA->[153], $TCA->[153], $TCA->[153], $TCA->[153], $TCA->[153], $TCA->[153], $TCA->[153], $TCA->[153], $TCA->[166], $TCA->[153], $TCA->[153], $TCA->[167], $TCA->[154], $TCA->[153], $TCA->[153], $TCA->[153], $TCA->[153], $TCA->[153], $TCA->[153], $TCA->[153], $TCA->[153], $TCA->[153], $TCA->[153], $TCA->[153], $TCA->[153], $TCA->[153], $TCA->[167], $TCA->[153], $TCA->[153], $TCA->[153], $TCA->[153], $TCA->[153], $TCA->[153], $TCA->[153], $TCA->[153], $TCA->[153]], [$TCA->[155]]],
  [undef, [$TCA->[209]], [$TCA->[208]], [$TCA->[210], $TCA->[211], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[211], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[173], $TCA->[213], $TCA->[210], $TCA->[173], $TCA->[173], $TCA->[173], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[211], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[173], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[211], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[214], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[174], $TCA->[175], $TCA->[173], $TCA->[161], $TCA->[210], $TCA->[210], $TCA->[176], $TCA->[210]], [$TCA->[76]], [$TCA->[216], $TCA->[217], $TCA->[218], $TCA->[219], $TCA->[220], $TCA->[221], $TCA->[222], $TCA->[222], $TCA->[218], $TCA->[223], $TCA->[220], $TCA->[224], $TCA->[177], $TCA->[177], $TCA->[177], $TCA->[228], $TCA->[220], $TCA->[218], $TCA->[221], $TCA->[229], $TCA->[230], $TCA->[231], $TCA->[232], $TCA->[230], $TCA->[233], $TCA->[234], $TCA->[235], $TCA->[236], $TCA->[220], $TCA->[237], $TCA->[220], $TCA->[238], $TCA->[239], $TCA->[216], $TCA->[240], $TCA->[241], $TCA->[242], $TCA->[243], $TCA->[244], $TCA->[245], $TCA->[219], $TCA->[246], $TCA->[246], $TCA->[216], $TCA->[218], $TCA->[247], $TCA->[248], $TCA->[249], $TCA->[250], $TCA->[216], $TCA->[216], $TCA->[169], $TCA->[251], $TCA->[167], $TCA->[252], $TCA->[253], $TCA->[177], $TCA->[178], $TCA->[170], $TCA->[256], $TCA->[257], $TCA->[177], $TCA->[258]], [$TCA->[179]]],
  [undef, [$TCA->[184]], [$TCA->[183]], [$TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[186], $TCA->[187], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[188], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[161], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185]], [$TCA->[76]], [$TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[91], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[190], $TCA->[190], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[191], $TCA->[192], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[169], $TCA->[193], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[170], $TCA->[190], $TCA->[189], $TCA->[189], $TCA->[189]], [$TCA->[194]]],
  [undef, [$TCA->[184]], [$TCA->[183]], [$TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[180], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[186], $TCA->[187], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[185], $TCA->[188], $TCA->[185], $TCA->[185], $TCA->[180], $TCA->[180], $TCA->[180], $TCA->[161], $TCA->[185], $TCA->[185], $TCA->[180], $TCA->[185]], [$TCA->[76]], [$TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[181], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[91], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[190], $TCA->[190], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[191], $TCA->[192], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[189], $TCA->[169], $TCA->[193], $TCA->[189], $TCA->[189], $TCA->[181], $TCA->[181], $TCA->[181], $TCA->[170], $TCA->[190], $TCA->[189], $TCA->[181], $TCA->[189]], [$TCA->[182]]],
  [undef, [$TCA->[209]], [$TCA->[208]], [$TCA->[210], $TCA->[211], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[211], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[212], $TCA->[213], $TCA->[210], $TCA->[212], $TCA->[212], $TCA->[212], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[211], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[212], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[211], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[214], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[215], $TCA->[212], $TCA->[212], $TCA->[161], $TCA->[210], $TCA->[210], $TCA->[212], $TCA->[210]], [$TCA->[76]], [$TCA->[216], $TCA->[217], $TCA->[218], $TCA->[219], $TCA->[220], $TCA->[221], $TCA->[222], $TCA->[222], $TCA->[218], $TCA->[223], $TCA->[220], $TCA->[224], $TCA->[225], $TCA->[226], $TCA->[227], $TCA->[228], $TCA->[220], $TCA->[218], $TCA->[221], $TCA->[229], $TCA->[230], $TCA->[231], $TCA->[232], $TCA->[230], $TCA->[233], $TCA->[234], $TCA->[235], $TCA->[236], $TCA->[220], $TCA->[237], $TCA->[220], $TCA->[238], $TCA->[239], $TCA->[216], $TCA->[240], $TCA->[241], $TCA->[242], $TCA->[243], $TCA->[244], $TCA->[245], $TCA->[219], $TCA->[246], $TCA->[246], $TCA->[216], $TCA->[218], $TCA->[247], $TCA->[248], $TCA->[249], $TCA->[250], $TCA->[216], $TCA->[216], $TCA->[169], $TCA->[251], $TCA->[167], $TCA->[252], $TCA->[253], $TCA->[254], $TCA->[255], $TCA->[170], $TCA->[256], $TCA->[257], $TCA->[255], $TCA->[258]], [$TCA->[259]]],
  [undef, [$TCA->[209]], [$TCA->[208]], [$TCA->[210], $TCA->[211], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[211], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[195], $TCA->[213], $TCA->[210], $TCA->[195], $TCA->[195], $TCA->[195], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[211], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[195], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[211], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[214], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[210], $TCA->[196], $TCA->[197], $TCA->[195], $TCA->[161], $TCA->[210], $TCA->[210], $TCA->[195], $TCA->[210]], [$TCA->[76]], [$TCA->[216], $TCA->[217], $TCA->[218], $TCA->[219], $TCA->[220], $TCA->[221], $TCA->[222], $TCA->[222], $TCA->[218], $TCA->[223], $TCA->[220], $TCA->[224], $TCA->[198], $TCA->[198], $TCA->[198], $TCA->[228], $TCA->[220], $TCA->[218], $TCA->[221], $TCA->[229], $TCA->[230], $TCA->[231], $TCA->[232], $TCA->[230], $TCA->[233], $TCA->[234], $TCA->[235], $TCA->[236], $TCA->[220], $TCA->[237], $TCA->[220], $TCA->[238], $TCA->[239], $TCA->[216], $TCA->[240], $TCA->[241], $TCA->[242], $TCA->[243], $TCA->[244], $TCA->[245], $TCA->[219], $TCA->[246], $TCA->[246], $TCA->[216], $TCA->[218], $TCA->[247], $TCA->[248], $TCA->[249], $TCA->[250], $TCA->[216], $TCA->[216], $TCA->[169], $TCA->[251], $TCA->[167], $TCA->[252], $TCA->[253], $TCA->[198], $TCA->[199], $TCA->[170], $TCA->[256], $TCA->[257], $TCA->[200], $TCA->[258]], [$TCA->[201]]],
  [undef, [$TCA->[203]], [$TCA->[202]], [$TCA->[204], $TCA->[204], $TCA->[204], $TCA->[204], $TCA->[204], $TCA->[204], $TCA->[204], $TCA->[204], $TCA->[204], $TCA->[204], $TCA->[204], $TCA->[204], $TCA->[204], $TCA->[204], $TCA->[204], $TCA->[204], $TCA->[204], $TCA->[204], $TCA->[204], $TCA->[204], $TCA->[204], $TCA->[204], $TCA->[204], $TCA->[204], $TCA->[204], $TCA->[204], $TCA->[204], $TCA->[204], $TCA->[204], $TCA->[204], $TCA->[204], $TCA->[204], $TCA->[204], $TCA->[204], $TCA->[204], $TCA->[204], $TCA->[204], $TCA->[204], $TCA->[204], $TCA->[204], $TCA->[204], $TCA->[204], $TCA->[204], $TCA->[204], $TCA->[204], $TCA->[204], $TCA->[204], $TCA->[204], $TCA->[204], $TCA->[204], $TCA->[204], $TCA->[204], $TCA->[204], $TCA->[204], $TCA->[204], $TCA->[204], $TCA->[204], $TCA->[204], $TCA->[204], $TCA->[204], $TCA->[204], $TCA->[204], $TCA->[204]], [$TCA->[205]], [$TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206], $TCA->[206]], [$TCA->[207]]],
  [undef, [$TCA->[62]], [$TCA->[61]], [$TCA->[260], $TCA->[260], $TCA->[260], $TCA->[260], $TCA->[260], $TCA->[260], $TCA->[260], $TCA->[260], $TCA->[260], $TCA->[260], $TCA->[260], $TCA->[260], $TCA->[260], $TCA->[260], $TCA->[260], $TCA->[260], $TCA->[260], $TCA->[260], $TCA->[260], $TCA->[260], $TCA->[260], $TCA->[260], $TCA->[260], $TCA->[260], $TCA->[260], $TCA->[260], $TCA->[260], $TCA->[260], $TCA->[260], $TCA->[260], $TCA->[260], $TCA->[260], $TCA->[260], $TCA->[260], $TCA->[260], $TCA->[260], $TCA->[260], $TCA->[260], $TCA->[260], $TCA->[260], $TCA->[260], $TCA->[260], $TCA->[260], $TCA->[260], $TCA->[260], $TCA->[260], $TCA->[260], $TCA->[260], $TCA->[260], $TCA->[260], $TCA->[260], $TCA->[260], $TCA->[260], $TCA->[260], $TCA->[260], $TCA->[260], $TCA->[260], $TCA->[260], $TCA->[161], $TCA->[260], $TCA->[260], $TCA->[260], $TCA->[260]], [$TCA->[261]], [$TCA->[262], $TCA->[262], $TCA->[262], $TCA->[262], $TCA->[262], $TCA->[262], $TCA->[164], $TCA->[164], $TCA->[262], $TCA->[262], $TCA->[262], $TCA->[262], $TCA->[263], $TCA->[264], $TCA->[263], $TCA->[262], $TCA->[262], $TCA->[262], $TCA->[262], $TCA->[262], $TCA->[262], $TCA->[262], $TCA->[262], $TCA->[262], $TCA->[262], $TCA->[262], $TCA->[262], $TCA->[262], $TCA->[262], $TCA->[262], $TCA->[262], $TCA->[262], $TCA->[262], $TCA->[262], $TCA->[262], $TCA->[166], $TCA->[262], $TCA->[262], $TCA->[167], $TCA->[262], $TCA->[262], $TCA->[262], $TCA->[262], $TCA->[262], $TCA->[262], $TCA->[262], $TCA->[262], $TCA->[262], $TCA->[262], $TCA->[262], $TCA->[262], $TCA->[169], $TCA->[262], $TCA->[167], $TCA->[262], $TCA->[262], $TCA->[263], $TCA->[265], $TCA->[170], $TCA->[262], $TCA->[171], $TCA->[266], $TCA->[262]], [$TCA->[267]]],
  [undef, [$TCA->[269]], [$TCA->[268]], [$TCA->[270], $TCA->[270], $TCA->[270], $TCA->[270], $TCA->[270], $TCA->[270], $TCA->[270], $TCA->[270], $TCA->[270], $TCA->[270], $TCA->[270], $TCA->[270], $TCA->[270], $TCA->[270], $TCA->[270], $TCA->[270], $TCA->[270], $TCA->[270], $TCA->[270], $TCA->[270], $TCA->[270], $TCA->[270], $TCA->[270], $TCA->[270], $TCA->[270], $TCA->[270], $TCA->[270], $TCA->[270], $TCA->[270], $TCA->[270], $TCA->[270], $TCA->[270], $TCA->[270], $TCA->[270], $TCA->[270], $TCA->[270], $TCA->[270], $TCA->[270], $TCA->[270], $TCA->[270], $TCA->[270], $TCA->[270], $TCA->[270], $TCA->[270], $TCA->[270], $TCA->[270], $TCA->[270], $TCA->[270], $TCA->[270], $TCA->[270], $TCA->[270], $TCA->[270], $TCA->[270], $TCA->[270], $TCA->[270], $TCA->[270], $TCA->[270], $TCA->[270], $TCA->[270], $TCA->[270], $TCA->[270], $TCA->[270], $TCA->[270]], [$TCA->[271]], [$TCA->[272], $TCA->[272], $TCA->[272], $TCA->[272], $TCA->[272], $TCA->[272], $TCA->[272], $TCA->[272], $TCA->[272], $TCA->[272], $TCA->[272], $TCA->[272], $TCA->[272], $TCA->[272], $TCA->[272], $TCA->[272], $TCA->[272], $TCA->[272], $TCA->[272], $TCA->[272], $TCA->[272], $TCA->[272], $TCA->[272], $TCA->[272], $TCA->[272], $TCA->[272], $TCA->[272], $TCA->[272], $TCA->[272], $TCA->[272], $TCA->[272], $TCA->[272], $TCA->[272], $TCA->[272], $TCA->[272], $TCA->[272], $TCA->[272], $TCA->[272], $TCA->[272], $TCA->[272], $TCA->[272], $TCA->[272], $TCA->[272], $TCA->[272], $TCA->[272], $TCA->[272], $TCA->[272], $TCA->[272], $TCA->[272], $TCA->[272], $TCA->[272], $TCA->[272], $TCA->[272], $TCA->[272], $TCA->[272], $TCA->[272], $TCA->[272], $TCA->[272], $TCA->[272], $TCA->[272], $TCA->[272], $TCA->[272], $TCA->[272]], [$TCA->[273]]],
  [undef, [$TCA->[275]], [$TCA->[274]], [$TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[277], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276], $TCA->[276]], [$TCA->[278]], [$TCA->[279], $TCA->[279], $TCA->[279], $TCA->[279], $TCA->[279], $TCA->[279], $TCA->[279], $TCA->[279], $TCA->[279], $TCA->[279], $TCA->[279], $TCA->[279], $TCA->[279], $TCA->[279], $TCA->[279], $TCA->[279], $TCA->[279], $TCA->[279], $TCA->[279], $TCA->[279], $TCA->[279], $TCA->[279], $TCA->[279], $TCA->[279], $TCA->[279], $TCA->[279], $TCA->[279], $TCA->[279], $TCA->[279], $TCA->[279], $TCA->[279], $TCA->[279], $TCA->[279], $TCA->[279], $TCA->[279], $TCA->[279], $TCA->[279], $TCA->[279], $TCA->[279], $TCA->[279], $TCA->[279], $TCA->[279], $TCA->[279], $TCA->[279], $TCA->[279], $TCA->[279], $TCA->[279], $TCA->[279], $TCA->[279], $TCA->[279], $TCA->[279], $TCA->[279], $TCA->[279], $TCA->[279], $TCA->[279], $TCA->[279], $TCA->[279], $TCA->[279], $TCA->[279], $TCA->[279], $TCA->[279], $TCA->[279], $TCA->[279]], [$TCA->[280]]]];
  my $ResetIMByET = {  (BODY_EL) => IN_BODY_IM,
    (CAPTION_EL) => IN_CAPTION_IM,
    (COLGROUP_EL) => IN_COLUMN_GROUP_IM,
    (FRAMESET_EL) => IN_FRAMESET_IM,
    (TABLE_EL) => IN_TABLE_IM,
    (TBODY_EL) => IN_TABLE_BODY_IM,
    (TFOOT_EL) => IN_TABLE_BODY_IM,
    (THEAD_EL) => IN_TABLE_BODY_IM,
    (TR_EL) => IN_ROW_IM,};
  my $ResetIMByETUnlessLast = {  (HEAD_EL) => IN_HEAD_IM,
    (TD_EL) => IN_CELL_IM,
    (TH_EL) => IN_CELL_IM,};
  
        sub reset_im () {
          my $last = 0;
          my $node_i = $#$OE;
          my $node = $OE->[$node_i];
          LOOP: {
            if ($node_i == 0) {
              $last = 1;
              $node = $CONTEXT if defined $CONTEXT;
            }
  
            if ($node->{et} == SELECT_EL) {
              SELECT: {
                last SELECT if $last;
                my $ancestor_i = $node_i;
                INNERLOOP: {
                  if ($ancestor_i == 0) {
                    last SELECT;
                  }
                  $ancestor_i--;
                  my $ancestor = $OE->[$ancestor_i];
                  if ($ancestor->{et} & (TEM_ELS)) {
                    last SELECT;
                  }
                  if ($ancestor->{et} & (TAB_ELS)) {
                    $IM = IN_SELECT_IN_TABLE_IM;
                    return;
                  }
                  redo INNERLOOP;
                } # INNERLOOP
              } # SELECT
              $IM = IN_SELECT_IM;
              return;
            }
  
            $IM = $ResetIMByET->{$node->{et}};
            return if defined $IM;
  
            unless ($last) {
              $IM = $ResetIMByETUnlessLast->{$node->{et}};
              return if defined $IM;
            }
  
            if ($node->{et} & (TEM_ELS)) {
              $IM = $TEMPLATE_IMS->[-1];
              return;
            }
            if ($node->{et} & (HTM_ELS)) {
              if (not defined $HEAD_ELEMENT) {
                $IM = BEFORE_HEAD_IM;
                return;
              } else {
                $IM = AFTER_HEAD_IM;
                return;
              }
            }
            if ($last) {
              $IM = IN_BODY_IM;
              return;
            }
            $node_i--;
            $node = $OE->[$node_i];
            redo LOOP;
          } # LOOP
        } # reset_im
      
  
          sub aaa ($$;%) {
            my ($token, $tag_name, %args) = @_;
            my @popped;
            if ($OE->[-1]->{ns} == HTMLNS and
                $OE->[-1]->{local_name} eq $tag_name) {
              my $found;
              for (reverse @$AFE) {
                if ($_ eq $OE->[-1]) {
                  $found = 1;
                  last;
                }
              }
              unless ($found) {
                #push @popped,
                pop @$OE;
                ## $args{remove_from_afe_and_oe} - nop
                #push @$OP, ['popped', \@popped];
                return;
              }
            }
  
            my $outer_loop_counter = 0;
            OUTER_LOOP: {
              if ($outer_loop_counter >= 8) {
                ## $args{remove_from_afe_and_oe} - nop
                push @$OP, ['popped', \@popped];
                return;
              }
              $outer_loop_counter++;
              my $formatting_element;
              my $formatting_element_afe_i;
              for (reverse 0..$#$AFE) {
                if (not ref $AFE->[$_]) {
                  last;
                } elsif ($AFE->[$_]->{local_name} eq $tag_name) { # ->{ns} == HTMLNS
                  $formatting_element = $AFE->[$_];
                  $formatting_element_afe_i = $_;
                  last;
                }
              }
              unless (defined $formatting_element) {
                ## The "in body" insertion mode, END_TAG_TOKEN, ELSE
                local $_ = $token;
                $ProcessIM->[IN_BODY_IM]->[END_TAG_TOKEN]->[0]->();
                ## $args{remove_from_afe_and_oe} - nop
                push @$OP, ['popped', \@popped];
                return;
              }
              my $beyond_scope;
              my $formatting_element_i;
              my $furthest_block;
              my $furthest_block_i;
              for (reverse 0..$#$OE) {
                if ($OE->[$_] eq $formatting_element) {
                  $formatting_element_i = $_;
                  last;
                } else {
                  if ($OE->[$_]->{et} & (APP_MAR_M_ANN_ELS | CAP_ELS | HTM_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) {
                    $beyond_scope = 1;
                  }
                  if ($OE->[$_]->{et} & (ADD_DIV_ELS | APP_MAR_M_ANN_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS | BOD_ELS | BUT_ELS | CAP_ELS | COL_ELS | DD_ELS | DT_ELS | FIE_INP_SEL_ELS | HHHHHH_ELS | HTM_ELS | IMG_ELS | LI_ELS | OBJ_ELS | OL_UL_ELS | P_ELS | STY_ELS | TAB_ELS | TBO_TFO_THE_ELS | TD_TH_ELS | TEM_ELS | TEX_ELS | TR_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) {
                    $furthest_block = $OE->[$_];
                    $furthest_block_i = $_;
                  }
                }
              }
              unless (defined $formatting_element_i) {
                push @$Errors, {type => 'AAA:in afe but not in open elements',
                                value => $token->{tag_name},
                                level => 'm',
                                di => $token->{di}, index => $token->{index}};
                splice @$AFE, $formatting_element_afe_i, 1, ();
                ## $args{remove_from_afe_and_oe} - nop
                push @$OP, ['popped', \@popped];
                return;
              }
              if ($beyond_scope) {
                push @$Errors, {type => 'AAA:formatting element not in scope',
                                level => 'm', value => $token->{tag_name},
                                di => $token->{di}, index => $token->{index}};
                if ($args{remove_from_afe_and_oe}) {
                  splice @$AFE, $formatting_element_afe_i, 1, ();
                  #push @popped,
                  splice @$OE, $formatting_element_i, 1, ();
                }
                push @$OP, ['popped', \@popped];
                return;
              }
              unless ($formatting_element eq $OE->[-1]) {
                push @$Errors, {type => 'AAA:formatting element not current',
                                level => 'm', value => $token->{tag_name},
                                di => $token->{di}, index => $token->{index}};
              }
              unless (defined $furthest_block) {
                #push @popped,
                splice @$OE, $formatting_element_i;
                splice @$AFE, $formatting_element_afe_i, 1, ();
                ## $args{remove_from_afe_and_oe} - nop
                push @$OP, ['popped', \@popped];
                return;
              }
  
          my $common_ancestor = $OE->[$formatting_element_i-1];
          my $bookmark = $formatting_element_afe_i;
          my $node = $furthest_block;
          my $node_i = $furthest_block_i;
          my $last_node = $furthest_block;
          my $inner_loop_counter = 0;
          INNER_LOOP: {
            $inner_loop_counter++;
            $node_i--;
            $node = $OE->[$node_i];
            last INNER_LOOP if $node eq $formatting_element;
            my $node_afe_i;
            for (reverse 0..$#$AFE) {
              if ($AFE->[$_] eq $node) {
                $node_afe_i = $_;
                last;
              }
            }
            if ($inner_loop_counter > 3 and defined $node_afe_i) {
              $formatting_element_afe_i-- if $node_afe_i < $formatting_element_afe_i;
              $bookmark-- if $node_afe_i < $bookmark;
              splice @$AFE, $node_afe_i, 1, ();
              undef $node_afe_i;
            }
            if (not defined $node_afe_i) {
              $furthest_block_i-- if $node_i < $furthest_block_i;
              push @popped, splice @$OE, $node_i, 1, ();
              redo INNER_LOOP;
            }
  
            ## Create an HTML element
            $node = {id => $NEXT_ID++,
                     token => $node->{token},
                     di => $node->{token}->{di}, index => $node->{token}->{index},
                     ns => HTMLNS,
                     local_name => $node->{token}->{tag_name},
                     attr_list => $node->{token}->{attr_list},
                     et => $Element2Type->[HTMLNS]->{$node->{token}->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}};
            $node->{aet} = $node->{et};
            $AFE->[$node_afe_i] = $node;
            $OE->[$node_i] = $node;
            ## As $node seems never to be a form-assosicated element,
            ## and it will be appended (not inserted) to another node
            ## later anyway, we don't have to associate the form owner
            ## here.  Note that /intended parent/ is $common_ancestor.
  
            if ($last_node eq $furthest_block) {
              $bookmark = $node_afe_i + 1;
            }
  
            push @$OP,
                ['create', $node],
                ['append', $last_node->{id} => $node->{id}];
            $last_node = $node;
            redo INNER_LOOP;
          } # INNER_LOOP
  
              
        push @$OP, ['append', $last_node->{id} => $common_ancestor->{id}];
      
  
              ## Create an HTML element
              my $new_element = {id => $NEXT_ID++,
                                 token => $formatting_element->{token},
                                 di => $formatting_element->{token}->{di},
                                 index => $formatting_element->{token}->{index},
                                 ns => HTMLNS,
                                 local_name => $formatting_element->{token}->{tag_name},
                                 attr_list => $formatting_element->{token}->{attr_list},
                                 et => $Element2Type->[HTMLNS]->{$formatting_element->{token}->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}};
              $new_element->{aet} = $new_element->{et};
              push @$OP,
                  ['create', $new_element],
                  ['move-children', $furthest_block->{id} => $new_element->{id}],
                  ['append', $new_element->{id} => $furthest_block->{id}];
              ## As $formatting_element is always a formatting element,
              ## it can't be a form-associated element.  Note that
              ## /intended parent/ is $furthest_block.
  
              if ($bookmark <= $formatting_element_afe_i) {
                splice @$AFE, $formatting_element_afe_i, 1, ();
                splice @$AFE, $bookmark, 0, $new_element;
              } else {
                splice @$AFE, $bookmark, 0, $new_element;
                splice @$AFE, $formatting_element_afe_i, 1, ();
                $bookmark--;
              }
  
              if ($formatting_element_i < $furthest_block_i) {
                splice @$OE, $furthest_block_i + 1, 0, ($new_element);
                #push @popped,
                splice @$OE, $formatting_element_i, 1, ();
                $furthest_block_i--;
              } else {
                #push @popped,
                splice @$OE, $formatting_element_i, 1, ();
                splice @$OE, $furthest_block_i + 1, 0, ($new_element);
              }
  
              redo OUTER_LOOP;
            } # OUTER_LOOP
          }
        
  
          sub aaa_foster ($$;%) {
            my ($token, $tag_name, %args) = @_;
            my @popped;
            if ($OE->[-1]->{ns} == HTMLNS and
                $OE->[-1]->{local_name} eq $tag_name) {
              my $found;
              for (reverse @$AFE) {
                if ($_ eq $OE->[-1]) {
                  $found = 1;
                  last;
                }
              }
              unless ($found) {
                #push @popped,
                pop @$OE;
                ## $args{remove_from_afe_and_oe} - nop
                #push @$OP, ['popped', \@popped];
                return;
              }
            }
  
            my $outer_loop_counter = 0;
            OUTER_LOOP: {
              if ($outer_loop_counter >= 8) {
                ## $args{remove_from_afe_and_oe} - nop
                push @$OP, ['popped', \@popped];
                return;
              }
              $outer_loop_counter++;
              my $formatting_element;
              my $formatting_element_afe_i;
              for (reverse 0..$#$AFE) {
                if (not ref $AFE->[$_]) {
                  last;
                } elsif ($AFE->[$_]->{local_name} eq $tag_name) { # ->{ns} == HTMLNS
                  $formatting_element = $AFE->[$_];
                  $formatting_element_afe_i = $_;
                  last;
                }
              }
              unless (defined $formatting_element) {
                ## The "in body" insertion mode, END_TAG_TOKEN, ELSE
                local $_ = $token;
                $ProcessIM->[IN_BODY_IM]->[END_TAG_TOKEN]->[0]->();
                ## $args{remove_from_afe_and_oe} - nop
                push @$OP, ['popped', \@popped];
                return;
              }
              my $beyond_scope;
              my $formatting_element_i;
              my $furthest_block;
              my $furthest_block_i;
              for (reverse 0..$#$OE) {
                if ($OE->[$_] eq $formatting_element) {
                  $formatting_element_i = $_;
                  last;
                } else {
                  if ($OE->[$_]->{et} & (APP_MAR_M_ANN_ELS | CAP_ELS | HTM_ELS | OBJ_ELS | TAB_ELS | TD_TH_ELS | TEM_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) {
                    $beyond_scope = 1;
                  }
                  if ($OE->[$_]->{et} & (ADD_DIV_ELS | APP_MAR_M_ANN_ELS | AAABBBBBCCDDDEFFFFFFHHHHIKLLMMMNNNNPPPSSSSTTWX_ELS | BOD_ELS | BUT_ELS | CAP_ELS | COL_ELS | DD_ELS | DT_ELS | FIE_INP_SEL_ELS | HHHHHH_ELS | HTM_ELS | IMG_ELS | LI_ELS | OBJ_ELS | OL_UL_ELS | P_ELS | STY_ELS | TAB_ELS | TBO_TFO_THE_ELS | TD_TH_ELS | TEM_ELS | TEX_ELS | TR_ELS | M_MI_M_MN_M_MO_M_MS_M_MTE_ELS | S_DES_S_FOR_S_TIT_ELS)) {
                    $furthest_block = $OE->[$_];
                    $furthest_block_i = $_;
                  }
                }
              }
              unless (defined $formatting_element_i) {
                push @$Errors, {type => 'AAA:in afe but not in open elements',
                                value => $token->{tag_name},
                                level => 'm',
                                di => $token->{di}, index => $token->{index}};
                splice @$AFE, $formatting_element_afe_i, 1, ();
                ## $args{remove_from_afe_and_oe} - nop
                push @$OP, ['popped', \@popped];
                return;
              }
              if ($beyond_scope) {
                push @$Errors, {type => 'AAA:formatting element not in scope',
                                level => 'm', value => $token->{tag_name},
                                di => $token->{di}, index => $token->{index}};
                if ($args{remove_from_afe_and_oe}) {
                  splice @$AFE, $formatting_element_afe_i, 1, ();
                  #push @popped,
                  splice @$OE, $formatting_element_i, 1, ();
                }
                push @$OP, ['popped', \@popped];
                return;
              }
              unless ($formatting_element eq $OE->[-1]) {
                push @$Errors, {type => 'AAA:formatting element not current',
                                level => 'm', value => $token->{tag_name},
                                di => $token->{di}, index => $token->{index}};
              }
              unless (defined $furthest_block) {
                #push @popped,
                splice @$OE, $formatting_element_i;
                splice @$AFE, $formatting_element_afe_i, 1, ();
                ## $args{remove_from_afe_and_oe} - nop
                push @$OP, ['popped', \@popped];
                return;
              }
  
          my $common_ancestor = $OE->[$formatting_element_i-1];
          my $bookmark = $formatting_element_afe_i;
          my $node = $furthest_block;
          my $node_i = $furthest_block_i;
          my $last_node = $furthest_block;
          my $inner_loop_counter = 0;
          INNER_LOOP: {
            $inner_loop_counter++;
            $node_i--;
            $node = $OE->[$node_i];
            last INNER_LOOP if $node eq $formatting_element;
            my $node_afe_i;
            for (reverse 0..$#$AFE) {
              if ($AFE->[$_] eq $node) {
                $node_afe_i = $_;
                last;
              }
            }
            if ($inner_loop_counter > 3 and defined $node_afe_i) {
              $formatting_element_afe_i-- if $node_afe_i < $formatting_element_afe_i;
              $bookmark-- if $node_afe_i < $bookmark;
              splice @$AFE, $node_afe_i, 1, ();
              undef $node_afe_i;
            }
            if (not defined $node_afe_i) {
              $furthest_block_i-- if $node_i < $furthest_block_i;
              push @popped, splice @$OE, $node_i, 1, ();
              redo INNER_LOOP;
            }
  
            ## Create an HTML element
            $node = {id => $NEXT_ID++,
                     token => $node->{token},
                     di => $node->{token}->{di}, index => $node->{token}->{index},
                     ns => HTMLNS,
                     local_name => $node->{token}->{tag_name},
                     attr_list => $node->{token}->{attr_list},
                     et => $Element2Type->[HTMLNS]->{$node->{token}->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}};
            $node->{aet} = $node->{et};
            $AFE->[$node_afe_i] = $node;
            $OE->[$node_i] = $node;
            ## As $node seems never to be a form-assosicated element,
            ## and it will be appended (not inserted) to another node
            ## later anyway, we don't have to associate the form owner
            ## here.  Note that /intended parent/ is $common_ancestor.
  
            if ($last_node eq $furthest_block) {
              $bookmark = $node_afe_i + 1;
            }
  
            push @$OP,
                ['create', $node],
                ['append', $last_node->{id} => $node->{id}];
            $last_node = $node;
            redo INNER_LOOP;
          } # INNER_LOOP
  
              
        if ($common_ancestor->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
          FOSTER: {
            for my $i (reverse 1..$#$OE) {
              if ($OE->[$i]->{et} & (TAB_ELS)) { # table
                push @$OP, ['append-foster', $last_node->{id} => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
                last FOSTER;
              } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
                push @$OP, ['append', $last_node->{id} => $OE->[$i]->{id}];
                last FOSTER;
              }
            }
            push @$OP, ['append', $last_node->{id} => $OE->[0]->{id}];
          } # FOSTER
        } else {
          push @$OP, ['append', $last_node->{id} => $common_ancestor->{id}];
        }
      
  
              ## Create an HTML element
              my $new_element = {id => $NEXT_ID++,
                                 token => $formatting_element->{token},
                                 di => $formatting_element->{token}->{di},
                                 index => $formatting_element->{token}->{index},
                                 ns => HTMLNS,
                                 local_name => $formatting_element->{token}->{tag_name},
                                 attr_list => $formatting_element->{token}->{attr_list},
                                 et => $Element2Type->[HTMLNS]->{$formatting_element->{token}->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}};
              $new_element->{aet} = $new_element->{et};
              push @$OP,
                  ['create', $new_element],
                  ['move-children', $furthest_block->{id} => $new_element->{id}],
                  ['append', $new_element->{id} => $furthest_block->{id}];
              ## As $formatting_element is always a formatting element,
              ## it can't be a form-associated element.  Note that
              ## /intended parent/ is $furthest_block.
  
              if ($bookmark <= $formatting_element_afe_i) {
                splice @$AFE, $formatting_element_afe_i, 1, ();
                splice @$AFE, $bookmark, 0, $new_element;
              } else {
                splice @$AFE, $bookmark, 0, $new_element;
                splice @$AFE, $formatting_element_afe_i, 1, ();
                $bookmark--;
              }
  
              if ($formatting_element_i < $furthest_block_i) {
                splice @$OE, $furthest_block_i + 1, 0, ($new_element);
                #push @popped,
                splice @$OE, $formatting_element_i, 1, ();
                $furthest_block_i--;
              } else {
                #push @popped,
                splice @$OE, $formatting_element_i, 1, ();
                splice @$OE, $furthest_block_i + 1, 0, ($new_element);
              }
  
              redo OUTER_LOOP;
            } # OUTER_LOOP
          }
        
  
          sub reconstruct_afe () {
            #return unless @$AFE;
            #return if not ref $AFE->[-1];
            for (reverse @$OE) {
              return if $_ eq $AFE->[-1];
            }
            my $entry_i = $#$AFE;
            my $entry = $AFE->[$entry_i];
            E: {
              last E if $entry_i == 0;
              $entry_i--;
              $entry = $AFE->[$entry_i];
              ($entry_i++, last E) if not ref $entry;
              for (reverse @$OE) {
                ($entry_i++, last E) if $_ eq $entry;
              }
              redo E;
            } # E
  
            for my $entry_i ($entry_i..$#$AFE) {
              $entry = $AFE->[$entry_i];
  
              ## Insert an HTML element
              my $node = {id => $NEXT_ID++,
                          token => $entry->{token},
                          di => $entry->{token}->{di},
                          index => $entry->{token}->{index},
                          ns => HTMLNS,
                          local_name => $entry->{token}->{tag_name},
                          attr_list => $entry->{token}->{attr_list},
                          et => $Element2Type->[HTMLNS]->{$entry->{token}->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}};
              $node->{aet} = $node->{et};
              
        push @$OP, ['insert', $node => $OE->[-1]->{id}];
      
              push @$OE, $node;
  
              $AFE->[$entry_i] = $node;
            }
          }
        
  
          sub reconstruct_afe_foster () {
            #return unless @$AFE;
            #return if not ref $AFE->[-1];
            for (reverse @$OE) {
              return if $_ eq $AFE->[-1];
            }
            my $entry_i = $#$AFE;
            my $entry = $AFE->[$entry_i];
            E: {
              last E if $entry_i == 0;
              $entry_i--;
              $entry = $AFE->[$entry_i];
              ($entry_i++, last E) if not ref $entry;
              for (reverse @$OE) {
                ($entry_i++, last E) if $_ eq $entry;
              }
              redo E;
            } # E
  
            for my $entry_i ($entry_i..$#$AFE) {
              $entry = $AFE->[$entry_i];
  
              ## Insert an HTML element
              my $node = {id => $NEXT_ID++,
                          token => $entry->{token},
                          di => $entry->{token}->{di},
                          index => $entry->{token}->{index},
                          ns => HTMLNS,
                          local_name => $entry->{token}->{tag_name},
                          attr_list => $entry->{token}->{attr_list},
                          et => $Element2Type->[HTMLNS]->{$entry->{token}->{tag_name}} || $Element2Type->[HTMLNS]->{'*'}};
              $node->{aet} = $node->{et};
              
        if ($OE->[-1]->{et} & (TAB_ELS | TBO_TFO_THE_ELS | TR_ELS)) { # table* context
          FOSTER: {
            for my $i (reverse 1..$#$OE) {
              if ($OE->[$i]->{et} & (TAB_ELS)) { # table
                push @$OP, ['insert-foster', $node => $OE->[$i]->{id}, $OE->[$i-1]->{id}];
                last FOSTER;
              } elsif ($OE->[$i]->{et} & (TEM_ELS)) { # template
                push @$OP, ['insert', $node => $OE->[$i]->{id}];
                last FOSTER;
              }
            }
            push @$OP, ['insert', $node => $OE->[0]->{id}];
          } # FOSTER
        } else {
          push @$OP, ['insert', $node => $OE->[-1]->{id}];
        }
      
              push @$OE, $node;
  
              $AFE->[$entry_i] = $node;
            }
          }
        my $StateByElementName = {'iframe' => RAWTEXT_STATE, 'noembed' => RAWTEXT_STATE, 'noframes' => RAWTEXT_STATE, 'plaintext' => PLAINTEXT_STATE, 'script' => SCRIPT_DATA_STATE, 'style' => RAWTEXT_STATE, 'textarea' => RCDATA_STATE, 'title' => RCDATA_STATE, 'xmp' => RAWTEXT_STATE, };
  
      ## ------ Input byte stream ------
      
  
  ## ------ Character encoding processing ------
  
  sub locale_tag ($;$) {
    if (@_ > 1) {
      $_[0]->{locale_tag} = $_[1];
      $_[0]->{locale_tag} =~ tr/A-Z/a-z/ if defined $_[0]->{locale_tag};
    }
    return $_[0]->{locale_tag};
  } # locale_tag
  
  sub known_definite_encoding ($;$) {
    if (@_ > 1) {
      $_[0]->{known_definite_encoding} = $_[1];
    }
    return $_[0]->{known_definite_encoding};
  } # known_definite_encoding
  
  sub is_xhr ($;$) {
    if (@_ > 1) {
      $_[0]->{is_xhr} = $_[1];
    }
    return $_[0]->{is_xhr};
  } # is_xhr
  
  sub _encoding_sniffing ($;%) {
    my ($self, %args) = @_;
  
    return if $args{no_body_data_yet};
    ## $args{no_body_data_yet} flag must be set to true if the body of
    ## the resource is not available to the parser such that
    ## $args{read_head} callback ought not be invoked yet.
  
    ## <HTML>
    my $sniffer = Web::Encoding::Sniffer->new_from_context
        ($self->{is_xhr} ? 'responsehtml' : 'html');
    ## </HTML>
    $sniffer->detect (
      ## $args{read_head} must be a callback which, when invoked,
      ## returns a byte string used to sniff the character encoding of
      ## the input stream.  As described in the HTML Standard, it should
      ## be at most 1024 bytes.  The callback should not invoke sync
      ## I/O.  This method should be invoked with
      ## $args{no_body_data_yet} flag unset only after 500ms has past or
      ## 1024 bytes has been received.  The callback should not invoke
      ## any exception.
      ${$args{read_head}->()},
  
      ## One of followings:
      ##   - Step 1. User-specified encoding
      ##   - The new character encoding by change the encoding
      ##     <https://www.whatwg.org/specs/web-apps/current-work/#change-the-encoding>
      ##     step 5. Encoding from <meta charset>
      ##   - XHR override charset
      override => $self->known_definite_encoding,
  
      ## $args{transport_encoding_name} must be specified iff the
      ## underlying protocol provides the character encoding for the
      ## input stream.  For HTTP, the |charset=""| parameter in the
      ## |Content-Type:| header specifies the character encoding.  The
      ## value is interpreted as an encoding name or alias defined in
      ## the Encoding Standard.  (Invalid encoding name will be
      ## ignored.)
      transport => $args{transport_encoding_name},
  
      #reference
  
      embed => undef,
      # XXX
      #do {
      #  if ($args{parent_document}) {
      #    ## $args{parent_document}, if specified, must be the |Document|
      #    ## through which the new (to be parsed) document is nested, or the
      #    ## active document of the parent browsing context of the new
      #    ## document.
      #    if $args{parent_document}->origin equals $self->document->origin and
      #       $args{parent_document}->charset is ASCII compatible {
      #      $args{parent_document}->charset; # XXX if "replacement"
      #    }
      #  } elsif ($args{history_encoding_name}) {
      #    ## EXPERIMENTAL: $args{get_history_encoding_name}, if specified,
      #    ## must be a callback which returns the canonical character
      #    ## encoding name for the input stream, guessed by e.g. last visit
      #    ## to this page.
      #    $args{history_encoding_name}; # XXX if "replacement"
      #  }
      #},
  
      locale => $self->locale_tag,
  
    );
    $self->{input_encoding} = $sniffer->encoding;
    $Confident = $sniffer->confident;
    # XXX export $sniffer->source for validator
  } # _encoding_sniffing
  
  sub _change_the_encoding ($$$) {
    my ($self, $name, $attr) = @_;
  
    ## "meta" start tag
    ## <http://www.whatwg.org/specs/web-apps/current-work/#parsing-main-inhead>.
  
    ## "meta". Confidence is /tentative/
    #return undef if $Confident; # certain or irrelevant
  
    $name = Web::Encoding::encoding_label_to_name $name;
    unless (defined $name) {
      ## "meta". Supported encoding
      return undef;
    }
  
    ## "meta". ASCII-compatible or UTF-16
    ## All encodings in Encoding Standard are ASCII-compatible or UTF-16.
  
    ## Change the encoding
    ## <http://www.whatwg.org/specs/web-apps/current-work/#change-the-encoding>.
  
    ## Step 1. UTF-16
    if (Web::Encoding::is_utf16_encoding_key $self->{input_encoding}) {
      $Confident = 1; # certain
      return undef;
    }
  
    ## Step 2.-3.
    $name = Web::Encoding::fixup_html_meta_encoding_name $name;
    
    ## Step 4. Same
    if ($name eq $self->{input_encoding}) {
      $Confident = 1; # certain
      return undef;
    }
  
    push @$Errors, {type => 'charset label detected',
                    text => $self->{input_encoding},
                    value => $name,
                    level => 'i',
                    di => $attr->{di}, index => $attr->{index}};
  
    ## Step 5. Change the encoding on the fly
    ## Not implemented.
  
    ## Step 6. Navigate with replace.
    return $name; # change!
  
    ### Step 6. If can't restart
    #$Confident = 1; # certain
    #return undef;
  } # _change_the_encoding
  
      sub di_data_set ($;$) {
        if (@_ > 1) {
          $_[0]->{di_data_set} = $_[1];
        }
        return $_[0]->{di_data_set} ||= [];
      } # di_data_set
  
      sub di ($;$) {
        if (@_ > 1) {
          $_[0]->{di} = $_[1];
        }
        return $_[0]->{di}; # or undef
      } # di
  
    
      ## ------ Tokenizer ------
      
      my $StateActions = [];
      $StateActions->[CDATA_SECTION_BRACKET_STATE] = sub {
  if ($Input =~ /\G([\])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@]@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 1};
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@
  @,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  $State = CDATA_SECTION_STATE_CR;
  } elsif ($Input =~ /\G([\]])/gcs) {
  $State = CDATA_SECTION_END_STATE;
  } elsif ($Input =~ /\G(.)/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@]@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 1};
          
  $State = CDATA_SECTION_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } else {
  if ($EOF) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@]@,
                            di => $DI, index => $Offset + (pos $Input) - 1};
          
  $State = CDATA_SECTION_STATE;
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[CDATA_SECTION_END_STATE] = sub {
  if ($Input =~ /\G([\])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@]]@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 2};
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@
  @,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  $State = CDATA_SECTION_STATE_CR;
  } elsif ($Input =~ /\G([\>])/gcs) {
  $State = DATA_STATE;
  } elsif ($Input =~ /\G([\]])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@]@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 2};
          
  } elsif ($Input =~ /\G(.)/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@]]@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 2};
          
  $State = CDATA_SECTION_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } else {
  if ($EOF) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@]]@,
                            di => $DI, index => $Offset + (pos $Input) - 2};
          
  $State = CDATA_SECTION_STATE;
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[CDATA_SECTION_STATE] = sub {
  if ($Input =~ /\G([^\\]]+)/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  
  } elsif ($Input =~ /\G([\])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@
  @,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  $State = CDATA_SECTION_STATE_CR;
  } elsif ($Input =~ /\G([\]])/gcs) {
  $State = CDATA_SECTION_BRACKET_STATE;
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[CDATA_SECTION_STATE_CR] = sub {
  if ($Input =~ /\G([\
  ])/gcs) {
  $State = CDATA_SECTION_STATE;
  } elsif ($Input =~ /\G([\])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@
  @,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  $State = CDATA_SECTION_STATE_CR;
  } elsif ($Input =~ /\G([\]])/gcs) {
  $State = CDATA_SECTION_BRACKET_STATE;
  } elsif ($Input =~ /\G(.)/gcs) {
  $State = CDATA_SECTION_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } else {
  if ($EOF) {
  $State = CDATA_SECTION_STATE;
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[DOCTYPE_NAME_STATE] = sub {
  if ($Input =~ /\G([^\	\\ \
  \\>ABCDEFGHJKNQRVWZILMOPSTUXY\ ]+)/gcs) {
  $Token->{q<name>} .= $1;
  
  } elsif ($Input =~ /\G([\	\\ \
  \])/gcs) {
  $State = A_DOCTYPE_NAME_STATE;
  } elsif ($Input =~ /\G([\>])/gcs) {
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {
  $Token->{q<name>} .= chr ((ord $1) + 32);
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<name>} .= q@@;
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  $Token->{q<force_quirks_flag>} = 1;
  push @$Tokens, $Token;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[DOCTYPE_PUBLIC_ID__DQ__STATE] = sub {
  if ($Input =~ /\G([^\\"\ \>]+)/gcs) {
  $Token->{q<public_identifier>} .= $1;
  
  } elsif ($Input =~ /\G([\])/gcs) {
  $Token->{q<public_identifier>} .= q@
  @;
  $State = DOCTYPE_PUBLIC_ID__DQ__STATE_CR;
  } elsif ($Input =~ /\G([\"])/gcs) {
  $State = A_DOCTYPE_PUBLIC_ID_STATE;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<public_identifier>} .= q@@;
  } elsif ($Input =~ /\G([\>])/gcs) {
  
              push @$Errors, {type => 'parser:literal not closed', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  $Token->{q<force_quirks_flag>} = 1;
  push @$Tokens, $Token;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[DOCTYPE_PUBLIC_ID__DQ__STATE_CR] = sub {
  if ($Input =~ /\G([\
  ])/gcs) {
  $State = DOCTYPE_PUBLIC_ID__DQ__STATE;
  } elsif ($Input =~ /\G([\])/gcs) {
  $Token->{q<public_identifier>} .= q@
  @;
  $State = DOCTYPE_PUBLIC_ID__DQ__STATE_CR;
  } elsif ($Input =~ /\G([\"])/gcs) {
  $State = A_DOCTYPE_PUBLIC_ID_STATE;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  $State = DOCTYPE_PUBLIC_ID__DQ__STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<public_identifier>} .= q@@;
  } elsif ($Input =~ /\G([\>])/gcs) {
  
              push @$Errors, {type => 'parser:literal not closed', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G(.)/gcs) {
  $State = DOCTYPE_PUBLIC_ID__DQ__STATE;
  $Token->{q<public_identifier>} .= $1;
  } else {
  if ($EOF) {
  $State = DOCTYPE_PUBLIC_ID__DQ__STATE;
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  $Token->{q<force_quirks_flag>} = 1;
  push @$Tokens, $Token;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[DOCTYPE_PUBLIC_ID__SQ__STATE] = sub {
  if ($Input =~ /\G([^\\'\ \>]+)/gcs) {
  $Token->{q<public_identifier>} .= $1;
  
  } elsif ($Input =~ /\G([\])/gcs) {
  $Token->{q<public_identifier>} .= q@
  @;
  $State = DOCTYPE_PUBLIC_ID__SQ__STATE_CR;
  } elsif ($Input =~ /\G([\'])/gcs) {
  $State = A_DOCTYPE_PUBLIC_ID_STATE;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<public_identifier>} .= q@@;
  } elsif ($Input =~ /\G([\>])/gcs) {
  
              push @$Errors, {type => 'parser:literal not closed', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  $Token->{q<force_quirks_flag>} = 1;
  push @$Tokens, $Token;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[DOCTYPE_PUBLIC_ID__SQ__STATE_CR] = sub {
  if ($Input =~ /\G([\
  ])/gcs) {
  $State = DOCTYPE_PUBLIC_ID__SQ__STATE;
  } elsif ($Input =~ /\G([\])/gcs) {
  $Token->{q<public_identifier>} .= q@
  @;
  $State = DOCTYPE_PUBLIC_ID__SQ__STATE_CR;
  } elsif ($Input =~ /\G([\'])/gcs) {
  $State = A_DOCTYPE_PUBLIC_ID_STATE;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  $State = DOCTYPE_PUBLIC_ID__SQ__STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<public_identifier>} .= q@@;
  } elsif ($Input =~ /\G([\>])/gcs) {
  
              push @$Errors, {type => 'parser:literal not closed', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G(.)/gcs) {
  $State = DOCTYPE_PUBLIC_ID__SQ__STATE;
  $Token->{q<public_identifier>} .= $1;
  } else {
  if ($EOF) {
  $State = DOCTYPE_PUBLIC_ID__SQ__STATE;
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  $Token->{q<force_quirks_flag>} = 1;
  push @$Tokens, $Token;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[DOCTYPE_STATE] = sub {
  if ($Input =~ /\G([\	\\ \
  \])/gcs) {
  $State = B_DOCTYPE_NAME_STATE;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => DOCTYPE_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<name>} = q@@;
  $State = DOCTYPE_NAME_STATE;
  } elsif ($Input =~ /\G([\>])/gcs) {
  
              push @$Errors, {type => 'no DOCTYPE name', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => DOCTYPE_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<force_quirks_flag>} = 1;
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {
  
              push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => DOCTYPE_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<name>} = chr ((ord $1) + 32);
  $State = DOCTYPE_NAME_STATE;
  } elsif ($Input =~ /\G(.)/gcs) {
  
              push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => DOCTYPE_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<name>} = $1;
  $State = DOCTYPE_NAME_STATE;
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
          $Token = {type => DOCTYPE_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<force_quirks_flag>} = 1;
  push @$Tokens, $Token;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[DOCTYPE_SYSTEM_ID__DQ__STATE] = sub {
  if ($Input =~ /\G([^\\"\ \>]+)/gcs) {
  $Token->{q<system_identifier>} .= $1;
  
  } elsif ($Input =~ /\G([\])/gcs) {
  $Token->{q<system_identifier>} .= q@
  @;
  $State = DOCTYPE_SYSTEM_ID__DQ__STATE_CR;
  } elsif ($Input =~ /\G([\"])/gcs) {
  $State = A_DOCTYPE_SYSTEM_ID_STATE;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<system_identifier>} .= q@@;
  } elsif ($Input =~ /\G([\>])/gcs) {
  
              push @$Errors, {type => 'parser:literal not closed', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  $Token->{q<force_quirks_flag>} = 1;
  push @$Tokens, $Token;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[DOCTYPE_SYSTEM_ID__DQ__STATE_CR] = sub {
  if ($Input =~ /\G([\
  ])/gcs) {
  $State = DOCTYPE_SYSTEM_ID__DQ__STATE;
  } elsif ($Input =~ /\G([\])/gcs) {
  $Token->{q<system_identifier>} .= q@
  @;
  $State = DOCTYPE_SYSTEM_ID__DQ__STATE_CR;
  } elsif ($Input =~ /\G([\"])/gcs) {
  $State = A_DOCTYPE_SYSTEM_ID_STATE;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  $State = DOCTYPE_SYSTEM_ID__DQ__STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<system_identifier>} .= q@@;
  } elsif ($Input =~ /\G([\>])/gcs) {
  
              push @$Errors, {type => 'parser:literal not closed', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G(.)/gcs) {
  $State = DOCTYPE_SYSTEM_ID__DQ__STATE;
  $Token->{q<system_identifier>} .= $1;
  } else {
  if ($EOF) {
  $State = DOCTYPE_SYSTEM_ID__DQ__STATE;
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  $Token->{q<force_quirks_flag>} = 1;
  push @$Tokens, $Token;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[DOCTYPE_SYSTEM_ID__SQ__STATE] = sub {
  if ($Input =~ /\G([^\\'\ \>]+)/gcs) {
  $Token->{q<system_identifier>} .= $1;
  
  } elsif ($Input =~ /\G([\])/gcs) {
  $Token->{q<system_identifier>} .= q@
  @;
  $State = DOCTYPE_SYSTEM_ID__SQ__STATE_CR;
  } elsif ($Input =~ /\G([\'])/gcs) {
  $State = A_DOCTYPE_SYSTEM_ID_STATE;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<system_identifier>} .= q@@;
  } elsif ($Input =~ /\G([\>])/gcs) {
  
              push @$Errors, {type => 'parser:literal not closed', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  $Token->{q<force_quirks_flag>} = 1;
  push @$Tokens, $Token;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[DOCTYPE_SYSTEM_ID__SQ__STATE_CR] = sub {
  if ($Input =~ /\G([\
  ])/gcs) {
  $State = DOCTYPE_SYSTEM_ID__SQ__STATE;
  } elsif ($Input =~ /\G([\])/gcs) {
  $Token->{q<system_identifier>} .= q@
  @;
  $State = DOCTYPE_SYSTEM_ID__SQ__STATE_CR;
  } elsif ($Input =~ /\G([\'])/gcs) {
  $State = A_DOCTYPE_SYSTEM_ID_STATE;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  $State = DOCTYPE_SYSTEM_ID__SQ__STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<system_identifier>} .= q@@;
  } elsif ($Input =~ /\G([\>])/gcs) {
  
              push @$Errors, {type => 'parser:literal not closed', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G(.)/gcs) {
  $State = DOCTYPE_SYSTEM_ID__SQ__STATE;
  $Token->{q<system_identifier>} .= $1;
  } else {
  if ($EOF) {
  $State = DOCTYPE_SYSTEM_ID__SQ__STATE;
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  $Token->{q<force_quirks_flag>} = 1;
  push @$Tokens, $Token;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[PLAINTEXT_STATE] = sub {
  if ($Input =~ /\G([^\\ ]+)/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  
  } elsif ($Input =~ /\G([\])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@
  @,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  $State = PLAINTEXT_STATE_CR;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  } else {
  if ($EOF) {
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[PLAINTEXT_STATE_CR] = sub {
  if ($Input =~ /\G([\
  ])/gcs) {
  $State = PLAINTEXT_STATE;
  } elsif ($Input =~ /\G([\])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@
  @,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  $State = PLAINTEXT_STATE_CR;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  $State = PLAINTEXT_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  } elsif ($Input =~ /\G(.)/gcs) {
  $State = PLAINTEXT_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } else {
  if ($EOF) {
  $State = PLAINTEXT_STATE;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[RAWTEXT_END_TAG_NAME_STATE] = sub {
  if ($Input =~ /\G([\	\\ \
  ])/gcs) {
  
            if (defined $LastStartTagName and
                $Token->{tag_name} eq $LastStartTagName) {
              $State = B_ATTR_NAME_STATE;
              return 1;
            }
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@</@,
                            di => $DI, index => $AnchoredIndex};
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = RAWTEXT_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } elsif ($Input =~ /\G([\])/gcs) {
  
            if (defined $LastStartTagName and
                $Token->{tag_name} eq $LastStartTagName) {
              $State = B_ATTR_NAME_STATE;
              return 1;
            }
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@</@,
                            di => $DI, index => $AnchoredIndex};
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@
  @,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  $State = RAWTEXT_STATE_CR;
  } elsif ($Input =~ /\G([\/])/gcs) {
  
            if (defined $LastStartTagName and
                $Token->{tag_name} eq $LastStartTagName) {
              $State = SELF_CLOSING_START_TAG_STATE;
              return 1;
            }
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@</@,
                            di => $DI, index => $AnchoredIndex};
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = RAWTEXT_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } elsif ($Input =~ /\G([\<])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@</@,
                            di => $DI, index => $AnchoredIndex};
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = RAWTEXT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  } elsif ($Input =~ /\G([\>])/gcs) {
  
          if (defined $LastStartTagName and
              $Token->{tag_name} eq $LastStartTagName) {
            $State = DATA_STATE;
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            push @$Tokens, $Token;
            return 1;
          }
        
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@</@,
                            di => $DI, index => $AnchoredIndex};
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = RAWTEXT_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {
  $Token->{q<tag_name>} .= chr ((ord $1) + 32);
  $Temp .= $1;
  } elsif ($Input =~ /\G([afbcdeghjknqrvwzilmopstuxy]+)/gcs) {
  $Token->{q<tag_name>} .= $1;
  $Temp .= $1;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@</@,
                            di => $DI, index => $AnchoredIndex};
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = RAWTEXT_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  } elsif ($Input =~ /\G(.)/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@</@,
                            di => $DI, index => $AnchoredIndex};
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = RAWTEXT_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } else {
  if ($EOF) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@</@,
                            di => $DI, index => $AnchoredIndex};
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = RAWTEXT_STATE;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[RAWTEXT_END_TAG_OPEN_STATE] = sub {
  if ($Input =~ /\G([\])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@</@,
                            di => $DI, index => $AnchoredIndex};
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@
  @,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  $State = RAWTEXT_STATE_CR;
  } elsif ($Input =~ /\G([\<])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@</@,
                            di => $DI, index => $AnchoredIndex};
          
  $State = RAWTEXT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  } elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {
  
          $Token = {type => END_TAG_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $State = RAWTEXT_END_TAG_NAME_STATE;
  $Token->{q<tag_name>} = chr ((ord $1) + 32);
  $Temp .= $1;
  } elsif ($Input =~ /\G([afbcdeghjknqrvwzilmopstuxy])/gcs) {
  
          $Token = {type => END_TAG_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $State = RAWTEXT_END_TAG_NAME_STATE;
  $Token->{q<tag_name>} = $1;
  $Temp .= $1;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@</@,
                            di => $DI, index => $AnchoredIndex};
          
  $State = RAWTEXT_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  } elsif ($Input =~ /\G(.)/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@</@,
                            di => $DI, index => $AnchoredIndex};
          
  $State = RAWTEXT_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } else {
  if ($EOF) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@</@,
                            di => $DI, index => $AnchoredIndex};
          
  $State = RAWTEXT_STATE;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[RAWTEXT_LESS_THAN_SIGN_STATE] = sub {
  if ($Input =~ /\G([\])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@<@,
                            di => $DI, index => $AnchoredIndex};
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@
  @,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  $State = RAWTEXT_STATE_CR;
  } elsif ($Input =~ /\G([\/])/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = RAWTEXT_END_TAG_OPEN_STATE;
  } elsif ($Input =~ /\G([\<])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@<@,
                            di => $DI, index => $AnchoredIndex};
          
  $State = RAWTEXT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@<@,
                            di => $DI, index => $AnchoredIndex};
          
  $State = RAWTEXT_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  } elsif ($Input =~ /\G(.)/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@<@,
                            di => $DI, index => $AnchoredIndex};
          
  $State = RAWTEXT_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } else {
  if ($EOF) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@<@,
                            di => $DI, index => $AnchoredIndex};
          
  $State = RAWTEXT_STATE;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[RAWTEXT_STATE] = sub {
  if ($Input =~ /\G([^\\<\ ]+)/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  
  } elsif ($Input =~ /\G([\])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@
  @,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  $State = RAWTEXT_STATE_CR;
  } elsif ($Input =~ /\G([\<])/gcs) {
  $State = RAWTEXT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  } else {
  if ($EOF) {
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[RAWTEXT_STATE_CR] = sub {
  if ($Input =~ /\G([\
  ])/gcs) {
  $State = RAWTEXT_STATE;
  } elsif ($Input =~ /\G([\])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@
  @,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  $State = RAWTEXT_STATE_CR;
  } elsif ($Input =~ /\G([\<])/gcs) {
  $State = RAWTEXT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  $State = RAWTEXT_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  } elsif ($Input =~ /\G(.)/gcs) {
  $State = RAWTEXT_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } else {
  if ($EOF) {
  $State = RAWTEXT_STATE;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[RCDATA_END_TAG_NAME_STATE] = sub {
  if ($Input =~ /\G([\	\\ \
  ])/gcs) {
  
            if (defined $LastStartTagName and
                $Token->{tag_name} eq $LastStartTagName) {
              $State = B_ATTR_NAME_STATE;
              return 1;
            }
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@</@,
                            di => $DI, index => $AnchoredIndex};
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = RCDATA_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } elsif ($Input =~ /\G([\])/gcs) {
  
            if (defined $LastStartTagName and
                $Token->{tag_name} eq $LastStartTagName) {
              $State = B_ATTR_NAME_STATE;
              return 1;
            }
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@</@,
                            di => $DI, index => $AnchoredIndex};
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@
  @,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  $State = RCDATA_STATE_CR;
  } elsif ($Input =~ /\G([\&])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@</@,
                            di => $DI, index => $AnchoredIndex};
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = CHARREF_IN_RCDATA_STATE;
  } elsif ($Input =~ /\G([\/])/gcs) {
  
            if (defined $LastStartTagName and
                $Token->{tag_name} eq $LastStartTagName) {
              $State = SELF_CLOSING_START_TAG_STATE;
              return 1;
            }
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@</@,
                            di => $DI, index => $AnchoredIndex};
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = RCDATA_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } elsif ($Input =~ /\G([\<])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@</@,
                            di => $DI, index => $AnchoredIndex};
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = RCDATA_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  } elsif ($Input =~ /\G([\>])/gcs) {
  
          if (defined $LastStartTagName and
              $Token->{tag_name} eq $LastStartTagName) {
            $State = DATA_STATE;
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            push @$Tokens, $Token;
            return 1;
          }
        
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@</@,
                            di => $DI, index => $AnchoredIndex};
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = RCDATA_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {
  $Token->{q<tag_name>} .= chr ((ord $1) + 32);
  $Temp .= $1;
  } elsif ($Input =~ /\G([afbcdeghjknqrvwzilmopstuxy]+)/gcs) {
  $Token->{q<tag_name>} .= $1;
  $Temp .= $1;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@</@,
                            di => $DI, index => $AnchoredIndex};
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = RCDATA_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  } elsif ($Input =~ /\G(.)/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@</@,
                            di => $DI, index => $AnchoredIndex};
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = RCDATA_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } else {
  if ($EOF) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@</@,
                            di => $DI, index => $AnchoredIndex};
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = RCDATA_STATE;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[RCDATA_END_TAG_OPEN_STATE] = sub {
  if ($Input =~ /\G([\])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@</@,
                            di => $DI, index => $AnchoredIndex};
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@
  @,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  $State = RCDATA_STATE_CR;
  } elsif ($Input =~ /\G([\&])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@</@,
                            di => $DI, index => $AnchoredIndex};
          
  $State = CHARREF_IN_RCDATA_STATE;
  } elsif ($Input =~ /\G([\<])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@</@,
                            di => $DI, index => $AnchoredIndex};
          
  $State = RCDATA_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  } elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {
  
          $Token = {type => END_TAG_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $State = RCDATA_END_TAG_NAME_STATE;
  $Token->{q<tag_name>} = chr ((ord $1) + 32);
  $Temp .= $1;
  } elsif ($Input =~ /\G([afbcdeghjknqrvwzilmopstuxy])/gcs) {
  
          $Token = {type => END_TAG_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $State = RCDATA_END_TAG_NAME_STATE;
  $Token->{q<tag_name>} = $1;
  $Temp .= $1;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@</@,
                            di => $DI, index => $AnchoredIndex};
          
  $State = RCDATA_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  } elsif ($Input =~ /\G(.)/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@</@,
                            di => $DI, index => $AnchoredIndex};
          
  $State = RCDATA_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } else {
  if ($EOF) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@</@,
                            di => $DI, index => $AnchoredIndex};
          
  $State = RCDATA_STATE;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[RCDATA_LESS_THAN_SIGN_STATE] = sub {
  if ($Input =~ /\G([\])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@<@,
                            di => $DI, index => $AnchoredIndex};
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@
  @,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  $State = RCDATA_STATE_CR;
  } elsif ($Input =~ /\G([\&])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@<@,
                            di => $DI, index => $AnchoredIndex};
          
  $State = CHARREF_IN_RCDATA_STATE;
  } elsif ($Input =~ /\G([\/])/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = RCDATA_END_TAG_OPEN_STATE;
  } elsif ($Input =~ /\G([\<])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@<@,
                            di => $DI, index => $AnchoredIndex};
          
  $State = RCDATA_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@<@,
                            di => $DI, index => $AnchoredIndex};
          
  $State = RCDATA_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  } elsif ($Input =~ /\G(.)/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@<@,
                            di => $DI, index => $AnchoredIndex};
          
  $State = RCDATA_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } else {
  if ($EOF) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@<@,
                            di => $DI, index => $AnchoredIndex};
          
  $State = RCDATA_STATE;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[RCDATA_STATE] = sub {
  if ($Input =~ /\G([^\\&\<\ ]+)/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  
  } elsif ($Input =~ /\G([\])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@
  @,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  $State = RCDATA_STATE_CR;
  } elsif ($Input =~ /\G([\&])/gcs) {
  $State = CHARREF_IN_RCDATA_STATE;
  } elsif ($Input =~ /\G([\<])/gcs) {
  $State = RCDATA_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  } else {
  if ($EOF) {
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[RCDATA_STATE___CHARREF_BEFORE_HEX_NUM_STATE] = sub {
  if ($Input =~ /\G([0123456789ABCDEFafbcde])/gcs) {
  $Temp .= $1;
  $State = RCDATA_STATE___CHARREF_HEX_NUM_STATE;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'bare hcro', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = RCDATA_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  } elsif ($Input =~ /\G([\])/gcs) {
  
              push @$Errors, {type => 'bare hcro', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@
  @,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  $State = RCDATA_STATE_CR;
  } elsif ($Input =~ /\G([\&])/gcs) {
  
              push @$Errors, {type => 'bare hcro', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = CHARREF_IN_RCDATA_STATE;
  } elsif ($Input =~ /\G([\<])/gcs) {
  
              push @$Errors, {type => 'bare hcro', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = RCDATA_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  } elsif ($Input =~ /\G(.)/gcs) {
  
              push @$Errors, {type => 'bare hcro', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = RCDATA_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'bare hcro', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = RCDATA_STATE;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[RCDATA_STATE___CHARREF_DECIMAL_NUM_STATE] = sub {
  if ($Input =~ /\G([0123456789]+)/gcs) {
  $Temp .= $1;
  } elsif ($Input =~ /\G([\;])/gcs) {
  
          my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = RCDATA_STATE;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = RCDATA_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  } elsif ($Input =~ /\G([\])/gcs) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@
  @,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  $State = RCDATA_STATE_CR;
  } elsif ($Input =~ /\G([\&])/gcs) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = CHARREF_IN_RCDATA_STATE;
  } elsif ($Input =~ /\G([\<])/gcs) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = RCDATA_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  } elsif ($Input =~ /\G(.)/gcs) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = RCDATA_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
          my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = RCDATA_STATE;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[RCDATA_STATE___CHARREF_HEX_NUM_STATE] = sub {
  if ($Input =~ /\G([0123456789ABCDEFafbcde]+)/gcs) {
  $Temp .= $1;
  } elsif ($Input =~ /\G([\;])/gcs) {
  
          my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = RCDATA_STATE;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = RCDATA_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  } elsif ($Input =~ /\G([\])/gcs) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@
  @,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  $State = RCDATA_STATE_CR;
  } elsif ($Input =~ /\G([\&])/gcs) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = CHARREF_IN_RCDATA_STATE;
  } elsif ($Input =~ /\G([\<])/gcs) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = RCDATA_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  } elsif ($Input =~ /\G(.)/gcs) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = RCDATA_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
          my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = RCDATA_STATE;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[RCDATA_STATE___CHARREF_NAME_STATE] = sub {
  if ($Input =~ /\G([\])/gcs) {
  
            my $return;
            REF: {
              ## 
  
              for (reverse (2 .. length $Temp)) {
                my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
                if (defined $value) {
                  my $temp_index = $TempIndex;
  
                  unless (';' eq substr $Temp, $_-1, 1) {
                    ## <HTML>
                    push @$Errors, {type => 'no refc',
                                    level => 'm',
                                    di => $DI,
                                    index => $TempIndex + $_};
                    ## </HTML>
  
                    ## A variant of |emit-temp|
                    push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                                    value => $value,
                                    di => $DI, index => $TempIndex};
                    $TempIndex += $_;
                    $value = '';
                  }
  
                  ## 
  
                  substr ($Temp, 0, $_) = $value;
                  last REF;
                }
              }
              if ($Temp =~ /;\z/) {
                push @$Errors, {level => 'm',
                                type => 'entity not declared',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                ## 
              }
            } # REF
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@
  @,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  $State = RCDATA_STATE_CR;
  return 1 if $return;
  } elsif ($Input =~ /\G([\&])/gcs) {
  
            my $return;
            REF: {
              ## 
  
              for (reverse (2 .. length $Temp)) {
                my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
                if (defined $value) {
                  my $temp_index = $TempIndex;
  
                  unless (';' eq substr $Temp, $_-1, 1) {
                    ## <HTML>
                    push @$Errors, {type => 'no refc',
                                    level => 'm',
                                    di => $DI,
                                    index => $TempIndex + $_};
                    ## </HTML>
  
                    ## A variant of |emit-temp|
                    push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                                    value => $value,
                                    di => $DI, index => $TempIndex};
                    $TempIndex += $_;
                    $value = '';
                  }
  
                  ## 
  
                  substr ($Temp, 0, $_) = $value;
                  last REF;
                }
              }
              if ($Temp =~ /;\z/) {
                push @$Errors, {level => 'm',
                                type => 'entity not declared',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                ## 
              }
            } # REF
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = CHARREF_IN_RCDATA_STATE;
  return 1 if $return;
  } elsif ($Input =~ /\G([0123456789]+)/gcs) {
  $Temp .= $1;
  } elsif ($Input =~ /\G([\;])/gcs) {
  $Temp .= $1;
  
            my $return;
            REF: {
              ## 
  
              for (reverse (2 .. length $Temp)) {
                my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
                if (defined $value) {
                  my $temp_index = $TempIndex;
  
                  unless (';' eq substr $Temp, $_-1, 1) {
                    ## <HTML>
                    push @$Errors, {type => 'no refc',
                                    level => 'm',
                                    di => $DI,
                                    index => $TempIndex + $_};
                    ## </HTML>
  
                    ## A variant of |emit-temp|
                    push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                                    value => $value,
                                    di => $DI, index => $TempIndex};
                    $TempIndex += $_;
                    $value = '';
                  }
  
                  ## 
  
                  substr ($Temp, 0, $_) = $value;
                  last REF;
                }
              }
              if ($Temp =~ /;\z/) {
                push @$Errors, {level => 'm',
                                type => 'entity not declared',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                ## 
              }
            } # REF
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = RCDATA_STATE;
  return 1 if $return;
  } elsif ($Input =~ /\G([\<])/gcs) {
  
            my $return;
            REF: {
              ## 
  
              for (reverse (2 .. length $Temp)) {
                my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
                if (defined $value) {
                  my $temp_index = $TempIndex;
  
                  unless (';' eq substr $Temp, $_-1, 1) {
                    ## <HTML>
                    push @$Errors, {type => 'no refc',
                                    level => 'm',
                                    di => $DI,
                                    index => $TempIndex + $_};
                    ## </HTML>
  
                    ## A variant of |emit-temp|
                    push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                                    value => $value,
                                    di => $DI, index => $TempIndex};
                    $TempIndex += $_;
                    $value = '';
                  }
  
                  ## 
  
                  substr ($Temp, 0, $_) = $value;
                  last REF;
                }
              }
              if ($Temp =~ /;\z/) {
                push @$Errors, {level => 'm',
                                type => 'entity not declared',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                ## 
              }
            } # REF
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = RCDATA_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  return 1 if $return;
  } elsif ($Input =~ /\G([\=])/gcs) {
  
            my $return;
            REF: {
              ## 
  
              for (reverse (2 .. length $Temp)) {
                my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
                if (defined $value) {
                  my $temp_index = $TempIndex;
  
                  unless (';' eq substr $Temp, $_-1, 1) {
                    ## <HTML>
                    push @$Errors, {type => 'no refc',
                                    level => 'm',
                                    di => $DI,
                                    index => $TempIndex + $_};
                    ## </HTML>
  
                    ## A variant of |emit-temp|
                    push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                                    value => $value,
                                    di => $DI, index => $TempIndex};
                    $TempIndex += $_;
                    $value = '';
                  }
  
                  ## 
  
                  substr ($Temp, 0, $_) = $value;
                  last REF;
                }
              }
              if ($Temp =~ /;\z/) {
                push @$Errors, {level => 'm',
                                type => 'entity not declared',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                ## 
              }
            } # REF
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = RCDATA_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  return 1 if $return;
  } elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY]+)/gcs) {
  $Temp .= $1;
  } elsif ($Input =~ /\G([afbcdeghjknqrvwzilmopstuxy]+)/gcs) {
  $Temp .= $1;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
            my $return;
            REF: {
              ## 
  
              for (reverse (2 .. length $Temp)) {
                my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
                if (defined $value) {
                  my $temp_index = $TempIndex;
  
                  unless (';' eq substr $Temp, $_-1, 1) {
                    ## <HTML>
                    push @$Errors, {type => 'no refc',
                                    level => 'm',
                                    di => $DI,
                                    index => $TempIndex + $_};
                    ## </HTML>
  
                    ## A variant of |emit-temp|
                    push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                                    value => $value,
                                    di => $DI, index => $TempIndex};
                    $TempIndex += $_;
                    $value = '';
                  }
  
                  ## 
  
                  substr ($Temp, 0, $_) = $value;
                  last REF;
                }
              }
              if ($Temp =~ /;\z/) {
                push @$Errors, {level => 'm',
                                type => 'entity not declared',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                ## 
              }
            } # REF
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = RCDATA_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  return 1 if $return;
  } elsif ($Input =~ /\G(.)/gcs) {
  
            my $return;
            REF: {
              ## 
  
              for (reverse (2 .. length $Temp)) {
                my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
                if (defined $value) {
                  my $temp_index = $TempIndex;
  
                  unless (';' eq substr $Temp, $_-1, 1) {
                    ## <HTML>
                    push @$Errors, {type => 'no refc',
                                    level => 'm',
                                    di => $DI,
                                    index => $TempIndex + $_};
                    ## </HTML>
  
                    ## A variant of |emit-temp|
                    push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                                    value => $value,
                                    di => $DI, index => $TempIndex};
                    $TempIndex += $_;
                    $value = '';
                  }
  
                  ## 
  
                  substr ($Temp, 0, $_) = $value;
                  last REF;
                }
              }
              if ($Temp =~ /;\z/) {
                push @$Errors, {level => 'm',
                                type => 'entity not declared',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                ## 
              }
            } # REF
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = RCDATA_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  return 1 if $return;
  } else {
  if ($EOF) {
  
            my $return;
            REF: {
              ## 
  
              for (reverse (2 .. length $Temp)) {
                my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
                if (defined $value) {
                  my $temp_index = $TempIndex;
  
                  unless (';' eq substr $Temp, $_-1, 1) {
                    ## <HTML>
                    push @$Errors, {type => 'no refc',
                                    level => 'm',
                                    di => $DI,
                                    index => $TempIndex + $_};
                    ## </HTML>
  
                    ## A variant of |emit-temp|
                    push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                                    value => $value,
                                    di => $DI, index => $TempIndex};
                    $TempIndex += $_;
                    $value = '';
                  }
  
                  ## 
  
                  substr ($Temp, 0, $_) = $value;
                  last REF;
                }
              }
              if ($Temp =~ /;\z/) {
                push @$Errors, {level => 'm',
                                type => 'entity not declared',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                ## 
              }
            } # REF
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = RCDATA_STATE;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[RCDATA_STATE___CHARREF_NUM_STATE] = sub {
  if ($Input =~ /\G([0123456789])/gcs) {
  $Temp .= $1;
  $State = RCDATA_STATE___CHARREF_DECIMAL_NUM_STATE;
  } elsif ($Input =~ /\G([X])/gcs) {
  $Temp .= $1;
  $State = RCDATA_STATE___CHARREF_BEFORE_HEX_NUM_STATE;
  } elsif ($Input =~ /\G([x])/gcs) {
  $Temp .= $1;
  $State = RCDATA_STATE___CHARREF_BEFORE_HEX_NUM_STATE;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'bare nero', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = RCDATA_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  } elsif ($Input =~ /\G([\])/gcs) {
  
              push @$Errors, {type => 'bare nero', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@
  @,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  $State = RCDATA_STATE_CR;
  } elsif ($Input =~ /\G([\&])/gcs) {
  
              push @$Errors, {type => 'bare nero', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = CHARREF_IN_RCDATA_STATE;
  } elsif ($Input =~ /\G([\<])/gcs) {
  
              push @$Errors, {type => 'bare nero', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = RCDATA_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  } elsif ($Input =~ /\G(.)/gcs) {
  
              push @$Errors, {type => 'bare nero', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = RCDATA_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'bare nero', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = RCDATA_STATE;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[RCDATA_STATE___CHARREF_STATE] = sub {
  if ($Input =~ /\G([\])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@
  @,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  $State = RCDATA_STATE_CR;
  } elsif ($Input =~ /\G([\#])/gcs) {
  $Temp .= $1;
  $State = RCDATA_STATE___CHARREF_NUM_STATE;
  } elsif ($Input =~ /\G([\&])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = CHARREF_IN_RCDATA_STATE;
  } elsif ($Input =~ /\G([0123456789])/gcs) {
  $Temp .= $1;
  $State = RCDATA_STATE___CHARREF_NAME_STATE;
  } elsif ($Input =~ /\G([\<])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = RCDATA_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  } elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {
  $Temp .= $1;
  $State = RCDATA_STATE___CHARREF_NAME_STATE;
  } elsif ($Input =~ /\G([afbcdeghjknqrvwzilmopstuxy])/gcs) {
  $Temp .= $1;
  $State = RCDATA_STATE___CHARREF_NAME_STATE;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = RCDATA_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  } elsif ($Input =~ /\G(.)/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = RCDATA_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } else {
  if ($EOF) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = RCDATA_STATE;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[RCDATA_STATE___CHARREF_STATE_CR] = sub {
  if ($Input =~ /\G([\
  ])/gcs) {
  $State = RCDATA_STATE___CHARREF_STATE;
  } elsif ($Input =~ /\G([\])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@
  @,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  $State = RCDATA_STATE_CR;
  } elsif ($Input =~ /\G([\#])/gcs) {
  $Temp .= $1;
  $State = RCDATA_STATE___CHARREF_NUM_STATE;
  } elsif ($Input =~ /\G([\&])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = CHARREF_IN_RCDATA_STATE;
  } elsif ($Input =~ /\G([0123456789])/gcs) {
  $Temp .= $1;
  $State = RCDATA_STATE___CHARREF_NAME_STATE;
  } elsif ($Input =~ /\G([\<])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = RCDATA_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  } elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {
  $Temp .= $1;
  $State = RCDATA_STATE___CHARREF_NAME_STATE;
  } elsif ($Input =~ /\G([afbcdeghjknqrvwzilmopstuxy])/gcs) {
  $Temp .= $1;
  $State = RCDATA_STATE___CHARREF_NAME_STATE;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = RCDATA_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  } elsif ($Input =~ /\G(.)/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = RCDATA_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } else {
  if ($EOF) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = RCDATA_STATE;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[RCDATA_STATE_CR] = sub {
  if ($Input =~ /\G([\
  ])/gcs) {
  $State = RCDATA_STATE;
  } elsif ($Input =~ /\G([\])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@
  @,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  $State = RCDATA_STATE_CR;
  } elsif ($Input =~ /\G([\&])/gcs) {
  $State = CHARREF_IN_RCDATA_STATE;
  } elsif ($Input =~ /\G([\<])/gcs) {
  $State = RCDATA_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  $State = RCDATA_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  } elsif ($Input =~ /\G(.)/gcs) {
  $State = RCDATA_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } else {
  if ($EOF) {
  $State = RCDATA_STATE;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[A_DOCTYPE_NAME_STATE] = sub {
  if ($Input =~ /\G([\	\\ \
  \]+)/gcs) {
  } elsif ($Input =~ /\G([\>])/gcs) {
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G([P])/gcs) {
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = A_DOCTYPE_NAME_STATE_P;
  } elsif ($Input =~ /\G([S])/gcs) {
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = A_DOCTYPE_NAME_STATE_S;
  } elsif ($Input =~ /\G([p])/gcs) {
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = A_DOCTYPE_NAME_STATE_P;
  } elsif ($Input =~ /\G([s])/gcs) {
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = A_DOCTYPE_NAME_STATE_S;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = BOGUS_DOCTYPE_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  } elsif ($Input =~ /\G(.)/gcs) {
  
              push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = BOGUS_DOCTYPE_STATE;
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  $Token->{q<force_quirks_flag>} = 1;
  push @$Tokens, $Token;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[A_DOCTYPE_NAME_STATE_P] = sub {
  if ($Input =~ /\G([U])/gcs) {
  $Temp .= $1;
  $State = A_DOCTYPE_NAME_STATE_PU;
  } elsif ($Input =~ /\G([u])/gcs) {
  $Temp .= $1;
  $State = A_DOCTYPE_NAME_STATE_PU;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = BOGUS_DOCTYPE_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  } elsif ($Input =~ /\G([\>])/gcs) {
  
              push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G(.)/gcs) {
  
              push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = BOGUS_DOCTYPE_STATE;
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = BOGUS_DOCTYPE_STATE;
  push @$Tokens, $Token;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[A_DOCTYPE_NAME_STATE_PU] = sub {
  if ($Input =~ /\G([B])/gcs) {
  $Temp .= $1;
  $State = A_DOCTYPE_NAME_STATE_PUB;
  } elsif ($Input =~ /\G([b])/gcs) {
  $Temp .= $1;
  $State = A_DOCTYPE_NAME_STATE_PUB;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = BOGUS_DOCTYPE_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  } elsif ($Input =~ /\G([\>])/gcs) {
  
              push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G(.)/gcs) {
  
              push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = BOGUS_DOCTYPE_STATE;
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = BOGUS_DOCTYPE_STATE;
  push @$Tokens, $Token;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[A_DOCTYPE_NAME_STATE_PUB] = sub {
  if ($Input =~ /\G([L])/gcs) {
  $Temp .= $1;
  $State = A_DOCTYPE_NAME_STATE_PUBL;
  } elsif ($Input =~ /\G([l])/gcs) {
  $Temp .= $1;
  $State = A_DOCTYPE_NAME_STATE_PUBL;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = BOGUS_DOCTYPE_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  } elsif ($Input =~ /\G([\>])/gcs) {
  
              push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G(.)/gcs) {
  
              push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = BOGUS_DOCTYPE_STATE;
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = BOGUS_DOCTYPE_STATE;
  push @$Tokens, $Token;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[A_DOCTYPE_NAME_STATE_PUBL] = sub {
  if ($Input =~ /\G([I])/gcs) {
  $Temp .= $1;
  $State = A_DOCTYPE_NAME_STATE_PUBLI;
  } elsif ($Input =~ /\G([i])/gcs) {
  $Temp .= $1;
  $State = A_DOCTYPE_NAME_STATE_PUBLI;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = BOGUS_DOCTYPE_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  } elsif ($Input =~ /\G([\>])/gcs) {
  
              push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G(.)/gcs) {
  
              push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = BOGUS_DOCTYPE_STATE;
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = BOGUS_DOCTYPE_STATE;
  push @$Tokens, $Token;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[A_DOCTYPE_NAME_STATE_PUBLI] = sub {
  if ($Input =~ /\G([C])/gcs) {
  $State = A_DOCTYPE_PUBLIC_KWD_STATE;
  } elsif ($Input =~ /\G([c])/gcs) {
  $State = A_DOCTYPE_PUBLIC_KWD_STATE;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = BOGUS_DOCTYPE_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  } elsif ($Input =~ /\G([\>])/gcs) {
  
              push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G(.)/gcs) {
  
              push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = BOGUS_DOCTYPE_STATE;
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = BOGUS_DOCTYPE_STATE;
  push @$Tokens, $Token;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[A_DOCTYPE_NAME_STATE_S] = sub {
  if ($Input =~ /\G([Y])/gcs) {
  $Temp .= $1;
  $State = A_DOCTYPE_NAME_STATE_SY;
  } elsif ($Input =~ /\G([y])/gcs) {
  $Temp .= $1;
  $State = A_DOCTYPE_NAME_STATE_SY;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = BOGUS_DOCTYPE_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  } elsif ($Input =~ /\G([\>])/gcs) {
  
              push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G(.)/gcs) {
  
              push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = BOGUS_DOCTYPE_STATE;
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = BOGUS_DOCTYPE_STATE;
  push @$Tokens, $Token;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[A_DOCTYPE_NAME_STATE_SY] = sub {
  if ($Input =~ /\G([S])/gcs) {
  $Temp .= $1;
  $State = A_DOCTYPE_NAME_STATE_SYS;
  } elsif ($Input =~ /\G([s])/gcs) {
  $Temp .= $1;
  $State = A_DOCTYPE_NAME_STATE_SYS;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = BOGUS_DOCTYPE_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  } elsif ($Input =~ /\G([\>])/gcs) {
  
              push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G(.)/gcs) {
  
              push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = BOGUS_DOCTYPE_STATE;
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = BOGUS_DOCTYPE_STATE;
  push @$Tokens, $Token;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[A_DOCTYPE_NAME_STATE_SYS] = sub {
  if ($Input =~ /\G([T])/gcs) {
  $Temp .= $1;
  $State = A_DOCTYPE_NAME_STATE_SYST;
  } elsif ($Input =~ /\G([t])/gcs) {
  $Temp .= $1;
  $State = A_DOCTYPE_NAME_STATE_SYST;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = BOGUS_DOCTYPE_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  } elsif ($Input =~ /\G([\>])/gcs) {
  
              push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G(.)/gcs) {
  
              push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = BOGUS_DOCTYPE_STATE;
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = BOGUS_DOCTYPE_STATE;
  push @$Tokens, $Token;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[A_DOCTYPE_NAME_STATE_SYST] = sub {
  if ($Input =~ /\G([E])/gcs) {
  $Temp .= $1;
  $State = A_DOCTYPE_NAME_STATE_SYSTE;
  } elsif ($Input =~ /\G([e])/gcs) {
  $Temp .= $1;
  $State = A_DOCTYPE_NAME_STATE_SYSTE;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = BOGUS_DOCTYPE_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  } elsif ($Input =~ /\G([\>])/gcs) {
  
              push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G(.)/gcs) {
  
              push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = BOGUS_DOCTYPE_STATE;
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = BOGUS_DOCTYPE_STATE;
  push @$Tokens, $Token;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[A_DOCTYPE_NAME_STATE_SYSTE] = sub {
  if ($Input =~ /\G([M])/gcs) {
  $State = A_DOCTYPE_SYSTEM_KWD_STATE;
  } elsif ($Input =~ /\G([m])/gcs) {
  $State = A_DOCTYPE_SYSTEM_KWD_STATE;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = BOGUS_DOCTYPE_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  } elsif ($Input =~ /\G([\>])/gcs) {
  
              push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G(.)/gcs) {
  
              push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = BOGUS_DOCTYPE_STATE;
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = BOGUS_DOCTYPE_STATE;
  push @$Tokens, $Token;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[A_DOCTYPE_PUBLIC_ID_STATE] = sub {
  if ($Input =~ /\G([\	\\ \
  \])/gcs) {
  $State = BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDS_STATE;
  } elsif ($Input =~ /\G([\>])/gcs) {
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = BOGUS_DOCTYPE_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  } elsif ($Input =~ /\G([\"])/gcs) {
  
              push @$Errors, {type => 'no space before literal', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<system_identifier>} = '';
  $State = DOCTYPE_SYSTEM_ID__DQ__STATE;
  } elsif ($Input =~ /\G([\'])/gcs) {
  
              push @$Errors, {type => 'no space before literal', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<system_identifier>} = '';
  $State = DOCTYPE_SYSTEM_ID__SQ__STATE;
  } elsif ($Input =~ /\G(.)/gcs) {
  
              push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = BOGUS_DOCTYPE_STATE;
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  $Token->{q<force_quirks_flag>} = 1;
  push @$Tokens, $Token;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[A_DOCTYPE_PUBLIC_KWD_STATE] = sub {
  if ($Input =~ /\G([\	\\ \
  \])/gcs) {
  $State = B_DOCTYPE_PUBLIC_ID_STATE;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = BOGUS_DOCTYPE_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  } elsif ($Input =~ /\G([\"])/gcs) {
  
              push @$Errors, {type => 'no space before literal', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<public_identifier>} = '';
  $State = DOCTYPE_PUBLIC_ID__DQ__STATE;
  } elsif ($Input =~ /\G([\'])/gcs) {
  
              push @$Errors, {type => 'no space before literal', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<public_identifier>} = '';
  $State = DOCTYPE_PUBLIC_ID__SQ__STATE;
  } elsif ($Input =~ /\G([\>])/gcs) {
  
              push @$Errors, {type => 'no DOCTYPE literal', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G(.)/gcs) {
  
              push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = BOGUS_DOCTYPE_STATE;
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  $Token->{q<force_quirks_flag>} = 1;
  push @$Tokens, $Token;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[A_DOCTYPE_SYSTEM_ID_STATE] = sub {
  if ($Input =~ /\G([\	\\ \
  \]+)/gcs) {
  } elsif ($Input =~ /\G([\>])/gcs) {
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $State = BOGUS_DOCTYPE_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  } elsif ($Input =~ /\G(.)/gcs) {
  
              push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $State = BOGUS_DOCTYPE_STATE;
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  $Token->{q<force_quirks_flag>} = 1;
  push @$Tokens, $Token;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[A_DOCTYPE_SYSTEM_KWD_STATE] = sub {
  if ($Input =~ /\G([\	\\ \
  \])/gcs) {
  $State = B_DOCTYPE_SYSTEM_ID_STATE;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = BOGUS_DOCTYPE_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  } elsif ($Input =~ /\G([\"])/gcs) {
  
              push @$Errors, {type => 'no space before literal', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<system_identifier>} = '';
  $State = DOCTYPE_SYSTEM_ID__DQ__STATE;
  } elsif ($Input =~ /\G([\'])/gcs) {
  
              push @$Errors, {type => 'no space before literal', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<system_identifier>} = '';
  $State = DOCTYPE_SYSTEM_ID__SQ__STATE;
  } elsif ($Input =~ /\G([\>])/gcs) {
  
              push @$Errors, {type => 'no DOCTYPE literal', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G(.)/gcs) {
  
              push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = BOGUS_DOCTYPE_STATE;
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  $Token->{q<force_quirks_flag>} = 1;
  push @$Tokens, $Token;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[A_ATTR_NAME_STATE] = sub {
  if ($Input =~ /\G([\	\\ \
  \]+)/gcs) {
  } elsif ($Input =~ /\G([\/])/gcs) {
  $State = SELF_CLOSING_START_TAG_STATE;
  } elsif ($Input =~ /\G([\=])/gcs) {
  $State = B_ATTR_VALUE_STATE;
  } elsif ($Input =~ /\G([\>])/gcs) {
  $State = DATA_STATE;
  
            if ($Token->{type} == END_TAG_TOKEN) {
              if (keys %{$Token->{attrs} or {}}) {
                push @$Errors, {type => 'end tag attribute',
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
              if ($Token->{self_closing_flag}) {
                push @$Errors, {type => 'nestc',
                                text => $Token->{tag_name},
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
            }
          
  push @$Tokens, $Token;
  
            if ($Token->{type} == START_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              if (not defined $LastStartTagName) { # "first start tag"
                $LastStartTagName = $Token->{tag_name};
                return 1;
              } else {
                $LastStartTagName = $Token->{tag_name};
              }
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
              return 1 if $Token->{tag_name} =~ /-/;
              return 1 if $Token->{attrs}->{is};
            }
          
  
            if ($Token->{type} == END_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              ## 
            }
          
  } elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {
  $Attr = {di => $DI};
  $Attr->{q<name>} = chr ((ord $1) + 32);
  $Attr->{index} = $Offset + (pos $Input) - length $1;
  $Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
  $State = ATTR_NAME_STATE;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  $Attr = {di => $DI};
  $Attr->{q<name>} = q@@;
  $Attr->{index} = $Offset + (pos $Input) - length $1;
  $Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
  $State = ATTR_NAME_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  } elsif ($Input =~ /\G([\"])/gcs) {
  $Attr = {di => $DI};
  $Attr->{q<name>} = $1;
  $Attr->{index} = $Offset + (pos $Input) - length $1;
  $Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
  $State = ATTR_NAME_STATE;
  
              push @$Errors, {type => 'bad attribute name', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  } elsif ($Input =~ /\G([\'])/gcs) {
  $Attr = {di => $DI};
  $Attr->{q<name>} = $1;
  $Attr->{index} = $Offset + (pos $Input) - length $1;
  $Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
  $State = ATTR_NAME_STATE;
  
              push @$Errors, {type => 'bad attribute name', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  } elsif ($Input =~ /\G([\<])/gcs) {
  $Attr = {di => $DI};
  $Attr->{q<name>} = $1;
  $Attr->{index} = $Offset + (pos $Input) - length $1;
  $Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
  $State = ATTR_NAME_STATE;
  
              push @$Errors, {type => 'tag not closed', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  } elsif ($Input =~ /\G(.)/gcs) {
  $Attr = {di => $DI};
  $Attr->{q<name>} = $1;
  $Attr->{index} = $Offset + (pos $Input) - length $1;
  $Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
  $State = ATTR_NAME_STATE;
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[A_ATTR_VALUE__QUOTED__STATE] = sub {
  if ($Input =~ /\G([\	\\ \
  \])/gcs) {
  $State = B_ATTR_NAME_STATE;
  } elsif ($Input =~ /\G([\/])/gcs) {
  $State = SELF_CLOSING_START_TAG_STATE;
  } elsif ($Input =~ /\G([\>])/gcs) {
  $State = DATA_STATE;
  
            if ($Token->{type} == END_TAG_TOKEN) {
              if (keys %{$Token->{attrs} or {}}) {
                push @$Errors, {type => 'end tag attribute',
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
              if ($Token->{self_closing_flag}) {
                push @$Errors, {type => 'nestc',
                                text => $Token->{tag_name},
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
            }
          
  push @$Tokens, $Token;
  
            if ($Token->{type} == START_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              if (not defined $LastStartTagName) { # "first start tag"
                $LastStartTagName = $Token->{tag_name};
                return 1;
              } else {
                $LastStartTagName = $Token->{tag_name};
              }
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
              return 1 if $Token->{tag_name} =~ /-/;
              return 1 if $Token->{attrs}->{is};
            }
          
  
            if ($Token->{type} == END_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              ## 
            }
          
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'no space before attr name', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Attr = {di => $DI};
  $Attr->{q<name>} = q@@;
  $Attr->{index} = $Offset + (pos $Input) - length $1;
  $Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
  $State = ATTR_NAME_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  } elsif ($Input =~ /\G([\"])/gcs) {
  
              push @$Errors, {type => 'no space before attr name', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Attr = {di => $DI};
  $Attr->{q<name>} = $1;
  $Attr->{index} = $Offset + (pos $Input) - length $1;
  $Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
  $State = ATTR_NAME_STATE;
  
              push @$Errors, {type => 'bad attribute name', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  } elsif ($Input =~ /\G([\'])/gcs) {
  
              push @$Errors, {type => 'no space before attr name', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Attr = {di => $DI};
  $Attr->{q<name>} = $1;
  $Attr->{index} = $Offset + (pos $Input) - length $1;
  $Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
  $State = ATTR_NAME_STATE;
  
              push @$Errors, {type => 'bad attribute name', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  } elsif ($Input =~ /\G([\<])/gcs) {
  
              push @$Errors, {type => 'no space before attr name', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Attr = {di => $DI};
  $Attr->{q<name>} = $1;
  $Attr->{index} = $Offset + (pos $Input) - length $1;
  $Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
  $State = ATTR_NAME_STATE;
  
              push @$Errors, {type => 'tag not closed', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  } elsif ($Input =~ /\G([\=])/gcs) {
  
              push @$Errors, {type => 'no space before attr name', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
              push @$Errors, {type => 'parser:no attr name', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Attr = {di => $DI};
  $Attr->{q<name>} = $1;
  $Attr->{index} = $Offset + (pos $Input) - length $1;
  $Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
  $State = ATTR_NAME_STATE;
  } elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {
  
              push @$Errors, {type => 'no space before attr name', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Attr = {di => $DI};
  $Attr->{q<name>} = chr ((ord $1) + 32);
  $Attr->{index} = $Offset + (pos $Input) - length $1;
  $Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
  $State = ATTR_NAME_STATE;
  } elsif ($Input =~ /\G(.)/gcs) {
  
              push @$Errors, {type => 'no space before attr name', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Attr = {di => $DI};
  $Attr->{q<name>} = $1;
  $Attr->{index} = $Offset + (pos $Input) - length $1;
  $Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
  $State = ATTR_NAME_STATE;
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[ATTR_NAME_STATE] = sub {
  if ($Input =~ /\G([^\	\\ \
  \\/\=\>ABCDEFGHJKNQRVWZILMOPSTUXY\ \"\'\<]+)/gcs) {
  $Attr->{q<name>} .= $1;
  
  } elsif ($Input =~ /\G[\	\
  \\\ ][\	\
  \\\ ]*\=[\	\
  \\\ ]*([^\ \	\
  \\\ \"\&\'\<\=\>\`])([^\ \	\
  \\\ \"\&\'\<\=\>\`]*)[\	\
  \\\ ][\	\
  \\\ ]*/gcs) {
  
          if (defined $Token->{attrs}->{$Attr->{name}}) {
            push @$Errors, {type => 'duplicate attribute',
                            text => $Attr->{name},
                            level => 'm',
                            di => $Attr->{di},
                            index => $Attr->{index}};
          } else {
            $Token->{attrs}->{$Attr->{name}} = $Attr;
            push @{$Token->{attr_list} ||= []}, $Attr;
            $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
          }
        
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + $-[1]];
  push @{$Attr->{q<value>}}, [$2, $DI, $Offset + $-[2]];
  $State = B_ATTR_NAME_STATE;
  } elsif ($Input =~ /\G[\	\
  \\\ ][\	\
  \\\ ]*\=[\	\
  \\\ ]*([^\ \	\
  \\\ \"\&\'\<\=\>\`])([^\ \	\
  \\\ \"\&\'\<\=\>\`]*)\>/gcs) {
  
          if (defined $Token->{attrs}->{$Attr->{name}}) {
            push @$Errors, {type => 'duplicate attribute',
                            text => $Attr->{name},
                            level => 'm',
                            di => $Attr->{di},
                            index => $Attr->{index}};
          } else {
            $Token->{attrs}->{$Attr->{name}} = $Attr;
            push @{$Token->{attr_list} ||= []}, $Attr;
            $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
          }
        
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + $-[1]];
  push @{$Attr->{q<value>}}, [$2, $DI, $Offset + $-[2]];
  $State = DATA_STATE;
  
            if ($Token->{type} == END_TAG_TOKEN) {
              if (keys %{$Token->{attrs} or {}}) {
                push @$Errors, {type => 'end tag attribute',
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
              if ($Token->{self_closing_flag}) {
                push @$Errors, {type => 'nestc',
                                text => $Token->{tag_name},
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
            }
          
  push @$Tokens, $Token;
  
            if ($Token->{type} == START_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              if (not defined $LastStartTagName) { # "first start tag"
                $LastStartTagName = $Token->{tag_name};
                return 1;
              } else {
                $LastStartTagName = $Token->{tag_name};
              }
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
              return 1 if $Token->{tag_name} =~ /-/;
              return 1 if $Token->{attrs}->{is};
            }
          
  
            if ($Token->{type} == END_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              ## 
            }
          
  } elsif ($Input =~ /\G\=[\	\
  \\\ ]*([^\ \	\
  \\\ \"\&\'\<\=\>\`])([^\ \	\
  \\\ \"\&\'\<\=\>\`]*)[\	\
  \\\ ][\	\
  \\\ ]*/gcs) {
  
          if (defined $Token->{attrs}->{$Attr->{name}}) {
            push @$Errors, {type => 'duplicate attribute',
                            text => $Attr->{name},
                            level => 'm',
                            di => $Attr->{di},
                            index => $Attr->{index}};
          } else {
            $Token->{attrs}->{$Attr->{name}} = $Attr;
            push @{$Token->{attr_list} ||= []}, $Attr;
            $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
          }
        
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + $-[1]];
  push @{$Attr->{q<value>}}, [$2, $DI, $Offset + $-[2]];
  $State = B_ATTR_NAME_STATE;
  } elsif ($Input =~ /\G[\	\
  \\\ ][\	\
  \\\ ]*([^\ \	\
  \\\ \"\'\/\<\=\>A-Z])([^\ \	\
  \\\ \"\'\/\<\=\>A-Z]*)/gcs) {
  
          if (defined $Token->{attrs}->{$Attr->{name}}) {
            push @$Errors, {type => 'duplicate attribute',
                            text => $Attr->{name},
                            level => 'm',
                            di => $Attr->{di},
                            index => $Attr->{index}};
          } else {
            $Token->{attrs}->{$Attr->{name}} = $Attr;
            push @{$Token->{attr_list} ||= []}, $Attr;
            $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
          }
        
  $State = A_ATTR_NAME_STATE;
  $Attr = {di => $DI};
  $Attr->{q<name>} = $1;
  $Attr->{index} = $Offset + $-[1];
  $Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
  $State = ATTR_NAME_STATE;
  $Attr->{q<name>} .= $2;
  } elsif ($Input =~ /\G[\	\
  \\\ ][\	\
  \\\ ]*\=[\	\
  \\\ ]*\"([^\ \\"\&]*)\"[\	\
  \\\ ][\	\
  \\\ ]*/gcs) {
  
          if (defined $Token->{attrs}->{$Attr->{name}}) {
            push @$Errors, {type => 'duplicate attribute',
                            text => $Attr->{name},
                            level => 'm',
                            di => $Attr->{di},
                            index => $Attr->{index}};
          } else {
            $Token->{attrs}->{$Attr->{name}} = $Attr;
            push @{$Token->{attr_list} ||= []}, $Attr;
            $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
          }
        
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + $-[1]];
  $State = B_ATTR_NAME_STATE;
  } elsif ($Input =~ /\G[\	\
  \\\ ][\	\
  \\\ ]*\=[\	\
  \\\ ]*\'([^\ \\&\']*)\'[\	\
  \\\ ][\	\
  \\\ ]*/gcs) {
  
          if (defined $Token->{attrs}->{$Attr->{name}}) {
            push @$Errors, {type => 'duplicate attribute',
                            text => $Attr->{name},
                            level => 'm',
                            di => $Attr->{di},
                            index => $Attr->{index}};
          } else {
            $Token->{attrs}->{$Attr->{name}} = $Attr;
            push @{$Token->{attr_list} ||= []}, $Attr;
            $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
          }
        
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + $-[1]];
  $State = B_ATTR_NAME_STATE;
  } elsif ($Input =~ /\G\=[\	\
  \\\ ]*([^\ \	\
  \\\ \"\&\'\<\=\>\`])([^\ \	\
  \\\ \"\&\'\<\=\>\`]*)\>/gcs) {
  
          if (defined $Token->{attrs}->{$Attr->{name}}) {
            push @$Errors, {type => 'duplicate attribute',
                            text => $Attr->{name},
                            level => 'm',
                            di => $Attr->{di},
                            index => $Attr->{index}};
          } else {
            $Token->{attrs}->{$Attr->{name}} = $Attr;
            push @{$Token->{attr_list} ||= []}, $Attr;
            $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
          }
        
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + $-[1]];
  push @{$Attr->{q<value>}}, [$2, $DI, $Offset + $-[2]];
  $State = DATA_STATE;
  
            if ($Token->{type} == END_TAG_TOKEN) {
              if (keys %{$Token->{attrs} or {}}) {
                push @$Errors, {type => 'end tag attribute',
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
              if ($Token->{self_closing_flag}) {
                push @$Errors, {type => 'nestc',
                                text => $Token->{tag_name},
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
            }
          
  push @$Tokens, $Token;
  
            if ($Token->{type} == START_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              if (not defined $LastStartTagName) { # "first start tag"
                $LastStartTagName = $Token->{tag_name};
                return 1;
              } else {
                $LastStartTagName = $Token->{tag_name};
              }
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
              return 1 if $Token->{tag_name} =~ /-/;
              return 1 if $Token->{attrs}->{is};
            }
          
  
            if ($Token->{type} == END_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              ## 
            }
          
  } elsif ($Input =~ /\G[\	\
  \\\ ][\	\
  \\\ ]*([A-Z])([^\ \	\
  \\\ \"\'\/\<\=\>A-Z]*)/gcs) {
  
          if (defined $Token->{attrs}->{$Attr->{name}}) {
            push @$Errors, {type => 'duplicate attribute',
                            text => $Attr->{name},
                            level => 'm',
                            di => $Attr->{di},
                            index => $Attr->{index}};
          } else {
            $Token->{attrs}->{$Attr->{name}} = $Attr;
            push @{$Token->{attr_list} ||= []}, $Attr;
            $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
          }
        
  $State = A_ATTR_NAME_STATE;
  $Attr = {di => $DI};
  $Attr->{q<name>} = chr ((ord $1) + 32);
  $Attr->{index} = $Offset + $-[1];
  $Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
  $State = ATTR_NAME_STATE;
  $Attr->{q<name>} .= $2;
  } elsif ($Input =~ /\G[\	\
  \\\ ][\	\
  \\\ ]*\=[\	\
  \\\ ]*\"([^\ \\"\&]*)\"\/\>/gcs) {
  
          if (defined $Token->{attrs}->{$Attr->{name}}) {
            push @$Errors, {type => 'duplicate attribute',
                            text => $Attr->{name},
                            level => 'm',
                            di => $Attr->{di},
                            index => $Attr->{index}};
          } else {
            $Token->{attrs}->{$Attr->{name}} = $Attr;
            push @{$Token->{attr_list} ||= []}, $Attr;
            $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
          }
        
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + $-[1]];
  $State = SELF_CLOSING_START_TAG_STATE;
  $Token->{q<self_closing_flag>} = 1;
  $State = DATA_STATE;
  
            if ($Token->{type} == END_TAG_TOKEN) {
              if (keys %{$Token->{attrs} or {}}) {
                push @$Errors, {type => 'end tag attribute',
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
              if ($Token->{self_closing_flag}) {
                push @$Errors, {type => 'nestc',
                                text => $Token->{tag_name},
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
            }
          
  push @$Tokens, $Token;
  
            if ($Token->{type} == START_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              if (not defined $LastStartTagName) { # "first start tag"
                $LastStartTagName = $Token->{tag_name};
                return 1;
              } else {
                $LastStartTagName = $Token->{tag_name};
              }
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
              return 1 if $Token->{tag_name} =~ /-/;
              return 1 if $Token->{attrs}->{is};
            }
          
  
            if ($Token->{type} == END_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              ## 
            }
          
  } elsif ($Input =~ /\G[\	\
  \\\ ][\	\
  \\\ ]*\=[\	\
  \\\ ]*\'([^\ \\&\']*)\'\/\>/gcs) {
  
          if (defined $Token->{attrs}->{$Attr->{name}}) {
            push @$Errors, {type => 'duplicate attribute',
                            text => $Attr->{name},
                            level => 'm',
                            di => $Attr->{di},
                            index => $Attr->{index}};
          } else {
            $Token->{attrs}->{$Attr->{name}} = $Attr;
            push @{$Token->{attr_list} ||= []}, $Attr;
            $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
          }
        
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + $-[1]];
  $State = SELF_CLOSING_START_TAG_STATE;
  $Token->{q<self_closing_flag>} = 1;
  $State = DATA_STATE;
  
            if ($Token->{type} == END_TAG_TOKEN) {
              if (keys %{$Token->{attrs} or {}}) {
                push @$Errors, {type => 'end tag attribute',
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
              if ($Token->{self_closing_flag}) {
                push @$Errors, {type => 'nestc',
                                text => $Token->{tag_name},
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
            }
          
  push @$Tokens, $Token;
  
            if ($Token->{type} == START_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              if (not defined $LastStartTagName) { # "first start tag"
                $LastStartTagName = $Token->{tag_name};
                return 1;
              } else {
                $LastStartTagName = $Token->{tag_name};
              }
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
              return 1 if $Token->{tag_name} =~ /-/;
              return 1 if $Token->{attrs}->{is};
            }
          
  
            if ($Token->{type} == END_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              ## 
            }
          
  } elsif ($Input =~ /\G[\	\
  \\\ ][\	\
  \\\ ]*\=[\	\
  \\\ ]*\"([^\ \\"\&]*)\"\>/gcs) {
  
          if (defined $Token->{attrs}->{$Attr->{name}}) {
            push @$Errors, {type => 'duplicate attribute',
                            text => $Attr->{name},
                            level => 'm',
                            di => $Attr->{di},
                            index => $Attr->{index}};
          } else {
            $Token->{attrs}->{$Attr->{name}} = $Attr;
            push @{$Token->{attr_list} ||= []}, $Attr;
            $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
          }
        
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + $-[1]];
  $State = DATA_STATE;
  
            if ($Token->{type} == END_TAG_TOKEN) {
              if (keys %{$Token->{attrs} or {}}) {
                push @$Errors, {type => 'end tag attribute',
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
              if ($Token->{self_closing_flag}) {
                push @$Errors, {type => 'nestc',
                                text => $Token->{tag_name},
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
            }
          
  push @$Tokens, $Token;
  
            if ($Token->{type} == START_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              if (not defined $LastStartTagName) { # "first start tag"
                $LastStartTagName = $Token->{tag_name};
                return 1;
              } else {
                $LastStartTagName = $Token->{tag_name};
              }
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
              return 1 if $Token->{tag_name} =~ /-/;
              return 1 if $Token->{attrs}->{is};
            }
          
  
            if ($Token->{type} == END_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              ## 
            }
          
  } elsif ($Input =~ /\G[\	\
  \\\ ][\	\
  \\\ ]*\=[\	\
  \\\ ]*\'([^\ \\&\']*)\'\>/gcs) {
  
          if (defined $Token->{attrs}->{$Attr->{name}}) {
            push @$Errors, {type => 'duplicate attribute',
                            text => $Attr->{name},
                            level => 'm',
                            di => $Attr->{di},
                            index => $Attr->{index}};
          } else {
            $Token->{attrs}->{$Attr->{name}} = $Attr;
            push @{$Token->{attr_list} ||= []}, $Attr;
            $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
          }
        
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + $-[1]];
  $State = DATA_STATE;
  
            if ($Token->{type} == END_TAG_TOKEN) {
              if (keys %{$Token->{attrs} or {}}) {
                push @$Errors, {type => 'end tag attribute',
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
              if ($Token->{self_closing_flag}) {
                push @$Errors, {type => 'nestc',
                                text => $Token->{tag_name},
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
            }
          
  push @$Tokens, $Token;
  
            if ($Token->{type} == START_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              if (not defined $LastStartTagName) { # "first start tag"
                $LastStartTagName = $Token->{tag_name};
                return 1;
              } else {
                $LastStartTagName = $Token->{tag_name};
              }
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
              return 1 if $Token->{tag_name} =~ /-/;
              return 1 if $Token->{attrs}->{is};
            }
          
  
            if ($Token->{type} == END_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              ## 
            }
          
  } elsif ($Input =~ /\G\=[\	\
  \\\ ]*\"([^\ \\"\&]*)\"[\	\
  \\\ ][\	\
  \\\ ]*/gcs) {
  
          if (defined $Token->{attrs}->{$Attr->{name}}) {
            push @$Errors, {type => 'duplicate attribute',
                            text => $Attr->{name},
                            level => 'm',
                            di => $Attr->{di},
                            index => $Attr->{index}};
          } else {
            $Token->{attrs}->{$Attr->{name}} = $Attr;
            push @{$Token->{attr_list} ||= []}, $Attr;
            $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
          }
        
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + $-[1]];
  $State = B_ATTR_NAME_STATE;
  } elsif ($Input =~ /\G\=[\	\
  \\\ ]*\'([^\ \\&\']*)\'[\	\
  \\\ ][\	\
  \\\ ]*/gcs) {
  
          if (defined $Token->{attrs}->{$Attr->{name}}) {
            push @$Errors, {type => 'duplicate attribute',
                            text => $Attr->{name},
                            level => 'm',
                            di => $Attr->{di},
                            index => $Attr->{index}};
          } else {
            $Token->{attrs}->{$Attr->{name}} = $Attr;
            push @{$Token->{attr_list} ||= []}, $Attr;
            $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
          }
        
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + $-[1]];
  $State = B_ATTR_NAME_STATE;
  } elsif ($Input =~ /\G\=[\	\
  \\\ ]*\"([^\ \\"\&]*)\"\/\>/gcs) {
  
          if (defined $Token->{attrs}->{$Attr->{name}}) {
            push @$Errors, {type => 'duplicate attribute',
                            text => $Attr->{name},
                            level => 'm',
                            di => $Attr->{di},
                            index => $Attr->{index}};
          } else {
            $Token->{attrs}->{$Attr->{name}} = $Attr;
            push @{$Token->{attr_list} ||= []}, $Attr;
            $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
          }
        
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + $-[1]];
  $State = SELF_CLOSING_START_TAG_STATE;
  $Token->{q<self_closing_flag>} = 1;
  $State = DATA_STATE;
  
            if ($Token->{type} == END_TAG_TOKEN) {
              if (keys %{$Token->{attrs} or {}}) {
                push @$Errors, {type => 'end tag attribute',
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
              if ($Token->{self_closing_flag}) {
                push @$Errors, {type => 'nestc',
                                text => $Token->{tag_name},
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
            }
          
  push @$Tokens, $Token;
  
            if ($Token->{type} == START_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              if (not defined $LastStartTagName) { # "first start tag"
                $LastStartTagName = $Token->{tag_name};
                return 1;
              } else {
                $LastStartTagName = $Token->{tag_name};
              }
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
              return 1 if $Token->{tag_name} =~ /-/;
              return 1 if $Token->{attrs}->{is};
            }
          
  
            if ($Token->{type} == END_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              ## 
            }
          
  } elsif ($Input =~ /\G\=[\	\
  \\\ ]*\'([^\ \\&\']*)\'\/\>/gcs) {
  
          if (defined $Token->{attrs}->{$Attr->{name}}) {
            push @$Errors, {type => 'duplicate attribute',
                            text => $Attr->{name},
                            level => 'm',
                            di => $Attr->{di},
                            index => $Attr->{index}};
          } else {
            $Token->{attrs}->{$Attr->{name}} = $Attr;
            push @{$Token->{attr_list} ||= []}, $Attr;
            $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
          }
        
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + $-[1]];
  $State = SELF_CLOSING_START_TAG_STATE;
  $Token->{q<self_closing_flag>} = 1;
  $State = DATA_STATE;
  
            if ($Token->{type} == END_TAG_TOKEN) {
              if (keys %{$Token->{attrs} or {}}) {
                push @$Errors, {type => 'end tag attribute',
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
              if ($Token->{self_closing_flag}) {
                push @$Errors, {type => 'nestc',
                                text => $Token->{tag_name},
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
            }
          
  push @$Tokens, $Token;
  
            if ($Token->{type} == START_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              if (not defined $LastStartTagName) { # "first start tag"
                $LastStartTagName = $Token->{tag_name};
                return 1;
              } else {
                $LastStartTagName = $Token->{tag_name};
              }
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
              return 1 if $Token->{tag_name} =~ /-/;
              return 1 if $Token->{attrs}->{is};
            }
          
  
            if ($Token->{type} == END_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              ## 
            }
          
  } elsif ($Input =~ /\G\=[\	\
  \\\ ]*\"([^\ \\"\&]*)\"\>/gcs) {
  
          if (defined $Token->{attrs}->{$Attr->{name}}) {
            push @$Errors, {type => 'duplicate attribute',
                            text => $Attr->{name},
                            level => 'm',
                            di => $Attr->{di},
                            index => $Attr->{index}};
          } else {
            $Token->{attrs}->{$Attr->{name}} = $Attr;
            push @{$Token->{attr_list} ||= []}, $Attr;
            $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
          }
        
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + $-[1]];
  $State = DATA_STATE;
  
            if ($Token->{type} == END_TAG_TOKEN) {
              if (keys %{$Token->{attrs} or {}}) {
                push @$Errors, {type => 'end tag attribute',
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
              if ($Token->{self_closing_flag}) {
                push @$Errors, {type => 'nestc',
                                text => $Token->{tag_name},
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
            }
          
  push @$Tokens, $Token;
  
            if ($Token->{type} == START_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              if (not defined $LastStartTagName) { # "first start tag"
                $LastStartTagName = $Token->{tag_name};
                return 1;
              } else {
                $LastStartTagName = $Token->{tag_name};
              }
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
              return 1 if $Token->{tag_name} =~ /-/;
              return 1 if $Token->{attrs}->{is};
            }
          
  
            if ($Token->{type} == END_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              ## 
            }
          
  } elsif ($Input =~ /\G\=[\	\
  \\\ ]*\'([^\ \\&\']*)\'\>/gcs) {
  
          if (defined $Token->{attrs}->{$Attr->{name}}) {
            push @$Errors, {type => 'duplicate attribute',
                            text => $Attr->{name},
                            level => 'm',
                            di => $Attr->{di},
                            index => $Attr->{index}};
          } else {
            $Token->{attrs}->{$Attr->{name}} = $Attr;
            push @{$Token->{attr_list} ||= []}, $Attr;
            $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
          }
        
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + $-[1]];
  $State = DATA_STATE;
  
            if ($Token->{type} == END_TAG_TOKEN) {
              if (keys %{$Token->{attrs} or {}}) {
                push @$Errors, {type => 'end tag attribute',
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
              if ($Token->{self_closing_flag}) {
                push @$Errors, {type => 'nestc',
                                text => $Token->{tag_name},
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
            }
          
  push @$Tokens, $Token;
  
            if ($Token->{type} == START_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              if (not defined $LastStartTagName) { # "first start tag"
                $LastStartTagName = $Token->{tag_name};
                return 1;
              } else {
                $LastStartTagName = $Token->{tag_name};
              }
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
              return 1 if $Token->{tag_name} =~ /-/;
              return 1 if $Token->{attrs}->{is};
            }
          
  
            if ($Token->{type} == END_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              ## 
            }
          
  } elsif ($Input =~ /\G[\	\
  \\\ ][\	\
  \\\ ]*\/\>/gcs) {
  
          if (defined $Token->{attrs}->{$Attr->{name}}) {
            push @$Errors, {type => 'duplicate attribute',
                            text => $Attr->{name},
                            level => 'm',
                            di => $Attr->{di},
                            index => $Attr->{index}};
          } else {
            $Token->{attrs}->{$Attr->{name}} = $Attr;
            push @{$Token->{attr_list} ||= []}, $Attr;
            $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
          }
        
  $State = SELF_CLOSING_START_TAG_STATE;
  $Token->{q<self_closing_flag>} = 1;
  $State = DATA_STATE;
  
            if ($Token->{type} == END_TAG_TOKEN) {
              if (keys %{$Token->{attrs} or {}}) {
                push @$Errors, {type => 'end tag attribute',
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
              if ($Token->{self_closing_flag}) {
                push @$Errors, {type => 'nestc',
                                text => $Token->{tag_name},
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
            }
          
  push @$Tokens, $Token;
  
            if ($Token->{type} == START_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              if (not defined $LastStartTagName) { # "first start tag"
                $LastStartTagName = $Token->{tag_name};
                return 1;
              } else {
                $LastStartTagName = $Token->{tag_name};
              }
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
              return 1 if $Token->{tag_name} =~ /-/;
              return 1 if $Token->{attrs}->{is};
            }
          
  
            if ($Token->{type} == END_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              ## 
            }
          
  } elsif ($Input =~ /\G[\	\
  \\\ ][\	\
  \\\ ]*\>/gcs) {
  
          if (defined $Token->{attrs}->{$Attr->{name}}) {
            push @$Errors, {type => 'duplicate attribute',
                            text => $Attr->{name},
                            level => 'm',
                            di => $Attr->{di},
                            index => $Attr->{index}};
          } else {
            $Token->{attrs}->{$Attr->{name}} = $Attr;
            push @{$Token->{attr_list} ||= []}, $Attr;
            $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
          }
        
  $State = DATA_STATE;
  
            if ($Token->{type} == END_TAG_TOKEN) {
              if (keys %{$Token->{attrs} or {}}) {
                push @$Errors, {type => 'end tag attribute',
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
              if ($Token->{self_closing_flag}) {
                push @$Errors, {type => 'nestc',
                                text => $Token->{tag_name},
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
            }
          
  push @$Tokens, $Token;
  
            if ($Token->{type} == START_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              if (not defined $LastStartTagName) { # "first start tag"
                $LastStartTagName = $Token->{tag_name};
                return 1;
              } else {
                $LastStartTagName = $Token->{tag_name};
              }
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
              return 1 if $Token->{tag_name} =~ /-/;
              return 1 if $Token->{attrs}->{is};
            }
          
  
            if ($Token->{type} == END_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              ## 
            }
          
  } elsif ($Input =~ /\G\/\>/gcs) {
  
          if (defined $Token->{attrs}->{$Attr->{name}}) {
            push @$Errors, {type => 'duplicate attribute',
                            text => $Attr->{name},
                            level => 'm',
                            di => $Attr->{di},
                            index => $Attr->{index}};
          } else {
            $Token->{attrs}->{$Attr->{name}} = $Attr;
            push @{$Token->{attr_list} ||= []}, $Attr;
            $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
          }
        
  $State = SELF_CLOSING_START_TAG_STATE;
  $Token->{q<self_closing_flag>} = 1;
  $State = DATA_STATE;
  
            if ($Token->{type} == END_TAG_TOKEN) {
              if (keys %{$Token->{attrs} or {}}) {
                push @$Errors, {type => 'end tag attribute',
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
              if ($Token->{self_closing_flag}) {
                push @$Errors, {type => 'nestc',
                                text => $Token->{tag_name},
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
            }
          
  push @$Tokens, $Token;
  
            if ($Token->{type} == START_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              if (not defined $LastStartTagName) { # "first start tag"
                $LastStartTagName = $Token->{tag_name};
                return 1;
              } else {
                $LastStartTagName = $Token->{tag_name};
              }
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
              return 1 if $Token->{tag_name} =~ /-/;
              return 1 if $Token->{attrs}->{is};
            }
          
  
            if ($Token->{type} == END_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              ## 
            }
          
  } elsif ($Input =~ /\G\>/gcs) {
  
          if (defined $Token->{attrs}->{$Attr->{name}}) {
            push @$Errors, {type => 'duplicate attribute',
                            text => $Attr->{name},
                            level => 'm',
                            di => $Attr->{di},
                            index => $Attr->{index}};
          } else {
            $Token->{attrs}->{$Attr->{name}} = $Attr;
            push @{$Token->{attr_list} ||= []}, $Attr;
            $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
          }
        
  $State = DATA_STATE;
  
            if ($Token->{type} == END_TAG_TOKEN) {
              if (keys %{$Token->{attrs} or {}}) {
                push @$Errors, {type => 'end tag attribute',
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
              if ($Token->{self_closing_flag}) {
                push @$Errors, {type => 'nestc',
                                text => $Token->{tag_name},
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
            }
          
  push @$Tokens, $Token;
  
            if ($Token->{type} == START_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              if (not defined $LastStartTagName) { # "first start tag"
                $LastStartTagName = $Token->{tag_name};
                return 1;
              } else {
                $LastStartTagName = $Token->{tag_name};
              }
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
              return 1 if $Token->{tag_name} =~ /-/;
              return 1 if $Token->{attrs}->{is};
            }
          
  
            if ($Token->{type} == END_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              ## 
            }
          
  } elsif ($Input =~ /\G([\	\\ \
  \])/gcs) {
  
          if (defined $Token->{attrs}->{$Attr->{name}}) {
            push @$Errors, {type => 'duplicate attribute',
                            text => $Attr->{name},
                            level => 'm',
                            di => $Attr->{di},
                            index => $Attr->{index}};
          } else {
            $Token->{attrs}->{$Attr->{name}} = $Attr;
            push @{$Token->{attr_list} ||= []}, $Attr;
            $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
          }
        
  $State = A_ATTR_NAME_STATE;
  } elsif ($Input =~ /\G([\/])/gcs) {
  
          if (defined $Token->{attrs}->{$Attr->{name}}) {
            push @$Errors, {type => 'duplicate attribute',
                            text => $Attr->{name},
                            level => 'm',
                            di => $Attr->{di},
                            index => $Attr->{index}};
          } else {
            $Token->{attrs}->{$Attr->{name}} = $Attr;
            push @{$Token->{attr_list} ||= []}, $Attr;
            $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
          }
        
  $State = SELF_CLOSING_START_TAG_STATE;
  } elsif ($Input =~ /\G([\=])/gcs) {
  
          if (defined $Token->{attrs}->{$Attr->{name}}) {
            push @$Errors, {type => 'duplicate attribute',
                            text => $Attr->{name},
                            level => 'm',
                            di => $Attr->{di},
                            index => $Attr->{index}};
          } else {
            $Token->{attrs}->{$Attr->{name}} = $Attr;
            push @{$Token->{attr_list} ||= []}, $Attr;
            $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
          }
        
  $State = B_ATTR_VALUE_STATE;
  } elsif ($Input =~ /\G([\>])/gcs) {
  
          if (defined $Token->{attrs}->{$Attr->{name}}) {
            push @$Errors, {type => 'duplicate attribute',
                            text => $Attr->{name},
                            level => 'm',
                            di => $Attr->{di},
                            index => $Attr->{index}};
          } else {
            $Token->{attrs}->{$Attr->{name}} = $Attr;
            push @{$Token->{attr_list} ||= []}, $Attr;
            $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
          }
        
  $State = DATA_STATE;
  
            if ($Token->{type} == END_TAG_TOKEN) {
              if (keys %{$Token->{attrs} or {}}) {
                push @$Errors, {type => 'end tag attribute',
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
              if ($Token->{self_closing_flag}) {
                push @$Errors, {type => 'nestc',
                                text => $Token->{tag_name},
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
            }
          
  push @$Tokens, $Token;
  
            if ($Token->{type} == START_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              if (not defined $LastStartTagName) { # "first start tag"
                $LastStartTagName = $Token->{tag_name};
                return 1;
              } else {
                $LastStartTagName = $Token->{tag_name};
              }
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
              return 1 if $Token->{tag_name} =~ /-/;
              return 1 if $Token->{attrs}->{is};
            }
          
  
            if ($Token->{type} == END_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              ## 
            }
          
  } elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {
  $Attr->{q<name>} .= chr ((ord $1) + 32);
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Attr->{q<name>} .= q@@;
  } elsif ($Input =~ /\G([\"])/gcs) {
  
              push @$Errors, {type => 'bad attribute name', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Attr->{q<name>} .= $1;
  } elsif ($Input =~ /\G([\'])/gcs) {
  
              push @$Errors, {type => 'bad attribute name', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Attr->{q<name>} .= $1;
  } elsif ($Input =~ /\G([\<])/gcs) {
  
              push @$Errors, {type => 'tag not closed', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Attr->{q<name>} .= $1;
  } else {
  if ($EOF) {
  
          if (defined $Token->{attrs}->{$Attr->{name}}) {
            push @$Errors, {type => 'duplicate attribute',
                            text => $Attr->{name},
                            level => 'm',
                            di => $Attr->{di},
                            index => $Attr->{index}};
          } else {
            $Token->{attrs}->{$Attr->{name}} = $Attr;
            push @{$Token->{attr_list} ||= []}, $Attr;
            $Attr->{name_args} = [undef, [undef, $Attr->{name}]];
          }
        
  $State = A_ATTR_NAME_STATE;
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[ATTR_VALUE__DQ__STATE] = sub {
  if ($Input =~ /\G([^\\"\&\ ]+)/gcs) {
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  
  } elsif ($Input =~ /\G([\])/gcs) {
  push @{$Attr->{q<value>}}, [q@
  @, $DI, $Offset + (pos $Input) - length $1];
  $State = ATTR_VALUE__DQ__STATE_CR;
  } elsif ($Input =~ /\G([\"])/gcs) {
  $State = A_ATTR_VALUE__QUOTED__STATE;
  } elsif ($Input =~ /\G([\&])/gcs) {
  $Temp = q@&@;
  $TempIndex = $Offset + (pos $Input) - (length $1) - 0;
  $State = ATTR_VALUE__DQ__STATE___CHARREF_STATE;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[ATTR_VALUE__DQ__STATE___CHARREF_BEFORE_HEX_NUM_STATE] = sub {
  if ($Input =~ /\G([0123456789ABCDEFafbcde])/gcs) {
  $Temp .= $1;
  $State = ATTR_VALUE__DQ__STATE___CHARREF_HEX_NUM_STATE;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'bare hcro', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__DQ__STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
  } elsif ($Input =~ /\G([\])/gcs) {
  
              push @$Errors, {type => 'bare hcro', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  push @{$Attr->{q<value>}}, [q@
  @, $DI, $Offset + (pos $Input) - length $1];
  $State = ATTR_VALUE__DQ__STATE_CR;
  } elsif ($Input =~ /\G([\"])/gcs) {
  
              push @$Errors, {type => 'bare hcro', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = A_ATTR_VALUE__QUOTED__STATE;
  } elsif ($Input =~ /\G([\&])/gcs) {
  
              push @$Errors, {type => 'bare hcro', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $Temp = q@&@;
  $TempIndex = $Offset + (pos $Input) - (length $1) - 0;
  $State = ATTR_VALUE__DQ__STATE___CHARREF_STATE;
  } elsif ($Input =~ /\G(.)/gcs) {
  
              push @$Errors, {type => 'bare hcro', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__DQ__STATE;
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'bare hcro', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__DQ__STATE;
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[ATTR_VALUE__DQ__STATE___CHARREF_DECIMAL_NUM_STATE] = sub {
  if ($Input =~ /\G([0123456789]+)/gcs) {
  $Temp .= $1;
  } elsif ($Input =~ /\G([\;])/gcs) {
  
          my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  $Attr->{has_ref} = 1;
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__DQ__STATE;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  $Attr->{has_ref} = 1;
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__DQ__STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
  } elsif ($Input =~ /\G([\])/gcs) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  $Attr->{has_ref} = 1;
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  push @{$Attr->{q<value>}}, [q@
  @, $DI, $Offset + (pos $Input) - length $1];
  $State = ATTR_VALUE__DQ__STATE_CR;
  } elsif ($Input =~ /\G([\"])/gcs) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  $Attr->{has_ref} = 1;
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = A_ATTR_VALUE__QUOTED__STATE;
  } elsif ($Input =~ /\G([\&])/gcs) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  $Attr->{has_ref} = 1;
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $Temp = q@&@;
  $TempIndex = $Offset + (pos $Input) - (length $1) - 0;
  $State = ATTR_VALUE__DQ__STATE___CHARREF_STATE;
  } elsif ($Input =~ /\G(.)/gcs) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  $Attr->{has_ref} = 1;
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__DQ__STATE;
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
          my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  $Attr->{has_ref} = 1;
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__DQ__STATE;
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[ATTR_VALUE__DQ__STATE___CHARREF_HEX_NUM_STATE] = sub {
  if ($Input =~ /\G([0123456789ABCDEFafbcde]+)/gcs) {
  $Temp .= $1;
  } elsif ($Input =~ /\G([\;])/gcs) {
  
          my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  $Attr->{has_ref} = 1;
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__DQ__STATE;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  $Attr->{has_ref} = 1;
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__DQ__STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
  } elsif ($Input =~ /\G([\])/gcs) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  $Attr->{has_ref} = 1;
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  push @{$Attr->{q<value>}}, [q@
  @, $DI, $Offset + (pos $Input) - length $1];
  $State = ATTR_VALUE__DQ__STATE_CR;
  } elsif ($Input =~ /\G([\"])/gcs) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  $Attr->{has_ref} = 1;
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = A_ATTR_VALUE__QUOTED__STATE;
  } elsif ($Input =~ /\G([\&])/gcs) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  $Attr->{has_ref} = 1;
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $Temp = q@&@;
  $TempIndex = $Offset + (pos $Input) - (length $1) - 0;
  $State = ATTR_VALUE__DQ__STATE___CHARREF_STATE;
  } elsif ($Input =~ /\G(.)/gcs) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  $Attr->{has_ref} = 1;
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__DQ__STATE;
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
          my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  $Attr->{has_ref} = 1;
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__DQ__STATE;
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[ATTR_VALUE__DQ__STATE___CHARREF_NAME_STATE] = sub {
  if ($Input =~ /\G([\])/gcs) {
  
            my $return;
            REF: {
              ## 
  
              for (reverse (2 .. length $Temp)) {
                my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
                if (defined $value) {
                  my $temp_index = $TempIndex;
  
                  unless (';' eq substr $Temp, $_-1, 1) {
                    if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                      last REF;
                    } elsif (0) { # before_equals
                      last REF;
                    } else {
                      ## <HTML>
                      push @$Errors, {type => 'no refc',
                                      level => 'm',
                                      di => $DI,
                                      index => $TempIndex + $_};
                      ## </HTML>
                    }
  
                    ## A variant of |append-to-attr|
                    push @{$Attr->{value}},
                        [$value, $DI, $TempIndex]; # IndexedString
                    $TempIndex += $_;
                    $value = '';
                  }
  
                  ## 
  
                  $Attr->{has_ref} = 1;
                  substr ($Temp, 0, $_) = $value;
                  last REF;
                }
              }
              if ($Temp =~ /;\z/) {
                push @$Errors, {type => 'entity not declared',
                                value => $Temp,
                                level => 'm',
                                di => $DI, index => $TempIndex};
                ## 
              }
            } # REF
          
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  push @{$Attr->{q<value>}}, [q@
  @, $DI, $Offset + (pos $Input) - length $1];
  $State = ATTR_VALUE__DQ__STATE_CR;
  return 1 if $return;
  } elsif ($Input =~ /\G([\"])/gcs) {
  
            my $return;
            REF: {
              ## 
  
              for (reverse (2 .. length $Temp)) {
                my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
                if (defined $value) {
                  my $temp_index = $TempIndex;
  
                  unless (';' eq substr $Temp, $_-1, 1) {
                    if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                      last REF;
                    } elsif (0) { # before_equals
                      last REF;
                    } else {
                      ## <HTML>
                      push @$Errors, {type => 'no refc',
                                      level => 'm',
                                      di => $DI,
                                      index => $TempIndex + $_};
                      ## </HTML>
                    }
  
                    ## A variant of |append-to-attr|
                    push @{$Attr->{value}},
                        [$value, $DI, $TempIndex]; # IndexedString
                    $TempIndex += $_;
                    $value = '';
                  }
  
                  ## 
  
                  $Attr->{has_ref} = 1;
                  substr ($Temp, 0, $_) = $value;
                  last REF;
                }
              }
              if ($Temp =~ /;\z/) {
                push @$Errors, {type => 'entity not declared',
                                value => $Temp,
                                level => 'm',
                                di => $DI, index => $TempIndex};
                ## 
              }
            } # REF
          
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = A_ATTR_VALUE__QUOTED__STATE;
  return 1 if $return;
  } elsif ($Input =~ /\G([\&])/gcs) {
  
            my $return;
            REF: {
              ## 
  
              for (reverse (2 .. length $Temp)) {
                my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
                if (defined $value) {
                  my $temp_index = $TempIndex;
  
                  unless (';' eq substr $Temp, $_-1, 1) {
                    if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                      last REF;
                    } elsif (0) { # before_equals
                      last REF;
                    } else {
                      ## <HTML>
                      push @$Errors, {type => 'no refc',
                                      level => 'm',
                                      di => $DI,
                                      index => $TempIndex + $_};
                      ## </HTML>
                    }
  
                    ## A variant of |append-to-attr|
                    push @{$Attr->{value}},
                        [$value, $DI, $TempIndex]; # IndexedString
                    $TempIndex += $_;
                    $value = '';
                  }
  
                  ## 
  
                  $Attr->{has_ref} = 1;
                  substr ($Temp, 0, $_) = $value;
                  last REF;
                }
              }
              if ($Temp =~ /;\z/) {
                push @$Errors, {type => 'entity not declared',
                                value => $Temp,
                                level => 'm',
                                di => $DI, index => $TempIndex};
                ## 
              }
            } # REF
          
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $Temp = q@&@;
  $TempIndex = $Offset + (pos $Input) - (length $1) - 0;
  $State = ATTR_VALUE__DQ__STATE___CHARREF_STATE;
  return 1 if $return;
  } elsif ($Input =~ /\G([0123456789]+)/gcs) {
  $Temp .= $1;
  } elsif ($Input =~ /\G([\;])/gcs) {
  $Temp .= $1;
  
            my $return;
            REF: {
              ## 
  
              for (reverse (2 .. length $Temp)) {
                my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
                if (defined $value) {
                  my $temp_index = $TempIndex;
  
                  unless (';' eq substr $Temp, $_-1, 1) {
                    if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                      last REF;
                    } elsif (0) { # before_equals
                      last REF;
                    } else {
                      ## <HTML>
                      push @$Errors, {type => 'no refc',
                                      level => 'm',
                                      di => $DI,
                                      index => $TempIndex + $_};
                      ## </HTML>
                    }
  
                    ## A variant of |append-to-attr|
                    push @{$Attr->{value}},
                        [$value, $DI, $TempIndex]; # IndexedString
                    $TempIndex += $_;
                    $value = '';
                  }
  
                  ## 
  
                  $Attr->{has_ref} = 1;
                  substr ($Temp, 0, $_) = $value;
                  last REF;
                }
              }
              if ($Temp =~ /;\z/) {
                push @$Errors, {type => 'entity not declared',
                                value => $Temp,
                                level => 'm',
                                di => $DI, index => $TempIndex};
                ## 
              }
            } # REF
          
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__DQ__STATE;
  return 1 if $return;
  } elsif ($Input =~ /\G([\=])/gcs) {
  
            my $return;
            REF: {
              ## 
  
              for (reverse (2 .. length $Temp)) {
                my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
                if (defined $value) {
                  my $temp_index = $TempIndex;
  
                  unless (';' eq substr $Temp, $_-1, 1) {
                    if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                      last REF;
                    } elsif (1) { # before_equals
                      last REF;
                    } else {
                      ## <HTML>
                      push @$Errors, {type => 'no refc',
                                      level => 'm',
                                      di => $DI,
                                      index => $TempIndex + $_};
                      ## </HTML>
                    }
  
                    ## A variant of |append-to-attr|
                    push @{$Attr->{value}},
                        [$value, $DI, $TempIndex]; # IndexedString
                    $TempIndex += $_;
                    $value = '';
                  }
  
                  ## 
  
                  $Attr->{has_ref} = 1;
                  substr ($Temp, 0, $_) = $value;
                  last REF;
                }
              }
              if ($Temp =~ /;\z/) {
                push @$Errors, {type => 'entity not declared',
                                value => $Temp,
                                level => 'm',
                                di => $DI, index => $TempIndex};
                ## 
              }
            } # REF
          
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__DQ__STATE;
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  return 1 if $return;
  } elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY]+)/gcs) {
  $Temp .= $1;
  } elsif ($Input =~ /\G([afbcdeghjknqrvwzilmopstuxy]+)/gcs) {
  $Temp .= $1;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
            my $return;
            REF: {
              ## 
  
              for (reverse (2 .. length $Temp)) {
                my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
                if (defined $value) {
                  my $temp_index = $TempIndex;
  
                  unless (';' eq substr $Temp, $_-1, 1) {
                    if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                      last REF;
                    } elsif (0) { # before_equals
                      last REF;
                    } else {
                      ## <HTML>
                      push @$Errors, {type => 'no refc',
                                      level => 'm',
                                      di => $DI,
                                      index => $TempIndex + $_};
                      ## </HTML>
                    }
  
                    ## A variant of |append-to-attr|
                    push @{$Attr->{value}},
                        [$value, $DI, $TempIndex]; # IndexedString
                    $TempIndex += $_;
                    $value = '';
                  }
  
                  ## 
  
                  $Attr->{has_ref} = 1;
                  substr ($Temp, 0, $_) = $value;
                  last REF;
                }
              }
              if ($Temp =~ /;\z/) {
                push @$Errors, {type => 'entity not declared',
                                value => $Temp,
                                level => 'm',
                                di => $DI, index => $TempIndex};
                ## 
              }
            } # REF
          
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__DQ__STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
  return 1 if $return;
  } elsif ($Input =~ /\G(.)/gcs) {
  
            my $return;
            REF: {
              ## 
  
              for (reverse (2 .. length $Temp)) {
                my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
                if (defined $value) {
                  my $temp_index = $TempIndex;
  
                  unless (';' eq substr $Temp, $_-1, 1) {
                    if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                      last REF;
                    } elsif (0) { # before_equals
                      last REF;
                    } else {
                      ## <HTML>
                      push @$Errors, {type => 'no refc',
                                      level => 'm',
                                      di => $DI,
                                      index => $TempIndex + $_};
                      ## </HTML>
                    }
  
                    ## A variant of |append-to-attr|
                    push @{$Attr->{value}},
                        [$value, $DI, $TempIndex]; # IndexedString
                    $TempIndex += $_;
                    $value = '';
                  }
  
                  ## 
  
                  $Attr->{has_ref} = 1;
                  substr ($Temp, 0, $_) = $value;
                  last REF;
                }
              }
              if ($Temp =~ /;\z/) {
                push @$Errors, {type => 'entity not declared',
                                value => $Temp,
                                level => 'm',
                                di => $DI, index => $TempIndex};
                ## 
              }
            } # REF
          
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__DQ__STATE;
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  return 1 if $return;
  } else {
  if ($EOF) {
  
            my $return;
            REF: {
              ## 
  
              for (reverse (2 .. length $Temp)) {
                my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
                if (defined $value) {
                  my $temp_index = $TempIndex;
  
                  unless (';' eq substr $Temp, $_-1, 1) {
                    if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                      last REF;
                    } elsif (0) { # before_equals
                      last REF;
                    } else {
                      ## <HTML>
                      push @$Errors, {type => 'no refc',
                                      level => 'm',
                                      di => $DI,
                                      index => $TempIndex + $_};
                      ## </HTML>
                    }
  
                    ## A variant of |append-to-attr|
                    push @{$Attr->{value}},
                        [$value, $DI, $TempIndex]; # IndexedString
                    $TempIndex += $_;
                    $value = '';
                  }
  
                  ## 
  
                  $Attr->{has_ref} = 1;
                  substr ($Temp, 0, $_) = $value;
                  last REF;
                }
              }
              if ($Temp =~ /;\z/) {
                push @$Errors, {type => 'entity not declared',
                                value => $Temp,
                                level => 'm',
                                di => $DI, index => $TempIndex};
                ## 
              }
            } # REF
          
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__DQ__STATE;
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[ATTR_VALUE__DQ__STATE___CHARREF_NUM_STATE] = sub {
  if ($Input =~ /\G([0123456789])/gcs) {
  $Temp .= $1;
  $State = ATTR_VALUE__DQ__STATE___CHARREF_DECIMAL_NUM_STATE;
  } elsif ($Input =~ /\G([X])/gcs) {
  $Temp .= $1;
  $State = ATTR_VALUE__DQ__STATE___CHARREF_BEFORE_HEX_NUM_STATE;
  } elsif ($Input =~ /\G([x])/gcs) {
  $Temp .= $1;
  $State = ATTR_VALUE__DQ__STATE___CHARREF_BEFORE_HEX_NUM_STATE;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'bare nero', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__DQ__STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
  } elsif ($Input =~ /\G([\])/gcs) {
  
              push @$Errors, {type => 'bare nero', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  push @{$Attr->{q<value>}}, [q@
  @, $DI, $Offset + (pos $Input) - length $1];
  $State = ATTR_VALUE__DQ__STATE_CR;
  } elsif ($Input =~ /\G([\"])/gcs) {
  
              push @$Errors, {type => 'bare nero', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = A_ATTR_VALUE__QUOTED__STATE;
  } elsif ($Input =~ /\G([\&])/gcs) {
  
              push @$Errors, {type => 'bare nero', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $Temp = q@&@;
  $TempIndex = $Offset + (pos $Input) - (length $1) - 0;
  $State = ATTR_VALUE__DQ__STATE___CHARREF_STATE;
  } elsif ($Input =~ /\G(.)/gcs) {
  
              push @$Errors, {type => 'bare nero', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__DQ__STATE;
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'bare nero', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__DQ__STATE;
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[ATTR_VALUE__DQ__STATE___CHARREF_STATE] = sub {
  if ($Input =~ /\G([\])/gcs) {
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  push @{$Attr->{q<value>}}, [q@
  @, $DI, $Offset + (pos $Input) - length $1];
  $State = ATTR_VALUE__DQ__STATE_CR;
  } elsif ($Input =~ /\G([\"])/gcs) {
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = A_ATTR_VALUE__QUOTED__STATE;
  } elsif ($Input =~ /\G([\#])/gcs) {
  $Temp .= $1;
  $State = ATTR_VALUE__DQ__STATE___CHARREF_NUM_STATE;
  } elsif ($Input =~ /\G([\&])/gcs) {
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $Temp = q@&@;
  $TempIndex = $Offset + (pos $Input) - (length $1) - 0;
  $State = ATTR_VALUE__DQ__STATE___CHARREF_STATE;
  } elsif ($Input =~ /\G([0123456789])/gcs) {
  $Temp .= $1;
  $State = ATTR_VALUE__DQ__STATE___CHARREF_NAME_STATE;
  } elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {
  $Temp .= $1;
  $State = ATTR_VALUE__DQ__STATE___CHARREF_NAME_STATE;
  } elsif ($Input =~ /\G([afbcdeghjknqrvwzilmopstuxy])/gcs) {
  $Temp .= $1;
  $State = ATTR_VALUE__DQ__STATE___CHARREF_NAME_STATE;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__DQ__STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
  } elsif ($Input =~ /\G(.)/gcs) {
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__DQ__STATE;
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  } else {
  if ($EOF) {
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__DQ__STATE;
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[ATTR_VALUE__DQ__STATE_CR] = sub {
  if ($Input =~ /\G([\
  ])/gcs) {
  $State = ATTR_VALUE__DQ__STATE;
  } elsif ($Input =~ /\G([\])/gcs) {
  push @{$Attr->{q<value>}}, [q@
  @, $DI, $Offset + (pos $Input) - length $1];
  $State = ATTR_VALUE__DQ__STATE_CR;
  } elsif ($Input =~ /\G([\"])/gcs) {
  $State = A_ATTR_VALUE__QUOTED__STATE;
  } elsif ($Input =~ /\G([\&])/gcs) {
  $Temp = q@&@;
  $TempIndex = $Offset + (pos $Input) - (length $1) - 0;
  $State = ATTR_VALUE__DQ__STATE___CHARREF_STATE;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  $State = ATTR_VALUE__DQ__STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
  } elsif ($Input =~ /\G(.)/gcs) {
  $State = ATTR_VALUE__DQ__STATE;
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  } else {
  if ($EOF) {
  $State = ATTR_VALUE__DQ__STATE;
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[ATTR_VALUE__SQ__STATE] = sub {
  if ($Input =~ /\G([^\\&\'\ ]+)/gcs) {
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  
  } elsif ($Input =~ /\G([\])/gcs) {
  push @{$Attr->{q<value>}}, [q@
  @, $DI, $Offset + (pos $Input) - length $1];
  $State = ATTR_VALUE__SQ__STATE_CR;
  } elsif ($Input =~ /\G([\&])/gcs) {
  $Temp = q@&@;
  $TempIndex = $Offset + (pos $Input) - (length $1) - 0;
  $State = ATTR_VALUE__SQ__STATE___CHARREF_STATE;
  } elsif ($Input =~ /\G([\'])/gcs) {
  $State = A_ATTR_VALUE__QUOTED__STATE;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[ATTR_VALUE__SQ__STATE___CHARREF_BEFORE_HEX_NUM_STATE] = sub {
  if ($Input =~ /\G([0123456789ABCDEFafbcde])/gcs) {
  $Temp .= $1;
  $State = ATTR_VALUE__SQ__STATE___CHARREF_HEX_NUM_STATE;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'bare hcro', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__SQ__STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
  } elsif ($Input =~ /\G([\])/gcs) {
  
              push @$Errors, {type => 'bare hcro', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  push @{$Attr->{q<value>}}, [q@
  @, $DI, $Offset + (pos $Input) - length $1];
  $State = ATTR_VALUE__SQ__STATE_CR;
  } elsif ($Input =~ /\G([\&])/gcs) {
  
              push @$Errors, {type => 'bare hcro', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $Temp = q@&@;
  $TempIndex = $Offset + (pos $Input) - (length $1) - 0;
  $State = ATTR_VALUE__SQ__STATE___CHARREF_STATE;
  } elsif ($Input =~ /\G([\'])/gcs) {
  
              push @$Errors, {type => 'bare hcro', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = A_ATTR_VALUE__QUOTED__STATE;
  } elsif ($Input =~ /\G(.)/gcs) {
  
              push @$Errors, {type => 'bare hcro', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__SQ__STATE;
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'bare hcro', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__SQ__STATE;
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[ATTR_VALUE__SQ__STATE___CHARREF_DECIMAL_NUM_STATE] = sub {
  if ($Input =~ /\G([0123456789]+)/gcs) {
  $Temp .= $1;
  } elsif ($Input =~ /\G([\;])/gcs) {
  
          my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  $Attr->{has_ref} = 1;
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__SQ__STATE;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  $Attr->{has_ref} = 1;
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__SQ__STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
  } elsif ($Input =~ /\G([\])/gcs) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  $Attr->{has_ref} = 1;
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  push @{$Attr->{q<value>}}, [q@
  @, $DI, $Offset + (pos $Input) - length $1];
  $State = ATTR_VALUE__SQ__STATE_CR;
  } elsif ($Input =~ /\G([\&])/gcs) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  $Attr->{has_ref} = 1;
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $Temp = q@&@;
  $TempIndex = $Offset + (pos $Input) - (length $1) - 0;
  $State = ATTR_VALUE__SQ__STATE___CHARREF_STATE;
  } elsif ($Input =~ /\G([\'])/gcs) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  $Attr->{has_ref} = 1;
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = A_ATTR_VALUE__QUOTED__STATE;
  } elsif ($Input =~ /\G(.)/gcs) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  $Attr->{has_ref} = 1;
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__SQ__STATE;
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
          my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  $Attr->{has_ref} = 1;
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__SQ__STATE;
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[ATTR_VALUE__SQ__STATE___CHARREF_HEX_NUM_STATE] = sub {
  if ($Input =~ /\G([0123456789ABCDEFafbcde]+)/gcs) {
  $Temp .= $1;
  } elsif ($Input =~ /\G([\;])/gcs) {
  
          my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  $Attr->{has_ref} = 1;
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__SQ__STATE;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  $Attr->{has_ref} = 1;
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__SQ__STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
  } elsif ($Input =~ /\G([\])/gcs) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  $Attr->{has_ref} = 1;
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  push @{$Attr->{q<value>}}, [q@
  @, $DI, $Offset + (pos $Input) - length $1];
  $State = ATTR_VALUE__SQ__STATE_CR;
  } elsif ($Input =~ /\G([\&])/gcs) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  $Attr->{has_ref} = 1;
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $Temp = q@&@;
  $TempIndex = $Offset + (pos $Input) - (length $1) - 0;
  $State = ATTR_VALUE__SQ__STATE___CHARREF_STATE;
  } elsif ($Input =~ /\G([\'])/gcs) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  $Attr->{has_ref} = 1;
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = A_ATTR_VALUE__QUOTED__STATE;
  } elsif ($Input =~ /\G(.)/gcs) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  $Attr->{has_ref} = 1;
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__SQ__STATE;
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
          my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  $Attr->{has_ref} = 1;
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__SQ__STATE;
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[ATTR_VALUE__SQ__STATE___CHARREF_NAME_STATE] = sub {
  if ($Input =~ /\G([\])/gcs) {
  
            my $return;
            REF: {
              ## 
  
              for (reverse (2 .. length $Temp)) {
                my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
                if (defined $value) {
                  my $temp_index = $TempIndex;
  
                  unless (';' eq substr $Temp, $_-1, 1) {
                    if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                      last REF;
                    } elsif (0) { # before_equals
                      last REF;
                    } else {
                      ## <HTML>
                      push @$Errors, {type => 'no refc',
                                      level => 'm',
                                      di => $DI,
                                      index => $TempIndex + $_};
                      ## </HTML>
                    }
  
                    ## A variant of |append-to-attr|
                    push @{$Attr->{value}},
                        [$value, $DI, $TempIndex]; # IndexedString
                    $TempIndex += $_;
                    $value = '';
                  }
  
                  ## 
  
                  $Attr->{has_ref} = 1;
                  substr ($Temp, 0, $_) = $value;
                  last REF;
                }
              }
              if ($Temp =~ /;\z/) {
                push @$Errors, {type => 'entity not declared',
                                value => $Temp,
                                level => 'm',
                                di => $DI, index => $TempIndex};
                ## 
              }
            } # REF
          
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  push @{$Attr->{q<value>}}, [q@
  @, $DI, $Offset + (pos $Input) - length $1];
  $State = ATTR_VALUE__SQ__STATE_CR;
  return 1 if $return;
  } elsif ($Input =~ /\G([\&])/gcs) {
  
            my $return;
            REF: {
              ## 
  
              for (reverse (2 .. length $Temp)) {
                my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
                if (defined $value) {
                  my $temp_index = $TempIndex;
  
                  unless (';' eq substr $Temp, $_-1, 1) {
                    if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                      last REF;
                    } elsif (0) { # before_equals
                      last REF;
                    } else {
                      ## <HTML>
                      push @$Errors, {type => 'no refc',
                                      level => 'm',
                                      di => $DI,
                                      index => $TempIndex + $_};
                      ## </HTML>
                    }
  
                    ## A variant of |append-to-attr|
                    push @{$Attr->{value}},
                        [$value, $DI, $TempIndex]; # IndexedString
                    $TempIndex += $_;
                    $value = '';
                  }
  
                  ## 
  
                  $Attr->{has_ref} = 1;
                  substr ($Temp, 0, $_) = $value;
                  last REF;
                }
              }
              if ($Temp =~ /;\z/) {
                push @$Errors, {type => 'entity not declared',
                                value => $Temp,
                                level => 'm',
                                di => $DI, index => $TempIndex};
                ## 
              }
            } # REF
          
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $Temp = q@&@;
  $TempIndex = $Offset + (pos $Input) - (length $1) - 0;
  $State = ATTR_VALUE__SQ__STATE___CHARREF_STATE;
  return 1 if $return;
  } elsif ($Input =~ /\G([\'])/gcs) {
  
            my $return;
            REF: {
              ## 
  
              for (reverse (2 .. length $Temp)) {
                my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
                if (defined $value) {
                  my $temp_index = $TempIndex;
  
                  unless (';' eq substr $Temp, $_-1, 1) {
                    if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                      last REF;
                    } elsif (0) { # before_equals
                      last REF;
                    } else {
                      ## <HTML>
                      push @$Errors, {type => 'no refc',
                                      level => 'm',
                                      di => $DI,
                                      index => $TempIndex + $_};
                      ## </HTML>
                    }
  
                    ## A variant of |append-to-attr|
                    push @{$Attr->{value}},
                        [$value, $DI, $TempIndex]; # IndexedString
                    $TempIndex += $_;
                    $value = '';
                  }
  
                  ## 
  
                  $Attr->{has_ref} = 1;
                  substr ($Temp, 0, $_) = $value;
                  last REF;
                }
              }
              if ($Temp =~ /;\z/) {
                push @$Errors, {type => 'entity not declared',
                                value => $Temp,
                                level => 'm',
                                di => $DI, index => $TempIndex};
                ## 
              }
            } # REF
          
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = A_ATTR_VALUE__QUOTED__STATE;
  return 1 if $return;
  } elsif ($Input =~ /\G([0123456789]+)/gcs) {
  $Temp .= $1;
  } elsif ($Input =~ /\G([\;])/gcs) {
  $Temp .= $1;
  
            my $return;
            REF: {
              ## 
  
              for (reverse (2 .. length $Temp)) {
                my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
                if (defined $value) {
                  my $temp_index = $TempIndex;
  
                  unless (';' eq substr $Temp, $_-1, 1) {
                    if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                      last REF;
                    } elsif (0) { # before_equals
                      last REF;
                    } else {
                      ## <HTML>
                      push @$Errors, {type => 'no refc',
                                      level => 'm',
                                      di => $DI,
                                      index => $TempIndex + $_};
                      ## </HTML>
                    }
  
                    ## A variant of |append-to-attr|
                    push @{$Attr->{value}},
                        [$value, $DI, $TempIndex]; # IndexedString
                    $TempIndex += $_;
                    $value = '';
                  }
  
                  ## 
  
                  $Attr->{has_ref} = 1;
                  substr ($Temp, 0, $_) = $value;
                  last REF;
                }
              }
              if ($Temp =~ /;\z/) {
                push @$Errors, {type => 'entity not declared',
                                value => $Temp,
                                level => 'm',
                                di => $DI, index => $TempIndex};
                ## 
              }
            } # REF
          
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__SQ__STATE;
  return 1 if $return;
  } elsif ($Input =~ /\G([\=])/gcs) {
  
            my $return;
            REF: {
              ## 
  
              for (reverse (2 .. length $Temp)) {
                my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
                if (defined $value) {
                  my $temp_index = $TempIndex;
  
                  unless (';' eq substr $Temp, $_-1, 1) {
                    if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                      last REF;
                    } elsif (1) { # before_equals
                      last REF;
                    } else {
                      ## <HTML>
                      push @$Errors, {type => 'no refc',
                                      level => 'm',
                                      di => $DI,
                                      index => $TempIndex + $_};
                      ## </HTML>
                    }
  
                    ## A variant of |append-to-attr|
                    push @{$Attr->{value}},
                        [$value, $DI, $TempIndex]; # IndexedString
                    $TempIndex += $_;
                    $value = '';
                  }
  
                  ## 
  
                  $Attr->{has_ref} = 1;
                  substr ($Temp, 0, $_) = $value;
                  last REF;
                }
              }
              if ($Temp =~ /;\z/) {
                push @$Errors, {type => 'entity not declared',
                                value => $Temp,
                                level => 'm',
                                di => $DI, index => $TempIndex};
                ## 
              }
            } # REF
          
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__SQ__STATE;
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  return 1 if $return;
  } elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY]+)/gcs) {
  $Temp .= $1;
  } elsif ($Input =~ /\G([afbcdeghjknqrvwzilmopstuxy]+)/gcs) {
  $Temp .= $1;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
            my $return;
            REF: {
              ## 
  
              for (reverse (2 .. length $Temp)) {
                my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
                if (defined $value) {
                  my $temp_index = $TempIndex;
  
                  unless (';' eq substr $Temp, $_-1, 1) {
                    if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                      last REF;
                    } elsif (0) { # before_equals
                      last REF;
                    } else {
                      ## <HTML>
                      push @$Errors, {type => 'no refc',
                                      level => 'm',
                                      di => $DI,
                                      index => $TempIndex + $_};
                      ## </HTML>
                    }
  
                    ## A variant of |append-to-attr|
                    push @{$Attr->{value}},
                        [$value, $DI, $TempIndex]; # IndexedString
                    $TempIndex += $_;
                    $value = '';
                  }
  
                  ## 
  
                  $Attr->{has_ref} = 1;
                  substr ($Temp, 0, $_) = $value;
                  last REF;
                }
              }
              if ($Temp =~ /;\z/) {
                push @$Errors, {type => 'entity not declared',
                                value => $Temp,
                                level => 'm',
                                di => $DI, index => $TempIndex};
                ## 
              }
            } # REF
          
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__SQ__STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
  return 1 if $return;
  } elsif ($Input =~ /\G(.)/gcs) {
  
            my $return;
            REF: {
              ## 
  
              for (reverse (2 .. length $Temp)) {
                my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
                if (defined $value) {
                  my $temp_index = $TempIndex;
  
                  unless (';' eq substr $Temp, $_-1, 1) {
                    if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                      last REF;
                    } elsif (0) { # before_equals
                      last REF;
                    } else {
                      ## <HTML>
                      push @$Errors, {type => 'no refc',
                                      level => 'm',
                                      di => $DI,
                                      index => $TempIndex + $_};
                      ## </HTML>
                    }
  
                    ## A variant of |append-to-attr|
                    push @{$Attr->{value}},
                        [$value, $DI, $TempIndex]; # IndexedString
                    $TempIndex += $_;
                    $value = '';
                  }
  
                  ## 
  
                  $Attr->{has_ref} = 1;
                  substr ($Temp, 0, $_) = $value;
                  last REF;
                }
              }
              if ($Temp =~ /;\z/) {
                push @$Errors, {type => 'entity not declared',
                                value => $Temp,
                                level => 'm',
                                di => $DI, index => $TempIndex};
                ## 
              }
            } # REF
          
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__SQ__STATE;
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  return 1 if $return;
  } else {
  if ($EOF) {
  
            my $return;
            REF: {
              ## 
  
              for (reverse (2 .. length $Temp)) {
                my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
                if (defined $value) {
                  my $temp_index = $TempIndex;
  
                  unless (';' eq substr $Temp, $_-1, 1) {
                    if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                      last REF;
                    } elsif (0) { # before_equals
                      last REF;
                    } else {
                      ## <HTML>
                      push @$Errors, {type => 'no refc',
                                      level => 'm',
                                      di => $DI,
                                      index => $TempIndex + $_};
                      ## </HTML>
                    }
  
                    ## A variant of |append-to-attr|
                    push @{$Attr->{value}},
                        [$value, $DI, $TempIndex]; # IndexedString
                    $TempIndex += $_;
                    $value = '';
                  }
  
                  ## 
  
                  $Attr->{has_ref} = 1;
                  substr ($Temp, 0, $_) = $value;
                  last REF;
                }
              }
              if ($Temp =~ /;\z/) {
                push @$Errors, {type => 'entity not declared',
                                value => $Temp,
                                level => 'm',
                                di => $DI, index => $TempIndex};
                ## 
              }
            } # REF
          
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__SQ__STATE;
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[ATTR_VALUE__SQ__STATE___CHARREF_NUM_STATE] = sub {
  if ($Input =~ /\G([0123456789])/gcs) {
  $Temp .= $1;
  $State = ATTR_VALUE__SQ__STATE___CHARREF_DECIMAL_NUM_STATE;
  } elsif ($Input =~ /\G([X])/gcs) {
  $Temp .= $1;
  $State = ATTR_VALUE__SQ__STATE___CHARREF_BEFORE_HEX_NUM_STATE;
  } elsif ($Input =~ /\G([x])/gcs) {
  $Temp .= $1;
  $State = ATTR_VALUE__SQ__STATE___CHARREF_BEFORE_HEX_NUM_STATE;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'bare nero', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__SQ__STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
  } elsif ($Input =~ /\G([\])/gcs) {
  
              push @$Errors, {type => 'bare nero', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  push @{$Attr->{q<value>}}, [q@
  @, $DI, $Offset + (pos $Input) - length $1];
  $State = ATTR_VALUE__SQ__STATE_CR;
  } elsif ($Input =~ /\G([\&])/gcs) {
  
              push @$Errors, {type => 'bare nero', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $Temp = q@&@;
  $TempIndex = $Offset + (pos $Input) - (length $1) - 0;
  $State = ATTR_VALUE__SQ__STATE___CHARREF_STATE;
  } elsif ($Input =~ /\G([\'])/gcs) {
  
              push @$Errors, {type => 'bare nero', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = A_ATTR_VALUE__QUOTED__STATE;
  } elsif ($Input =~ /\G(.)/gcs) {
  
              push @$Errors, {type => 'bare nero', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__SQ__STATE;
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'bare nero', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__SQ__STATE;
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[ATTR_VALUE__SQ__STATE___CHARREF_STATE] = sub {
  if ($Input =~ /\G([\])/gcs) {
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  push @{$Attr->{q<value>}}, [q@
  @, $DI, $Offset + (pos $Input) - length $1];
  $State = ATTR_VALUE__SQ__STATE_CR;
  } elsif ($Input =~ /\G([\#])/gcs) {
  $Temp .= $1;
  $State = ATTR_VALUE__SQ__STATE___CHARREF_NUM_STATE;
  } elsif ($Input =~ /\G([\&])/gcs) {
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $Temp = q@&@;
  $TempIndex = $Offset + (pos $Input) - (length $1) - 0;
  $State = ATTR_VALUE__SQ__STATE___CHARREF_STATE;
  } elsif ($Input =~ /\G([\'])/gcs) {
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = A_ATTR_VALUE__QUOTED__STATE;
  } elsif ($Input =~ /\G([0123456789])/gcs) {
  $Temp .= $1;
  $State = ATTR_VALUE__SQ__STATE___CHARREF_NAME_STATE;
  } elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {
  $Temp .= $1;
  $State = ATTR_VALUE__SQ__STATE___CHARREF_NAME_STATE;
  } elsif ($Input =~ /\G([afbcdeghjknqrvwzilmopstuxy])/gcs) {
  $Temp .= $1;
  $State = ATTR_VALUE__SQ__STATE___CHARREF_NAME_STATE;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__SQ__STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
  } elsif ($Input =~ /\G(.)/gcs) {
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__SQ__STATE;
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  } else {
  if ($EOF) {
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__SQ__STATE;
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[ATTR_VALUE__SQ__STATE_CR] = sub {
  if ($Input =~ /\G([\
  ])/gcs) {
  $State = ATTR_VALUE__SQ__STATE;
  } elsif ($Input =~ /\G([\])/gcs) {
  push @{$Attr->{q<value>}}, [q@
  @, $DI, $Offset + (pos $Input) - length $1];
  $State = ATTR_VALUE__SQ__STATE_CR;
  } elsif ($Input =~ /\G([\&])/gcs) {
  $Temp = q@&@;
  $TempIndex = $Offset + (pos $Input) - (length $1) - 0;
  $State = ATTR_VALUE__SQ__STATE___CHARREF_STATE;
  } elsif ($Input =~ /\G([\'])/gcs) {
  $State = A_ATTR_VALUE__QUOTED__STATE;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  $State = ATTR_VALUE__SQ__STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
  } elsif ($Input =~ /\G(.)/gcs) {
  $State = ATTR_VALUE__SQ__STATE;
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  } else {
  if ($EOF) {
  $State = ATTR_VALUE__SQ__STATE;
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[ATTR_VALUE__UNQUOTED__STATE] = sub {
  if ($Input =~ /\G([^\	\\ \
  \\&\>\ \"\'\<\=\`]+)/gcs) {
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  
  } elsif ($Input =~ /\G([\	\\ \
  \])/gcs) {
  $State = B_ATTR_NAME_STATE;
  } elsif ($Input =~ /\G([\&])/gcs) {
  $Temp = q@&@;
  $TempIndex = $Offset + (pos $Input) - (length $1) - 0;
  $State = ATTR_VALUE__UNQUOTED__STATE___CHARREF_STATE;
  } elsif ($Input =~ /\G([\>])/gcs) {
  $State = DATA_STATE;
  
            if ($Token->{type} == END_TAG_TOKEN) {
              if (keys %{$Token->{attrs} or {}}) {
                push @$Errors, {type => 'end tag attribute',
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
              if ($Token->{self_closing_flag}) {
                push @$Errors, {type => 'nestc',
                                text => $Token->{tag_name},
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
            }
          
  push @$Tokens, $Token;
  
            if ($Token->{type} == START_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              if (not defined $LastStartTagName) { # "first start tag"
                $LastStartTagName = $Token->{tag_name};
                return 1;
              } else {
                $LastStartTagName = $Token->{tag_name};
              }
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
              return 1 if $Token->{tag_name} =~ /-/;
              return 1 if $Token->{attrs}->{is};
            }
          
  
            if ($Token->{type} == END_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              ## 
            }
          
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
  } elsif ($Input =~ /\G([\"])/gcs) {
  
              push @$Errors, {type => 'bad attribute value', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  } elsif ($Input =~ /\G([\'])/gcs) {
  
              push @$Errors, {type => 'bad attribute value', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  } elsif ($Input =~ /\G([\<])/gcs) {
  
              push @$Errors, {type => 'tag not closed', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  } elsif ($Input =~ /\G([\=])/gcs) {
  
              push @$Errors, {type => 'bad attribute value', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  } elsif ($Input =~ /\G([\`])/gcs) {
  
              push @$Errors, {type => 'bad attribute value', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[ATTR_VALUE__UNQUOTED__STATE___CHARREF_BEFORE_HEX_NUM_STATE] = sub {
  if ($Input =~ /\G([0123456789ABCDEFafbcde])/gcs) {
  $Temp .= $1;
  $State = ATTR_VALUE__UNQUOTED__STATE___CHARREF_HEX_NUM_STATE;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'bare hcro', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__UNQUOTED__STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
  } elsif ($Input =~ /\G([\	\\ \
  ])/gcs) {
  
              push @$Errors, {type => 'bare hcro', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = B_ATTR_NAME_STATE;
  } elsif ($Input =~ /\G([\])/gcs) {
  
              push @$Errors, {type => 'bare hcro', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = B_ATTR_NAME_STATE;
  } elsif ($Input =~ /\G([\"])/gcs) {
  
              push @$Errors, {type => 'bare hcro', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__UNQUOTED__STATE;
  
              push @$Errors, {type => 'bad attribute value', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  } elsif ($Input =~ /\G([\&])/gcs) {
  
              push @$Errors, {type => 'bare hcro', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $Temp = q@&@;
  $TempIndex = $Offset + (pos $Input) - (length $1) - 0;
  $State = ATTR_VALUE__UNQUOTED__STATE___CHARREF_STATE;
  } elsif ($Input =~ /\G([\'])/gcs) {
  
              push @$Errors, {type => 'bare hcro', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__UNQUOTED__STATE;
  
              push @$Errors, {type => 'bad attribute value', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  } elsif ($Input =~ /\G([\<])/gcs) {
  
              push @$Errors, {type => 'bare hcro', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__UNQUOTED__STATE;
  
              push @$Errors, {type => 'tag not closed', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  } elsif ($Input =~ /\G([\=])/gcs) {
  
              push @$Errors, {type => 'bare hcro', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__UNQUOTED__STATE;
  
              push @$Errors, {type => 'bad attribute value', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  } elsif ($Input =~ /\G([\>])/gcs) {
  
              push @$Errors, {type => 'bare hcro', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = DATA_STATE;
  
            if ($Token->{type} == END_TAG_TOKEN) {
              if (keys %{$Token->{attrs} or {}}) {
                push @$Errors, {type => 'end tag attribute',
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
              if ($Token->{self_closing_flag}) {
                push @$Errors, {type => 'nestc',
                                text => $Token->{tag_name},
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
            }
          
  push @$Tokens, $Token;
  
            if ($Token->{type} == START_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              if (not defined $LastStartTagName) { # "first start tag"
                $LastStartTagName = $Token->{tag_name};
                return 1;
              } else {
                $LastStartTagName = $Token->{tag_name};
              }
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
              return 1 if $Token->{tag_name} =~ /-/;
              return 1 if $Token->{attrs}->{is};
            }
          
  
            if ($Token->{type} == END_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              ## 
            }
          
  } elsif ($Input =~ /\G([\`])/gcs) {
  
              push @$Errors, {type => 'bare hcro', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__UNQUOTED__STATE;
  
              push @$Errors, {type => 'bad attribute value', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  } elsif ($Input =~ /\G(.)/gcs) {
  
              push @$Errors, {type => 'bare hcro', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__UNQUOTED__STATE;
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'bare hcro', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__UNQUOTED__STATE;
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[ATTR_VALUE__UNQUOTED__STATE___CHARREF_DECIMAL_NUM_STATE] = sub {
  if ($Input =~ /\G([0123456789]+)/gcs) {
  $Temp .= $1;
  } elsif ($Input =~ /\G([\;])/gcs) {
  
          my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  $Attr->{has_ref} = 1;
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__UNQUOTED__STATE;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  $Attr->{has_ref} = 1;
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__UNQUOTED__STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
  } elsif ($Input =~ /\G([\	\\ \
  ])/gcs) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  $Attr->{has_ref} = 1;
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = B_ATTR_NAME_STATE;
  } elsif ($Input =~ /\G([\])/gcs) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  $Attr->{has_ref} = 1;
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = B_ATTR_NAME_STATE;
  } elsif ($Input =~ /\G([\"])/gcs) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  $Attr->{has_ref} = 1;
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__UNQUOTED__STATE;
  
              push @$Errors, {type => 'bad attribute value', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  } elsif ($Input =~ /\G([\&])/gcs) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  $Attr->{has_ref} = 1;
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $Temp = q@&@;
  $TempIndex = $Offset + (pos $Input) - (length $1) - 0;
  $State = ATTR_VALUE__UNQUOTED__STATE___CHARREF_STATE;
  } elsif ($Input =~ /\G([\'])/gcs) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  $Attr->{has_ref} = 1;
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__UNQUOTED__STATE;
  
              push @$Errors, {type => 'bad attribute value', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  } elsif ($Input =~ /\G([\<])/gcs) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  $Attr->{has_ref} = 1;
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__UNQUOTED__STATE;
  
              push @$Errors, {type => 'tag not closed', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  } elsif ($Input =~ /\G([\=])/gcs) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  $Attr->{has_ref} = 1;
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__UNQUOTED__STATE;
  
              push @$Errors, {type => 'bad attribute value', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  } elsif ($Input =~ /\G([\>])/gcs) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  $Attr->{has_ref} = 1;
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = DATA_STATE;
  
            if ($Token->{type} == END_TAG_TOKEN) {
              if (keys %{$Token->{attrs} or {}}) {
                push @$Errors, {type => 'end tag attribute',
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
              if ($Token->{self_closing_flag}) {
                push @$Errors, {type => 'nestc',
                                text => $Token->{tag_name},
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
            }
          
  push @$Tokens, $Token;
  
            if ($Token->{type} == START_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              if (not defined $LastStartTagName) { # "first start tag"
                $LastStartTagName = $Token->{tag_name};
                return 1;
              } else {
                $LastStartTagName = $Token->{tag_name};
              }
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
              return 1 if $Token->{tag_name} =~ /-/;
              return 1 if $Token->{attrs}->{is};
            }
          
  
            if ($Token->{type} == END_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              ## 
            }
          
  } elsif ($Input =~ /\G([\`])/gcs) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  $Attr->{has_ref} = 1;
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__UNQUOTED__STATE;
  
              push @$Errors, {type => 'bad attribute value', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  } elsif ($Input =~ /\G(.)/gcs) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  $Attr->{has_ref} = 1;
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__UNQUOTED__STATE;
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
          my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  $Attr->{has_ref} = 1;
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__UNQUOTED__STATE;
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[ATTR_VALUE__UNQUOTED__STATE___CHARREF_HEX_NUM_STATE] = sub {
  if ($Input =~ /\G([0123456789ABCDEFafbcde]+)/gcs) {
  $Temp .= $1;
  } elsif ($Input =~ /\G([\;])/gcs) {
  
          my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  $Attr->{has_ref} = 1;
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__UNQUOTED__STATE;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  $Attr->{has_ref} = 1;
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__UNQUOTED__STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
  } elsif ($Input =~ /\G([\	\\ \
  ])/gcs) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  $Attr->{has_ref} = 1;
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = B_ATTR_NAME_STATE;
  } elsif ($Input =~ /\G([\])/gcs) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  $Attr->{has_ref} = 1;
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = B_ATTR_NAME_STATE;
  } elsif ($Input =~ /\G([\"])/gcs) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  $Attr->{has_ref} = 1;
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__UNQUOTED__STATE;
  
              push @$Errors, {type => 'bad attribute value', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  } elsif ($Input =~ /\G([\&])/gcs) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  $Attr->{has_ref} = 1;
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $Temp = q@&@;
  $TempIndex = $Offset + (pos $Input) - (length $1) - 0;
  $State = ATTR_VALUE__UNQUOTED__STATE___CHARREF_STATE;
  } elsif ($Input =~ /\G([\'])/gcs) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  $Attr->{has_ref} = 1;
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__UNQUOTED__STATE;
  
              push @$Errors, {type => 'bad attribute value', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  } elsif ($Input =~ /\G([\<])/gcs) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  $Attr->{has_ref} = 1;
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__UNQUOTED__STATE;
  
              push @$Errors, {type => 'tag not closed', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  } elsif ($Input =~ /\G([\=])/gcs) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  $Attr->{has_ref} = 1;
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__UNQUOTED__STATE;
  
              push @$Errors, {type => 'bad attribute value', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  } elsif ($Input =~ /\G([\>])/gcs) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  $Attr->{has_ref} = 1;
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = DATA_STATE;
  
            if ($Token->{type} == END_TAG_TOKEN) {
              if (keys %{$Token->{attrs} or {}}) {
                push @$Errors, {type => 'end tag attribute',
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
              if ($Token->{self_closing_flag}) {
                push @$Errors, {type => 'nestc',
                                text => $Token->{tag_name},
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
            }
          
  push @$Tokens, $Token;
  
            if ($Token->{type} == START_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              if (not defined $LastStartTagName) { # "first start tag"
                $LastStartTagName = $Token->{tag_name};
                return 1;
              } else {
                $LastStartTagName = $Token->{tag_name};
              }
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
              return 1 if $Token->{tag_name} =~ /-/;
              return 1 if $Token->{attrs}->{is};
            }
          
  
            if ($Token->{type} == END_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              ## 
            }
          
  } elsif ($Input =~ /\G([\`])/gcs) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  $Attr->{has_ref} = 1;
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__UNQUOTED__STATE;
  
              push @$Errors, {type => 'bad attribute value', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  } elsif ($Input =~ /\G(.)/gcs) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  $Attr->{has_ref} = 1;
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__UNQUOTED__STATE;
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
          my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  $Attr->{has_ref} = 1;
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__UNQUOTED__STATE;
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[ATTR_VALUE__UNQUOTED__STATE___CHARREF_NAME_STATE] = sub {
  if ($Input =~ /\G([\	\\ \
  ])/gcs) {
  
            my $return;
            REF: {
              ## 
  
              for (reverse (2 .. length $Temp)) {
                my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
                if (defined $value) {
                  my $temp_index = $TempIndex;
  
                  unless (';' eq substr $Temp, $_-1, 1) {
                    if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                      last REF;
                    } elsif (0) { # before_equals
                      last REF;
                    } else {
                      ## <HTML>
                      push @$Errors, {type => 'no refc',
                                      level => 'm',
                                      di => $DI,
                                      index => $TempIndex + $_};
                      ## </HTML>
                    }
  
                    ## A variant of |append-to-attr|
                    push @{$Attr->{value}},
                        [$value, $DI, $TempIndex]; # IndexedString
                    $TempIndex += $_;
                    $value = '';
                  }
  
                  ## 
  
                  $Attr->{has_ref} = 1;
                  substr ($Temp, 0, $_) = $value;
                  last REF;
                }
              }
              if ($Temp =~ /;\z/) {
                push @$Errors, {type => 'entity not declared',
                                value => $Temp,
                                level => 'm',
                                di => $DI, index => $TempIndex};
                ## 
              }
            } # REF
          
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = B_ATTR_NAME_STATE;
  return 1 if $return;
  } elsif ($Input =~ /\G([\])/gcs) {
  
            my $return;
            REF: {
              ## 
  
              for (reverse (2 .. length $Temp)) {
                my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
                if (defined $value) {
                  my $temp_index = $TempIndex;
  
                  unless (';' eq substr $Temp, $_-1, 1) {
                    if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                      last REF;
                    } elsif (0) { # before_equals
                      last REF;
                    } else {
                      ## <HTML>
                      push @$Errors, {type => 'no refc',
                                      level => 'm',
                                      di => $DI,
                                      index => $TempIndex + $_};
                      ## </HTML>
                    }
  
                    ## A variant of |append-to-attr|
                    push @{$Attr->{value}},
                        [$value, $DI, $TempIndex]; # IndexedString
                    $TempIndex += $_;
                    $value = '';
                  }
  
                  ## 
  
                  $Attr->{has_ref} = 1;
                  substr ($Temp, 0, $_) = $value;
                  last REF;
                }
              }
              if ($Temp =~ /;\z/) {
                push @$Errors, {type => 'entity not declared',
                                value => $Temp,
                                level => 'm',
                                di => $DI, index => $TempIndex};
                ## 
              }
            } # REF
          
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = B_ATTR_NAME_STATE;
  return 1 if $return;
  } elsif ($Input =~ /\G([\&])/gcs) {
  
            my $return;
            REF: {
              ## 
  
              for (reverse (2 .. length $Temp)) {
                my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
                if (defined $value) {
                  my $temp_index = $TempIndex;
  
                  unless (';' eq substr $Temp, $_-1, 1) {
                    if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                      last REF;
                    } elsif (0) { # before_equals
                      last REF;
                    } else {
                      ## <HTML>
                      push @$Errors, {type => 'no refc',
                                      level => 'm',
                                      di => $DI,
                                      index => $TempIndex + $_};
                      ## </HTML>
                    }
  
                    ## A variant of |append-to-attr|
                    push @{$Attr->{value}},
                        [$value, $DI, $TempIndex]; # IndexedString
                    $TempIndex += $_;
                    $value = '';
                  }
  
                  ## 
  
                  $Attr->{has_ref} = 1;
                  substr ($Temp, 0, $_) = $value;
                  last REF;
                }
              }
              if ($Temp =~ /;\z/) {
                push @$Errors, {type => 'entity not declared',
                                value => $Temp,
                                level => 'm',
                                di => $DI, index => $TempIndex};
                ## 
              }
            } # REF
          
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $Temp = q@&@;
  $TempIndex = $Offset + (pos $Input) - (length $1) - 0;
  $State = ATTR_VALUE__UNQUOTED__STATE___CHARREF_STATE;
  return 1 if $return;
  } elsif ($Input =~ /\G([0123456789]+)/gcs) {
  $Temp .= $1;
  } elsif ($Input =~ /\G([\;])/gcs) {
  $Temp .= $1;
  
            my $return;
            REF: {
              ## 
  
              for (reverse (2 .. length $Temp)) {
                my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
                if (defined $value) {
                  my $temp_index = $TempIndex;
  
                  unless (';' eq substr $Temp, $_-1, 1) {
                    if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                      last REF;
                    } elsif (0) { # before_equals
                      last REF;
                    } else {
                      ## <HTML>
                      push @$Errors, {type => 'no refc',
                                      level => 'm',
                                      di => $DI,
                                      index => $TempIndex + $_};
                      ## </HTML>
                    }
  
                    ## A variant of |append-to-attr|
                    push @{$Attr->{value}},
                        [$value, $DI, $TempIndex]; # IndexedString
                    $TempIndex += $_;
                    $value = '';
                  }
  
                  ## 
  
                  $Attr->{has_ref} = 1;
                  substr ($Temp, 0, $_) = $value;
                  last REF;
                }
              }
              if ($Temp =~ /;\z/) {
                push @$Errors, {type => 'entity not declared',
                                value => $Temp,
                                level => 'm',
                                di => $DI, index => $TempIndex};
                ## 
              }
            } # REF
          
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__UNQUOTED__STATE;
  return 1 if $return;
  } elsif ($Input =~ /\G([\>])/gcs) {
  
            my $return;
            REF: {
              ## 
  
              for (reverse (2 .. length $Temp)) {
                my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
                if (defined $value) {
                  my $temp_index = $TempIndex;
  
                  unless (';' eq substr $Temp, $_-1, 1) {
                    if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                      last REF;
                    } elsif (0) { # before_equals
                      last REF;
                    } else {
                      ## <HTML>
                      push @$Errors, {type => 'no refc',
                                      level => 'm',
                                      di => $DI,
                                      index => $TempIndex + $_};
                      ## </HTML>
                    }
  
                    ## A variant of |append-to-attr|
                    push @{$Attr->{value}},
                        [$value, $DI, $TempIndex]; # IndexedString
                    $TempIndex += $_;
                    $value = '';
                  }
  
                  ## 
  
                  $Attr->{has_ref} = 1;
                  substr ($Temp, 0, $_) = $value;
                  last REF;
                }
              }
              if ($Temp =~ /;\z/) {
                push @$Errors, {type => 'entity not declared',
                                value => $Temp,
                                level => 'm',
                                di => $DI, index => $TempIndex};
                ## 
              }
            } # REF
          
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = DATA_STATE;
  
            if ($Token->{type} == END_TAG_TOKEN) {
              if (keys %{$Token->{attrs} or {}}) {
                push @$Errors, {type => 'end tag attribute',
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
              if ($Token->{self_closing_flag}) {
                push @$Errors, {type => 'nestc',
                                text => $Token->{tag_name},
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
            }
          
  push @$Tokens, $Token;
  
            if ($Token->{type} == START_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              if (not defined $LastStartTagName) { # "first start tag"
                $LastStartTagName = $Token->{tag_name};
                return 1;
              } else {
                $LastStartTagName = $Token->{tag_name};
              }
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
              return 1 if $Token->{tag_name} =~ /-/;
              return 1 if $Token->{attrs}->{is};
            }
          
  
            if ($Token->{type} == END_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              ## 
            }
          
  return 1 if $return;
  } elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY]+)/gcs) {
  $Temp .= $1;
  } elsif ($Input =~ /\G([afbcdeghjknqrvwzilmopstuxy]+)/gcs) {
  $Temp .= $1;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
            my $return;
            REF: {
              ## 
  
              for (reverse (2 .. length $Temp)) {
                my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
                if (defined $value) {
                  my $temp_index = $TempIndex;
  
                  unless (';' eq substr $Temp, $_-1, 1) {
                    if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                      last REF;
                    } elsif (0) { # before_equals
                      last REF;
                    } else {
                      ## <HTML>
                      push @$Errors, {type => 'no refc',
                                      level => 'm',
                                      di => $DI,
                                      index => $TempIndex + $_};
                      ## </HTML>
                    }
  
                    ## A variant of |append-to-attr|
                    push @{$Attr->{value}},
                        [$value, $DI, $TempIndex]; # IndexedString
                    $TempIndex += $_;
                    $value = '';
                  }
  
                  ## 
  
                  $Attr->{has_ref} = 1;
                  substr ($Temp, 0, $_) = $value;
                  last REF;
                }
              }
              if ($Temp =~ /;\z/) {
                push @$Errors, {type => 'entity not declared',
                                value => $Temp,
                                level => 'm',
                                di => $DI, index => $TempIndex};
                ## 
              }
            } # REF
          
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__UNQUOTED__STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
  return 1 if $return;
  } elsif ($Input =~ /\G([\"])/gcs) {
  
            my $return;
            REF: {
              ## 
  
              for (reverse (2 .. length $Temp)) {
                my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
                if (defined $value) {
                  my $temp_index = $TempIndex;
  
                  unless (';' eq substr $Temp, $_-1, 1) {
                    if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                      last REF;
                    } elsif (0) { # before_equals
                      last REF;
                    } else {
                      ## <HTML>
                      push @$Errors, {type => 'no refc',
                                      level => 'm',
                                      di => $DI,
                                      index => $TempIndex + $_};
                      ## </HTML>
                    }
  
                    ## A variant of |append-to-attr|
                    push @{$Attr->{value}},
                        [$value, $DI, $TempIndex]; # IndexedString
                    $TempIndex += $_;
                    $value = '';
                  }
  
                  ## 
  
                  $Attr->{has_ref} = 1;
                  substr ($Temp, 0, $_) = $value;
                  last REF;
                }
              }
              if ($Temp =~ /;\z/) {
                push @$Errors, {type => 'entity not declared',
                                value => $Temp,
                                level => 'm',
                                di => $DI, index => $TempIndex};
                ## 
              }
            } # REF
          
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__UNQUOTED__STATE;
  
              push @$Errors, {type => 'bad attribute value', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  return 1 if $return;
  } elsif ($Input =~ /\G([\'])/gcs) {
  
            my $return;
            REF: {
              ## 
  
              for (reverse (2 .. length $Temp)) {
                my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
                if (defined $value) {
                  my $temp_index = $TempIndex;
  
                  unless (';' eq substr $Temp, $_-1, 1) {
                    if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                      last REF;
                    } elsif (0) { # before_equals
                      last REF;
                    } else {
                      ## <HTML>
                      push @$Errors, {type => 'no refc',
                                      level => 'm',
                                      di => $DI,
                                      index => $TempIndex + $_};
                      ## </HTML>
                    }
  
                    ## A variant of |append-to-attr|
                    push @{$Attr->{value}},
                        [$value, $DI, $TempIndex]; # IndexedString
                    $TempIndex += $_;
                    $value = '';
                  }
  
                  ## 
  
                  $Attr->{has_ref} = 1;
                  substr ($Temp, 0, $_) = $value;
                  last REF;
                }
              }
              if ($Temp =~ /;\z/) {
                push @$Errors, {type => 'entity not declared',
                                value => $Temp,
                                level => 'm',
                                di => $DI, index => $TempIndex};
                ## 
              }
            } # REF
          
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__UNQUOTED__STATE;
  
              push @$Errors, {type => 'bad attribute value', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  return 1 if $return;
  } elsif ($Input =~ /\G([\<])/gcs) {
  
            my $return;
            REF: {
              ## 
  
              for (reverse (2 .. length $Temp)) {
                my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
                if (defined $value) {
                  my $temp_index = $TempIndex;
  
                  unless (';' eq substr $Temp, $_-1, 1) {
                    if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                      last REF;
                    } elsif (0) { # before_equals
                      last REF;
                    } else {
                      ## <HTML>
                      push @$Errors, {type => 'no refc',
                                      level => 'm',
                                      di => $DI,
                                      index => $TempIndex + $_};
                      ## </HTML>
                    }
  
                    ## A variant of |append-to-attr|
                    push @{$Attr->{value}},
                        [$value, $DI, $TempIndex]; # IndexedString
                    $TempIndex += $_;
                    $value = '';
                  }
  
                  ## 
  
                  $Attr->{has_ref} = 1;
                  substr ($Temp, 0, $_) = $value;
                  last REF;
                }
              }
              if ($Temp =~ /;\z/) {
                push @$Errors, {type => 'entity not declared',
                                value => $Temp,
                                level => 'm',
                                di => $DI, index => $TempIndex};
                ## 
              }
            } # REF
          
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__UNQUOTED__STATE;
  
              push @$Errors, {type => 'tag not closed', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  return 1 if $return;
  } elsif ($Input =~ /\G([\=])/gcs) {
  
            my $return;
            REF: {
              ## 
  
              for (reverse (2 .. length $Temp)) {
                my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
                if (defined $value) {
                  my $temp_index = $TempIndex;
  
                  unless (';' eq substr $Temp, $_-1, 1) {
                    if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                      last REF;
                    } elsif (1) { # before_equals
                      last REF;
                    } else {
                      ## <HTML>
                      push @$Errors, {type => 'no refc',
                                      level => 'm',
                                      di => $DI,
                                      index => $TempIndex + $_};
                      ## </HTML>
                    }
  
                    ## A variant of |append-to-attr|
                    push @{$Attr->{value}},
                        [$value, $DI, $TempIndex]; # IndexedString
                    $TempIndex += $_;
                    $value = '';
                  }
  
                  ## 
  
                  $Attr->{has_ref} = 1;
                  substr ($Temp, 0, $_) = $value;
                  last REF;
                }
              }
              if ($Temp =~ /;\z/) {
                push @$Errors, {type => 'entity not declared',
                                value => $Temp,
                                level => 'm',
                                di => $DI, index => $TempIndex};
                ## 
              }
            } # REF
          
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__UNQUOTED__STATE;
  
              push @$Errors, {type => 'bad attribute value', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  return 1 if $return;
  } elsif ($Input =~ /\G([\`])/gcs) {
  
            my $return;
            REF: {
              ## 
  
              for (reverse (2 .. length $Temp)) {
                my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
                if (defined $value) {
                  my $temp_index = $TempIndex;
  
                  unless (';' eq substr $Temp, $_-1, 1) {
                    if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                      last REF;
                    } elsif (0) { # before_equals
                      last REF;
                    } else {
                      ## <HTML>
                      push @$Errors, {type => 'no refc',
                                      level => 'm',
                                      di => $DI,
                                      index => $TempIndex + $_};
                      ## </HTML>
                    }
  
                    ## A variant of |append-to-attr|
                    push @{$Attr->{value}},
                        [$value, $DI, $TempIndex]; # IndexedString
                    $TempIndex += $_;
                    $value = '';
                  }
  
                  ## 
  
                  $Attr->{has_ref} = 1;
                  substr ($Temp, 0, $_) = $value;
                  last REF;
                }
              }
              if ($Temp =~ /;\z/) {
                push @$Errors, {type => 'entity not declared',
                                value => $Temp,
                                level => 'm',
                                di => $DI, index => $TempIndex};
                ## 
              }
            } # REF
          
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__UNQUOTED__STATE;
  
              push @$Errors, {type => 'bad attribute value', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  return 1 if $return;
  } elsif ($Input =~ /\G(.)/gcs) {
  
            my $return;
            REF: {
              ## 
  
              for (reverse (2 .. length $Temp)) {
                my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
                if (defined $value) {
                  my $temp_index = $TempIndex;
  
                  unless (';' eq substr $Temp, $_-1, 1) {
                    if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                      last REF;
                    } elsif (0) { # before_equals
                      last REF;
                    } else {
                      ## <HTML>
                      push @$Errors, {type => 'no refc',
                                      level => 'm',
                                      di => $DI,
                                      index => $TempIndex + $_};
                      ## </HTML>
                    }
  
                    ## A variant of |append-to-attr|
                    push @{$Attr->{value}},
                        [$value, $DI, $TempIndex]; # IndexedString
                    $TempIndex += $_;
                    $value = '';
                  }
  
                  ## 
  
                  $Attr->{has_ref} = 1;
                  substr ($Temp, 0, $_) = $value;
                  last REF;
                }
              }
              if ($Temp =~ /;\z/) {
                push @$Errors, {type => 'entity not declared',
                                value => $Temp,
                                level => 'm',
                                di => $DI, index => $TempIndex};
                ## 
              }
            } # REF
          
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__UNQUOTED__STATE;
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  return 1 if $return;
  } else {
  if ($EOF) {
  
            my $return;
            REF: {
              ## 
  
              for (reverse (2 .. length $Temp)) {
                my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
                if (defined $value) {
                  my $temp_index = $TempIndex;
  
                  unless (';' eq substr $Temp, $_-1, 1) {
                    if ((substr $Temp, $_, 1) =~ /^[A-Za-z0-9]/) {
                      last REF;
                    } elsif (0) { # before_equals
                      last REF;
                    } else {
                      ## <HTML>
                      push @$Errors, {type => 'no refc',
                                      level => 'm',
                                      di => $DI,
                                      index => $TempIndex + $_};
                      ## </HTML>
                    }
  
                    ## A variant of |append-to-attr|
                    push @{$Attr->{value}},
                        [$value, $DI, $TempIndex]; # IndexedString
                    $TempIndex += $_;
                    $value = '';
                  }
  
                  ## 
  
                  $Attr->{has_ref} = 1;
                  substr ($Temp, 0, $_) = $value;
                  last REF;
                }
              }
              if ($Temp =~ /;\z/) {
                push @$Errors, {type => 'entity not declared',
                                value => $Temp,
                                level => 'm',
                                di => $DI, index => $TempIndex};
                ## 
              }
            } # REF
          
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__UNQUOTED__STATE;
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[ATTR_VALUE__UNQUOTED__STATE___CHARREF_NUM_STATE] = sub {
  if ($Input =~ /\G([0123456789])/gcs) {
  $Temp .= $1;
  $State = ATTR_VALUE__UNQUOTED__STATE___CHARREF_DECIMAL_NUM_STATE;
  } elsif ($Input =~ /\G([X])/gcs) {
  $Temp .= $1;
  $State = ATTR_VALUE__UNQUOTED__STATE___CHARREF_BEFORE_HEX_NUM_STATE;
  } elsif ($Input =~ /\G([x])/gcs) {
  $Temp .= $1;
  $State = ATTR_VALUE__UNQUOTED__STATE___CHARREF_BEFORE_HEX_NUM_STATE;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'bare nero', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__UNQUOTED__STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
  } elsif ($Input =~ /\G([\	\\ \
  ])/gcs) {
  
              push @$Errors, {type => 'bare nero', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = B_ATTR_NAME_STATE;
  } elsif ($Input =~ /\G([\])/gcs) {
  
              push @$Errors, {type => 'bare nero', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = B_ATTR_NAME_STATE;
  } elsif ($Input =~ /\G([\"])/gcs) {
  
              push @$Errors, {type => 'bare nero', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__UNQUOTED__STATE;
  
              push @$Errors, {type => 'bad attribute value', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  } elsif ($Input =~ /\G([\&])/gcs) {
  
              push @$Errors, {type => 'bare nero', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $Temp = q@&@;
  $TempIndex = $Offset + (pos $Input) - (length $1) - 0;
  $State = ATTR_VALUE__UNQUOTED__STATE___CHARREF_STATE;
  } elsif ($Input =~ /\G([\'])/gcs) {
  
              push @$Errors, {type => 'bare nero', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__UNQUOTED__STATE;
  
              push @$Errors, {type => 'bad attribute value', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  } elsif ($Input =~ /\G([\<])/gcs) {
  
              push @$Errors, {type => 'bare nero', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__UNQUOTED__STATE;
  
              push @$Errors, {type => 'tag not closed', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  } elsif ($Input =~ /\G([\=])/gcs) {
  
              push @$Errors, {type => 'bare nero', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__UNQUOTED__STATE;
  
              push @$Errors, {type => 'bad attribute value', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  } elsif ($Input =~ /\G([\>])/gcs) {
  
              push @$Errors, {type => 'bare nero', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = DATA_STATE;
  
            if ($Token->{type} == END_TAG_TOKEN) {
              if (keys %{$Token->{attrs} or {}}) {
                push @$Errors, {type => 'end tag attribute',
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
              if ($Token->{self_closing_flag}) {
                push @$Errors, {type => 'nestc',
                                text => $Token->{tag_name},
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
            }
          
  push @$Tokens, $Token;
  
            if ($Token->{type} == START_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              if (not defined $LastStartTagName) { # "first start tag"
                $LastStartTagName = $Token->{tag_name};
                return 1;
              } else {
                $LastStartTagName = $Token->{tag_name};
              }
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
              return 1 if $Token->{tag_name} =~ /-/;
              return 1 if $Token->{attrs}->{is};
            }
          
  
            if ($Token->{type} == END_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              ## 
            }
          
  } elsif ($Input =~ /\G([\`])/gcs) {
  
              push @$Errors, {type => 'bare nero', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__UNQUOTED__STATE;
  
              push @$Errors, {type => 'bad attribute value', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  } elsif ($Input =~ /\G(.)/gcs) {
  
              push @$Errors, {type => 'bare nero', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__UNQUOTED__STATE;
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'bare nero', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__UNQUOTED__STATE;
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[ATTR_VALUE__UNQUOTED__STATE___CHARREF_STATE] = sub {
  if ($Input =~ /\G([\	\\ \
  ])/gcs) {
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = B_ATTR_NAME_STATE;
  } elsif ($Input =~ /\G([\])/gcs) {
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = B_ATTR_NAME_STATE;
  } elsif ($Input =~ /\G([\#])/gcs) {
  $Temp .= $1;
  $State = ATTR_VALUE__UNQUOTED__STATE___CHARREF_NUM_STATE;
  } elsif ($Input =~ /\G([\&])/gcs) {
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $Temp = q@&@;
  $TempIndex = $Offset + (pos $Input) - (length $1) - 0;
  $State = ATTR_VALUE__UNQUOTED__STATE___CHARREF_STATE;
  } elsif ($Input =~ /\G([0123456789])/gcs) {
  $Temp .= $1;
  $State = ATTR_VALUE__UNQUOTED__STATE___CHARREF_NAME_STATE;
  } elsif ($Input =~ /\G([\>])/gcs) {
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = DATA_STATE;
  
            if ($Token->{type} == END_TAG_TOKEN) {
              if (keys %{$Token->{attrs} or {}}) {
                push @$Errors, {type => 'end tag attribute',
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
              if ($Token->{self_closing_flag}) {
                push @$Errors, {type => 'nestc',
                                text => $Token->{tag_name},
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
            }
          
  push @$Tokens, $Token;
  
            if ($Token->{type} == START_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              if (not defined $LastStartTagName) { # "first start tag"
                $LastStartTagName = $Token->{tag_name};
                return 1;
              } else {
                $LastStartTagName = $Token->{tag_name};
              }
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
              return 1 if $Token->{tag_name} =~ /-/;
              return 1 if $Token->{attrs}->{is};
            }
          
  
            if ($Token->{type} == END_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              ## 
            }
          
  } elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {
  $Temp .= $1;
  $State = ATTR_VALUE__UNQUOTED__STATE___CHARREF_NAME_STATE;
  } elsif ($Input =~ /\G([afbcdeghjknqrvwzilmopstuxy])/gcs) {
  $Temp .= $1;
  $State = ATTR_VALUE__UNQUOTED__STATE___CHARREF_NAME_STATE;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__UNQUOTED__STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
  } elsif ($Input =~ /\G([\"])/gcs) {
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__UNQUOTED__STATE;
  
              push @$Errors, {type => 'bad attribute value', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  } elsif ($Input =~ /\G([\'])/gcs) {
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__UNQUOTED__STATE;
  
              push @$Errors, {type => 'bad attribute value', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  } elsif ($Input =~ /\G([\<])/gcs) {
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__UNQUOTED__STATE;
  
              push @$Errors, {type => 'tag not closed', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  } elsif ($Input =~ /\G([\=])/gcs) {
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__UNQUOTED__STATE;
  
              push @$Errors, {type => 'bad attribute value', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  } elsif ($Input =~ /\G([\`])/gcs) {
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__UNQUOTED__STATE;
  
              push @$Errors, {type => 'bad attribute value', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  } elsif ($Input =~ /\G(.)/gcs) {
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__UNQUOTED__STATE;
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  } else {
  if ($EOF) {
  push @{$Attr->{q<value>}}, [$Temp, $DI, $TempIndex];
  $State = ATTR_VALUE__UNQUOTED__STATE;
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[ATTR_VALUE__UNQUOTED__STATE_CR] = sub {
  if ($Input =~ /\G([\	\\ ])/gcs) {
  $State = B_ATTR_NAME_STATE;
  } elsif ($Input =~ /\G([\
  ])/gcs) {
  $State = ATTR_VALUE__UNQUOTED__STATE;
  } elsif ($Input =~ /\G([\])/gcs) {
  $State = B_ATTR_NAME_STATE;
  } elsif ($Input =~ /\G([\&])/gcs) {
  $Temp = q@&@;
  $TempIndex = $Offset + (pos $Input) - (length $1) - 0;
  $State = ATTR_VALUE__UNQUOTED__STATE___CHARREF_STATE;
  } elsif ($Input =~ /\G([\>])/gcs) {
  $State = DATA_STATE;
  
            if ($Token->{type} == END_TAG_TOKEN) {
              if (keys %{$Token->{attrs} or {}}) {
                push @$Errors, {type => 'end tag attribute',
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
              if ($Token->{self_closing_flag}) {
                push @$Errors, {type => 'nestc',
                                text => $Token->{tag_name},
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
            }
          
  push @$Tokens, $Token;
  
            if ($Token->{type} == START_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              if (not defined $LastStartTagName) { # "first start tag"
                $LastStartTagName = $Token->{tag_name};
                return 1;
              } else {
                $LastStartTagName = $Token->{tag_name};
              }
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
              return 1 if $Token->{tag_name} =~ /-/;
              return 1 if $Token->{attrs}->{is};
            }
          
  
            if ($Token->{type} == END_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              ## 
            }
          
  } elsif ($Input =~ /\G([\ ])/gcs) {
  $State = ATTR_VALUE__UNQUOTED__STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
  } elsif ($Input =~ /\G([\"])/gcs) {
  $State = ATTR_VALUE__UNQUOTED__STATE;
  
              push @$Errors, {type => 'bad attribute value', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  } elsif ($Input =~ /\G([\'])/gcs) {
  $State = ATTR_VALUE__UNQUOTED__STATE;
  
              push @$Errors, {type => 'bad attribute value', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  } elsif ($Input =~ /\G([\<])/gcs) {
  $State = ATTR_VALUE__UNQUOTED__STATE;
  
              push @$Errors, {type => 'tag not closed', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  } elsif ($Input =~ /\G([\=])/gcs) {
  $State = ATTR_VALUE__UNQUOTED__STATE;
  
              push @$Errors, {type => 'bad attribute value', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  } elsif ($Input =~ /\G([\`])/gcs) {
  $State = ATTR_VALUE__UNQUOTED__STATE;
  
              push @$Errors, {type => 'bad attribute value', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  } elsif ($Input =~ /\G(.)/gcs) {
  $State = ATTR_VALUE__UNQUOTED__STATE;
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  } else {
  if ($EOF) {
  $State = ATTR_VALUE__UNQUOTED__STATE;
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[B_DOCTYPE_NAME_STATE] = sub {
  if ($Input =~ /\G([\	\\ \
  \]+)/gcs) {
  } elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {
  
          $Token = {type => DOCTYPE_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<name>} = chr ((ord $1) + 32);
  $State = DOCTYPE_NAME_STATE;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => DOCTYPE_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<name>} = q@@;
  $State = DOCTYPE_NAME_STATE;
  } elsif ($Input =~ /\G([\>])/gcs) {
  
              push @$Errors, {type => 'no DOCTYPE name', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => DOCTYPE_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<force_quirks_flag>} = 1;
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G(.)/gcs) {
  
          $Token = {type => DOCTYPE_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<name>} = $1;
  $State = DOCTYPE_NAME_STATE;
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
          $Token = {type => DOCTYPE_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<force_quirks_flag>} = 1;
  push @$Tokens, $Token;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[B_DOCTYPE_PUBLIC_ID_STATE] = sub {
  if ($Input =~ /\G([\	\\ \
  \]+)/gcs) {
  } elsif ($Input =~ /\G([\"])/gcs) {
  $Token->{q<public_identifier>} = '';
  $State = DOCTYPE_PUBLIC_ID__DQ__STATE;
  } elsif ($Input =~ /\G([\'])/gcs) {
  $Token->{q<public_identifier>} = '';
  $State = DOCTYPE_PUBLIC_ID__SQ__STATE;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = BOGUS_DOCTYPE_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  } elsif ($Input =~ /\G([\>])/gcs) {
  
              push @$Errors, {type => 'no DOCTYPE literal', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G(.)/gcs) {
  
              push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = BOGUS_DOCTYPE_STATE;
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  $Token->{q<force_quirks_flag>} = 1;
  push @$Tokens, $Token;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[B_DOCTYPE_SYSTEM_ID_STATE] = sub {
  if ($Input =~ /\G([\	\\ \
  \]+)/gcs) {
  } elsif ($Input =~ /\G([\"])/gcs) {
  $Token->{q<system_identifier>} = '';
  $State = DOCTYPE_SYSTEM_ID__DQ__STATE;
  } elsif ($Input =~ /\G([\'])/gcs) {
  $Token->{q<system_identifier>} = '';
  $State = DOCTYPE_SYSTEM_ID__SQ__STATE;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = BOGUS_DOCTYPE_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  } elsif ($Input =~ /\G([\>])/gcs) {
  
              push @$Errors, {type => 'no DOCTYPE literal', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G(.)/gcs) {
  
              push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = BOGUS_DOCTYPE_STATE;
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  $Token->{q<force_quirks_flag>} = 1;
  push @$Tokens, $Token;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[B_ATTR_NAME_STATE] = sub {
  if ($Input =~ /\G([^\ \	\
  \\\ \"\'\/\<\=\>A-Z])([^\ \	\
  \\\ \"\'\/\<\=\>A-Z]*)/gcs) {
  $Attr = {di => $DI};
  $Attr->{q<name>} = $1;
  $Attr->{index} = $Offset + $-[1];
  $Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
  $State = ATTR_NAME_STATE;
  $Attr->{q<name>} .= $2;
  } elsif ($Input =~ /\G([A-Z])([^\ \	\
  \\\ \"\'\/\<\=\>A-Z]*)/gcs) {
  $Attr = {di => $DI};
  $Attr->{q<name>} = chr ((ord $1) + 32);
  $Attr->{index} = $Offset + $-[1];
  $Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
  $State = ATTR_NAME_STATE;
  $Attr->{q<name>} .= $2;
  } elsif ($Input =~ /\G\/\>/gcs) {
  $State = SELF_CLOSING_START_TAG_STATE;
  $Token->{q<self_closing_flag>} = 1;
  $State = DATA_STATE;
  
            if ($Token->{type} == END_TAG_TOKEN) {
              if (keys %{$Token->{attrs} or {}}) {
                push @$Errors, {type => 'end tag attribute',
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
              if ($Token->{self_closing_flag}) {
                push @$Errors, {type => 'nestc',
                                text => $Token->{tag_name},
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
            }
          
  push @$Tokens, $Token;
  
            if ($Token->{type} == START_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              if (not defined $LastStartTagName) { # "first start tag"
                $LastStartTagName = $Token->{tag_name};
                return 1;
              } else {
                $LastStartTagName = $Token->{tag_name};
              }
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
              return 1 if $Token->{tag_name} =~ /-/;
              return 1 if $Token->{attrs}->{is};
            }
          
  
            if ($Token->{type} == END_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              ## 
            }
          
  } elsif ($Input =~ /\G\>/gcs) {
  $State = DATA_STATE;
  
            if ($Token->{type} == END_TAG_TOKEN) {
              if (keys %{$Token->{attrs} or {}}) {
                push @$Errors, {type => 'end tag attribute',
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
              if ($Token->{self_closing_flag}) {
                push @$Errors, {type => 'nestc',
                                text => $Token->{tag_name},
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
            }
          
  push @$Tokens, $Token;
  
            if ($Token->{type} == START_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              if (not defined $LastStartTagName) { # "first start tag"
                $LastStartTagName = $Token->{tag_name};
                return 1;
              } else {
                $LastStartTagName = $Token->{tag_name};
              }
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
              return 1 if $Token->{tag_name} =~ /-/;
              return 1 if $Token->{attrs}->{is};
            }
          
  
            if ($Token->{type} == END_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              ## 
            }
          
  } elsif ($Input =~ /\G([\	\\ \
  \]+)/gcs) {
  } elsif ($Input =~ /\G([\/])/gcs) {
  $State = SELF_CLOSING_START_TAG_STATE;
  } elsif ($Input =~ /\G([\>])/gcs) {
  $State = DATA_STATE;
  
            if ($Token->{type} == END_TAG_TOKEN) {
              if (keys %{$Token->{attrs} or {}}) {
                push @$Errors, {type => 'end tag attribute',
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
              if ($Token->{self_closing_flag}) {
                push @$Errors, {type => 'nestc',
                                text => $Token->{tag_name},
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
            }
          
  push @$Tokens, $Token;
  
            if ($Token->{type} == START_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              if (not defined $LastStartTagName) { # "first start tag"
                $LastStartTagName = $Token->{tag_name};
                return 1;
              } else {
                $LastStartTagName = $Token->{tag_name};
              }
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
              return 1 if $Token->{tag_name} =~ /-/;
              return 1 if $Token->{attrs}->{is};
            }
          
  
            if ($Token->{type} == END_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              ## 
            }
          
  } elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {
  $Attr = {di => $DI};
  $Attr->{q<name>} = chr ((ord $1) + 32);
  $Attr->{index} = $Offset + (pos $Input) - length $1;
  $Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
  $State = ATTR_NAME_STATE;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  $Attr = {di => $DI};
  $Attr->{q<name>} = q@@;
  $Attr->{index} = $Offset + (pos $Input) - length $1;
  $Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
  $State = ATTR_NAME_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  } elsif ($Input =~ /\G([\"])/gcs) {
  $Attr = {di => $DI};
  $Attr->{q<name>} = $1;
  $Attr->{index} = $Offset + (pos $Input) - length $1;
  $Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
  $State = ATTR_NAME_STATE;
  
              push @$Errors, {type => 'bad attribute name', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  } elsif ($Input =~ /\G([\'])/gcs) {
  $Attr = {di => $DI};
  $Attr->{q<name>} = $1;
  $Attr->{index} = $Offset + (pos $Input) - length $1;
  $Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
  $State = ATTR_NAME_STATE;
  
              push @$Errors, {type => 'bad attribute name', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  } elsif ($Input =~ /\G([\<])/gcs) {
  $Attr = {di => $DI};
  $Attr->{q<name>} = $1;
  $Attr->{index} = $Offset + (pos $Input) - length $1;
  $Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
  $State = ATTR_NAME_STATE;
  
              push @$Errors, {type => 'tag not closed', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  } elsif ($Input =~ /\G([\=])/gcs) {
  
              push @$Errors, {type => 'parser:no attr name', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Attr = {di => $DI};
  $Attr->{q<name>} = $1;
  $Attr->{index} = $Offset + (pos $Input) - length $1;
  $Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
  $State = ATTR_NAME_STATE;
  } elsif ($Input =~ /\G(.)/gcs) {
  $Attr = {di => $DI};
  $Attr->{q<name>} = $1;
  $Attr->{index} = $Offset + (pos $Input) - length $1;
  $Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
  $State = ATTR_NAME_STATE;
  } else {
  if ($EOF) {
  $State = A_ATTR_NAME_STATE;
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[B_ATTR_VALUE_STATE] = sub {
  if ($Input =~ /\G([\	\\ \
  \]+)/gcs) {
  } elsif ($Input =~ /\G([\"])/gcs) {
  $State = ATTR_VALUE__DQ__STATE;
  } elsif ($Input =~ /\G([\&])/gcs) {
  $Temp = q@&@;
  $TempIndex = $Offset + (pos $Input) - (length $1) - 0;
  $State = ATTR_VALUE__UNQUOTED__STATE___CHARREF_STATE;
  } elsif ($Input =~ /\G([\'])/gcs) {
  $State = ATTR_VALUE__SQ__STATE;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  $State = ATTR_VALUE__UNQUOTED__STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [q@@, $DI, $Offset + (pos $Input) - length $1];
  } elsif ($Input =~ /\G([\<])/gcs) {
  $State = ATTR_VALUE__UNQUOTED__STATE;
  
              push @$Errors, {type => 'tag not closed', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  } elsif ($Input =~ /\G([\=])/gcs) {
  $State = ATTR_VALUE__UNQUOTED__STATE;
  
              push @$Errors, {type => 'bad attribute value', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  } elsif ($Input =~ /\G([\>])/gcs) {
  
              push @$Errors, {type => 'bad attribute value', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $State = DATA_STATE;
  
            if ($Token->{type} == END_TAG_TOKEN) {
              if (keys %{$Token->{attrs} or {}}) {
                push @$Errors, {type => 'end tag attribute',
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
              if ($Token->{self_closing_flag}) {
                push @$Errors, {type => 'nestc',
                                text => $Token->{tag_name},
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
            }
          
  push @$Tokens, $Token;
  
            if ($Token->{type} == START_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              if (not defined $LastStartTagName) { # "first start tag"
                $LastStartTagName = $Token->{tag_name};
                return 1;
              } else {
                $LastStartTagName = $Token->{tag_name};
              }
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
              return 1 if $Token->{tag_name} =~ /-/;
              return 1 if $Token->{attrs}->{is};
            }
          
  
            if ($Token->{type} == END_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              ## 
            }
          
  } elsif ($Input =~ /\G([\`])/gcs) {
  $State = ATTR_VALUE__UNQUOTED__STATE;
  
              push @$Errors, {type => 'bad attribute value', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  } elsif ($Input =~ /\G(.)/gcs) {
  $State = ATTR_VALUE__UNQUOTED__STATE;
  push @{$Attr->{q<value>}}, [$1, $DI, $Offset + (pos $Input) - length $1];
  } else {
  if ($EOF) {
  $State = ATTR_VALUE__UNQUOTED__STATE;
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDS_STATE] = sub {
  if ($Input =~ /\G([\	\\ \
  \]+)/gcs) {
  } elsif ($Input =~ /\G([\"])/gcs) {
  $Token->{q<system_identifier>} = '';
  $State = DOCTYPE_SYSTEM_ID__DQ__STATE;
  } elsif ($Input =~ /\G([\'])/gcs) {
  $Token->{q<system_identifier>} = '';
  $State = DOCTYPE_SYSTEM_ID__SQ__STATE;
  } elsif ($Input =~ /\G([\>])/gcs) {
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = BOGUS_DOCTYPE_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  } elsif ($Input =~ /\G(.)/gcs) {
  
              push @$Errors, {type => 'bogus DOCTYPE', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<force_quirks_flag>} = 1;
  $State = BOGUS_DOCTYPE_STATE;
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  $Token->{q<force_quirks_flag>} = 1;
  push @$Tokens, $Token;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[BOGUS_DOCTYPE_STATE] = sub {
  if ($Input =~ /\G([^\>\ ]+)/gcs) {
  
  } elsif ($Input =~ /\G([\>])/gcs) {
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  } else {
  if ($EOF) {
  push @$Tokens, $Token;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[BOGUS_COMMENT_STATE] = sub {
  if ($Input =~ /\G([^\\>\ ]+)/gcs) {
  push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
  
  } elsif ($Input =~ /\G([\])/gcs) {
  push @{$Token->{q<data>}}, [q@
  @, $DI, $Offset + (pos $Input) - (length $1) - 0];
  $State = BOGUS_COMMENT_STATE_CR;
  } elsif ($Input =~ /\G([\>])/gcs) {
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
  } else {
  if ($EOF) {
  push @$Tokens, $Token;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[BOGUS_COMMENT_STATE_CR] = sub {
  if ($Input =~ /\G([\
  ])/gcs) {
  $State = BOGUS_COMMENT_STATE;
  } elsif ($Input =~ /\G([\])/gcs) {
  push @{$Token->{q<data>}}, [q@
  @, $DI, $Offset + (pos $Input) - (length $1) - 0];
  $State = BOGUS_COMMENT_STATE_CR;
  } elsif ($Input =~ /\G([\>])/gcs) {
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  $State = BOGUS_COMMENT_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
  } elsif ($Input =~ /\G(.)/gcs) {
  $State = BOGUS_COMMENT_STATE;
  push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
  } else {
  if ($EOF) {
  $State = BOGUS_COMMENT_STATE;
  push @$Tokens, $Token;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[CHARREF_IN_RCDATA_STATE] = sub {
  if ($Input =~ /\G([\])/gcs) {
  $Temp = q@&@;
  $TempIndex = $Offset + (pos $Input) - (length $1) - 1;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@
  @,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  $State = RCDATA_STATE_CR;
  } elsif ($Input =~ /\G([\#])/gcs) {
  $Temp = q@&@;
  $TempIndex = $Offset + (pos $Input) - (length $1) - 1;
  $Temp .= $1;
  $State = RCDATA_STATE___CHARREF_NUM_STATE;
  } elsif ($Input =~ /\G([\&])/gcs) {
  $Temp = q@&@;
  $TempIndex = $Offset + (pos $Input) - (length $1) - 1;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = CHARREF_IN_RCDATA_STATE;
  } elsif ($Input =~ /\G([0123456789])/gcs) {
  $Temp = q@&@;
  $TempIndex = $Offset + (pos $Input) - (length $1) - 1;
  $Temp .= $1;
  $State = RCDATA_STATE___CHARREF_NAME_STATE;
  } elsif ($Input =~ /\G([\<])/gcs) {
  $Temp = q@&@;
  $TempIndex = $Offset + (pos $Input) - (length $1) - 1;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = RCDATA_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  } elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {
  $Temp = q@&@;
  $TempIndex = $Offset + (pos $Input) - (length $1) - 1;
  $Temp .= $1;
  $State = RCDATA_STATE___CHARREF_NAME_STATE;
  } elsif ($Input =~ /\G([afbcdeghjknqrvwzilmopstuxy])/gcs) {
  $Temp = q@&@;
  $TempIndex = $Offset + (pos $Input) - (length $1) - 1;
  $Temp .= $1;
  $State = RCDATA_STATE___CHARREF_NAME_STATE;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  $Temp = q@&@;
  $TempIndex = $Offset + (pos $Input) - (length $1) - 1;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = RCDATA_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  } elsif ($Input =~ /\G(.)/gcs) {
  $Temp = q@&@;
  $TempIndex = $Offset + (pos $Input) - (length $1) - 1;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = RCDATA_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } else {
  if ($EOF) {
  $Temp = q@&@;
  $TempIndex = $Offset + (pos $Input) - 1;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = RCDATA_STATE;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[CHARREF_IN_DATA_STATE] = sub {
  if ($Input =~ /\G([\])/gcs) {
  $Temp = q@&@;
  $TempIndex = $Offset + (pos $Input) - (length $1) - 1;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@
  @,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  $State = DATA_STATE_CR;
  } elsif ($Input =~ /\G([\#])/gcs) {
  $Temp = q@&@;
  $TempIndex = $Offset + (pos $Input) - (length $1) - 1;
  $Temp .= $1;
  $State = DATA_STATE___CHARREF_NUM_STATE;
  } elsif ($Input =~ /\G([\&])/gcs) {
  $Temp = q@&@;
  $TempIndex = $Offset + (pos $Input) - (length $1) - 1;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = CHARREF_IN_DATA_STATE;
  } elsif ($Input =~ /\G([0123456789])/gcs) {
  $Temp = q@&@;
  $TempIndex = $Offset + (pos $Input) - (length $1) - 1;
  $Temp .= $1;
  $State = DATA_STATE___CHARREF_NAME_STATE;
  } elsif ($Input =~ /\G([\<])/gcs) {
  $Temp = q@&@;
  $TempIndex = $Offset + (pos $Input) - (length $1) - 1;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = TAG_OPEN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  } elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {
  $Temp = q@&@;
  $TempIndex = $Offset + (pos $Input) - (length $1) - 1;
  $Temp .= $1;
  $State = DATA_STATE___CHARREF_NAME_STATE;
  } elsif ($Input =~ /\G([afbcdeghjknqrvwzilmopstuxy])/gcs) {
  $Temp = q@&@;
  $TempIndex = $Offset + (pos $Input) - (length $1) - 1;
  $Temp .= $1;
  $State = DATA_STATE___CHARREF_NAME_STATE;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  $Temp = q@&@;
  $TempIndex = $Offset + (pos $Input) - (length $1) - 1;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = DATA_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } elsif ($Input =~ /\G(.)/gcs) {
  $Temp = q@&@;
  $TempIndex = $Offset + (pos $Input) - (length $1) - 1;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = DATA_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } else {
  if ($EOF) {
  $Temp = q@&@;
  $TempIndex = $Offset + (pos $Input) - 1;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = DATA_STATE;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[COMMENT_END_BANG_STATE] = sub {
  if ($Input =~ /\G([\])/gcs) {
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + (pos $Input) - (length $1) - 3];
  push @{$Token->{q<data>}}, [q@
  @, $DI, $Offset + (pos $Input) - (length $1) - 0];
  $State = COMMENT_STATE_CR;
  } elsif ($Input =~ /\G([\-])/gcs) {
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + (pos $Input) - (length $1) - 3];
  $State = COMMENT_END_DASH_STATE;
  } elsif ($Input =~ /\G([\<])/gcs) {
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + (pos $Input) - (length $1) - 3];
  push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + (pos $Input) - (length $1) - 3];
  $State = COMMENT_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
  } elsif ($Input =~ /\G([\>])/gcs) {
  
              push @$Errors, {type => 'parser:comment not closed', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G(.)/gcs) {
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + (pos $Input) - (length $1) - 3];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  push @$Tokens, $Token;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[COMMENT_END_DASH_STATE] = sub {
  if ($Input =~ /\G([\])/gcs) {
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + (pos $Input) - (length $1) - 1];
  push @{$Token->{q<data>}}, [q@
  @, $DI, $Offset + (pos $Input) - (length $1) - 0];
  $State = COMMENT_STATE_CR;
  } elsif ($Input =~ /\G([\-])/gcs) {
  $State = COMMENT_END_STATE;
  } elsif ($Input =~ /\G([\<])/gcs) {
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + (pos $Input) - (length $1) - 1];
  push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + (pos $Input) - (length $1) - 1];
  $State = COMMENT_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
  } elsif ($Input =~ /\G(.)/gcs) {
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + (pos $Input) - (length $1) - 1];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  push @$Tokens, $Token;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[COMMENT_END_DASH_STATE_CR] = sub {
  if ($Input =~ /\G([\
  ])/gcs) {
  $State = COMMENT_END_DASH_STATE;
  } elsif ($Input =~ /\G([\])/gcs) {
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + (pos $Input) - (length $1) - 1];
  push @{$Token->{q<data>}}, [q@
  @, $DI, $Offset + (pos $Input) - (length $1) - 0];
  $State = COMMENT_STATE_CR;
  } elsif ($Input =~ /\G([\-])/gcs) {
  $State = COMMENT_END_STATE;
  } elsif ($Input =~ /\G([\<])/gcs) {
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + (pos $Input) - (length $1) - 1];
  push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + (pos $Input) - (length $1) - 1];
  $State = COMMENT_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
  } elsif ($Input =~ /\G(.)/gcs) {
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + (pos $Input) - (length $1) - 1];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
  } else {
  if ($EOF) {
  $State = COMMENT_END_DASH_STATE;
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  push @$Tokens, $Token;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[COMMENT_END_STATE] = sub {
  if ($Input =~ /\G([\])/gcs) {
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + (pos $Input) - (length $1) - 2];
  push @{$Token->{q<data>}}, [q@
  @, $DI, $Offset + (pos $Input) - (length $1) - 0];
  $State = COMMENT_STATE_CR;
  } elsif ($Input =~ /\G([\!])/gcs) {
  $State = COMMENT_END_BANG_STATE;
  } elsif ($Input =~ /\G([\-])/gcs) {
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + (pos $Input) - (length $1) - 0];
  } elsif ($Input =~ /\G([\<])/gcs) {
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + (pos $Input) - (length $1) - 2];
  push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  } elsif ($Input =~ /\G([\>])/gcs) {
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + (pos $Input) - (length $1) - 2];
  $State = COMMENT_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
  } elsif ($Input =~ /\G(.)/gcs) {
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + (pos $Input) - (length $1) - 2];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  push @$Tokens, $Token;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[COMMENT_END_STATE_CR] = sub {
  if ($Input =~ /\G([\
  ])/gcs) {
  $State = COMMENT_END_STATE;
  } elsif ($Input =~ /\G([\])/gcs) {
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + (pos $Input) - (length $1) - 2];
  push @{$Token->{q<data>}}, [q@
  @, $DI, $Offset + (pos $Input) - (length $1) - 0];
  $State = COMMENT_STATE_CR;
  } elsif ($Input =~ /\G([\!])/gcs) {
  $State = COMMENT_END_BANG_STATE;
  } elsif ($Input =~ /\G([\-])/gcs) {
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + (pos $Input) - (length $1) - 0];
  } elsif ($Input =~ /\G([\<])/gcs) {
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + (pos $Input) - (length $1) - 2];
  push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  } elsif ($Input =~ /\G([\>])/gcs) {
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + (pos $Input) - (length $1) - 2];
  $State = COMMENT_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
  } elsif ($Input =~ /\G(.)/gcs) {
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + (pos $Input) - (length $1) - 2];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
  } else {
  if ($EOF) {
  $State = COMMENT_END_STATE;
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  push @$Tokens, $Token;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH_STATE] = sub {
  if ($Input =~ /\G([\>])/gcs) {
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'parser:comment not closed', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + (pos $Input) - (length $1) - 2];
  $State = COMMENT_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
  } elsif ($Input =~ /\G([\])/gcs) {
  
              push @$Errors, {type => 'parser:comment not closed', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + (pos $Input) - (length $1) - 2];
  push @{$Token->{q<data>}}, [q@
  @, $DI, $Offset + (pos $Input) - (length $1) - 0];
  $State = COMMENT_STATE_CR;
  } elsif ($Input =~ /\G([\!])/gcs) {
  
              push @$Errors, {type => 'parser:comment not closed', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $State = COMMENT_END_BANG_STATE;
  } elsif ($Input =~ /\G([\-])/gcs) {
  
              push @$Errors, {type => 'parser:comment not closed', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + (pos $Input) - (length $1) - 0];
  } elsif ($Input =~ /\G([\<])/gcs) {
  
              push @$Errors, {type => 'parser:comment not closed', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + (pos $Input) - (length $1) - 2];
  push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  } elsif ($Input =~ /\G(.)/gcs) {
  
              push @$Errors, {type => 'parser:comment not closed', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + (pos $Input) - (length $1) - 2];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
  } else {
  if ($EOF) {
  $State = COMMENT_END_STATE;
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  push @$Tokens, $Token;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[COMMENT_LESS_THAN_SIGN_BANG_DASH_STATE] = sub {
  if ($Input =~ /\G([\])/gcs) {
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + (pos $Input) - (length $1) - 1];
  push @{$Token->{q<data>}}, [q@
  @, $DI, $Offset + (pos $Input) - (length $1) - 0];
  $State = COMMENT_STATE_CR;
  } elsif ($Input =~ /\G([\-])/gcs) {
  $State = COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH_STATE;
  } elsif ($Input =~ /\G([\<])/gcs) {
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + (pos $Input) - (length $1) - 1];
  push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + (pos $Input) - (length $1) - 1];
  $State = COMMENT_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
  } elsif ($Input =~ /\G(.)/gcs) {
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + (pos $Input) - (length $1) - 1];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
  } else {
  if ($EOF) {
  $State = COMMENT_END_DASH_STATE;
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  push @$Tokens, $Token;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[COMMENT_LESS_THAN_SIGN_BANG_STATE] = sub {
  if ($Input =~ /\G([\])/gcs) {
  push @{$Token->{q<data>}}, [q@
  @, $DI, $Offset + (pos $Input) - (length $1) - 0];
  $State = COMMENT_STATE_CR;
  } elsif ($Input =~ /\G([\-])/gcs) {
  $State = COMMENT_LESS_THAN_SIGN_BANG_DASH_STATE;
  } elsif ($Input =~ /\G([\<])/gcs) {
  push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  $State = COMMENT_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
  } elsif ($Input =~ /\G(.)/gcs) {
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
  } else {
  if ($EOF) {
  $State = COMMENT_STATE;
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  push @$Tokens, $Token;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[COMMENT_LESS_THAN_SIGN_STATE] = sub {
  if ($Input =~ /\G([\])/gcs) {
  push @{$Token->{q<data>}}, [q@
  @, $DI, $Offset + (pos $Input) - (length $1) - 0];
  $State = COMMENT_STATE_CR;
  } elsif ($Input =~ /\G([\!])/gcs) {
  push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
  $State = COMMENT_LESS_THAN_SIGN_BANG_STATE;
  } elsif ($Input =~ /\G([\-])/gcs) {
  $State = COMMENT_END_DASH_STATE;
  } elsif ($Input =~ /\G([\<]+)/gcs) {
  push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
  } elsif ($Input =~ /\G([\ ])/gcs) {
  $State = COMMENT_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
  } elsif ($Input =~ /\G(.)/gcs) {
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
  } else {
  if ($EOF) {
  $State = COMMENT_STATE;
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  push @$Tokens, $Token;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[COMMENT_START_DASH_STATE] = sub {
  if ($Input =~ /\G([\])/gcs) {
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + (pos $Input) - (length $1) - 1];
  push @{$Token->{q<data>}}, [q@
  @, $DI, $Offset + (pos $Input) - (length $1) - 0];
  $State = COMMENT_STATE_CR;
  } elsif ($Input =~ /\G([\-])/gcs) {
  $State = COMMENT_END_STATE;
  } elsif ($Input =~ /\G([\<])/gcs) {
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + (pos $Input) - (length $1) - 1];
  push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + (pos $Input) - (length $1) - 1];
  $State = COMMENT_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
  } elsif ($Input =~ /\G([\>])/gcs) {
  
              push @$Errors, {type => 'parser:comment closed', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G(.)/gcs) {
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + (pos $Input) - (length $1) - 1];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  push @$Tokens, $Token;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[COMMENT_START_STATE] = sub {
  if ($Input =~ /\G([\])/gcs) {
  push @{$Token->{q<data>}}, [q@
  @, $DI, $Offset + (pos $Input) - (length $1) - 0];
  $State = COMMENT_STATE_CR;
  } elsif ($Input =~ /\G([\-])/gcs) {
  $State = COMMENT_START_DASH_STATE;
  } elsif ($Input =~ /\G([\<])/gcs) {
  push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  $State = COMMENT_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
  } elsif ($Input =~ /\G([\>])/gcs) {
  
              push @$Errors, {type => 'parser:comment closed', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G(.)/gcs) {
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
  } else {
  if ($EOF) {
  $State = COMMENT_STATE;
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  push @$Tokens, $Token;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[COMMENT_STATE] = sub {
  if ($Input =~ /\G([^\\-\<\ ]+)/gcs) {
  push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
  
  } elsif ($Input =~ /\G([\])/gcs) {
  push @{$Token->{q<data>}}, [q@
  @, $DI, $Offset + (pos $Input) - (length $1) - 0];
  $State = COMMENT_STATE_CR;
  } elsif ($Input =~ /\G([\-])/gcs) {
  $State = COMMENT_END_DASH_STATE;
  } elsif ($Input =~ /\G([\<])/gcs) {
  push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  push @$Tokens, $Token;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[COMMENT_STATE_CR] = sub {
  if ($Input =~ /\G([\
  ])/gcs) {
  $State = COMMENT_STATE;
  } elsif ($Input =~ /\G([\])/gcs) {
  push @{$Token->{q<data>}}, [q@
  @, $DI, $Offset + (pos $Input) - (length $1) - 0];
  $State = COMMENT_STATE_CR;
  } elsif ($Input =~ /\G([\-])/gcs) {
  $State = COMMENT_END_DASH_STATE;
  } elsif ($Input =~ /\G([\<])/gcs) {
  push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  $State = COMMENT_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
  } elsif ($Input =~ /\G(.)/gcs) {
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
  } else {
  if ($EOF) {
  $State = COMMENT_STATE;
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  push @$Tokens, $Token;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[DATA_STATE] = sub {
  if ($Input =~ /\G([^\\&\<\ ]+)/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  
  } elsif ($Input =~ /\G([\])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@
  @,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  $State = DATA_STATE_CR;
  } elsif ($Input =~ /\G([\&])/gcs) {
  $State = CHARREF_IN_DATA_STATE;
  } elsif ($Input =~ /\G([\<])/gcs) {
  $State = TAG_OPEN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } else {
  if ($EOF) {
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[DATA_STATE___CHARREF_BEFORE_HEX_NUM_STATE] = sub {
  if ($Input =~ /\G([0123456789ABCDEFafbcde])/gcs) {
  $Temp .= $1;
  $State = DATA_STATE___CHARREF_HEX_NUM_STATE;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'bare hcro', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = DATA_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } elsif ($Input =~ /\G([\])/gcs) {
  
              push @$Errors, {type => 'bare hcro', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@
  @,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  $State = DATA_STATE_CR;
  } elsif ($Input =~ /\G([\&])/gcs) {
  
              push @$Errors, {type => 'bare hcro', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = CHARREF_IN_DATA_STATE;
  } elsif ($Input =~ /\G([\<])/gcs) {
  
              push @$Errors, {type => 'bare hcro', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = TAG_OPEN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  } elsif ($Input =~ /\G(.)/gcs) {
  
              push @$Errors, {type => 'bare hcro', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = DATA_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'bare hcro', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = DATA_STATE;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[DATA_STATE___CHARREF_DECIMAL_NUM_STATE] = sub {
  if ($Input =~ /\G([0123456789]+)/gcs) {
  $Temp .= $1;
  } elsif ($Input =~ /\G([\;])/gcs) {
  
          my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = DATA_STATE;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = DATA_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } elsif ($Input =~ /\G([\])/gcs) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@
  @,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  $State = DATA_STATE_CR;
  } elsif ($Input =~ /\G([\&])/gcs) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = CHARREF_IN_DATA_STATE;
  } elsif ($Input =~ /\G([\<])/gcs) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = TAG_OPEN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  } elsif ($Input =~ /\G(.)/gcs) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = DATA_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
          my $code = do { $Temp =~ /\A&#0*([0-9]{1,10})\z/ ? 0+$1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = DATA_STATE;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[DATA_STATE___CHARREF_HEX_NUM_STATE] = sub {
  if ($Input =~ /\G([0123456789ABCDEFafbcde]+)/gcs) {
  $Temp .= $1;
  } elsif ($Input =~ /\G([\;])/gcs) {
  
          my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = DATA_STATE;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = DATA_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } elsif ($Input =~ /\G([\])/gcs) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@
  @,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  $State = DATA_STATE_CR;
  } elsif ($Input =~ /\G([\&])/gcs) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = CHARREF_IN_DATA_STATE;
  } elsif ($Input =~ /\G([\<])/gcs) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = TAG_OPEN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  } elsif ($Input =~ /\G(.)/gcs) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = DATA_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'no refc', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
          my $code = do { $Temp =~ /\A&#[Xx]0*([0-9A-Fa-f]{1,8})\z/ ? hex $1 : 0xFFFFFFFF };
          if (my $replace = $InvalidCharRefs->{$code}) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U+%04X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = $replace;
          } elsif ($code > 0x10FFFF) {
            push @$Errors, {type => 'invalid character reference',
                            text => (sprintf 'U-%08X', $code),
                            level => 'm',
                            di => $DI, index => $TempIndex};
            $code = 0xFFFD;
          ## 
          }
          $Temp = chr $code;
        
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = DATA_STATE;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[DATA_STATE___CHARREF_NAME_STATE] = sub {
  if ($Input =~ /\G([\])/gcs) {
  
            my $return;
            REF: {
              ## 
  
              for (reverse (2 .. length $Temp)) {
                my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
                if (defined $value) {
                  my $temp_index = $TempIndex;
  
                  unless (';' eq substr $Temp, $_-1, 1) {
                    ## <HTML>
                    push @$Errors, {type => 'no refc',
                                    level => 'm',
                                    di => $DI,
                                    index => $TempIndex + $_};
                    ## </HTML>
  
                    ## A variant of |emit-temp|
                    push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                                    value => $value,
                                    di => $DI, index => $TempIndex};
                    $TempIndex += $_;
                    $value = '';
                  }
  
                  ## 
  
                  substr ($Temp, 0, $_) = $value;
                  last REF;
                }
              }
              if ($Temp =~ /;\z/) {
                push @$Errors, {level => 'm',
                                type => 'entity not declared',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                ## 
              }
            } # REF
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@
  @,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  $State = DATA_STATE_CR;
  return 1 if $return;
  } elsif ($Input =~ /\G([\&])/gcs) {
  
            my $return;
            REF: {
              ## 
  
              for (reverse (2 .. length $Temp)) {
                my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
                if (defined $value) {
                  my $temp_index = $TempIndex;
  
                  unless (';' eq substr $Temp, $_-1, 1) {
                    ## <HTML>
                    push @$Errors, {type => 'no refc',
                                    level => 'm',
                                    di => $DI,
                                    index => $TempIndex + $_};
                    ## </HTML>
  
                    ## A variant of |emit-temp|
                    push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                                    value => $value,
                                    di => $DI, index => $TempIndex};
                    $TempIndex += $_;
                    $value = '';
                  }
  
                  ## 
  
                  substr ($Temp, 0, $_) = $value;
                  last REF;
                }
              }
              if ($Temp =~ /;\z/) {
                push @$Errors, {level => 'm',
                                type => 'entity not declared',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                ## 
              }
            } # REF
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = CHARREF_IN_DATA_STATE;
  return 1 if $return;
  } elsif ($Input =~ /\G([0123456789]+)/gcs) {
  $Temp .= $1;
  } elsif ($Input =~ /\G([\;])/gcs) {
  $Temp .= $1;
  
            my $return;
            REF: {
              ## 
  
              for (reverse (2 .. length $Temp)) {
                my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
                if (defined $value) {
                  my $temp_index = $TempIndex;
  
                  unless (';' eq substr $Temp, $_-1, 1) {
                    ## <HTML>
                    push @$Errors, {type => 'no refc',
                                    level => 'm',
                                    di => $DI,
                                    index => $TempIndex + $_};
                    ## </HTML>
  
                    ## A variant of |emit-temp|
                    push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                                    value => $value,
                                    di => $DI, index => $TempIndex};
                    $TempIndex += $_;
                    $value = '';
                  }
  
                  ## 
  
                  substr ($Temp, 0, $_) = $value;
                  last REF;
                }
              }
              if ($Temp =~ /;\z/) {
                push @$Errors, {level => 'm',
                                type => 'entity not declared',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                ## 
              }
            } # REF
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = DATA_STATE;
  return 1 if $return;
  } elsif ($Input =~ /\G([\<])/gcs) {
  
            my $return;
            REF: {
              ## 
  
              for (reverse (2 .. length $Temp)) {
                my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
                if (defined $value) {
                  my $temp_index = $TempIndex;
  
                  unless (';' eq substr $Temp, $_-1, 1) {
                    ## <HTML>
                    push @$Errors, {type => 'no refc',
                                    level => 'm',
                                    di => $DI,
                                    index => $TempIndex + $_};
                    ## </HTML>
  
                    ## A variant of |emit-temp|
                    push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                                    value => $value,
                                    di => $DI, index => $TempIndex};
                    $TempIndex += $_;
                    $value = '';
                  }
  
                  ## 
  
                  substr ($Temp, 0, $_) = $value;
                  last REF;
                }
              }
              if ($Temp =~ /;\z/) {
                push @$Errors, {level => 'm',
                                type => 'entity not declared',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                ## 
              }
            } # REF
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = TAG_OPEN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  return 1 if $return;
  } elsif ($Input =~ /\G([\=])/gcs) {
  
            my $return;
            REF: {
              ## 
  
              for (reverse (2 .. length $Temp)) {
                my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
                if (defined $value) {
                  my $temp_index = $TempIndex;
  
                  unless (';' eq substr $Temp, $_-1, 1) {
                    ## <HTML>
                    push @$Errors, {type => 'no refc',
                                    level => 'm',
                                    di => $DI,
                                    index => $TempIndex + $_};
                    ## </HTML>
  
                    ## A variant of |emit-temp|
                    push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                                    value => $value,
                                    di => $DI, index => $TempIndex};
                    $TempIndex += $_;
                    $value = '';
                  }
  
                  ## 
  
                  substr ($Temp, 0, $_) = $value;
                  last REF;
                }
              }
              if ($Temp =~ /;\z/) {
                push @$Errors, {level => 'm',
                                type => 'entity not declared',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                ## 
              }
            } # REF
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = DATA_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  return 1 if $return;
  } elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY]+)/gcs) {
  $Temp .= $1;
  } elsif ($Input =~ /\G([afbcdeghjknqrvwzilmopstuxy]+)/gcs) {
  $Temp .= $1;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
            my $return;
            REF: {
              ## 
  
              for (reverse (2 .. length $Temp)) {
                my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
                if (defined $value) {
                  my $temp_index = $TempIndex;
  
                  unless (';' eq substr $Temp, $_-1, 1) {
                    ## <HTML>
                    push @$Errors, {type => 'no refc',
                                    level => 'm',
                                    di => $DI,
                                    index => $TempIndex + $_};
                    ## </HTML>
  
                    ## A variant of |emit-temp|
                    push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                                    value => $value,
                                    di => $DI, index => $TempIndex};
                    $TempIndex += $_;
                    $value = '';
                  }
  
                  ## 
  
                  substr ($Temp, 0, $_) = $value;
                  last REF;
                }
              }
              if ($Temp =~ /;\z/) {
                push @$Errors, {level => 'm',
                                type => 'entity not declared',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                ## 
              }
            } # REF
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = DATA_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  return 1 if $return;
  } elsif ($Input =~ /\G(.)/gcs) {
  
            my $return;
            REF: {
              ## 
  
              for (reverse (2 .. length $Temp)) {
                my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
                if (defined $value) {
                  my $temp_index = $TempIndex;
  
                  unless (';' eq substr $Temp, $_-1, 1) {
                    ## <HTML>
                    push @$Errors, {type => 'no refc',
                                    level => 'm',
                                    di => $DI,
                                    index => $TempIndex + $_};
                    ## </HTML>
  
                    ## A variant of |emit-temp|
                    push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                                    value => $value,
                                    di => $DI, index => $TempIndex};
                    $TempIndex += $_;
                    $value = '';
                  }
  
                  ## 
  
                  substr ($Temp, 0, $_) = $value;
                  last REF;
                }
              }
              if ($Temp =~ /;\z/) {
                push @$Errors, {level => 'm',
                                type => 'entity not declared',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                ## 
              }
            } # REF
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = DATA_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  return 1 if $return;
  } else {
  if ($EOF) {
  
            my $return;
            REF: {
              ## 
  
              for (reverse (2 .. length $Temp)) {
                my $value = $Web::HTML::EntityChar->{substr $Temp, 1, $_-1};
                if (defined $value) {
                  my $temp_index = $TempIndex;
  
                  unless (';' eq substr $Temp, $_-1, 1) {
                    ## <HTML>
                    push @$Errors, {type => 'no refc',
                                    level => 'm',
                                    di => $DI,
                                    index => $TempIndex + $_};
                    ## </HTML>
  
                    ## A variant of |emit-temp|
                    push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                                    value => $value,
                                    di => $DI, index => $TempIndex};
                    $TempIndex += $_;
                    $value = '';
                  }
  
                  ## 
  
                  substr ($Temp, 0, $_) = $value;
                  last REF;
                }
              }
              if ($Temp =~ /;\z/) {
                push @$Errors, {level => 'm',
                                type => 'entity not declared',
                                value => $Temp,
                                di => $DI, index => $TempIndex};
                ## 
              }
            } # REF
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = DATA_STATE;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[DATA_STATE___CHARREF_NUM_STATE] = sub {
  if ($Input =~ /\G([0123456789])/gcs) {
  $Temp .= $1;
  $State = DATA_STATE___CHARREF_DECIMAL_NUM_STATE;
  } elsif ($Input =~ /\G([X])/gcs) {
  $Temp .= $1;
  $State = DATA_STATE___CHARREF_BEFORE_HEX_NUM_STATE;
  } elsif ($Input =~ /\G([x])/gcs) {
  $Temp .= $1;
  $State = DATA_STATE___CHARREF_BEFORE_HEX_NUM_STATE;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'bare nero', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = DATA_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } elsif ($Input =~ /\G([\])/gcs) {
  
              push @$Errors, {type => 'bare nero', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@
  @,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  $State = DATA_STATE_CR;
  } elsif ($Input =~ /\G([\&])/gcs) {
  
              push @$Errors, {type => 'bare nero', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = CHARREF_IN_DATA_STATE;
  } elsif ($Input =~ /\G([\<])/gcs) {
  
              push @$Errors, {type => 'bare nero', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = TAG_OPEN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  } elsif ($Input =~ /\G(.)/gcs) {
  
              push @$Errors, {type => 'bare nero', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = DATA_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'bare nero', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = DATA_STATE;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[DATA_STATE___CHARREF_STATE] = sub {
  if ($Input =~ /\G([\])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@
  @,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  $State = DATA_STATE_CR;
  } elsif ($Input =~ /\G([\#])/gcs) {
  $Temp .= $1;
  $State = DATA_STATE___CHARREF_NUM_STATE;
  } elsif ($Input =~ /\G([\&])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = CHARREF_IN_DATA_STATE;
  } elsif ($Input =~ /\G([0123456789])/gcs) {
  $Temp .= $1;
  $State = DATA_STATE___CHARREF_NAME_STATE;
  } elsif ($Input =~ /\G([\<])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = TAG_OPEN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  } elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {
  $Temp .= $1;
  $State = DATA_STATE___CHARREF_NAME_STATE;
  } elsif ($Input =~ /\G([afbcdeghjknqrvwzilmopstuxy])/gcs) {
  $Temp .= $1;
  $State = DATA_STATE___CHARREF_NAME_STATE;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = DATA_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } elsif ($Input =~ /\G(.)/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = DATA_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } else {
  if ($EOF) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = DATA_STATE;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[DATA_STATE___CHARREF_STATE_CR] = sub {
  if ($Input =~ /\G([\
  ])/gcs) {
  $State = DATA_STATE___CHARREF_STATE;
  } elsif ($Input =~ /\G([\])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@
  @,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  $State = DATA_STATE_CR;
  } elsif ($Input =~ /\G([\#])/gcs) {
  $Temp .= $1;
  $State = DATA_STATE___CHARREF_NUM_STATE;
  } elsif ($Input =~ /\G([\&])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = CHARREF_IN_DATA_STATE;
  } elsif ($Input =~ /\G([0123456789])/gcs) {
  $Temp .= $1;
  $State = DATA_STATE___CHARREF_NAME_STATE;
  } elsif ($Input =~ /\G([\<])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = TAG_OPEN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  } elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {
  $Temp .= $1;
  $State = DATA_STATE___CHARREF_NAME_STATE;
  } elsif ($Input =~ /\G([afbcdeghjknqrvwzilmopstuxy])/gcs) {
  $Temp .= $1;
  $State = DATA_STATE___CHARREF_NAME_STATE;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = DATA_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } elsif ($Input =~ /\G(.)/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = DATA_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } else {
  if ($EOF) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = DATA_STATE;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[DATA_STATE_CR] = sub {
  if ($Input =~ /\G([\
  ])/gcs) {
  $State = DATA_STATE;
  } elsif ($Input =~ /\G([\])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@
  @,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  $State = DATA_STATE_CR;
  } elsif ($Input =~ /\G([\&])/gcs) {
  $State = CHARREF_IN_DATA_STATE;
  } elsif ($Input =~ /\G([\<])/gcs) {
  $State = TAG_OPEN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  $State = DATA_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } elsif ($Input =~ /\G(.)/gcs) {
  $State = DATA_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } else {
  if ($EOF) {
  $State = DATA_STATE;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[END_TAG_OPEN_STATE] = sub {
  if ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {
  
          $Token = {type => END_TAG_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $State = TAG_NAME_STATE;
  $Token->{q<tag_name>} = chr ((ord $1) + 32);
  } elsif ($Input =~ /\G([afbcdeghjknqrvwzilmopstuxy])/gcs) {
  
          $Token = {type => END_TAG_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $State = TAG_NAME_STATE;
  $Token->{q<tag_name>} = $1;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'bare etago', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $State = BOGUS_COMMENT_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<data>} = [[q@@, $DI, $Offset + (pos $Input) - length $1]];
  } elsif ($Input =~ /\G([\])/gcs) {
  
              push @$Errors, {type => 'bare etago', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[q@
  @, $DI, $Offset + (pos $Input) - length $1]];
  $State = BOGUS_COMMENT_STATE_CR;
  } elsif ($Input =~ /\G([\>])/gcs) {
  
              push @$Errors, {type => 'empty end tag', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $State = DATA_STATE;
  } elsif ($Input =~ /\G(.)/gcs) {
  
              push @$Errors, {type => 'bare etago', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $State = BOGUS_COMMENT_STATE;
  $Token->{q<data>} = [[$1, $DI, $Offset + (pos $Input) - length $1]];
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@</@,
                            di => $DI, index => $AnchoredIndex};
          
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[MDO_STATE] = sub {
  if ($Input =~ /\G([\-])/gcs) {
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  } elsif ($Input =~ /\G([D])/gcs) {
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE_D;
  } elsif ($Input =~ /\G([\[])/gcs) {
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__5B;
  } elsif ($Input =~ /\G([d])/gcs) {
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE_D;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $State = BOGUS_COMMENT_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<data>} = [[q@@, $DI, $Offset + (pos $Input) - length $1]];
  } elsif ($Input =~ /\G([\])/gcs) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[q@
  @, $DI, $Offset + (pos $Input) - length $1]];
  $State = BOGUS_COMMENT_STATE_CR;
  } elsif ($Input =~ /\G([\>])/gcs) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G(.)/gcs) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $State = BOGUS_COMMENT_STATE;
  $Token->{q<data>} = [[$1, $DI, $Offset + (pos $Input) - length $1]];
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = BOGUS_COMMENT_STATE;
  push @$Tokens, $Token;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[MDO_STATE__] = sub {
  if ($Input =~ /\G([\-])/gcs) {
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_STATE;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  $State = BOGUS_COMMENT_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
  } elsif ($Input =~ /\G([\])/gcs) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  push @{$Token->{q<data>}}, [q@
  @, $DI, $Offset + (pos $Input) - (length $1) - 0];
  $State = BOGUS_COMMENT_STATE_CR;
  } elsif ($Input =~ /\G([\>])/gcs) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G(.)/gcs) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  $State = BOGUS_COMMENT_STATE;
  push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  $State = BOGUS_COMMENT_STATE;
  push @$Tokens, $Token;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[MDO_STATE_D] = sub {
  if ($Input =~ /\G([O])/gcs) {
  $Temp .= $1;
  $State = MDO_STATE_DO;
  } elsif ($Input =~ /\G([o])/gcs) {
  $Temp .= $1;
  $State = MDO_STATE_DO;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  $State = BOGUS_COMMENT_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
  } elsif ($Input =~ /\G([\])/gcs) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  push @{$Token->{q<data>}}, [q@
  @, $DI, $Offset + (pos $Input) - (length $1) - 0];
  $State = BOGUS_COMMENT_STATE_CR;
  } elsif ($Input =~ /\G([\>])/gcs) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G(.)/gcs) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  $State = BOGUS_COMMENT_STATE;
  push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  $State = BOGUS_COMMENT_STATE;
  push @$Tokens, $Token;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[MDO_STATE_DO] = sub {
  if ($Input =~ /\G([C])/gcs) {
  $Temp .= $1;
  $State = MDO_STATE_DOC;
  } elsif ($Input =~ /\G([c])/gcs) {
  $Temp .= $1;
  $State = MDO_STATE_DOC;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  $State = BOGUS_COMMENT_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
  } elsif ($Input =~ /\G([\])/gcs) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  push @{$Token->{q<data>}}, [q@
  @, $DI, $Offset + (pos $Input) - (length $1) - 0];
  $State = BOGUS_COMMENT_STATE_CR;
  } elsif ($Input =~ /\G([\>])/gcs) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G(.)/gcs) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  $State = BOGUS_COMMENT_STATE;
  push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  $State = BOGUS_COMMENT_STATE;
  push @$Tokens, $Token;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[MDO_STATE_DOC] = sub {
  if ($Input =~ /\G([T])/gcs) {
  $Temp .= $1;
  $State = MDO_STATE_DOCT;
  } elsif ($Input =~ /\G([t])/gcs) {
  $Temp .= $1;
  $State = MDO_STATE_DOCT;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  $State = BOGUS_COMMENT_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
  } elsif ($Input =~ /\G([\])/gcs) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  push @{$Token->{q<data>}}, [q@
  @, $DI, $Offset + (pos $Input) - (length $1) - 0];
  $State = BOGUS_COMMENT_STATE_CR;
  } elsif ($Input =~ /\G([\>])/gcs) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G(.)/gcs) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  $State = BOGUS_COMMENT_STATE;
  push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  $State = BOGUS_COMMENT_STATE;
  push @$Tokens, $Token;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[MDO_STATE_DOCT] = sub {
  if ($Input =~ /\G([Y])/gcs) {
  $Temp .= $1;
  $State = MDO_STATE_DOCTY;
  } elsif ($Input =~ /\G([y])/gcs) {
  $Temp .= $1;
  $State = MDO_STATE_DOCTY;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  $State = BOGUS_COMMENT_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
  } elsif ($Input =~ /\G([\])/gcs) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  push @{$Token->{q<data>}}, [q@
  @, $DI, $Offset + (pos $Input) - (length $1) - 0];
  $State = BOGUS_COMMENT_STATE_CR;
  } elsif ($Input =~ /\G([\>])/gcs) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G(.)/gcs) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  $State = BOGUS_COMMENT_STATE;
  push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  $State = BOGUS_COMMENT_STATE;
  push @$Tokens, $Token;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[MDO_STATE_DOCTY] = sub {
  if ($Input =~ /\G([P])/gcs) {
  $Temp .= $1;
  $State = MDO_STATE_DOCTYP;
  } elsif ($Input =~ /\G([p])/gcs) {
  $Temp .= $1;
  $State = MDO_STATE_DOCTYP;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  $State = BOGUS_COMMENT_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
  } elsif ($Input =~ /\G([\])/gcs) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  push @{$Token->{q<data>}}, [q@
  @, $DI, $Offset + (pos $Input) - (length $1) - 0];
  $State = BOGUS_COMMENT_STATE_CR;
  } elsif ($Input =~ /\G([\>])/gcs) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G(.)/gcs) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  $State = BOGUS_COMMENT_STATE;
  push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  $State = BOGUS_COMMENT_STATE;
  push @$Tokens, $Token;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[MDO_STATE_DOCTYP] = sub {
  if ($Input =~ /\G([E])/gcs) {
  $State = DOCTYPE_STATE;
  } elsif ($Input =~ /\G([e])/gcs) {
  $State = DOCTYPE_STATE;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  $State = BOGUS_COMMENT_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
  } elsif ($Input =~ /\G([\])/gcs) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  push @{$Token->{q<data>}}, [q@
  @, $DI, $Offset + (pos $Input) - (length $1) - 0];
  $State = BOGUS_COMMENT_STATE_CR;
  } elsif ($Input =~ /\G([\>])/gcs) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G(.)/gcs) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  $State = BOGUS_COMMENT_STATE;
  push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  $State = BOGUS_COMMENT_STATE;
  push @$Tokens, $Token;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[MDO_STATE__5B] = sub {
  if ($Input =~ /\G([C])/gcs) {
  $Temp .= $1;
  $State = MDO_STATE__5BC;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  $State = BOGUS_COMMENT_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
  } elsif ($Input =~ /\G([\])/gcs) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  push @{$Token->{q<data>}}, [q@
  @, $DI, $Offset + (pos $Input) - (length $1) - 0];
  $State = BOGUS_COMMENT_STATE_CR;
  } elsif ($Input =~ /\G([\>])/gcs) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G(.)/gcs) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  $State = BOGUS_COMMENT_STATE;
  push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  $State = BOGUS_COMMENT_STATE;
  push @$Tokens, $Token;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[MDO_STATE__5BC] = sub {
  if ($Input =~ /\G([D])/gcs) {
  $Temp .= $1;
  $State = MDO_STATE__5BCD;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  $State = BOGUS_COMMENT_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
  } elsif ($Input =~ /\G([\])/gcs) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  push @{$Token->{q<data>}}, [q@
  @, $DI, $Offset + (pos $Input) - (length $1) - 0];
  $State = BOGUS_COMMENT_STATE_CR;
  } elsif ($Input =~ /\G([\>])/gcs) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G(.)/gcs) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  $State = BOGUS_COMMENT_STATE;
  push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  $State = BOGUS_COMMENT_STATE;
  push @$Tokens, $Token;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[MDO_STATE__5BCD] = sub {
  if ($Input =~ /\G([A])/gcs) {
  $Temp .= $1;
  $State = MDO_STATE__5BCDA;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  $State = BOGUS_COMMENT_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
  } elsif ($Input =~ /\G([\])/gcs) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  push @{$Token->{q<data>}}, [q@
  @, $DI, $Offset + (pos $Input) - (length $1) - 0];
  $State = BOGUS_COMMENT_STATE_CR;
  } elsif ($Input =~ /\G([\>])/gcs) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G(.)/gcs) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  $State = BOGUS_COMMENT_STATE;
  push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  $State = BOGUS_COMMENT_STATE;
  push @$Tokens, $Token;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[MDO_STATE__5BCDA] = sub {
  if ($Input =~ /\G([T])/gcs) {
  $Temp .= $1;
  $State = MDO_STATE__5BCDAT;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  $State = BOGUS_COMMENT_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
  } elsif ($Input =~ /\G([\])/gcs) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  push @{$Token->{q<data>}}, [q@
  @, $DI, $Offset + (pos $Input) - (length $1) - 0];
  $State = BOGUS_COMMENT_STATE_CR;
  } elsif ($Input =~ /\G([\>])/gcs) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G(.)/gcs) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  $State = BOGUS_COMMENT_STATE;
  push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  $State = BOGUS_COMMENT_STATE;
  push @$Tokens, $Token;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[MDO_STATE__5BCDAT] = sub {
  if ($Input =~ /\G([A])/gcs) {
  $Temp .= $1;
  $State = MDO_STATE__5BCDATA;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  $State = BOGUS_COMMENT_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
  } elsif ($Input =~ /\G([\])/gcs) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  push @{$Token->{q<data>}}, [q@
  @, $DI, $Offset + (pos $Input) - (length $1) - 0];
  $State = BOGUS_COMMENT_STATE_CR;
  } elsif ($Input =~ /\G([\>])/gcs) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G(.)/gcs) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  $State = BOGUS_COMMENT_STATE;
  push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  $State = BOGUS_COMMENT_STATE;
  push @$Tokens, $Token;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[MDO_STATE__5BCDATA] = sub {
  if ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  $State = BOGUS_COMMENT_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  push @{$Token->{q<data>}}, [q@@, $DI, $Offset + (pos $Input) - (length $1) - 0];
  } elsif ($Input =~ /\G([\])/gcs) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  push @{$Token->{q<data>}}, [q@
  @, $DI, $Offset + (pos $Input) - (length $1) - 0];
  $State = BOGUS_COMMENT_STATE_CR;
  } elsif ($Input =~ /\G([\>])/gcs) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G([\[])/gcs) {
  
            if (not defined $InForeign) {
              pos ($Input) -= length $1;
              return 1;
            } else {
              if ($InForeign) {
                $State = CDATA_SECTION_STATE;
                return 0;
              }
            }
          
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
  $State = BOGUS_COMMENT_STATE;
  } elsif ($Input =~ /\G(.)/gcs) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  $State = BOGUS_COMMENT_STATE;
  push @{$Token->{q<data>}}, [$1, $DI, $Offset + (pos $Input) - (length $1)];
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'bogus comment', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  push @{$Token->{q<data>}}, [$Temp, $DI, $TempIndex];
  $State = BOGUS_COMMENT_STATE;
  push @$Tokens, $Token;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE] = sub {
  if ($Input =~ /\G([\	\\ \
  ])/gcs) {
  
          if ($Temp eq 'script') {
            $State = SCRIPT_DATA_ESCAPED_STATE;
          } else {
            $State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
          }
        
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } elsif ($Input =~ /\G([\])/gcs) {
  
          if ($Temp eq 'script') {
            $State = SCRIPT_DATA_ESCAPED_STATE;
          } else {
            $State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
          }
        
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@
  @,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  $State = SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE_CR;
  } elsif ($Input =~ /\G([\-])/gcs) {
  $State = SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@-@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  } elsif ($Input =~ /\G([\/])/gcs) {
  
          if ($Temp eq 'script') {
            $State = SCRIPT_DATA_ESCAPED_STATE;
          } else {
            $State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
          }
        
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } elsif ($Input =~ /\G([\<])/gcs) {
  $State = SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@<@,
                            di => $DI, index => $AnchoredIndex};
          
  } elsif ($Input =~ /\G([\>])/gcs) {
  
          if ($Temp eq 'script') {
            $State = SCRIPT_DATA_ESCAPED_STATE;
          } else {
            $State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
          }
        
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {
  $Temp .= chr ((ord $1) + 32);
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } elsif ($Input =~ /\G([afbcdeghjknqrvwzilmopstuxy]+)/gcs) {
  $Temp .= $1;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } elsif ($Input =~ /\G([\ ])/gcs) {
  $State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  } elsif ($Input =~ /\G(.)/gcs) {
  $State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } else {
  if ($EOF) {
  $State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE_CR] = sub {
  if ($Input =~ /\G([\	\\ ])/gcs) {
  $State = SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE;
  
          if ($Temp eq 'script') {
            $State = SCRIPT_DATA_ESCAPED_STATE;
          } else {
            $State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
          }
        
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } elsif ($Input =~ /\G([\
  ])/gcs) {
  $State = SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE;
  } elsif ($Input =~ /\G([\])/gcs) {
  
          if ($Temp eq 'script') {
            $State = SCRIPT_DATA_ESCAPED_STATE;
          } else {
            $State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
          }
        
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@
  @,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  $State = SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE_CR;
  } elsif ($Input =~ /\G([\-])/gcs) {
  $State = SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@-@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  } elsif ($Input =~ /\G([\/])/gcs) {
  $State = SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE;
  
          if ($Temp eq 'script') {
            $State = SCRIPT_DATA_ESCAPED_STATE;
          } else {
            $State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
          }
        
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } elsif ($Input =~ /\G([\<])/gcs) {
  $State = SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@<@,
                            di => $DI, index => $AnchoredIndex};
          
  } elsif ($Input =~ /\G([\>])/gcs) {
  $State = SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE;
  
          if ($Temp eq 'script') {
            $State = SCRIPT_DATA_ESCAPED_STATE;
          } else {
            $State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
          }
        
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {
  $State = SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE;
  $Temp .= chr ((ord $1) + 32);
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } elsif ($Input =~ /\G([afbcdeghjknqrvwzilmopstuxy])/gcs) {
  $State = SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE;
  $Temp .= $1;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } elsif ($Input =~ /\G([\ ])/gcs) {
  $State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  } elsif ($Input =~ /\G(.)/gcs) {
  $State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } else {
  if ($EOF) {
  $State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE] = sub {
  if ($Input =~ /\G([\	\\ \
  ])/gcs) {
  
          if ($Temp eq 'script') {
            $State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
          } else {
            $State = SCRIPT_DATA_ESCAPED_STATE;
          }
        
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } elsif ($Input =~ /\G([\])/gcs) {
  
          if ($Temp eq 'script') {
            $State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
          } else {
            $State = SCRIPT_DATA_ESCAPED_STATE;
          }
        
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@
  @,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  $State = SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE_CR;
  } elsif ($Input =~ /\G([\-])/gcs) {
  $State = SCRIPT_DATA_ESCAPED_DASH_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@-@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  } elsif ($Input =~ /\G([\/])/gcs) {
  
          if ($Temp eq 'script') {
            $State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
          } else {
            $State = SCRIPT_DATA_ESCAPED_STATE;
          }
        
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } elsif ($Input =~ /\G([\<])/gcs) {
  $State = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  } elsif ($Input =~ /\G([\>])/gcs) {
  
          if ($Temp eq 'script') {
            $State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
          } else {
            $State = SCRIPT_DATA_ESCAPED_STATE;
          }
        
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {
  $Temp .= chr ((ord $1) + 32);
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } elsif ($Input =~ /\G([afbcdeghjknqrvwzilmopstuxy]+)/gcs) {
  $Temp .= $1;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } elsif ($Input =~ /\G([\ ])/gcs) {
  $State = SCRIPT_DATA_ESCAPED_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  } elsif ($Input =~ /\G(.)/gcs) {
  $State = SCRIPT_DATA_ESCAPED_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } else {
  if ($EOF) {
  $State = SCRIPT_DATA_ESCAPED_STATE;
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE_CR] = sub {
  if ($Input =~ /\G([\	\\ ])/gcs) {
  $State = SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE;
  
          if ($Temp eq 'script') {
            $State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
          } else {
            $State = SCRIPT_DATA_ESCAPED_STATE;
          }
        
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } elsif ($Input =~ /\G([\
  ])/gcs) {
  $State = SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE;
  } elsif ($Input =~ /\G([\])/gcs) {
  
          if ($Temp eq 'script') {
            $State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
          } else {
            $State = SCRIPT_DATA_ESCAPED_STATE;
          }
        
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@
  @,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  $State = SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE_CR;
  } elsif ($Input =~ /\G([\-])/gcs) {
  $State = SCRIPT_DATA_ESCAPED_DASH_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@-@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  } elsif ($Input =~ /\G([\/])/gcs) {
  $State = SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE;
  
          if ($Temp eq 'script') {
            $State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
          } else {
            $State = SCRIPT_DATA_ESCAPED_STATE;
          }
        
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } elsif ($Input =~ /\G([\<])/gcs) {
  $State = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  } elsif ($Input =~ /\G([\>])/gcs) {
  $State = SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE;
  
          if ($Temp eq 'script') {
            $State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
          } else {
            $State = SCRIPT_DATA_ESCAPED_STATE;
          }
        
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {
  $State = SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE;
  $Temp .= chr ((ord $1) + 32);
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } elsif ($Input =~ /\G([afbcdeghjknqrvwzilmopstuxy])/gcs) {
  $State = SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE;
  $Temp .= $1;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } elsif ($Input =~ /\G([\ ])/gcs) {
  $State = SCRIPT_DATA_ESCAPED_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  } elsif ($Input =~ /\G(.)/gcs) {
  $State = SCRIPT_DATA_ESCAPED_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } else {
  if ($EOF) {
  $State = SCRIPT_DATA_ESCAPED_STATE;
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE] = sub {
  if ($Input =~ /\G([\])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@
  @,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  $State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE_CR;
  } elsif ($Input =~ /\G([\-])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@-@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  } elsif ($Input =~ /\G([\<])/gcs) {
  $State = SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@<@,
                            di => $DI, index => $AnchoredIndex};
          
  } elsif ($Input =~ /\G([\>])/gcs) {
  $State = SCRIPT_DATA_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@>@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  } elsif ($Input =~ /\G(.)/gcs) {
  $State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE] = sub {
  if ($Input =~ /\G([\])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@
  @,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  $State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE_CR;
  } elsif ($Input =~ /\G([\-])/gcs) {
  $State = SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@-@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  } elsif ($Input =~ /\G([\<])/gcs) {
  $State = SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@<@,
                            di => $DI, index => $AnchoredIndex};
          
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  } elsif ($Input =~ /\G(.)/gcs) {
  $State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE] = sub {
  if ($Input =~ /\G([\])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@
  @,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  $State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE_CR;
  } elsif ($Input =~ /\G([\-])/gcs) {
  $State = SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@-@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  } elsif ($Input =~ /\G([\/])/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@/@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  } elsif ($Input =~ /\G([\<])/gcs) {
  $State = SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@<@,
                            di => $DI, index => $AnchoredIndex};
          
  } elsif ($Input =~ /\G([\ ])/gcs) {
  $State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  } elsif ($Input =~ /\G(.)/gcs) {
  $State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } else {
  if ($EOF) {
  $State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[SCRIPT_DATA_DOUBLE_ESCAPED_STATE] = sub {
  if ($Input =~ /\G([^\\-\<\ ]+)/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  
  } elsif ($Input =~ /\G([\])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@
  @,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  $State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE_CR;
  } elsif ($Input =~ /\G([\-])/gcs) {
  $State = SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@-@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  } elsif ($Input =~ /\G([\<])/gcs) {
  $State = SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@<@,
                            di => $DI, index => $AnchoredIndex};
          
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[SCRIPT_DATA_DOUBLE_ESCAPED_STATE_CR] = sub {
  if ($Input =~ /\G([\
  ])/gcs) {
  $State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
  } elsif ($Input =~ /\G([\])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@
  @,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  $State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE_CR;
  } elsif ($Input =~ /\G([\-])/gcs) {
  $State = SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@-@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  } elsif ($Input =~ /\G([\<])/gcs) {
  $State = SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@<@,
                            di => $DI, index => $AnchoredIndex};
          
  } elsif ($Input =~ /\G([\ ])/gcs) {
  $State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  } elsif ($Input =~ /\G(.)/gcs) {
  $State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } else {
  if ($EOF) {
  $State = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[SCRIPT_DATA_END_TAG_NAME_STATE] = sub {
  if ($Input =~ /\G([\	\\ \
  ])/gcs) {
  
            if (defined $LastStartTagName and
                $Token->{tag_name} eq $LastStartTagName) {
              $State = B_ATTR_NAME_STATE;
              return 1;
            }
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@</@,
                            di => $DI, index => $AnchoredIndex};
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = SCRIPT_DATA_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } elsif ($Input =~ /\G([\])/gcs) {
  
            if (defined $LastStartTagName and
                $Token->{tag_name} eq $LastStartTagName) {
              $State = B_ATTR_NAME_STATE;
              return 1;
            }
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@</@,
                            di => $DI, index => $AnchoredIndex};
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@
  @,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  $State = SCRIPT_DATA_STATE_CR;
  } elsif ($Input =~ /\G([\/])/gcs) {
  
            if (defined $LastStartTagName and
                $Token->{tag_name} eq $LastStartTagName) {
              $State = SELF_CLOSING_START_TAG_STATE;
              return 1;
            }
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@</@,
                            di => $DI, index => $AnchoredIndex};
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = SCRIPT_DATA_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } elsif ($Input =~ /\G([\<])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@</@,
                            di => $DI, index => $AnchoredIndex};
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = SCRIPT_DATA_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  } elsif ($Input =~ /\G([\>])/gcs) {
  
          if (defined $LastStartTagName and
              $Token->{tag_name} eq $LastStartTagName) {
            $State = DATA_STATE;
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            push @$Tokens, $Token;
            return 1;
          }
        
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@</@,
                            di => $DI, index => $AnchoredIndex};
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = SCRIPT_DATA_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {
  $Token->{q<tag_name>} .= chr ((ord $1) + 32);
  $Temp .= $1;
  } elsif ($Input =~ /\G([afbcdeghjknqrvwzilmopstuxy]+)/gcs) {
  $Token->{q<tag_name>} .= $1;
  $Temp .= $1;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@</@,
                            di => $DI, index => $AnchoredIndex};
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = SCRIPT_DATA_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  } elsif ($Input =~ /\G(.)/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@</@,
                            di => $DI, index => $AnchoredIndex};
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = SCRIPT_DATA_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } else {
  if ($EOF) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@</@,
                            di => $DI, index => $AnchoredIndex};
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = SCRIPT_DATA_STATE;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[SCRIPT_DATA_END_TAG_OPEN_STATE] = sub {
  if ($Input =~ /\G([\])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@</@,
                            di => $DI, index => $AnchoredIndex};
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@
  @,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  $State = SCRIPT_DATA_STATE_CR;
  } elsif ($Input =~ /\G([\<])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@</@,
                            di => $DI, index => $AnchoredIndex};
          
  $State = SCRIPT_DATA_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  } elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {
  
          $Token = {type => END_TAG_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $State = SCRIPT_DATA_END_TAG_NAME_STATE;
  $Token->{q<tag_name>} = chr ((ord $1) + 32);
  $Temp .= $1;
  } elsif ($Input =~ /\G([afbcdeghjknqrvwzilmopstuxy])/gcs) {
  
          $Token = {type => END_TAG_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $State = SCRIPT_DATA_END_TAG_NAME_STATE;
  $Token->{q<tag_name>} = $1;
  $Temp .= $1;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@</@,
                            di => $DI, index => $AnchoredIndex};
          
  $State = SCRIPT_DATA_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  } elsif ($Input =~ /\G(.)/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@</@,
                            di => $DI, index => $AnchoredIndex};
          
  $State = SCRIPT_DATA_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } else {
  if ($EOF) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@</@,
                            di => $DI, index => $AnchoredIndex};
          
  $State = SCRIPT_DATA_STATE;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[SCRIPT_DATA_ESCAPE_START_DASH_STATE] = sub {
  if ($Input =~ /\G([\])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@
  @,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  $State = SCRIPT_DATA_STATE_CR;
  } elsif ($Input =~ /\G([\-])/gcs) {
  $State = SCRIPT_DATA_ESCAPED_DASH_DASH_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@-@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  } elsif ($Input =~ /\G([\<])/gcs) {
  $State = SCRIPT_DATA_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  $State = SCRIPT_DATA_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  } elsif ($Input =~ /\G(.)/gcs) {
  $State = SCRIPT_DATA_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } else {
  if ($EOF) {
  $State = SCRIPT_DATA_STATE;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[SCRIPT_DATA_ESCAPE_START_STATE] = sub {
  if ($Input =~ /\G([\])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@
  @,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  $State = SCRIPT_DATA_STATE_CR;
  } elsif ($Input =~ /\G([\-])/gcs) {
  $State = SCRIPT_DATA_ESCAPE_START_DASH_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@-@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  } elsif ($Input =~ /\G([\<])/gcs) {
  $State = SCRIPT_DATA_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  $State = SCRIPT_DATA_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  } elsif ($Input =~ /\G(.)/gcs) {
  $State = SCRIPT_DATA_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } else {
  if ($EOF) {
  $State = SCRIPT_DATA_STATE;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[SCRIPT_DATA_ESCAPED_DASH_DASH_STATE] = sub {
  if ($Input =~ /\G([\])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@
  @,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  $State = SCRIPT_DATA_ESCAPED_STATE_CR;
  } elsif ($Input =~ /\G([\-])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@-@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  } elsif ($Input =~ /\G([\<])/gcs) {
  $State = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  } elsif ($Input =~ /\G([\>])/gcs) {
  $State = SCRIPT_DATA_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@>@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $State = SCRIPT_DATA_ESCAPED_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  } elsif ($Input =~ /\G(.)/gcs) {
  $State = SCRIPT_DATA_ESCAPED_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[SCRIPT_DATA_ESCAPED_DASH_STATE] = sub {
  if ($Input =~ /\G([\])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@
  @,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  $State = SCRIPT_DATA_ESCAPED_STATE_CR;
  } elsif ($Input =~ /\G([\-])/gcs) {
  $State = SCRIPT_DATA_ESCAPED_DASH_DASH_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@-@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  } elsif ($Input =~ /\G([\<])/gcs) {
  $State = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $State = SCRIPT_DATA_ESCAPED_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  } elsif ($Input =~ /\G(.)/gcs) {
  $State = SCRIPT_DATA_ESCAPED_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE] = sub {
  if ($Input =~ /\G([\	\\ \
  ])/gcs) {
  
            if (defined $LastStartTagName and
                $Token->{tag_name} eq $LastStartTagName) {
              $State = B_ATTR_NAME_STATE;
              return 1;
            }
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@</@,
                            di => $DI, index => $AnchoredIndex};
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = SCRIPT_DATA_ESCAPED_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } elsif ($Input =~ /\G([\])/gcs) {
  
            if (defined $LastStartTagName and
                $Token->{tag_name} eq $LastStartTagName) {
              $State = B_ATTR_NAME_STATE;
              return 1;
            }
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@</@,
                            di => $DI, index => $AnchoredIndex};
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@
  @,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  $State = SCRIPT_DATA_ESCAPED_STATE_CR;
  } elsif ($Input =~ /\G([\-])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@</@,
                            di => $DI, index => $AnchoredIndex};
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = SCRIPT_DATA_ESCAPED_DASH_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@-@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  } elsif ($Input =~ /\G([\/])/gcs) {
  
            if (defined $LastStartTagName and
                $Token->{tag_name} eq $LastStartTagName) {
              $State = SELF_CLOSING_START_TAG_STATE;
              return 1;
            }
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@</@,
                            di => $DI, index => $AnchoredIndex};
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = SCRIPT_DATA_ESCAPED_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } elsif ($Input =~ /\G([\<])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@</@,
                            di => $DI, index => $AnchoredIndex};
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  } elsif ($Input =~ /\G([\>])/gcs) {
  
          if (defined $LastStartTagName and
              $Token->{tag_name} eq $LastStartTagName) {
            $State = DATA_STATE;
            $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
            push @$Tokens, $Token;
            return 1;
          }
        
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@</@,
                            di => $DI, index => $AnchoredIndex};
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = SCRIPT_DATA_ESCAPED_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {
  $Token->{q<tag_name>} .= chr ((ord $1) + 32);
  $Temp .= $1;
  } elsif ($Input =~ /\G([afbcdeghjknqrvwzilmopstuxy]+)/gcs) {
  $Token->{q<tag_name>} .= $1;
  $Temp .= $1;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@</@,
                            di => $DI, index => $AnchoredIndex};
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = SCRIPT_DATA_ESCAPED_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  } elsif ($Input =~ /\G(.)/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@</@,
                            di => $DI, index => $AnchoredIndex};
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = SCRIPT_DATA_ESCAPED_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } else {
  if ($EOF) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@</@,
                            di => $DI, index => $AnchoredIndex};
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $Temp,
                            di => $DI,
                            index => $TempIndex} if length $Temp;
          
  $State = SCRIPT_DATA_ESCAPED_STATE;
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE] = sub {
  if ($Input =~ /\G([\])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@</@,
                            di => $DI, index => $AnchoredIndex};
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@
  @,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  $State = SCRIPT_DATA_ESCAPED_STATE_CR;
  } elsif ($Input =~ /\G([\-])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@</@,
                            di => $DI, index => $AnchoredIndex};
          
  $State = SCRIPT_DATA_ESCAPED_DASH_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@-@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  } elsif ($Input =~ /\G([\<])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@</@,
                            di => $DI, index => $AnchoredIndex};
          
  $State = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  } elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {
  
          $Token = {type => END_TAG_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $State = SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE;
  $Token->{q<tag_name>} .= chr ((ord $1) + 32);
  $Temp .= $1;
  } elsif ($Input =~ /\G([afbcdeghjknqrvwzilmopstuxy])/gcs) {
  
          $Token = {type => END_TAG_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $State = SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE;
  $Token->{q<tag_name>} .= $1;
  $Temp .= $1;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@</@,
                            di => $DI, index => $AnchoredIndex};
          
  $State = SCRIPT_DATA_ESCAPED_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  } elsif ($Input =~ /\G(.)/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@</@,
                            di => $DI, index => $AnchoredIndex};
          
  $State = SCRIPT_DATA_ESCAPED_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } else {
  if ($EOF) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@</@,
                            di => $DI, index => $AnchoredIndex};
          
  $State = SCRIPT_DATA_ESCAPED_STATE;
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE] = sub {
  if ($Input =~ /\G([\])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@<@,
                            di => $DI, index => $AnchoredIndex};
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@
  @,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  $State = SCRIPT_DATA_ESCAPED_STATE_CR;
  } elsif ($Input =~ /\G([\-])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@<@,
                            di => $DI, index => $AnchoredIndex};
          
  $State = SCRIPT_DATA_ESCAPED_DASH_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@-@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  } elsif ($Input =~ /\G([\/])/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE;
  } elsif ($Input =~ /\G([\<])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@<@,
                            di => $DI, index => $AnchoredIndex};
          
  $State = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  } elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@<@,
                            di => $DI, index => $AnchoredIndex};
          
  $State = SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE;
  $Temp .= chr ((ord $1) + 32);
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } elsif ($Input =~ /\G([afbcdeghjknqrvwzilmopstuxy])/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@<@,
                            di => $DI, index => $AnchoredIndex};
          
  $State = SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE;
  $Temp .= $1;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@<@,
                            di => $DI, index => $AnchoredIndex};
          
  $State = SCRIPT_DATA_ESCAPED_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  } elsif ($Input =~ /\G(.)/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@<@,
                            di => $DI, index => $AnchoredIndex};
          
  $State = SCRIPT_DATA_ESCAPED_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } else {
  if ($EOF) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@<@,
                            di => $DI, index => $AnchoredIndex};
          
  $State = SCRIPT_DATA_ESCAPED_STATE;
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[SCRIPT_DATA_ESCAPED_STATE] = sub {
  if ($Input =~ /\G([^\\-\<\ ]+)/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  
  } elsif ($Input =~ /\G([\])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@
  @,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  $State = SCRIPT_DATA_ESCAPED_STATE_CR;
  } elsif ($Input =~ /\G([\-])/gcs) {
  $State = SCRIPT_DATA_ESCAPED_DASH_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@-@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  } elsif ($Input =~ /\G([\<])/gcs) {
  $State = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[SCRIPT_DATA_ESCAPED_STATE_CR] = sub {
  if ($Input =~ /\G([\
  ])/gcs) {
  $State = SCRIPT_DATA_ESCAPED_STATE;
  } elsif ($Input =~ /\G([\])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@
  @,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  $State = SCRIPT_DATA_ESCAPED_STATE_CR;
  } elsif ($Input =~ /\G([\-])/gcs) {
  $State = SCRIPT_DATA_ESCAPED_DASH_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@-@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  } elsif ($Input =~ /\G([\<])/gcs) {
  $State = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  $State = SCRIPT_DATA_ESCAPED_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  } elsif ($Input =~ /\G(.)/gcs) {
  $State = SCRIPT_DATA_ESCAPED_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } else {
  if ($EOF) {
  $State = SCRIPT_DATA_ESCAPED_STATE;
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[SCRIPT_DATA_LESS_THAN_SIGN_STATE] = sub {
  if ($Input =~ /\G([\])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@<@,
                            di => $DI, index => $AnchoredIndex};
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@
  @,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  $State = SCRIPT_DATA_STATE_CR;
  } elsif ($Input =~ /\G([\!])/gcs) {
  $State = SCRIPT_DATA_ESCAPE_START_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@<!@,
                            di => $DI, index => $AnchoredIndex};
          
  } elsif ($Input =~ /\G([\/])/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = SCRIPT_DATA_END_TAG_OPEN_STATE;
  } elsif ($Input =~ /\G([\<])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@<@,
                            di => $DI, index => $AnchoredIndex};
          
  $State = SCRIPT_DATA_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@<@,
                            di => $DI, index => $AnchoredIndex};
          
  $State = SCRIPT_DATA_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  } elsif ($Input =~ /\G(.)/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@<@,
                            di => $DI, index => $AnchoredIndex};
          
  $State = SCRIPT_DATA_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } else {
  if ($EOF) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@<@,
                            di => $DI, index => $AnchoredIndex};
          
  $State = SCRIPT_DATA_STATE;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[SCRIPT_DATA_STATE] = sub {
  if ($Input =~ /\G([^\\<\ ]+)/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  
  } elsif ($Input =~ /\G([\])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@
  @,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  $State = SCRIPT_DATA_STATE_CR;
  } elsif ($Input =~ /\G([\<])/gcs) {
  $State = SCRIPT_DATA_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  } else {
  if ($EOF) {
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[SCRIPT_DATA_STATE_CR] = sub {
  if ($Input =~ /\G([\
  ])/gcs) {
  $State = SCRIPT_DATA_STATE;
  } elsif ($Input =~ /\G([\])/gcs) {
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@
  @,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  $State = SCRIPT_DATA_STATE_CR;
  } elsif ($Input =~ /\G([\<])/gcs) {
  $State = SCRIPT_DATA_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  $State = SCRIPT_DATA_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@@,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  } elsif ($Input =~ /\G(.)/gcs) {
  $State = SCRIPT_DATA_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } else {
  if ($EOF) {
  $State = SCRIPT_DATA_STATE;
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[SELF_CLOSING_START_TAG_STATE] = sub {
  if ($Input =~ /\G([\>])/gcs) {
  $Token->{q<self_closing_flag>} = 1;
  $State = DATA_STATE;
  
            if ($Token->{type} == END_TAG_TOKEN) {
              if (keys %{$Token->{attrs} or {}}) {
                push @$Errors, {type => 'end tag attribute',
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
              if ($Token->{self_closing_flag}) {
                push @$Errors, {type => 'nestc',
                                text => $Token->{tag_name},
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
            }
          
  push @$Tokens, $Token;
  
            if ($Token->{type} == START_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              if (not defined $LastStartTagName) { # "first start tag"
                $LastStartTagName = $Token->{tag_name};
                return 1;
              } else {
                $LastStartTagName = $Token->{tag_name};
              }
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
              return 1 if $Token->{tag_name} =~ /-/;
              return 1 if $Token->{attrs}->{is};
            }
          
  
            if ($Token->{type} == END_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              ## 
            }
          
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'nestc has no net', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Attr = {di => $DI};
  $Attr->{q<name>} = q@@;
  $Attr->{index} = $Offset + (pos $Input) - length $1;
  $Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
  $State = ATTR_NAME_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  } elsif ($Input =~ /\G([\	\\ \
  \])/gcs) {
  
              push @$Errors, {type => 'nestc has no net', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $State = B_ATTR_NAME_STATE;
  } elsif ($Input =~ /\G([\"])/gcs) {
  
              push @$Errors, {type => 'nestc has no net', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Attr = {di => $DI};
  $Attr->{q<name>} = $1;
  $Attr->{index} = $Offset + (pos $Input) - length $1;
  $Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
  $State = ATTR_NAME_STATE;
  
              push @$Errors, {type => 'bad attribute name', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  } elsif ($Input =~ /\G([\'])/gcs) {
  
              push @$Errors, {type => 'nestc has no net', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Attr = {di => $DI};
  $Attr->{q<name>} = $1;
  $Attr->{index} = $Offset + (pos $Input) - length $1;
  $Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
  $State = ATTR_NAME_STATE;
  
              push @$Errors, {type => 'bad attribute name', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  } elsif ($Input =~ /\G([\/])/gcs) {
  
              push @$Errors, {type => 'nestc has no net', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $State = SELF_CLOSING_START_TAG_STATE;
  } elsif ($Input =~ /\G([\<])/gcs) {
  
              push @$Errors, {type => 'nestc has no net', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Attr = {di => $DI};
  $Attr->{q<name>} = $1;
  $Attr->{index} = $Offset + (pos $Input) - length $1;
  $Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
  $State = ATTR_NAME_STATE;
  
              push @$Errors, {type => 'tag not closed', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  } elsif ($Input =~ /\G([\=])/gcs) {
  
              push @$Errors, {type => 'nestc has no net', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
              push @$Errors, {type => 'parser:no attr name', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Attr = {di => $DI};
  $Attr->{q<name>} = $1;
  $Attr->{index} = $Offset + (pos $Input) - length $1;
  $Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
  $State = ATTR_NAME_STATE;
  } elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {
  
              push @$Errors, {type => 'nestc has no net', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Attr = {di => $DI};
  $Attr->{q<name>} = chr ((ord $1) + 32);
  $Attr->{index} = $Offset + (pos $Input) - length $1;
  $Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
  $State = ATTR_NAME_STATE;
  } elsif ($Input =~ /\G(.)/gcs) {
  
              push @$Errors, {type => 'nestc has no net', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Attr = {di => $DI};
  $Attr->{q<name>} = $1;
  $Attr->{index} = $Offset + (pos $Input) - length $1;
  $Attr->{q<value>} = [['', $Attr->{di}, $Attr->{index}]];
  $State = ATTR_NAME_STATE;
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[TAG_NAME_STATE] = sub {
  if ($Input =~ /\G([^\	\\ \
  \\/\>ABCDEFGHJKNQRVWZILMOPSTUXY\ ]+)/gcs) {
  $Token->{q<tag_name>} .= $1;
  
  } elsif ($Input =~ /\G([\	\\ \
  \])/gcs) {
  $State = B_ATTR_NAME_STATE;
  } elsif ($Input =~ /\G([\/])/gcs) {
  $State = SELF_CLOSING_START_TAG_STATE;
  } elsif ($Input =~ /\G([\>])/gcs) {
  $State = DATA_STATE;
  
            if ($Token->{type} == END_TAG_TOKEN) {
              if (keys %{$Token->{attrs} or {}}) {
                push @$Errors, {type => 'end tag attribute',
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
              if ($Token->{self_closing_flag}) {
                push @$Errors, {type => 'nestc',
                                text => $Token->{tag_name},
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
            }
          
  push @$Tokens, $Token;
  
            if ($Token->{type} == START_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              if (not defined $LastStartTagName) { # "first start tag"
                $LastStartTagName = $Token->{tag_name};
                return 1;
              } else {
                $LastStartTagName = $Token->{tag_name};
              }
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
              return 1 if $Token->{tag_name} =~ /-/;
              return 1 if $Token->{attrs}->{is};
            }
          
  
            if ($Token->{type} == END_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              ## 
            }
          
  } elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {
  $Token->{q<tag_name>} .= chr ((ord $1) + 32);
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  $Token->{q<tag_name>} .= q@@;
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  $StateActions->[TAG_OPEN_STATE] = sub {
  if ($Input =~ /\G\!(\-)\-\-([^\ \\-\<\>])([^\ \\-\<]*)\-\-\!(\<)(\<*)(\!)\-([^\ \\-\<])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[4] - 3];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[7] - 1];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-(\<)(\<*)(\!)\-([^\ \\-\<])([^\ \\-\<]*)\-\-([^\ \\!\-\<\>])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[5] - 1];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[7] - 2];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-(\<)(\<*)(\!)\-([^\ \\-\<])([^\ \\-\<]*)\-\-\!([^\ \\-\<\>])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[5] - 1];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[7] - 3];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-\-([^\ \\!\-\<\>])([^\ \\-\<]*)\-(\<)(\<*)(\!)\-([^\ \\-\<])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[2] - 2];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[4] - 1];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[7] - 1];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-\-\!([^\ \\-\<\>])([^\ \\-\<]*)\-(\<)(\<*)(\!)\-([^\ \\-\<])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[2] - 3];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[4] - 1];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[7] - 1];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-([^\ \\-\<\>])([^\ \\-\<]*)\-\-\!(\<)(\<*)(\!)\-([^\ \\-\<])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[4] - 3];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[7] - 1];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-(\<)(\<*)(\!)\-([^\ \\-\<])([^\ \\-\<]*)\-\-([^\ \\!\-\<\>])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[5] - 1];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[7] - 2];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-(\<)(\<*)(\!)\-([^\ \\-\<])([^\ \\-\<]*)\-\-\!([^\ \\-\<\>])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[5] - 1];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[7] - 3];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-([^\ \\-\<\>])([^\ \\-\<]*)\-\-(\<)(\<*)(\!)\-([^\ \\-\<])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[4] - 2];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[7] - 1];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-([^\ \\-\<\>])([^\ \\-\<]*)\-\-\!(\<)(\<*)(\!)([^\ \\-\<])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[4] - 3];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-(\<)(\<*)(\!)([^\ \\-\<])([^\ \\-\<]*)\-\-([^\ \\!\-\<\>])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[7] - 2];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-(\<)(\<*)(\!)([^\ \\-\<])([^\ \\-\<]*)\-\-\!([^\ \\-\<\>])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[7] - 3];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-\-([^\ \\!\-\<\>])([^\ \\-\<]*)(\<)(\<*)(\!)\-([^\ \\-\<])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[2] - 2];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[7] - 1];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-\-([^\ \\!\-\<\>])([^\ \\-\<]*)\-(\<)(\<*)(\!)([^\ \\-\<])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[2] - 2];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[4] - 1];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-\-\!([^\ \\-\<\>])([^\ \\-\<]*)(\<)(\<*)(\!)\-([^\ \\-\<])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[2] - 3];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[7] - 1];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-\-\!([^\ \\-\<\>])([^\ \\-\<]*)\-(\<)(\<*)(\!)([^\ \\-\<])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[2] - 3];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[4] - 1];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-\-\!(\<)(\<*)(\!)\-([^\ \\-\<])([^\ \\-\<]*)\-([^\ \\-\<])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[2] - 3];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[5] - 1];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[7] - 1];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-\-\!\-([^\ \\-\<])([^\ \\-\<]*)(\<)(\<*)(\!)\-([^\ \\-\<])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + (pos $Input) - (length $1) - 3];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[7] - 1];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-([^\ \\-\<\>])([^\ \\-\<]*)\-\-(\<)(\<*)(\!)\-([^\ \\-\<])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[4] - 2];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[7] - 1];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-([^\ \\-\<\>])([^\ \\-\<]*)\-\-\!(\<)(\<*)(\!)([^\ \\-\<])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[4] - 3];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-(\<)(\<*)(\!)([^\ \\-\<])([^\ \\-\<]*)\-\-([^\ \\!\-\<\>])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[7] - 2];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-(\<)(\<*)(\!)([^\ \\-\<])([^\ \\-\<]*)\-\-\!([^\ \\-\<\>])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[7] - 3];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-([^\ \\-\<\>])([^\ \\-\<]*)(\<)(\<*)\-\-([^\ \\!\-\<\>])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[6] - 2];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  } elsif ($Input =~ /\G\!(\-)\-\-([^\ \\-\<\>])([^\ \\-\<]*)(\<)(\<*)\-\-\!([^\ \\-\<\>])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[6] - 3];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  } elsif ($Input =~ /\G\!(\-)\-\-([^\ \\-\<\>])([^\ \\-\<]*)\-(\<)(\<*)(\!)\-([^\ \\-\<])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[4] - 1];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[7] - 1];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-([^\ \\-\<\>])([^\ \\-\<]*)\-\-(\<)(\<*)(\!)([^\ \\-\<])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[4] - 2];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-([^\ \\-\<\>])([^\ \\-\<]*)\-\-\!(\<)(\<*)([^\ \\!\-\<])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[4] - 3];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  } elsif ($Input =~ /\G\!(\-)\-\-(\<)(\<*)([^\ \\!\-\<])([^\ \\-\<]*)\-\-([^\ \\!\-\<\>])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[6] - 2];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  } elsif ($Input =~ /\G\!(\-)\-\-(\<)(\<*)([^\ \\!\-\<])([^\ \\-\<]*)\-\-\!([^\ \\-\<\>])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[6] - 3];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  } elsif ($Input =~ /\G\!(\-)\-\-\-([^\ \\!\-\<\>])([^\ \\-\<]*)(\<)(\<*)(\!)([^\ \\-\<])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[2] - 2];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-\-([^\ \\!\-\<\>])([^\ \\-\<]*)\-(\<)(\<*)([^\ \\!\-\<])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[2] - 2];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[4] - 1];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  } elsif ($Input =~ /\G\!(\-)\-\-\-(\<)(\<*)(\!)\-([^\ \\-\<])([^\ \\-\<]*)\-([^\ \\-\<])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[2] - 2];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[5] - 1];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[7] - 1];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-\-\!([^\ \\-\<\>])([^\ \\-\<]*)(\<)(\<*)(\!)([^\ \\-\<])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[2] - 3];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-\-\!([^\ \\-\<\>])([^\ \\-\<]*)\-(\<)(\<*)([^\ \\!\-\<])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[2] - 3];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[4] - 1];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  } elsif ($Input =~ /\G\!(\-)\-\-\-\!(\<)(\<*)(\!)([^\ \\-\<])([^\ \\-\<]*)\-([^\ \\-\<])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[2] - 3];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[7] - 1];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-\-\!\-([^\ \\-\<])([^\ \\-\<]*)(\<)(\<*)(\!)([^\ \\-\<])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + (pos $Input) - (length $1) - 3];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-([^\ \\-\<\>])([^\ \\-\<]*)(\<)(\<*)\-\-([^\ \\!\-\<\>])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[6] - 2];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  } elsif ($Input =~ /\G\!(\-)\-([^\ \\-\<\>])([^\ \\-\<]*)(\<)(\<*)\-\-\!([^\ \\-\<\>])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[6] - 3];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  } elsif ($Input =~ /\G\!(\-)\-([^\ \\-\<\>])([^\ \\-\<]*)\-(\<)(\<*)(\!)\-([^\ \\-\<])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[4] - 1];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[7] - 1];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-([^\ \\-\<\>])([^\ \\-\<]*)\-\-(\<)(\<*)(\!)([^\ \\-\<])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[4] - 2];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-([^\ \\-\<\>])([^\ \\-\<]*)\-\-\!(\<)(\<*)([^\ \\!\-\<])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[4] - 3];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  } elsif ($Input =~ /\G\!(\-)\-(\<)(\<*)([^\ \\!\-\<])([^\ \\-\<]*)\-\-([^\ \\!\-\<\>])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[6] - 2];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  } elsif ($Input =~ /\G\!(\-)\-(\<)(\<*)([^\ \\!\-\<])([^\ \\-\<]*)\-\-\!([^\ \\-\<\>])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[6] - 3];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  } elsif ($Input =~ /\G\!(\-)\-\-([^\ \\-\<\>])([^\ \\-\<]*)(\<)(\<*)(\!)\-([^\ \\-\<])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[7] - 1];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-([^\ \\-\<\>])([^\ \\-\<]*)\-(\<)(\<*)(\!)([^\ \\-\<])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[4] - 1];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-([^\ \\-\<\>])([^\ \\-\<]*)\-\-(\<)(\<*)([^\ \\!\-\<])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[4] - 2];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  } elsif ($Input =~ /\G\!(\-)\-\-(\<)(\<*)(\!)\-([^\ \\-\<])([^\ \\-\<]*)\-([^\ \\-\<])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[5] - 1];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[7] - 1];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-\-([^\ \\!\-\<\>])([^\ \\-\<]*)(\<)(\<*)([^\ \\!\-\<])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[2] - 2];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  } elsif ($Input =~ /\G\!(\-)\-\-\-([^\ \\!\-\<\>])([^\ \\-\<]*)(\<)(\<*)\-([^\ \\-\<])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[2] - 2];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[6] - 1];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  } elsif ($Input =~ /\G\!(\-)\-\-\-(\<)(\<*)(\!)([^\ \\-\<])([^\ \\-\<]*)\-([^\ \\-\<])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[2] - 2];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[7] - 1];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-\-\!([^\ \\-\<\>])([^\ \\-\<]*)(\<)(\<*)([^\ \\!\-\<])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[2] - 3];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  } elsif ($Input =~ /\G\!(\-)\-\-\-\!([^\ \\-\<\>])([^\ \\-\<]*)(\<)(\<*)\-([^\ \\-\<])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[2] - 3];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[6] - 1];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  } elsif ($Input =~ /\G\!(\-)\-\-\-\!(\<)(\<*)([^\ \\!\-\<])([^\ \\-\<]*)\-([^\ \\-\<])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[2] - 3];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[6] - 1];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  } elsif ($Input =~ /\G\!(\-)\-\-\-\!\-([^\ \\-\<])([^\ \\-\<]*)(\<)(\<*)([^\ \\!\-\<])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + (pos $Input) - (length $1) - 3];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  } elsif ($Input =~ /\G\!(\-)\-([^\ \\-\<\>])([^\ \\-\<]*)(\<)(\<*)(\!)\-([^\ \\-\<])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[7] - 1];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-([^\ \\-\<\>])([^\ \\-\<]*)\-(\<)(\<*)(\!)([^\ \\-\<])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[4] - 1];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-([^\ \\-\<\>])([^\ \\-\<]*)\-\-(\<)(\<*)([^\ \\!\-\<])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[4] - 2];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  } elsif ($Input =~ /\G\!(\-)\-(\<)(\<*)(\!)\-([^\ \\-\<])([^\ \\-\<]*)\-([^\ \\-\<])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[5] - 1];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[7] - 1];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-([^\ \\-\<\>])([^\ \\-\<]*)(\<)(\<*)(\!)([^\ \\-\<])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-([^\ \\-\<\>])([^\ \\-\<]*)\-(\<)(\<*)([^\ \\!\-\<])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[4] - 1];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  } elsif ($Input =~ /\G\!(\-)\-\-(\<)(\<*)(\!)([^\ \\-\<])([^\ \\-\<]*)\-([^\ \\-\<])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[7] - 1];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-\-(\<)(\<*)([^\ \\!\-\<])([^\ \\-\<]*)\-([^\ \\-\<])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[2] - 2];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[6] - 1];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  } elsif ($Input =~ /\G\!(\-)\-([^\ \\-\<\>])([^\ \\-\<]*)(\<)(\<*)(\!)([^\ \\-\<])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-([^\ \\-\<\>])([^\ \\-\<]*)\-(\<)(\<*)([^\ \\!\-\<])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[4] - 1];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  } elsif ($Input =~ /\G\!(\-)\-(\<)(\<*)(\!)([^\ \\-\<])([^\ \\-\<]*)\-([^\ \\-\<])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[7] - 1];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-([^\ \\-\<\>])([^\ \\-\<]*)(\<)(\<*)([^\ \\!\-\<])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  } elsif ($Input =~ /\G\!(\-)\-\-([^\ \\-\<\>])([^\ \\-\<]*)(\<)(\<*)\-([^\ \\-\<])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[6] - 1];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  } elsif ($Input =~ /\G\!(\-)\-\-(\<)(\<*)([^\ \\!\-\<])([^\ \\-\<]*)\-([^\ \\-\<])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[6] - 1];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  } elsif ($Input =~ /\G\!(\-)\-([^\ \\-\<\>])([^\ \\-\<]*)(\<)(\<*)([^\ \\!\-\<])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  } elsif ($Input =~ /\G\!(\-)\-([^\ \\-\<\>])([^\ \\-\<]*)(\<)(\<*)\-([^\ \\-\<])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[6] - 1];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  } elsif ($Input =~ /\G\!(\-)\-(\<)(\<*)([^\ \\!\-\<])([^\ \\-\<]*)\-([^\ \\-\<])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[6] - 1];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  } elsif ($Input =~ /\G\!(\-)\-\-([^\ \\-\<\>])([^\ \\-\<]*)\-\-([^\ \\!\-\<\>])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[4] - 2];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  } elsif ($Input =~ /\G\!(\-)\-\-([^\ \\-\<\>])([^\ \\-\<]*)\-\-\!([^\ \\-\<\>])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[4] - 3];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  } elsif ($Input =~ /\G\!(\-)\-([^\ \\-\<\>])([^\ \\-\<]*)\-\-([^\ \\!\-\<\>])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[4] - 2];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  } elsif ($Input =~ /\G\!(\-)\-([^\ \\-\<\>])([^\ \\-\<]*)\-\-\!([^\ \\-\<\>])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[4] - 3];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  } elsif ($Input =~ /\G\!(\-)\-\-\-([^\ \\!\-\<\>])([^\ \\-\<]*)\-([^\ \\-\<])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[2] - 2];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[4] - 1];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  } elsif ($Input =~ /\G\!(\-)\-\-\-\!([^\ \\-\<\>])([^\ \\-\<]*)\-([^\ \\-\<])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[2] - 3];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[4] - 1];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  } elsif ($Input =~ /\G\!(\-)\-\-([^\ \\-\<\>])([^\ \\-\<]*)\-\-\!(\<)(\<*)(\!)\-(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[4] - 3];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[7] - 1];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-\-([^\ \\!\-\<\>])([^\ \\-\<]*)\-(\<)(\<*)(\!)\-(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[2] - 2];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[4] - 1];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[7] - 1];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-\-\!([^\ \\-\<\>])([^\ \\-\<]*)\-(\<)(\<*)(\!)\-(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[2] - 3];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[4] - 1];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[7] - 1];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-([^\ \\-\<\>])([^\ \\-\<]*)\-([^\ \\-\<])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[4] - 1];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  } elsif ($Input =~ /\G\!(\-)\-([^\ \\-\<\>])([^\ \\-\<]*)\-\-\!(\<)(\<*)(\!)\-(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[4] - 3];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[7] - 1];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-([^\ \\-\<\>])([^\ \\-\<]*)\-\-(\<)(\<*)(\!)\-(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[4] - 2];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[7] - 1];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-([^\ \\-\<\>])([^\ \\-\<]*)\-\-\!(\<)(\<*)(\!)(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[4] - 3];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-(\<)(\<*)(\!)\-([^\ \\-\<])([^\ \\-\<]*)\-\-\!(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[5] - 1];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[7] - 3];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-\-([^\ \\!\-\<\>])([^\ \\-\<]*)(\<)(\<*)(\!)\-(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[2] - 2];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[7] - 1];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-\-([^\ \\!\-\<\>])([^\ \\-\<]*)\-(\<)(\<*)(\!)(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[2] - 2];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[4] - 1];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-\-\!([^\ \\-\<\>])([^\ \\-\<]*)(\<)(\<*)(\!)\-(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[2] - 3];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[7] - 1];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-\-\!([^\ \\-\<\>])([^\ \\-\<]*)\-(\<)(\<*)(\!)(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[2] - 3];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[4] - 1];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-\-\!(\<)(\<*)(\!)\-([^\ \\-\<])([^\ \\-\<]*)\-(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[2] - 3];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[5] - 1];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[7] - 1];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-\-\!\-([^\ \\-\<])([^\ \\-\<]*)(\<)(\<*)(\!)\-(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + (pos $Input) - (length $1) - 3];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[7] - 1];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-\-\!\-(\<)(\<*)(\!)\-([^\ \\-\<])([^\ \\-\<]*)(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + (pos $Input) - (length $1) - 3];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[5] - 1];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-([^\ \\-\<\>])([^\ \\-\<]*)\-([^\ \\-\<])([^\ \\-\<]*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[4] - 1];
  $State = COMMENT_STATE;
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  } elsif ($Input =~ /\G\!(\-)\-([^\ \\-\<\>])([^\ \\-\<]*)\-\-(\<)(\<*)(\!)\-(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[4] - 2];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[7] - 1];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-([^\ \\-\<\>])([^\ \\-\<]*)\-\-\!(\<)(\<*)(\!)(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[4] - 3];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-(\<)(\<*)(\!)\-([^\ \\-\<])([^\ \\-\<]*)\-\-\!(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[5] - 1];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[7] - 3];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-([^\ \\-\<\>])([^\ \\-\<]*)\-(\<)(\<*)(\!)\-(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[4] - 1];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[7] - 1];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-([^\ \\-\<\>])([^\ \\-\<]*)\-\-(\<)(\<*)(\!)(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[4] - 2];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-(\<)(\<*)(\!)([^\ \\-\<])([^\ \\-\<]*)\-\-\!(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[7] - 3];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-(\<)(\<*)(\!)\-([^\ \\-\<])([^\ \\-\<]*)\-\-(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[5] - 1];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[7] - 2];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-\-([^\ \\!\-\<\>])([^\ \\-\<]*)(\<)(\<*)(\!)(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[2] - 2];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-\-(\<)(\<*)(\!)\-([^\ \\-\<])([^\ \\-\<]*)\-(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[2] - 2];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[5] - 1];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[7] - 1];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-\-\!([^\ \\-\<\>])([^\ \\-\<]*)(\<)(\<*)(\!)(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[2] - 3];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-\-\!(\<)(\<*)(\!)([^\ \\-\<])([^\ \\-\<]*)\-(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[2] - 3];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[7] - 1];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-\-\!(\<)(\<*)(\!)\-([^\ \\-\<])([^\ \\-\<]*)(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[2] - 3];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[5] - 1];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-\-\!\-([^\ \\-\<])([^\ \\-\<]*)(\<)(\<*)(\!)(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + (pos $Input) - (length $1) - 3];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-\-\!\-(\<)(\<*)(\!)([^\ \\-\<])([^\ \\-\<]*)(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + (pos $Input) - (length $1) - 3];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-([^\ \\-\<\>])([^\ \\-\<]*)\-\-\!(\<)(\<*)(\!)\-\-\>/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[4] - 3];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G\!(\-)\-\-\-([^\ \\!\-\<\>])([^\ \\-\<]*)\-(\<)(\<*)(\!)\-\-\>/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[2] - 2];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[4] - 1];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G\!(\-)\-\-\-\!([^\ \\-\<\>])([^\ \\-\<]*)\-(\<)(\<*)(\!)\-\-\>/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[2] - 3];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[4] - 1];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G\!(\-)\-([^\ \\-\<\>])([^\ \\-\<]*)\-(\<)(\<*)(\!)\-(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[4] - 1];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[7] - 1];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-([^\ \\-\<\>])([^\ \\-\<]*)\-\-(\<)(\<*)(\!)(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[4] - 2];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-(\<)(\<*)(\!)([^\ \\-\<])([^\ \\-\<]*)\-\-\!(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[7] - 3];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-(\<)(\<*)(\!)\-([^\ \\-\<])([^\ \\-\<]*)\-\-(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[5] - 1];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[7] - 2];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-([^\ \\-\<\>])([^\ \\-\<]*)(\<)(\<*)(\!)\-(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[7] - 1];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-([^\ \\-\<\>])([^\ \\-\<]*)(\<)(\<*)\-\-\!(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[6] - 3];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  } elsif ($Input =~ /\G\!(\-)\-\-([^\ \\-\<\>])([^\ \\-\<]*)\-(\<)(\<*)(\!)(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[4] - 1];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-(\<)(\<*)([^\ \\!\-\<])([^\ \\-\<]*)\-\-\!(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[6] - 3];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  } elsif ($Input =~ /\G\!(\-)\-\-(\<)(\<*)(\!)([^\ \\-\<])([^\ \\-\<]*)\-\-(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[7] - 2];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-(\<)(\<*)(\!)\-([^\ \\-\<])([^\ \\-\<]*)\-(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[5] - 1];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[7] - 1];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-(\<)(\<*)\-\-([^\ \\!\-\<\>])([^\ \\-\<]*)(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[4] - 2];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  } elsif ($Input =~ /\G\!(\-)\-\-(\<)(\<*)\-\-\!([^\ \\-\<\>])([^\ \\-\<]*)(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[4] - 3];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  } elsif ($Input =~ /\G\!(\-)\-\-\-([^\ \\!\-\<\>])([^\ \\-\<]*)(\<)(\<*)\-(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[2] - 2];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[6] - 1];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  } elsif ($Input =~ /\G\!(\-)\-\-\-(\<)(\<*)(\!)([^\ \\-\<])([^\ \\-\<]*)\-(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[2] - 2];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[7] - 1];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-\-(\<)(\<*)(\!)\-([^\ \\-\<])([^\ \\-\<]*)(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[2] - 2];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[5] - 1];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-\-\!([^\ \\-\<\>])([^\ \\-\<]*)(\<)(\<*)\-(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[2] - 3];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[6] - 1];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  } elsif ($Input =~ /\G\!(\-)\-\-\-\!(\<)(\<*)([^\ \\!\-\<])([^\ \\-\<]*)\-(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[2] - 3];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[6] - 1];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  } elsif ($Input =~ /\G\!(\-)\-\-\-\!(\<)(\<*)(\!)([^\ \\-\<])([^\ \\-\<]*)(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[2] - 3];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-\-\!\-(\<)(\<*)([^\ \\!\-\<])([^\ \\-\<]*)(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + (pos $Input) - (length $1) - 3];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  } elsif ($Input =~ /\G\!(\-)\-([^\ \\-\<\>])([^\ \\-\<]*)\-\-\!(\<)(\<*)(\!)\-\-\>/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[4] - 3];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G\!(\-)\-\-([^\ \\-\<\>])([^\ \\-\<]*)\-\-(\<)(\<*)(\!)\-\-\>/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[4] - 2];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G\!(\-)\-\-\-([^\ \\!\-\<\>])([^\ \\-\<]*)(\<)(\<*)(\!)\-\-\>/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[2] - 2];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G\!(\-)\-\-\-\!([^\ \\-\<\>])([^\ \\-\<]*)(\<)(\<*)(\!)\-\-\>/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[2] - 3];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G\!(\-)\-\-\-\!\-([^\ \\-\<])([^\ \\-\<]*)(\<)(\<*)(\!)\-\-\>/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + (pos $Input) - (length $1) - 3];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G\!(\-)\-([^\ \\-\<\>])([^\ \\-\<]*)(\<)(\<*)(\!)\-(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[7] - 1];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-([^\ \\-\<\>])([^\ \\-\<]*)(\<)(\<*)\-\-\!(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[6] - 3];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  } elsif ($Input =~ /\G\!(\-)\-([^\ \\-\<\>])([^\ \\-\<]*)\-(\<)(\<*)(\!)(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[4] - 1];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-(\<)(\<*)([^\ \\!\-\<])([^\ \\-\<]*)\-\-\!(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[6] - 3];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  } elsif ($Input =~ /\G\!(\-)\-(\<)(\<*)(\!)([^\ \\-\<])([^\ \\-\<]*)\-\-(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[7] - 2];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-(\<)(\<*)(\!)\-([^\ \\-\<])([^\ \\-\<]*)\-(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[5] - 1];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[7] - 1];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-(\<)(\<*)\-\-([^\ \\!\-\<\>])([^\ \\-\<]*)(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[4] - 2];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  } elsif ($Input =~ /\G\!(\-)\-(\<)(\<*)\-\-\!([^\ \\-\<\>])([^\ \\-\<]*)(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[4] - 3];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  } elsif ($Input =~ /\G\!(\-)\-\-([^\ \\-\<\>])([^\ \\-\<]*)(\<)(\<*)(\!)(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-([^\ \\-\<\>])([^\ \\-\<]*)(\<)(\<*)\-\-(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[6] - 2];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  } elsif ($Input =~ /\G\!(\-)\-\-(\<)(\<*)([^\ \\!\-\<])([^\ \\-\<]*)\-\-(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[6] - 2];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  } elsif ($Input =~ /\G\!(\-)\-\-(\<)(\<*)(\!)([^\ \\-\<])([^\ \\-\<]*)\-(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[7] - 1];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-(\<)(\<*)(\!)\-([^\ \\-\<])([^\ \\-\<]*)(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[5] - 1];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-\-(\<)(\<*)([^\ \\!\-\<])([^\ \\-\<]*)\-(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[2] - 2];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[6] - 1];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  } elsif ($Input =~ /\G\!(\-)\-\-\-(\<)(\<*)(\!)([^\ \\-\<])([^\ \\-\<]*)(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[2] - 2];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-\-\!(\<)(\<*)([^\ \\!\-\<])([^\ \\-\<]*)(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[2] - 3];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  } elsif ($Input =~ /\G\!(\-)\-\-\-\!(\<)(\<*)\-([^\ \\-\<])([^\ \\-\<]*)(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[2] - 3];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[4] - 1];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  } elsif ($Input =~ /\G\!(\-)\-([^\ \\-\<\>])([^\ \\-\<]*)\-\-(\<)(\<*)(\!)\-\-\>/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[4] - 2];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G\!(\-)\-\-([^\ \\-\<\>])([^\ \\-\<]*)\-(\<)(\<*)(\!)\-\-\>/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[4] - 1];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G\!(\-)\-\-(\<)(\<*)(\!)\-([^\ \\-\<])([^\ \\-\<]*)\-\-\!\-/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[5] - 1];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + (pos $Input) - (length $1) - 3];
  $State = COMMENT_END_DASH_STATE;
  } elsif ($Input =~ /\G\!(\-)\-\-\-\!(\<)(\<*)(\!)\-([^\ \\-\<])([^\ \\-\<]*)\-\-/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[2] - 3];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[5] - 1];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_STATE;
  } elsif ($Input =~ /\G\!(\-)\-\-\-\!\-(\<)(\<*)(\!)\-([^\ \\-\<])([^\ \\-\<]*)\-/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + (pos $Input) - (length $1) - 3];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[5] - 1];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_DASH_STATE;
  } elsif ($Input =~ /\G\!(\-)\-([^\ \\-\<\>])([^\ \\-\<]*)(\<)(\<*)(\!)(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-([^\ \\-\<\>])([^\ \\-\<]*)(\<)(\<*)\-\-(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[6] - 2];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  } elsif ($Input =~ /\G\!(\-)\-(\<)(\<*)([^\ \\!\-\<])([^\ \\-\<]*)\-\-(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[6] - 2];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  } elsif ($Input =~ /\G\!(\-)\-(\<)(\<*)(\!)([^\ \\-\<])([^\ \\-\<]*)\-(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[7] - 1];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-(\<)(\<*)(\!)\-([^\ \\-\<])([^\ \\-\<]*)(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[5] - 1];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-([^\ \\-\<\>])([^\ \\-\<]*)(\<)(\<*)\-(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[6] - 1];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  } elsif ($Input =~ /\G\!(\-)\-\-(\<)(\<*)([^\ \\!\-\<])([^\ \\-\<]*)\-(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[6] - 1];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  } elsif ($Input =~ /\G\!(\-)\-\-(\<)(\<*)(\!)([^\ \\-\<])([^\ \\-\<]*)(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-\-(\<)(\<*)([^\ \\!\-\<])([^\ \\-\<]*)(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[2] - 2];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  } elsif ($Input =~ /\G\!(\-)\-\-\-(\<)(\<*)\-([^\ \\-\<])([^\ \\-\<]*)(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[2] - 2];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[4] - 1];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  } elsif ($Input =~ /\G\/([A-Z])([^\ \	\
  \\\ \/\>A-Z]*)[\	\
  \\\ ][\	\
  \\\ ]*/gcs) {
  $State = END_TAG_OPEN_STATE;
  
          $Token = {type => END_TAG_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $State = TAG_NAME_STATE;
  $Token->{q<tag_name>} = chr ((ord $1) + 32);
  $Token->{q<tag_name>} .= $2;
  $State = B_ATTR_NAME_STATE;
  } elsif ($Input =~ /\G\/([a-z])([^\ \	\
  \\\ \/\>A-Z]*)[\	\
  \\\ ][\	\
  \\\ ]*/gcs) {
  $State = END_TAG_OPEN_STATE;
  
          $Token = {type => END_TAG_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<tag_name>} = $1;
  $Token->{q<tag_name>} .= $2;
  $State = B_ATTR_NAME_STATE;
  } elsif ($Input =~ /\G\!(\-)\-([^\ \\-\<\>])([^\ \\-\<]*)\-(\<)(\<*)(\!)\-\-\>/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[4] - 1];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G\!(\-)\-(\<)(\<*)(\!)\-([^\ \\-\<])([^\ \\-\<]*)\-\-\!\-/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[5] - 1];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + (pos $Input) - (length $1) - 3];
  $State = COMMENT_END_DASH_STATE;
  } elsif ($Input =~ /\G\!(\-)\-\-([^\ \\-\<\>])([^\ \\-\<]*)(\<)(\<*)(\!)\-\-\>/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G\!(\-)\-\-(\<)(\<*)(\!)([^\ \\-\<])([^\ \\-\<]*)\-\-\!\-/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + (pos $Input) - (length $1) - 3];
  $State = COMMENT_END_DASH_STATE;
  } elsif ($Input =~ /\G\!(\-)\-\-(\<)(\<*)(\!)\-([^\ \\-\<])([^\ \\-\<]*)\-\-\>/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[5] - 1];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G\!(\-)\-\-\-(\<)(\<*)(\!)\-([^\ \\-\<])([^\ \\-\<]*)\-\-/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[2] - 2];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[5] - 1];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_STATE;
  } elsif ($Input =~ /\G\!(\-)\-\-\-\!(\<)(\<*)(\!)([^\ \\-\<])([^\ \\-\<]*)\-\-/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[2] - 3];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_STATE;
  } elsif ($Input =~ /\G\!(\-)\-\-\-\!\-(\<)(\<*)(\!)([^\ \\-\<])([^\ \\-\<]*)\-/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + (pos $Input) - (length $1) - 3];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_DASH_STATE;
  } elsif ($Input =~ /\G([A-Z])([^\ \	\
  \\\ \/\>A-Z]*)[\	\
  \\\ ][\	\
  \\\ ]*/gcs) {
  
          $Token = {type => START_TAG_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $State = TAG_NAME_STATE;
  $Token->{q<tag_name>} = chr ((ord $1) + 32);
  $Token->{q<tag_name>} .= $2;
  $State = B_ATTR_NAME_STATE;
  } elsif ($Input =~ /\G([a-z])([^\ \	\
  \\\ \/\>A-Z]*)[\	\
  \\\ ][\	\
  \\\ ]*/gcs) {
  
          $Token = {type => START_TAG_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<tag_name>} = $1;
  $Token->{q<tag_name>} .= $2;
  $State = B_ATTR_NAME_STATE;
  } elsif ($Input =~ /\G\!(\-)\-([^\ \\-\<\>])([^\ \\-\<]*)(\<)(\<*)\-(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[6] - 1];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  } elsif ($Input =~ /\G\!(\-)\-(\<)(\<*)([^\ \\!\-\<])([^\ \\-\<]*)\-(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[6] - 1];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  } elsif ($Input =~ /\G\!(\-)\-(\<)(\<*)(\!)([^\ \\-\<])([^\ \\-\<]*)(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$8, $DI, $Offset + $-[8]];
  } elsif ($Input =~ /\G\!(\-)\-\-(\<)(\<*)([^\ \\!\-\<])([^\ \\-\<]*)(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  } elsif ($Input =~ /\G\!(\-)\-\-(\<)(\<*)\-([^\ \\-\<])([^\ \\-\<]*)(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[4] - 1];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  } elsif ($Input =~ /\G\!(\-)\-([^\ \\-\<\>])([^\ \\-\<]*)(\<)(\<*)(\!)\-\-\>/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G\!(\-)\-(\<)(\<*)(\!)([^\ \\-\<])([^\ \\-\<]*)\-\-\!\-/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + (pos $Input) - (length $1) - 3];
  $State = COMMENT_END_DASH_STATE;
  } elsif ($Input =~ /\G\!(\-)\-(\<)(\<*)(\!)\-([^\ \\-\<])([^\ \\-\<]*)\-\-\>/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[5] - 1];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G\!(\-)\-\-([^\ \\-\<\>])([^\ \\-\<]*)(\<)(\<*)\-\-\!\-/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + (pos $Input) - (length $1) - 3];
  $State = COMMENT_END_DASH_STATE;
  } elsif ($Input =~ /\G\!(\-)\-\-([^\ \\-\<\>])([^\ \\-\<]*)\-\-\!(\<)(\<*)\-/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[4] - 3];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_END_DASH_STATE;
  } elsif ($Input =~ /\G\!(\-)\-\-(\<)(\<*)([^\ \\!\-\<])([^\ \\-\<]*)\-\-\!\-/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + (pos $Input) - (length $1) - 3];
  $State = COMMENT_END_DASH_STATE;
  } elsif ($Input =~ /\G\!(\-)\-\-(\<)(\<*)(\!)([^\ \\-\<])([^\ \\-\<]*)\-\-\>/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G\!(\-)\-\-(\<)(\<*)\-\-([^\ \\!\-\<\>])([^\ \\-\<]*)\-/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[4] - 2];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_END_DASH_STATE;
  } elsif ($Input =~ /\G\!(\-)\-\-(\<)(\<*)\-\-\!([^\ \\-\<\>])([^\ \\-\<]*)\-/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[4] - 3];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_END_DASH_STATE;
  } elsif ($Input =~ /\G\!(\-)\-\-\-([^\ \\!\-\<\>])([^\ \\-\<]*)(\<)(\<*)\-\-/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[2] - 2];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_END_STATE;
  } elsif ($Input =~ /\G\!(\-)\-\-\-([^\ \\!\-\<\>])([^\ \\-\<]*)\-(\<)(\<*)\-/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[2] - 2];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[4] - 1];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_END_DASH_STATE;
  } elsif ($Input =~ /\G\!(\-)\-\-\-(\<)(\<*)(\!)([^\ \\-\<])([^\ \\-\<]*)\-\-/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[2] - 2];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_END_STATE;
  } elsif ($Input =~ /\G\!(\-)\-\-\-\!([^\ \\-\<\>])([^\ \\-\<]*)(\<)(\<*)\-\-/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[2] - 3];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_END_STATE;
  } elsif ($Input =~ /\G\!(\-)\-\-\-\!([^\ \\-\<\>])([^\ \\-\<]*)\-(\<)(\<*)\-/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[2] - 3];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[4] - 1];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_END_DASH_STATE;
  } elsif ($Input =~ /\G\!(\-)\-\-\-\!(\<)(\<*)([^\ \\!\-\<])([^\ \\-\<]*)\-\-/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[2] - 3];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_END_STATE;
  } elsif ($Input =~ /\G\!(\-)\-\-\-\!\-(\<)(\<*)([^\ \\!\-\<])([^\ \\-\<]*)\-/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + (pos $Input) - (length $1) - 3];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_END_DASH_STATE;
  } elsif ($Input =~ /\G\!(\-)\-(\<)(\<*)([^\ \\!\-\<])([^\ \\-\<]*)(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  } elsif ($Input =~ /\G\!(\-)\-(\<)(\<*)\-([^\ \\-\<])([^\ \\-\<]*)(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[4] - 1];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$7, $DI, $Offset + $-[7]];
  } elsif ($Input =~ /\G\!(\-)\-([^\ \\-\<\>])([^\ \\-\<]*)(\<)(\<*)\-\-\!\-/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + (pos $Input) - (length $1) - 3];
  $State = COMMENT_END_DASH_STATE;
  } elsif ($Input =~ /\G\!(\-)\-([^\ \\-\<\>])([^\ \\-\<]*)\-\-\!(\<)(\<*)\-/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[4] - 3];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_END_DASH_STATE;
  } elsif ($Input =~ /\G\!(\-)\-(\<)(\<*)([^\ \\!\-\<])([^\ \\-\<]*)\-\-\!\-/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + (pos $Input) - (length $1) - 3];
  $State = COMMENT_END_DASH_STATE;
  } elsif ($Input =~ /\G\!(\-)\-(\<)(\<*)(\!)([^\ \\-\<])([^\ \\-\<]*)\-\-\>/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G\!(\-)\-(\<)(\<*)\-\-([^\ \\!\-\<\>])([^\ \\-\<]*)\-/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[4] - 2];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_END_DASH_STATE;
  } elsif ($Input =~ /\G\!(\-)\-(\<)(\<*)\-\-\!([^\ \\-\<\>])([^\ \\-\<]*)\-/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[4] - 3];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_END_DASH_STATE;
  } elsif ($Input =~ /\G\!(\-)\-\-([^\ \\-\<\>])([^\ \\-\<]*)(\<)(\<*)\-\-\>/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G\!(\-)\-\-([^\ \\-\<\>])([^\ \\-\<]*)\-\-(\<)(\<*)\-/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[4] - 2];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_END_DASH_STATE;
  } elsif ($Input =~ /\G\!(\-)\-\-(\<)(\<*)([^\ \\!\-\<])([^\ \\-\<]*)\-\-\>/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G\!(\-)\-\-\-(\<)(\<*)([^\ \\!\-\<])([^\ \\-\<]*)\-\-/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[2] - 2];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_END_STATE;
  } elsif ($Input =~ /\G\!(\-)\-\-\-\!(\<)(\<*)\-([^\ \\-\<])([^\ \\-\<]*)\-/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[2] - 3];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[4] - 1];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_END_DASH_STATE;
  } elsif ($Input =~ /\G\!(\-)\-\-\-\!\-([^\ \\-\<])([^\ \\-\<]*)(\<)(\<*)\-/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + (pos $Input) - (length $1) - 3];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_END_DASH_STATE;
  } elsif ($Input =~ /\G\!(\-)\-([^\ \\-\<\>])([^\ \\-\<]*)(\<)(\<*)\-\-\>/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G\!(\-)\-([^\ \\-\<\>])([^\ \\-\<]*)\-\-(\<)(\<*)\-/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[4] - 2];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_END_DASH_STATE;
  } elsif ($Input =~ /\G\!(\-)\-(\<)(\<*)([^\ \\!\-\<])([^\ \\-\<]*)\-\-\>/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G\!(\-)\-\-([^\ \\-\<\>])([^\ \\-\<]*)\-(\<)(\<*)\-/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[4] - 1];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_END_DASH_STATE;
  } elsif ($Input =~ /\G\!(\-)\-\-\-(\<)(\<*)\-([^\ \\-\<])([^\ \\-\<]*)\-/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[2] - 2];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[4] - 1];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_END_DASH_STATE;
  } elsif ($Input =~ /\G\!(\-)\-([^\ \\-\<\>])([^\ \\-\<]*)\-(\<)(\<*)\-/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[4] - 1];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_END_DASH_STATE;
  } elsif ($Input =~ /\G\!(\-)\-\-(\<)(\<*)\-([^\ \\-\<])([^\ \\-\<]*)\-/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[4] - 1];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_END_DASH_STATE;
  } elsif ($Input =~ /\G\!(\-)\-(\<)(\<*)\-([^\ \\-\<])([^\ \\-\<]*)\-/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[4] - 1];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_END_DASH_STATE;
  } elsif ($Input =~ /\G\!(\-)\-\-([^\ \\-\<\>])([^\ \\-\<]*)\-\-\!\-/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + (pos $Input) - (length $1) - 3];
  $State = COMMENT_END_DASH_STATE;
  } elsif ($Input =~ /\G\!(\-)\-\-\-([^\ \\!\-\<\>])([^\ \\-\<]*)\-\-/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[2] - 2];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_STATE;
  } elsif ($Input =~ /\G\!(\-)\-\-\-\!([^\ \\-\<\>])([^\ \\-\<]*)\-\-/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[2] - 3];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_STATE;
  } elsif ($Input =~ /\G\!(\-)\-([^\ \\-\<\>])([^\ \\-\<]*)\-\-\!\-/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + (pos $Input) - (length $1) - 3];
  $State = COMMENT_END_DASH_STATE;
  } elsif ($Input =~ /\G\!(\-)\-\-([^\ \\-\<\>])([^\ \\-\<]*)\-\-\>/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G\!(\-)\-\-\-\!\-([^\ \\-\<])([^\ \\-\<]*)\-/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + (pos $Input) - (length $1) - 3];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_DASH_STATE;
  } elsif ($Input =~ /\G\!(\-)\-([^\ \\-\<\>])([^\ \\-\<]*)\-\-\>/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G\!(\-)\-\-\-\!\-(\<)(\<*)(\!)\-(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + (pos $Input) - (length $1) - 3];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[5] - 1];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  } elsif ($Input =~ /\G\!(\-)\-\-\-\!(\<)(\<*)(\!)\-(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[2] - 3];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[5] - 1];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  } elsif ($Input =~ /\G\!(\-)\-\-\-\!\-(\<)(\<*)(\!)(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + (pos $Input) - (length $1) - 3];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  } elsif ($Input =~ /\G\/([A-Z])([^\ \	\
  \\\ \/\>A-Z]*)\/\>/gcs) {
  $State = END_TAG_OPEN_STATE;
  
          $Token = {type => END_TAG_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $State = TAG_NAME_STATE;
  $Token->{q<tag_name>} = chr ((ord $1) + 32);
  $Token->{q<tag_name>} .= $2;
  $State = SELF_CLOSING_START_TAG_STATE;
  $Token->{q<self_closing_flag>} = 1;
  $State = DATA_STATE;
  
            if ($Token->{type} == END_TAG_TOKEN) {
              if (keys %{$Token->{attrs} or {}}) {
                push @$Errors, {type => 'end tag attribute',
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
              if ($Token->{self_closing_flag}) {
                push @$Errors, {type => 'nestc',
                                text => $Token->{tag_name},
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
            }
          
  push @$Tokens, $Token;
  
            if ($Token->{type} == START_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              if (not defined $LastStartTagName) { # "first start tag"
                $LastStartTagName = $Token->{tag_name};
                return 1;
              } else {
                $LastStartTagName = $Token->{tag_name};
              }
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
              return 1 if $Token->{tag_name} =~ /-/;
              return 1 if $Token->{attrs}->{is};
            }
          
  
            if ($Token->{type} == END_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              ## 
            }
          
  } elsif ($Input =~ /\G\/([a-z])([^\ \	\
  \\\ \/\>A-Z]*)\/\>/gcs) {
  $State = END_TAG_OPEN_STATE;
  
          $Token = {type => END_TAG_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<tag_name>} = $1;
  $Token->{q<tag_name>} .= $2;
  $State = SELF_CLOSING_START_TAG_STATE;
  $Token->{q<self_closing_flag>} = 1;
  $State = DATA_STATE;
  
            if ($Token->{type} == END_TAG_TOKEN) {
              if (keys %{$Token->{attrs} or {}}) {
                push @$Errors, {type => 'end tag attribute',
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
              if ($Token->{self_closing_flag}) {
                push @$Errors, {type => 'nestc',
                                text => $Token->{tag_name},
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
            }
          
  push @$Tokens, $Token;
  
            if ($Token->{type} == START_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              if (not defined $LastStartTagName) { # "first start tag"
                $LastStartTagName = $Token->{tag_name};
                return 1;
              } else {
                $LastStartTagName = $Token->{tag_name};
              }
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
              return 1 if $Token->{tag_name} =~ /-/;
              return 1 if $Token->{attrs}->{is};
            }
          
  
            if ($Token->{type} == END_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              ## 
            }
          
  } elsif ($Input =~ /\G([A-Z])([^\ \	\
  \\\ \/\>A-Z]*)\/\>/gcs) {
  
          $Token = {type => START_TAG_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $State = TAG_NAME_STATE;
  $Token->{q<tag_name>} = chr ((ord $1) + 32);
  $Token->{q<tag_name>} .= $2;
  $State = SELF_CLOSING_START_TAG_STATE;
  $Token->{q<self_closing_flag>} = 1;
  $State = DATA_STATE;
  
            if ($Token->{type} == END_TAG_TOKEN) {
              if (keys %{$Token->{attrs} or {}}) {
                push @$Errors, {type => 'end tag attribute',
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
              if ($Token->{self_closing_flag}) {
                push @$Errors, {type => 'nestc',
                                text => $Token->{tag_name},
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
            }
          
  push @$Tokens, $Token;
  
            if ($Token->{type} == START_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              if (not defined $LastStartTagName) { # "first start tag"
                $LastStartTagName = $Token->{tag_name};
                return 1;
              } else {
                $LastStartTagName = $Token->{tag_name};
              }
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
              return 1 if $Token->{tag_name} =~ /-/;
              return 1 if $Token->{attrs}->{is};
            }
          
  
            if ($Token->{type} == END_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              ## 
            }
          
  } elsif ($Input =~ /\G([a-z])([^\ \	\
  \\\ \/\>A-Z]*)\/\>/gcs) {
  
          $Token = {type => START_TAG_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<tag_name>} = $1;
  $Token->{q<tag_name>} .= $2;
  $State = SELF_CLOSING_START_TAG_STATE;
  $Token->{q<self_closing_flag>} = 1;
  $State = DATA_STATE;
  
            if ($Token->{type} == END_TAG_TOKEN) {
              if (keys %{$Token->{attrs} or {}}) {
                push @$Errors, {type => 'end tag attribute',
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
              if ($Token->{self_closing_flag}) {
                push @$Errors, {type => 'nestc',
                                text => $Token->{tag_name},
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
            }
          
  push @$Tokens, $Token;
  
            if ($Token->{type} == START_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              if (not defined $LastStartTagName) { # "first start tag"
                $LastStartTagName = $Token->{tag_name};
                return 1;
              } else {
                $LastStartTagName = $Token->{tag_name};
              }
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
              return 1 if $Token->{tag_name} =~ /-/;
              return 1 if $Token->{attrs}->{is};
            }
          
  
            if ($Token->{type} == END_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              ## 
            }
          
  } elsif ($Input =~ /\G\!(\-)\-\-\-(\<)(\<*)(\!)\-(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[2] - 2];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[5] - 1];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  } elsif ($Input =~ /\G\!(\-)\-\-\-\!(\<)(\<*)(\!)(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[2] - 3];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  } elsif ($Input =~ /\G\/([A-Z])([^\ \	\
  \\\ \/\>A-Z]*)\>/gcs) {
  $State = END_TAG_OPEN_STATE;
  
          $Token = {type => END_TAG_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $State = TAG_NAME_STATE;
  $Token->{q<tag_name>} = chr ((ord $1) + 32);
  $Token->{q<tag_name>} .= $2;
  $State = DATA_STATE;
  
            if ($Token->{type} == END_TAG_TOKEN) {
              if (keys %{$Token->{attrs} or {}}) {
                push @$Errors, {type => 'end tag attribute',
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
              if ($Token->{self_closing_flag}) {
                push @$Errors, {type => 'nestc',
                                text => $Token->{tag_name},
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
            }
          
  push @$Tokens, $Token;
  
            if ($Token->{type} == START_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              if (not defined $LastStartTagName) { # "first start tag"
                $LastStartTagName = $Token->{tag_name};
                return 1;
              } else {
                $LastStartTagName = $Token->{tag_name};
              }
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
              return 1 if $Token->{tag_name} =~ /-/;
              return 1 if $Token->{attrs}->{is};
            }
          
  
            if ($Token->{type} == END_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              ## 
            }
          
  } elsif ($Input =~ /\G\/([a-z])([^\ \	\
  \\\ \/\>A-Z]*)\>/gcs) {
  $State = END_TAG_OPEN_STATE;
  
          $Token = {type => END_TAG_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<tag_name>} = $1;
  $Token->{q<tag_name>} .= $2;
  $State = DATA_STATE;
  
            if ($Token->{type} == END_TAG_TOKEN) {
              if (keys %{$Token->{attrs} or {}}) {
                push @$Errors, {type => 'end tag attribute',
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
              if ($Token->{self_closing_flag}) {
                push @$Errors, {type => 'nestc',
                                text => $Token->{tag_name},
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
            }
          
  push @$Tokens, $Token;
  
            if ($Token->{type} == START_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              if (not defined $LastStartTagName) { # "first start tag"
                $LastStartTagName = $Token->{tag_name};
                return 1;
              } else {
                $LastStartTagName = $Token->{tag_name};
              }
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
              return 1 if $Token->{tag_name} =~ /-/;
              return 1 if $Token->{attrs}->{is};
            }
          
  
            if ($Token->{type} == END_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              ## 
            }
          
  } elsif ($Input =~ /\G\!(\-)\-\-\-\!\-(\<)(\<*)(\!)\-\-\>/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + (pos $Input) - (length $1) - 3];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G([A-Z])([^\ \	\
  \\\ \/\>A-Z]*)\>/gcs) {
  
          $Token = {type => START_TAG_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $State = TAG_NAME_STATE;
  $Token->{q<tag_name>} = chr ((ord $1) + 32);
  $Token->{q<tag_name>} .= $2;
  $State = DATA_STATE;
  
            if ($Token->{type} == END_TAG_TOKEN) {
              if (keys %{$Token->{attrs} or {}}) {
                push @$Errors, {type => 'end tag attribute',
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
              if ($Token->{self_closing_flag}) {
                push @$Errors, {type => 'nestc',
                                text => $Token->{tag_name},
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
            }
          
  push @$Tokens, $Token;
  
            if ($Token->{type} == START_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              if (not defined $LastStartTagName) { # "first start tag"
                $LastStartTagName = $Token->{tag_name};
                return 1;
              } else {
                $LastStartTagName = $Token->{tag_name};
              }
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
              return 1 if $Token->{tag_name} =~ /-/;
              return 1 if $Token->{attrs}->{is};
            }
          
  
            if ($Token->{type} == END_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              ## 
            }
          
  } elsif ($Input =~ /\G([a-z])([^\ \	\
  \\\ \/\>A-Z]*)\>/gcs) {
  
          $Token = {type => START_TAG_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<tag_name>} = $1;
  $Token->{q<tag_name>} .= $2;
  $State = DATA_STATE;
  
            if ($Token->{type} == END_TAG_TOKEN) {
              if (keys %{$Token->{attrs} or {}}) {
                push @$Errors, {type => 'end tag attribute',
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
              if ($Token->{self_closing_flag}) {
                push @$Errors, {type => 'nestc',
                                text => $Token->{tag_name},
                                level => 'm',
                                di => $Token->{di},
                                index => $Token->{index}};
              }
            }
          
  push @$Tokens, $Token;
  
            if ($Token->{type} == START_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              if (not defined $LastStartTagName) { # "first start tag"
                $LastStartTagName = $Token->{tag_name};
                return 1;
              } else {
                $LastStartTagName = $Token->{tag_name};
              }
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              return 1 if $Token->{tag_name} eq 'meta' and not $Confident;
              return 1 if $Token->{tag_name} =~ /-/;
              return 1 if $Token->{attrs}->{is};
            }
          
  
            if ($Token->{type} == END_TAG_TOKEN) {
              ## <!Temma><HTML>
              undef $InForeign;
              ## </HTML></!Temma>
              $Token->{tn} = $TagName2Group->{$Token->{tag_name}} || 0;
              return 1 if $TokenizerAbortingTagNames->{$Token->{tag_name}};
              ## 
            }
          
  } elsif ($Input =~ /\G\!(\-)\-\-(\<)(\<*)(\!)\-(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[5] - 1];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  } elsif ($Input =~ /\G\!(\-)\-\-(\<)(\<*)\-\-\!(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[4] - 3];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  } elsif ($Input =~ /\G\!(\-)\-\-\-(\<)(\<*)(\!)(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[2] - 2];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  } elsif ($Input =~ /\G\!(\-)\-\-\-\!(\<)(\<*)\-(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[2] - 3];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[4] - 1];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  } elsif ($Input =~ /\G\!(\-)\-\-\-\!(\<)(\<*)(\!)\-\-\>/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[2] - 3];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G\!(\-)\-(\<)(\<*)(\!)\-(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[5] - 1];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  } elsif ($Input =~ /\G\!(\-)\-(\<)(\<*)\-\-\!(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[4] - 3];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  } elsif ($Input =~ /\G\!(\-)\-\-(\<)(\<*)(\!)(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  } elsif ($Input =~ /\G\!(\-)\-\-(\<)(\<*)\-\-(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[4] - 2];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  } elsif ($Input =~ /\G\!(\-)\-\-\-(\<)(\<*)\-(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[2] - 2];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[4] - 1];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  } elsif ($Input =~ /\G\!(\-)\-\-\-(\<)(\<*)(\!)\-\-\>/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[2] - 2];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G\!(\-)\-(\<)(\<*)(\!)(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$6, $DI, $Offset + $-[6]];
  } elsif ($Input =~ /\G\!(\-)\-(\<)(\<*)\-\-(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[4] - 2];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  } elsif ($Input =~ /\G\!(\-)\-\-(\<)(\<*)\-(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[4] - 1];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  } elsif ($Input =~ /\G\!(\-)\-\-(\<)(\<*)(\!)\-\-\>/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G\!(\-)\-(\<)(\<*)\-(\<)(\<*)/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[4] - 1];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  $State = COMMENT_LESS_THAN_SIGN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  push @{$Token->{q<data>}}, [$5, $DI, $Offset + $-[5]];
  } elsif ($Input =~ /\G\!(\-)\-(\<)(\<*)(\!)\-\-\>/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  push @{$Token->{q<data>}}, [$4, $DI, $Offset + $-[4]];
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G\!(\-)\-\-(\<)(\<*)\-\-\!\-/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + (pos $Input) - (length $1) - 3];
  $State = COMMENT_END_DASH_STATE;
  } elsif ($Input =~ /\G\!(\-)\-\-\-\!(\<)(\<*)\-\-/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + $-[2] - 3];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_STATE;
  } elsif ($Input =~ /\G\!(\-)\-\-\-\!\-(\<)(\<*)\-/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + (pos $Input) - (length $1) - 3];
  $State = COMMENT_END_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_DASH_STATE;
  } elsif ($Input =~ /\G\!(\-)\-(\<)(\<*)\-\-\!\-/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + (pos $Input) - (length $1) - 3];
  $State = COMMENT_END_DASH_STATE;
  } elsif ($Input =~ /\G\!(\-)\-\-(\<)(\<*)\-\-\>/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_START_DASH_STATE;
  push @{$Token->{q<data>}}, [q@-@, $DI, $Offset + $-[2] - 1];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G\!(\-)\-\-\-(\<)(\<*)\-\-/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_STATE;
  push @{$Token->{q<data>}}, [q@--@, $DI, $Offset + $-[2] - 2];
  push @{$Token->{q<data>}}, [$2, $DI, $Offset + $-[2]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = COMMENT_END_STATE;
  } elsif ($Input =~ /\G\!(\-)\-(\<)(\<*)\-\-\>/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [[$2, $DI, $Offset + $-[2]]];
  push @{$Token->{q<data>}}, [$3, $DI, $Offset + $-[3]];
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G\!(\-)\-\-\-\!\-\-/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = COMMENT_END_BANG_STATE;
  push @{$Token->{q<data>}}, [q@--!@, $DI, $Offset + (pos $Input) - (length $1) - 3];
  $State = COMMENT_END_STATE;
  } elsif ($Input =~ /\G\!(\-)\-\-\-\>/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  $Temp = $1;
  $TempIndex = $Offset + (pos $Input) - (length $1);
  $State = MDO_STATE__;
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $Token->{q<data>} = [['', $DI, $Offset + pos $Input]];
  $State = DATA_STATE;
  push @$Tokens, $Token;
  } elsif ($Input =~ /\G([\!])/gcs) {
  
          $Temp = '';
          $TempIndex = $Offset + (pos $Input);
        
  $State = MDO_STATE;
  } elsif ($Input =~ /\G([\/])/gcs) {
  $State = END_TAG_OPEN_STATE;
  } elsif ($Input =~ /\G([ABCDEFGHJKNQRVWZILMOPSTUXY])/gcs) {
  
          $Token = {type => START_TAG_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $State = TAG_NAME_STATE;
  $Token->{q<tag_name>} = chr ((ord $1) + 32);
  } elsif ($Input =~ /\G([afbcdeghjknqrvwzilmopstuxy])/gcs) {
  
          $Token = {type => START_TAG_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $State = TAG_NAME_STATE;
  $Token->{q<tag_name>} = $1;
  } elsif ($Input =~ /\G([\ ])/gcs) {
  
              push @$Errors, {type => 'bare stago', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@<@,
                            di => $DI, index => $AnchoredIndex};
          
  $State = DATA_STATE;
  
              push @$Errors, {type => 'NULL', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } elsif ($Input =~ /\G([\])/gcs) {
  
              push @$Errors, {type => 'bare stago', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@<@,
                            di => $DI, index => $AnchoredIndex};
          
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@
  @,
                            di => $DI, index => $Offset + (pos $Input) - (length $1) - 0};
          
  $State = DATA_STATE_CR;
  } elsif ($Input =~ /\G([\&])/gcs) {
  
              push @$Errors, {type => 'bare stago', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@<@,
                            di => $DI, index => $AnchoredIndex};
          
  $State = CHARREF_IN_DATA_STATE;
  } elsif ($Input =~ /\G([\<])/gcs) {
  
              push @$Errors, {type => 'bare stago', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@<@,
                            di => $DI, index => $AnchoredIndex};
          
  $State = TAG_OPEN_STATE;
  $AnchoredIndex = $Offset + (pos $Input) - 1;
  } elsif ($Input =~ /\G([\?])/gcs) {
  
              push @$Errors, {type => 'pio', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
          $Token = {type => COMMENT_TOKEN, tn => 0, 
                    di => $DI, index => $AnchoredIndex};
        
  $State = BOGUS_COMMENT_STATE;
  $Token->{q<data>} = [[$1, $DI, $Offset + (pos $Input) - length $1]];
  } elsif ($Input =~ /\G(.)/gcs) {
  
              push @$Errors, {type => 'bare stago', level => 'm',
                              di => $DI, index => $Offset + (pos $Input) - 1};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@<@,
                            di => $DI, index => $AnchoredIndex};
          
  $State = DATA_STATE;
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => $1,
                            di => $DI, index => $Offset + (pos $Input) - (length $1)};
          
  } else {
  if ($EOF) {
  
              push @$Errors, {type => 'parser:EOF', level => 'm',
                              di => $DI, index => $Offset + (pos $Input)};
            
  
            push @$Tokens, {type => TEXT_TOKEN, tn => 0,
                            value => q@<@,
                            di => $DI, index => $AnchoredIndex};
          
  
            push @$Tokens, {type => END_OF_FILE_TOKEN, tn => 0,
                            di => $DI,
                            index => $Offset + pos $Input};
          
  return 1;
  } else {
  return 1;
  }
  }
  return 0;
  };
  
      sub _tokenize ($) {
        TOKENIZER: while (1) {
          my $code = $StateActions->[$State]
              or die "Unknown state |$State|";
          &$code and last TOKENIZER;
        } # TOKENIZER
      } # _tokenize
    
      ## ------ Tree constructor ------
      
      sub _construct_tree ($$) {
        my $self = shift;
  
        for my $token (@$Tokens) {
          local $_ = $token;
          if ((not @$OE) or 
  ($OE->[-1]->{aet} & (HTML_NS_ELS)) or 
  (($OE->[-1]->{aet} & (M_MI_M_MN_M_MO_M_MS_M_MTE_ELS)) and 
  ($token->{type} == START_TAG_TOKEN and not ($token->{tn} == TAG_NAME_MALIGNMARK_MGLYPH))) or 
  (($OE->[-1]->{aet} & (M_MI_M_MN_M_MO_M_MS_M_MTE_ELS)) and 
  ($token->{type} == 6)) or 
  (($OE->[-1]->{aet} & (M_ANN_ELS)) and 
  ($token->{type} == START_TAG_TOKEN and $token->{tn} == TAG_NAME_SVG)) or 
  (($OE->[-1]->{aet} & (M_ANN_M_ANN_ELS | S_DES_S_FOR_S_TIT_ELS)) and 
  ($token->{type} == 5)) or 
  (($OE->[-1]->{aet} & (M_ANN_M_ANN_ELS | S_DES_S_FOR_S_TIT_ELS)) and 
  ($token->{type} == 6)) or 
  ($token->{type} == 4)) {
            &{$ProcessIM->[$IM]->[$token->{type}]->[$token->{tn}]};
          } else {
            &{$ProcessIM->[IN_FOREIGN_CONTENT_IM]->[$token->{type}]->[$token->{tn}]};
          }
        }
  
        ## Adjusted current node
        $InForeign = !!(
          @$OE and $OE->[-1]->{aet} & (MATHML_NS_ELS | SVG_NS_ELS)
        );
  
        $self->dom_tree ($OP);
        @$OP = ();
        @$Tokens = ();
      } # _construct_tree
    
      ## ------ DOM integration ------
      
  sub dom_tree ($$) {
    my ($self, $ops) = @_;
  
    my $doc = $self->{document};
    my $strict = $doc->strict_error_checking;
    $doc->strict_error_checking (0);
  
    my $nodes = $self->{nodes};
    for my $op (@$ops) {
      if ($op->[0] eq 'insert' or
          $op->[0] eq 'insert-foster' or
          $op->[0] eq 'create') {
        my $data = $op->[1];
        my $el = $doc->create_element_ns
            ($NSToURL->[$data->{ns}], [$data->{prefix}, $data->{local_name}]);
        $el->manakai_set_source_location (['', $data->{di}, $data->{index}]);
        ## Note that $data->{ns} can be 0.
        for my $attr (@{$data->{attr_list} or []}) {
          $el->manakai_set_attribute_indexed_string_ns
              (@{$attr->{name_args}} => $attr->{value}); # IndexedString
        }
        if ($data->{et} & (TEM_ELS)) {
          $nodes->[$data->{id}] = $el->content;
          $el->content->manakai_set_source_location
              (['', $data->{di}, $data->{index}]);
        } else {
          $nodes->[$data->{id}] = $el;
        }
        # XXX $data->{script_flags}
  
        if (defined $data->{form}) {
          my $form = $nodes->[$data->{form}];
          #warn "XXX set form owner of $el to $form if $nodes->[$op->[2]] and $form are in the same home subtree";
        }
  
        if ($op->[0] eq 'insert') {
          $nodes->[$op->[2]]->append_child ($el);
        } elsif ($op->[0] eq 'insert-foster') {
          my $next_sibling = $nodes->[$op->[2]];
          my $parent = $next_sibling->parent_node;
          if (defined $parent) {
            if ($parent->node_type == $parent->DOCUMENT_NODE) {
              #
            } else {
              $parent->insert_before ($el, $next_sibling);
            }
          } else {
            $nodes->[$op->[3]]->append_child ($el);
          }
        }
      } elsif ($op->[0] eq 'text') {
        $nodes->[$op->[2]]->manakai_append_indexed_string ($op->[1]); # IndexedString
      } elsif ($op->[0] eq 'text-foster') {
        my $next_sibling = $nodes->[$op->[2]];
        my $parent = $next_sibling->parent_node;
        if (defined $parent) {
          if ($parent->node_type == $parent->DOCUMENT_NODE) {
            #
          } else {
            my $prev_sibling = $next_sibling->previous_sibling;
            if (defined $prev_sibling and
                $prev_sibling->node_type == $prev_sibling->TEXT_NODE) {
              $prev_sibling->manakai_append_indexed_string ($op->[1]);
            } else {
              $prev_sibling = $doc->create_text_node ('');
              $prev_sibling->manakai_append_indexed_string ($op->[1]);
              $parent->insert_before ($prev_sibling, $next_sibling);
            }
          }
        } else {
          $nodes->[$op->[3]]->manakai_append_text ($op->[1]);
        }
  
      } elsif ($op->[0] eq 'append') {
        $nodes->[$op->[2]]->append_child ($nodes->[$op->[1]]);
      } elsif ($op->[0] eq 'append-by-list') {
        my @node = $op->[1]->to_list;
        if (@node and $node[0]->node_type == $node[0]->TEXT_NODE) {
          my $node = shift @node;
          $nodes->[$op->[2]]->manakai_append_indexed_string
              ($node->manakai_get_indexed_string);
        }
        $nodes->[$op->[2]]->append_child ($_) for @node;
      } elsif ($op->[0] eq 'append-foster') {
        my $next_sibling = $nodes->[$op->[2]];
        my $parent = $next_sibling->parent_node;
        if (defined $parent) {
          if ($parent->node_type == $parent->DOCUMENT_NODE) {
            #
          } else {
            $parent->insert_before ($nodes->[$op->[1]], $next_sibling);
          }
        } else {
          $nodes->[$op->[3]]->append_child ($nodes->[$op->[1]]);
        }
      } elsif ($op->[0] eq 'move-children') {
        my $new_parent = $nodes->[$op->[2]];
        # XXX mutation observer?
        for ($nodes->[$op->[1]]->child_nodes->to_list) {
          $new_parent->append_child ($_);
        }
  
      } elsif ($op->[0] eq 'comment') {
        my $comment = $doc->create_comment (join '', map { $_->[0] } @{$op->[1]->{data}}); # IndexedString
        $comment->manakai_set_source_location
            (['', $op->[1]->{di}, $op->[1]->{index}]);
        $nodes->[$op->[2]]->append_child ($comment);
      } elsif ($op->[0] eq 'pi') {
        my $pi = $doc->create_processing_instruction ($op->[1]->{target}, '');
        $pi->manakai_append_indexed_string ($op->[1]->{data});
        $pi->manakai_set_source_location
            (['', $op->[1]->{di}, $op->[1]->{index}]);
        if ($op->[2] == 1) { # DOCTYPE
          unless ($self->ignore_doctype_pis) {
            local $nodes->[$op->[2]]->owner_document->dom_config->{manakai_allow_doctype_children} = 1;
            $nodes->[$op->[2]]->append_child ($pi);
          }
        } else {
          $nodes->[$op->[2]]->append_child ($pi);
        }
      } elsif ($op->[0] eq 'doctype') {
        my $data = $op->[1];
        my $dt = $doc->implementation->create_document_type
            (defined $data->{name} ? $data->{name} : '',
             defined $data->{public_identifier} ? $data->{public_identifier} : '',
             defined $data->{system_identifier} ? $data->{system_identifier} : '');
        $dt->manakai_set_source_location (['', $data->{di}, $data->{index}]);
        $nodes->[1] = $dt;
        $nodes->[$op->[2]]->append_child ($dt);
  
      } elsif ($op->[0] eq 'set-if-missing') {
        my $el = $nodes->[$op->[2]];
        for my $attr (@{$op->[1]}) {
          $el->manakai_set_attribute_indexed_string_ns
              (@{$attr->{name_args}} => $attr->{value}) # IndexedString
              unless $el->has_attribute_ns ($attr->{name_args}->[0], $attr->{name_args}->[1]->[1]);
        }
  
      } elsif ($op->[0] eq 'change-the-encoding') {
        unless ($Confident) {
          my $changed = $self->_change_the_encoding ($op->[1], $op->[2]);
          push @$Callbacks, [$self->onrestartwithencoding, $changed]
              if defined $changed;
        }
        if ($op->[2]->{has_ref}) {
          push @$Errors, {type => 'charref in charset', level => 'm',
                          di => $op->[2]->{di}, index => $op->[2]->{index}};
        }
  
      } elsif ($op->[0] eq 'script') {
        # XXX insertion point setup
        push @$Callbacks, [$self->onscript, $nodes->[$op->[1]]];
      } elsif ($op->[0] eq 'ignore-script') {
        #warn "XXX set already started flag of $nodes->[$op->[1]]";
      } elsif ($op->[0] eq 'appcache') {
        if (defined $op->[1]) {
          my $value = join '', map { $_->[0] } @{$op->[1]->{value}}; # IndexedString
          push @$Callbacks, [$self->onappcacheselection, length $value ? $value : undef];
        } else {
          push @$Callbacks, [$self->onappcacheselection, undef];
        }
  
      } elsif ($op->[0] eq 'popped') {
        push @$Callbacks, [$self->onelementspopped, [map { $nodes->[$_->{id}] } grep { $_->{et} & (AUD_VID_ELS | OBJ_ELS | STY_ELS | TEX_ELS) } @{$op->[1]}]];
      } elsif ($op->[0] eq 'stop-parsing') {
        push @$Callbacks, [$self->onelementspopped, [map { $nodes->[$_->{id}] } grep { $_->{et} & (AUD_VID_ELS | OBJ_ELS | STY_ELS | TEX_ELS) } @$OE]];
        #@$OE = ();
  
        # XXX stop parsing
      } elsif ($op->[0] eq 'abort') {
        push @$Callbacks, [$self->onelementspopped, [map { $nodes->[$_->{id}] } grep { $_->{et} & (AUD_VID_ELS | OBJ_ELS | STY_ELS | TEX_ELS) } @$OE]];
        #@$OE = ();
  
        # XXX abort
  
      } elsif ($op->[0] eq 'remove') {
        my $parent = $nodes->[$op->[1]]->parent_node;
        $parent->remove_child ($nodes->[$op->[1]]) if defined $parent;
  
      } elsif ($op->[0] eq 'set-compat-mode') {
        $doc->manakai_compat_mode ($op->[1]);
  ## 
  
      } else {
        die "Unknown operation |$op->[0]|";
      }
    }
  
    $doc->strict_error_checking ($strict);
  } # dom_tree
  
      sub ignore_doctype_pis ($;$) {
        if (@_ > 1) {
          $_[0]->{ignore_doctype_pis} = $_[1];
        }
        return $_[0]->{ignore_doctype_pis};
      } # ignore_doctype_pis
  
    
      ## ------ API ------
      
      sub _run ($) {
        my ($self) = @_;
        return 1 if $self->{pause};
        my $is = $self->{input_stream};
        # XXX rewrite loop conditions
        my $length = @$is == 0 ? 0 : defined $is->[0]->[0] ? length $is->[0]->[0] : 0;
        my $in_offset = 0;
        {
          my $len = 10000;
          $len = $length - $in_offset if $in_offset + $len > $length;
          if ($len > 0) {
            $Input = substr $is->[0]->[0], $in_offset, $len;
          } elsif (@$is and not defined $is->[0]->[0]) {
            $Input = '';
            pos ($Input) = 0;
            $EOF = 1;
          } else {
            shift @$is;
            if (@$is) {
              if (defined $is->[0]->[0]) {
                $length = length $is->[0]->[0];
                $in_offset = 0;
                redo;
              } else {
                $Input = '';
                pos ($Input) = 0;
                $EOF = 1;
              }
            } else {
              last;
            }
          }
          {
            $self->_tokenize;
            $self->_construct_tree;
  
            if (@$Callbacks or @$Errors or $self->{is_sub_parser}) {
              $self->{saved_states} = {AnchoredIndex => $AnchoredIndex, Attr => $Attr, CONTEXT => $CONTEXT, Confident => $Confident, DI => $DI, EOF => $EOF, FORM_ELEMENT => $FORM_ELEMENT, FRAMESET_OK => $FRAMESET_OK, HEAD_ELEMENT => $HEAD_ELEMENT, IM => $IM, LastStartTagName => $LastStartTagName, NEXT_ID => $NEXT_ID, ORIGINAL_IM => $ORIGINAL_IM, Offset => $Offset, QUIRKS => $QUIRKS, State => $State, Temp => $Temp, TempIndex => $TempIndex, Token => $Token};
              {
                my $Errors = $Errors;
                my $Callbacks = $Callbacks;
  
                $self->onerrors->($self, $Errors) if @$Errors;
                @$Errors = ();
                while (@$Callbacks) {
                  my $cb = shift @$Callbacks;
                  $cb->[0]->($self, $cb->[1]);
                }
  
                if ($self->{restart}) {
                  delete $self->{restart};
                  return 0;
                }
  
                if ($self->{pause}) {
                  my $pos = pos $Input;
                  $is->[0] = [substr $is->[0]->[0], $in_offset + $pos]
                      if defined $is->[0]->[0];
                  $Offset += $pos;
                  $self->{saved_states}->{Offset} = $Offset;
                  return 1;
                }
              }
              ($AnchoredIndex, $Attr, $CONTEXT, $Confident, $DI, $EOF, $FORM_ELEMENT, $FRAMESET_OK, $HEAD_ELEMENT, $IM, $LastStartTagName, $NEXT_ID, $ORIGINAL_IM, $Offset, $QUIRKS, $State, $Temp, $TempIndex, $Token) = @{$self->{saved_states}}{qw(AnchoredIndex Attr CONTEXT Confident DI EOF FORM_ELEMENT FRAMESET_OK HEAD_ELEMENT IM LastStartTagName NEXT_ID ORIGINAL_IM Offset QUIRKS State Temp TempIndex Token)};
  ($AFE, $Callbacks, $Errors, $OE, $OP, $TABLE_CHARS, $TEMPLATE_IMS, $Tokens) = @{$self->{saved_lists}}{qw(AFE Callbacks Errors OE OP TABLE_CHARS TEMPLATE_IMS Tokens)};
  () = @{$self->{saved_maps}}{qw()};
            }
  
            redo unless pos $Input == length $Input; # XXX parser pause flag
          }
          $Offset += $len;
          $in_offset += $len;
          redo unless $EOF;
        }
        if ($EOF) {
  ## 
          $self->onparsed->($self);
          $self->_cleanup_states;
        }
        return 1;
      } # _run
    
  
      sub _feed_chars ($$) {
        my ($self, $input) = @_;
        for (@$input) {
          pos ($_) = 0;
          while (/[\x{0001}-\x{0008}\x{000B}\x{000E}-\x{001F}\x{007F}-\x{009F}\x{D800}-\x{DFFF}\x{FDD0}-\x{FDEF}\x{FFFE}-\x{FFFF}\x{1FFFE}-\x{1FFFF}\x{2FFFE}-\x{2FFFF}\x{3FFFE}-\x{3FFFF}\x{4FFFE}-\x{4FFFF}\x{5FFFE}-\x{5FFFF}\x{6FFFE}-\x{6FFFF}\x{7FFFE}-\x{7FFFF}\x{8FFFE}-\x{8FFFF}\x{9FFFE}-\x{9FFFF}\x{AFFFE}-\x{AFFFF}\x{BFFFE}-\x{BFFFF}\x{CFFFE}-\x{CFFFF}\x{DFFFE}-\x{DFFFF}\x{EFFFE}-\x{EFFFF}\x{FFFFE}-\x{FFFFF}\x{10FFFE}-\x{10FFFF}]/gc) {
            my $index = $-[0];
            my $char = ord substr $_, $index, 1;
            if ($char < 0x100) {
              push @$Errors, {type => 'control char', level => 'm',
                              text => (sprintf 'U+%04X', $char),
                              di => $DI,
                              index => $self->{input_stream_offset} + $index};
            } elsif ($char < 0xE000) {
              push @$Errors, {type => 'char:surrogate', level => 'm',
                              text => (sprintf 'U+%04X', $char),
                              di => $DI,
                              index => $self->{input_stream_offset} + $index};
            } else {
              push @$Errors, {type => 'nonchar', level => 'm',
                              text => (sprintf 'U+%04X', $char),
                              di => $DI,
                              index => $self->{input_stream_offset} + $index};
            }
          }
          push @{$self->{input_stream}}, [$_];
          $self->{input_stream_offset} += length $_;
        } # @$input
        return $self->_run;
      } # _feed_chars
    
  
      sub _feed_eof ($) {
        my $self = $_[0];
        push @{$self->{input_stream}}, [undef];
        return $self->_run;
      } # _feed_eof
    
  
      sub parse_char_string ($$$) {
        my $self = $_[0];
        my $input = [$_[1]]; # string copy
  
        $self->{document} = my $doc = $_[2];
        $self->{IframeSrcdoc} = $doc->manakai_is_srcdoc;
        ## <HTML>
        $doc->manakai_is_html (1);
        ## </HTML>
        ## 
        $doc->manakai_compat_mode ('no quirks');
        $doc->remove_child ($_) for $doc->child_nodes->to_list;
        $self->{nodes} = [$doc];
        local ($AFE, $AnchoredIndex, $Attr, $CONTEXT, $Callbacks, $Confident, $DI, $EOF, $Errors, $FORM_ELEMENT, $FRAMESET_OK, $HEAD_ELEMENT, $IM, $IframeSrcdoc, $InForeign, $Input, $LastStartTagName, $NEXT_ID, $OE, $OP, $ORIGINAL_IM, $Offset, $QUIRKS, $Scripting, $State, $TABLE_CHARS, $TEMPLATE_IMS, $Temp, $TempIndex, $Token, $Tokens);
        $FRAMESET_OK = 1;
  $AnchoredIndex = 0;
  $NEXT_ID = 1;
  $Offset = 0;
  $self->{saved_lists} = {AFE => ($AFE = []), Callbacks => ($Callbacks = []), Errors => ($Errors = []), OE => ($OE = []), OP => ($OP = []), TABLE_CHARS => ($TABLE_CHARS = []), TEMPLATE_IMS => ($TEMPLATE_IMS = []), Tokens => ($Tokens = [])};
  $self->{saved_maps} = {};
        $IframeSrcdoc = $self->{IframeSrcdoc};
  $Scripting = $self->{Scripting};
        $Confident = 1; # irrelevant
        $State = DATA_STATE;;
        ## <!Temma>
        $IM = INITIAL_IM;
        ## </!Temma>
  
        $self->{input_stream} = [];
        $self->{input_stream_offset} = 0;
        my $dids = $self->di_data_set;
        $self->{di} = $DI = defined $self->{di} ? $self->{di} : @$dids || 1;
        $dids->[$DI] ||= {} if $DI >= 0;
        ## 
        $doc->manakai_set_source_location (['', $DI, 0]);
  
        local $self->{onextentref};
        $self->_feed_chars ($input) or die "Can't restart";
        $self->_feed_eof or die "Can't restart";
  
        return;
      } # parse_char_string
    
  
      sub parse_char_string_with_context ($$$$) {
        my $self = $_[0];
        my $context = $_[2]; # an Element or undef
  
        ## HTML fragment parsing algorithm
        ## <http://www.whatwg.org/specs/web-apps/current-work/#parsing-html-fragments>.
  
        ## XML fragment parsing algorithm
        ## <http://www.whatwg.org/specs/web-apps/current-work/#parsing-xhtml-fragments>
  
        ## 1.
        $self->{document} = my $doc = $_[3]; # an empty Document
        $self->{IframeSrcdoc} = $doc->manakai_is_srcdoc;
        $doc->remove_child ($_) for $doc->child_nodes->to_list;
        my $nodes = $self->{nodes} = [$doc];
        ## <HTML>
        $doc->manakai_is_html (1);
  
        ## HTML 2.
        if (defined $context) {
          $doc->manakai_compat_mode ($context->owner_document->manakai_compat_mode);
        } else {
          ## Not in spec
          $doc->manakai_compat_mode ('no quirks');
        }
        ## </HTML>
  
        local ($AFE, $AnchoredIndex, $Attr, $CONTEXT, $Callbacks, $Confident, $DI, $EOF, $Errors, $FORM_ELEMENT, $FRAMESET_OK, $HEAD_ELEMENT, $IM, $IframeSrcdoc, $InForeign, $Input, $LastStartTagName, $NEXT_ID, $OE, $OP, $ORIGINAL_IM, $Offset, $QUIRKS, $Scripting, $State, $TABLE_CHARS, $TEMPLATE_IMS, $Temp, $TempIndex, $Token, $Tokens);
        $FRAMESET_OK = 1;
  $AnchoredIndex = 0;
  $NEXT_ID = 1;
  $Offset = 0;
  $self->{saved_lists} = {AFE => ($AFE = []), Callbacks => ($Callbacks = []), Errors => ($Errors = []), OE => ($OE = []), OP => ($OP = []), TABLE_CHARS => ($TABLE_CHARS = []), TEMPLATE_IMS => ($TEMPLATE_IMS = []), Tokens => ($Tokens = [])};
  $self->{saved_maps} = {};
        $IframeSrcdoc = $self->{IframeSrcdoc};
  $Scripting = $self->{Scripting};
        $State = DATA_STATE;;
  
        ## 3.
        my $input = [$_[1]]; # string copy
        $self->{input_stream} = [];
        $self->{input_stream_offset} = 0;
        my $dids = $self->di_data_set;
        $self->{di} = $DI = defined $self->{di} ? $self->{di} : @$dids || 1;
        $dids->[$DI] ||= {} if $DI >= 0;
        ## 
  
        ## HTML 4. / XML 3. (cnt.)
        my $root;
        if (defined $context) {
          $IM = INITIAL_IM;
  
          ## HTML 4.1. / XML 2., 4., 6.
          my $node_ns = $context->namespace_uri || '';
          my $node_ln = $context->local_name;
          if ($node_ns eq 'http://www.w3.org/1999/xhtml') {
            ## <HTML>
            if ($Scripting and $node_ln eq 'noscript') {
              $State = RAWTEXT_STATE;;
            } else {
              $State = $StateByElementName->{$node_ln} || $State;
            }
            ## </HTML>
            $CONTEXT = {id => $NEXT_ID++,
                        #token => undef,
                        #di => $token->{di}, index => $token->{index},
                        ns => HTMLNS,
                        local_name => $node_ln,
                        attr_list => [], # not relevant
                        et => $Element2Type->[HTMLNS]->{$node_ln} || $Element2Type->[HTMLNS]->{'*'},
                        aet => $Element2Type->[HTMLNS]->{$node_ln} || $Element2Type->[HTMLNS]->{'*'}};
          ## <HTML>
          } elsif ($node_ns eq 'http://www.w3.org/2000/svg') {
            $CONTEXT = {id => $NEXT_ID++,
                        #token => undef,
                        #di => $token->{di}, index => $token->{index},
                        ns => SVGNS,
                        local_name => $node_ln,
                        attr_list => [], # not relevant
                        et => $Element2Type->[SVGNS]->{$node_ln} || $Element2Type->[SVGNS]->{'*'},
                        aet => $Element2Type->[SVGNS]->{$node_ln} || $Element2Type->[SVGNS]->{'*'}};
          } elsif ($node_ns eq 'http://www.w3.org/1998/Math/MathML') {
            $CONTEXT = {id => $NEXT_ID++,
                        #token => undef,
                        #di => $token->{di}, index => $token->{index},
                        ns => MATHMLNS,
                        local_name => $node_ln,
                        attr_list => [], # not relevant
                        et => $Element2Type->[MATHMLNS]->{$node_ln} || $Element2Type->[MATHMLNS]->{'*'},
                        aet => $Element2Type->[MATHMLNS]->{$node_ln} || $Element2Type->[MATHMLNS]->{'*'}};
            if ($node_ln eq 'annotation-xml') {
              my $encoding = $context->get_attribute_ns (undef, 'encoding');
              if (defined $encoding) {
                $encoding =~ tr/A-Z/a-z/; ## ASCII case-insensitive.
                if ($encoding eq 'text/html' or
                    $encoding eq 'application/xhtml+xml') {
                  $CONTEXT->{et} |= M_ANN_M_ANN_ELS;
                  $CONTEXT->{aet} |= M_ANN_M_ANN_ELS;
                }
              }
            }
          ## </HTML>
          } else {
            $CONTEXT = {id => $NEXT_ID++,
                        #token => undef,
                        #di => $token->{di}, index => $token->{index},
                        ns => 0,
                        local_name => $node_ln,
                        attr_list => [], # not relevant
                        et => 0,
                        aet => 0};
          }
          ## 
          $nodes->[$CONTEXT->{id}] = $context;
  
          ## <HTML>
          ## HTML 4.2.
          $root = $doc->create_element ('html');
          ## </HTML>
          ## 
  
          ## HTML 4.3.
          $doc->append_child ($root);
  
          ## <HTML>
          ## HTML 4.4.
          @$OE = ({id => $NEXT_ID++,
                   #token => undef,
                   #di => $token->{di}, index => $token->{index},
                   ns => HTMLNS,
                   local_name => 'html',
                   attr_list => [],
                   et => $Element2Type->[HTMLNS]->{html},
                   aet => $CONTEXT->{aet}});
          ## </HTML>
          ## 
  
          ## HTML 4.5.
          if ($node_ns eq 'http://www.w3.org/1999/xhtml' and
              $node_ln eq 'template') {
            ## <HTML>
            push @$TEMPLATE_IMS, IN_TEMPLATE_IM;
            ## </HTML>
            ## 
          }
          $nodes->[$OE->[-1]->{id}] = $root;
  
          ## <HTML>
          ## HTML 4.6.
          &reset_im;
  
          ## HTML 4.7.
          my $anode = $context;
          while (defined $anode) {
            if ($anode->node_type == 1 and
                ($anode->namespace_uri || '') eq 'http://www.w3.org/1999/xhtml' and
                $anode->local_name eq 'form') {
              if ($anode eq $context) {
                $FORM_ELEMENT = $CONTEXT;
              } else {
                $FORM_ELEMENT = {id => $NEXT_ID++,
                                 #token => undef,
                                 #di => $token->{di}, index => $token->{index},
                                 ns => HTMLNS,
                                 local_name => 'form',
                                 attr_list => [], # not relevant
                                 et => $Element2Type->[HTMLNS]->{form},
                                 aet => $Element2Type->[HTMLNS]->{form}};
              }
              last;
            }
            $anode = $anode->parent_node;
          }
          ## </HTML>
        } else { # $context
          $IM = INITIAL_IM;
        } # $context
  
        ## HTML 5.
        $Confident = 1; # irrelevant
  
        ## HTML 6. / XML 3. (cnt.)
        local $self->{onextentref};
        $self->_feed_chars ($input) or die "Can't restart";
        $self->_feed_eof or die "Can't restart";
  
        ## XML 5. If not well-formed, throw SyntaxError - should be
        ## handled by callee using $self->onerror.
  
        ## 7.
        return defined $context ? $root->child_nodes : $doc->child_nodes;
      } # parse_char_string_with_context
    
  
      sub parse_chars_start ($$) {
        my ($self, $doc) = @_;
  
        $self->{input_stream} = [];
        $self->{input_stream_offset} = 0;
        $self->{document} = $doc;
        $self->{IframeSrcdoc} = $doc->manakai_is_srcdoc;
        $doc->manakai_is_html (1);
        $doc->manakai_compat_mode ('no quirks');
        $doc->remove_child ($_) for $doc->child_nodes->to_list;
        $self->{nodes} = [$doc];
  
        local ($AFE, $AnchoredIndex, $Attr, $CONTEXT, $Callbacks, $Confident, $DI, $EOF, $Errors, $FORM_ELEMENT, $FRAMESET_OK, $HEAD_ELEMENT, $IM, $IframeSrcdoc, $InForeign, $Input, $LastStartTagName, $NEXT_ID, $OE, $OP, $ORIGINAL_IM, $Offset, $QUIRKS, $Scripting, $State, $TABLE_CHARS, $TEMPLATE_IMS, $Temp, $TempIndex, $Token, $Tokens);
        $FRAMESET_OK = 1;
  $AnchoredIndex = 0;
  $NEXT_ID = 1;
  $Offset = 0;
  $self->{saved_lists} = {AFE => ($AFE = []), Callbacks => ($Callbacks = []), Errors => ($Errors = []), OE => ($OE = []), OP => ($OP = []), TABLE_CHARS => ($TABLE_CHARS = []), TEMPLATE_IMS => ($TEMPLATE_IMS = []), Tokens => ($Tokens = [])};
  $self->{saved_maps} = {};
        $IframeSrcdoc = $self->{IframeSrcdoc};
  $Scripting = $self->{Scripting};
        $Confident = 1; # irrelevant
        $State = DATA_STATE;;
        $IM = INITIAL_IM;
  
        my $dids = $self->di_data_set;
        $DI = @$dids || 1;
        $self->{di} = my $source_di = defined $self->{di} ? $self->{di} : $DI+1;
        $dids->[$source_di] ||= {} if $source_di >= 0; # the main data source of the input stream
        $dids->[$DI]->{map} = [[0, $source_di, 0]]; # the input stream
        $doc->manakai_set_source_location (['', $DI, 0]);
        ## Note that $DI != $source_di to support document.write()'s
        ## insertion.
        ## 
  
        $self->{saved_states} = {AnchoredIndex => $AnchoredIndex, Attr => $Attr, CONTEXT => $CONTEXT, Confident => $Confident, DI => $DI, EOF => $EOF, FORM_ELEMENT => $FORM_ELEMENT, FRAMESET_OK => $FRAMESET_OK, HEAD_ELEMENT => $HEAD_ELEMENT, IM => $IM, LastStartTagName => $LastStartTagName, NEXT_ID => $NEXT_ID, ORIGINAL_IM => $ORIGINAL_IM, Offset => $Offset, QUIRKS => $QUIRKS, State => $State, Temp => $Temp, TempIndex => $TempIndex, Token => $Token};
        return;
      } # parse_chars_start
    
  
      sub parse_chars_feed ($$) {
        my $self = $_[0];
        my $input = [$_[1]]; # string copy
  
        local ($AFE, $AnchoredIndex, $Attr, $CONTEXT, $Callbacks, $Confident, $DI, $EOF, $Errors, $FORM_ELEMENT, $FRAMESET_OK, $HEAD_ELEMENT, $IM, $IframeSrcdoc, $InForeign, $Input, $LastStartTagName, $NEXT_ID, $OE, $OP, $ORIGINAL_IM, $Offset, $QUIRKS, $Scripting, $State, $TABLE_CHARS, $TEMPLATE_IMS, $Temp, $TempIndex, $Token, $Tokens);
        $IframeSrcdoc = $self->{IframeSrcdoc};
  $Scripting = $self->{Scripting};
        ($AnchoredIndex, $Attr, $CONTEXT, $Confident, $DI, $EOF, $FORM_ELEMENT, $FRAMESET_OK, $HEAD_ELEMENT, $IM, $LastStartTagName, $NEXT_ID, $ORIGINAL_IM, $Offset, $QUIRKS, $State, $Temp, $TempIndex, $Token) = @{$self->{saved_states}}{qw(AnchoredIndex Attr CONTEXT Confident DI EOF FORM_ELEMENT FRAMESET_OK HEAD_ELEMENT IM LastStartTagName NEXT_ID ORIGINAL_IM Offset QUIRKS State Temp TempIndex Token)};
  ($AFE, $Callbacks, $Errors, $OE, $OP, $TABLE_CHARS, $TEMPLATE_IMS, $Tokens) = @{$self->{saved_lists}}{qw(AFE Callbacks Errors OE OP TABLE_CHARS TEMPLATE_IMS Tokens)};
  () = @{$self->{saved_maps}}{qw()};
  
        $self->_feed_chars ($input) or die "Can't restart";
  
        $self->{saved_states} = {AnchoredIndex => $AnchoredIndex, Attr => $Attr, CONTEXT => $CONTEXT, Confident => $Confident, DI => $DI, EOF => $EOF, FORM_ELEMENT => $FORM_ELEMENT, FRAMESET_OK => $FRAMESET_OK, HEAD_ELEMENT => $HEAD_ELEMENT, IM => $IM, LastStartTagName => $LastStartTagName, NEXT_ID => $NEXT_ID, ORIGINAL_IM => $ORIGINAL_IM, Offset => $Offset, QUIRKS => $QUIRKS, State => $State, Temp => $Temp, TempIndex => $TempIndex, Token => $Token};
        return;
      } # parse_chars_feed
  
      sub parse_chars_end ($) {
        my $self = $_[0];
        local ($AFE, $AnchoredIndex, $Attr, $CONTEXT, $Callbacks, $Confident, $DI, $EOF, $Errors, $FORM_ELEMENT, $FRAMESET_OK, $HEAD_ELEMENT, $IM, $IframeSrcdoc, $InForeign, $Input, $LastStartTagName, $NEXT_ID, $OE, $OP, $ORIGINAL_IM, $Offset, $QUIRKS, $Scripting, $State, $TABLE_CHARS, $TEMPLATE_IMS, $Temp, $TempIndex, $Token, $Tokens);
        $IframeSrcdoc = $self->{IframeSrcdoc};
  $Scripting = $self->{Scripting};
        ($AnchoredIndex, $Attr, $CONTEXT, $Confident, $DI, $EOF, $FORM_ELEMENT, $FRAMESET_OK, $HEAD_ELEMENT, $IM, $LastStartTagName, $NEXT_ID, $ORIGINAL_IM, $Offset, $QUIRKS, $State, $Temp, $TempIndex, $Token) = @{$self->{saved_states}}{qw(AnchoredIndex Attr CONTEXT Confident DI EOF FORM_ELEMENT FRAMESET_OK HEAD_ELEMENT IM LastStartTagName NEXT_ID ORIGINAL_IM Offset QUIRKS State Temp TempIndex Token)};
  ($AFE, $Callbacks, $Errors, $OE, $OP, $TABLE_CHARS, $TEMPLATE_IMS, $Tokens) = @{$self->{saved_lists}}{qw(AFE Callbacks Errors OE OP TABLE_CHARS TEMPLATE_IMS Tokens)};
  () = @{$self->{saved_maps}}{qw()};
  
        $self->_feed_eof or die "Can't restart";
        
        return;
      } # parse_chars_end
  
    
  
      sub parse_byte_string ($$$$) {
        my $self = $_[0];
  
        $self->{document} = my $doc = $_[3];
        $self->{IframeSrcdoc} = $doc->manakai_is_srcdoc;
        $doc->manakai_is_html (1);
        $doc->manakai_compat_mode ('no quirks');
        $self->{can_restart} = 1;
  
        PARSER: {
          $self->{input_stream} = [];
          $self->{input_stream_offset} = 0;
          $self->{nodes} = [$doc];
          $doc->remove_child ($_) for $doc->child_nodes->to_list;
  
          local ($AFE, $AnchoredIndex, $Attr, $CONTEXT, $Callbacks, $Confident, $DI, $EOF, $Errors, $FORM_ELEMENT, $FRAMESET_OK, $HEAD_ELEMENT, $IM, $IframeSrcdoc, $InForeign, $Input, $LastStartTagName, $NEXT_ID, $OE, $OP, $ORIGINAL_IM, $Offset, $QUIRKS, $Scripting, $State, $TABLE_CHARS, $TEMPLATE_IMS, $Temp, $TempIndex, $Token, $Tokens);
          $FRAMESET_OK = 1;
  $AnchoredIndex = 0;
  $NEXT_ID = 1;
  $Offset = 0;
  $self->{saved_lists} = {AFE => ($AFE = []), Callbacks => ($Callbacks = []), Errors => ($Errors = []), OE => ($OE = []), OP => ($OP = []), TABLE_CHARS => ($TABLE_CHARS = []), TEMPLATE_IMS => ($TEMPLATE_IMS = []), Tokens => ($Tokens = [])};
  $self->{saved_maps} = {};
          $IframeSrcdoc = $self->{IframeSrcdoc};
  $Scripting = $self->{Scripting};
  
          my $inputref = \($_[2]);
          $self->_encoding_sniffing
              (transport_encoding_name => $_[1],
               read_head => sub {
            return \substr $$inputref, 0, 1024;
          }); # $Confident is set within this method.
          $doc->input_encoding ($self->{input_encoding});
  
          my $input = [decode_web_charset $self->{input_encoding}, $$inputref];
          my $dids = $self->di_data_set;
          $self->{di} = $DI = defined $self->{di} ? $self->{di} : @$dids || 1;
          $dids->[$DI] ||= {} if $DI >= 0;
          $doc->manakai_set_source_location (['', $DI, 0]);
          ## 
  
          $State = DATA_STATE;;
          $IM = INITIAL_IM;
  
          local $self->{onextentref};
          $self->_feed_chars ($input) or redo PARSER;
          $self->_feed_eof or redo PARSER;
        } # PARSER
  
        return;
      } # parse_byte_string
    
  
      sub _parse_bytes_init ($) {
        my $self = $_[0];
  
        my $doc = $self->{document};
        $self->{IframeSrcdoc} = $doc->manakai_is_srcdoc;
        $doc->remove_child ($_) for $doc->child_nodes->to_list;
        $self->{nodes} = [$doc];
  
        delete $self->{parse_bytes_started};
        $self->{input_stream} = [];
        $self->{input_stream_offset} = 0;
        $FRAMESET_OK = 1;
  $AnchoredIndex = 0;
  $NEXT_ID = 1;
  $Offset = 0;
  $self->{saved_lists} = {AFE => ($AFE = []), Callbacks => ($Callbacks = []), Errors => ($Errors = []), OE => ($OE = []), OP => ($OP = []), TABLE_CHARS => ($TABLE_CHARS = []), TEMPLATE_IMS => ($TEMPLATE_IMS = []), Tokens => ($Tokens = [])};
  $self->{saved_maps} = {};
        $IframeSrcdoc = $self->{IframeSrcdoc};
  $Scripting = $self->{Scripting};
        $State = DATA_STATE;;
        $IM = INITIAL_IM;
  
        my $dids = $self->di_data_set;
        $DI = @$dids || 1;
        $self->{di} = my $source_di = defined $self->{di} ? $self->{di} : $DI+1;
        $dids->[$DI]->{map} = [[0, $source_di, 0]]; # the input stream
        $dids->[$source_di] ||= {} if $source_di >= 0; # the main data source of the input stream
        $doc->manakai_set_source_location (['', $DI, 0]);
        ## Note that $DI != $source_di to support document.write()'s
        ## insertion.
        ## 
      } # _parse_bytes_init
    
  
      sub _parse_bytes_start_parsing ($;%) {
        my ($self, %args) = @_;
        
        $self->_encoding_sniffing
            (transport_encoding_name => $self->{transport_encoding_label},
             no_body_data_yet => $args{no_body_data_yet},
             read_head => sub {
               return \(substr $self->{byte_buffer}, 0, 1024);
             }); # $Confident is set within this method.
        if (not defined $self->{input_encoding} and $args{no_body_data_yet}) {
          return 1;
        }
        $self->{document}->input_encoding ($self->{input_encoding});
  
        $self->{parse_bytes_started} = 1;
  
        $self->{decoder} = Web::Encoding::Decoder->new_from_encoding_key
            ($self->{input_encoding});
        $self->{decoder}->ignore_bom (1);
        $self->{decoder}->onerror (sub {
          $self->onerrors->($self, [{@_, di => $self->{di}}]);
        });
        my $input = $self->{decoder}->bytes ($self->{byte_buffer});
        $self->_feed_chars ($input) or return 0;
  
        return 1;
      } # _parse_bytes_start_parsing
    
  
      sub parse_bytes_start ($$$) {
        my $self = $_[0];
  
        $self->{byte_buffer} = '';
        $self->{byte_buffer_orig} = '';
        $self->{transport_encoding_label} = $_[1];
  
        $self->{document} = my $doc = $_[2];
        $doc->manakai_is_html (1);
        $self->{can_restart} = 1;
  
        local ($AFE, $AnchoredIndex, $Attr, $CONTEXT, $Callbacks, $Confident, $DI, $EOF, $Errors, $FORM_ELEMENT, $FRAMESET_OK, $HEAD_ELEMENT, $IM, $IframeSrcdoc, $InForeign, $Input, $LastStartTagName, $NEXT_ID, $OE, $OP, $ORIGINAL_IM, $Offset, $QUIRKS, $Scripting, $State, $TABLE_CHARS, $TEMPLATE_IMS, $Temp, $TempIndex, $Token, $Tokens);
        PARSER: {
          $self->_parse_bytes_init;
          $self->_parse_bytes_start_parsing (no_body_data_yet => 1) or do {
            $self->{byte_buffer} = $self->{byte_buffer_orig};
            redo PARSER;
          };
        } # PARSER
  
        $self->{saved_states} = {AnchoredIndex => $AnchoredIndex, Attr => $Attr, CONTEXT => $CONTEXT, Confident => $Confident, DI => $DI, EOF => $EOF, FORM_ELEMENT => $FORM_ELEMENT, FRAMESET_OK => $FRAMESET_OK, HEAD_ELEMENT => $HEAD_ELEMENT, IM => $IM, LastStartTagName => $LastStartTagName, NEXT_ID => $NEXT_ID, ORIGINAL_IM => $ORIGINAL_IM, Offset => $Offset, QUIRKS => $QUIRKS, State => $State, Temp => $Temp, TempIndex => $TempIndex, Token => $Token};
        return;
      } # parse_bytes_start
    
  
      ## The $args{start_parsing} flag should be set true if it has
      ## taken more than 500ms from the start of overall parsing
      ## process.
      sub parse_bytes_feed ($$;%) {
        my ($self, undef, %args) = @_;
  
        local ($AFE, $AnchoredIndex, $Attr, $CONTEXT, $Callbacks, $Confident, $DI, $EOF, $Errors, $FORM_ELEMENT, $FRAMESET_OK, $HEAD_ELEMENT, $IM, $IframeSrcdoc, $InForeign, $Input, $LastStartTagName, $NEXT_ID, $OE, $OP, $ORIGINAL_IM, $Offset, $QUIRKS, $Scripting, $State, $TABLE_CHARS, $TEMPLATE_IMS, $Temp, $TempIndex, $Token, $Tokens);
        $IframeSrcdoc = $self->{IframeSrcdoc};
  $Scripting = $self->{Scripting};
        ($AnchoredIndex, $Attr, $CONTEXT, $Confident, $DI, $EOF, $FORM_ELEMENT, $FRAMESET_OK, $HEAD_ELEMENT, $IM, $LastStartTagName, $NEXT_ID, $ORIGINAL_IM, $Offset, $QUIRKS, $State, $Temp, $TempIndex, $Token) = @{$self->{saved_states}}{qw(AnchoredIndex Attr CONTEXT Confident DI EOF FORM_ELEMENT FRAMESET_OK HEAD_ELEMENT IM LastStartTagName NEXT_ID ORIGINAL_IM Offset QUIRKS State Temp TempIndex Token)};
  ($AFE, $Callbacks, $Errors, $OE, $OP, $TABLE_CHARS, $TEMPLATE_IMS, $Tokens) = @{$self->{saved_lists}}{qw(AFE Callbacks Errors OE OP TABLE_CHARS TEMPLATE_IMS Tokens)};
  () = @{$self->{saved_maps}}{qw()};
  
        $self->{byte_buffer} .= $_[1];
        $self->{byte_buffer_orig} .= $_[1];
        PARSER: {
          if ($self->{parse_bytes_started}) {
            # XXX $self->{decoder} is undef if feed_bytes invoked after feed_eof
            if (defined $self->{decoder}) {
              my $input = $self->{decoder}->bytes ($_[1]);
              $self->_feed_chars ($input) or do {
                $self->{byte_buffer} = $self->{byte_buffer_orig};
                $self->_parse_bytes_init;
                redo PARSER;
              };
            }
          } else {
            if ($args{start_parsing} or 1024 <= length $self->{byte_buffer}) {
              $self->_parse_bytes_start_parsing or do {
                $self->{byte_buffer} = $self->{byte_buffer_orig};
                $self->_parse_bytes_init;
                redo PARSER;
              };
            }
          }
        } # PARSER
  
        $self->{saved_states} = {AnchoredIndex => $AnchoredIndex, Attr => $Attr, CONTEXT => $CONTEXT, Confident => $Confident, DI => $DI, EOF => $EOF, FORM_ELEMENT => $FORM_ELEMENT, FRAMESET_OK => $FRAMESET_OK, HEAD_ELEMENT => $HEAD_ELEMENT, IM => $IM, LastStartTagName => $LastStartTagName, NEXT_ID => $NEXT_ID, ORIGINAL_IM => $ORIGINAL_IM, Offset => $Offset, QUIRKS => $QUIRKS, State => $State, Temp => $Temp, TempIndex => $TempIndex, Token => $Token};
        return;
      } # parse_bytes_feed
  
      sub parse_bytes_end ($) {
        my $self = $_[0];
        local ($AFE, $AnchoredIndex, $Attr, $CONTEXT, $Callbacks, $Confident, $DI, $EOF, $Errors, $FORM_ELEMENT, $FRAMESET_OK, $HEAD_ELEMENT, $IM, $IframeSrcdoc, $InForeign, $Input, $LastStartTagName, $NEXT_ID, $OE, $OP, $ORIGINAL_IM, $Offset, $QUIRKS, $Scripting, $State, $TABLE_CHARS, $TEMPLATE_IMS, $Temp, $TempIndex, $Token, $Tokens);
        $IframeSrcdoc = $self->{IframeSrcdoc};
  $Scripting = $self->{Scripting};
        ($AnchoredIndex, $Attr, $CONTEXT, $Confident, $DI, $EOF, $FORM_ELEMENT, $FRAMESET_OK, $HEAD_ELEMENT, $IM, $LastStartTagName, $NEXT_ID, $ORIGINAL_IM, $Offset, $QUIRKS, $State, $Temp, $TempIndex, $Token) = @{$self->{saved_states}}{qw(AnchoredIndex Attr CONTEXT Confident DI EOF FORM_ELEMENT FRAMESET_OK HEAD_ELEMENT IM LastStartTagName NEXT_ID ORIGINAL_IM Offset QUIRKS State Temp TempIndex Token)};
  ($AFE, $Callbacks, $Errors, $OE, $OP, $TABLE_CHARS, $TEMPLATE_IMS, $Tokens) = @{$self->{saved_lists}}{qw(AFE Callbacks Errors OE OP TABLE_CHARS TEMPLATE_IMS Tokens)};
  () = @{$self->{saved_maps}}{qw()};
  
        PARSER: {
          unless ($self->{parse_bytes_started}) {
            $self->_parse_bytes_start_parsing or do {
              $self->{byte_buffer} = $self->{byte_buffer_orig};
              $self->_parse_bytes_init;
              redo PARSER;
            };
          }
  
          if (defined $self->{decoder}) {
            my $input = $self->{decoder}->eof;
            $self->_feed_chars ($input) or do {
              $self->{byte_buffer} = $self->{byte_buffer_orig};
              $self->_parse_bytes_init;
              redo PARSER;
            };
            delete $self->{decoder};
          }
  
          $self->_feed_eof or do {
            $self->{byte_buffer} = $self->{byte_buffer_orig};
            $self->_parse_bytes_init;
            redo PARSER;
          };
        } # PARSER
        
        return;
      } # parse_bytes_end
    
  
      1;
  
  =head1 LICENSE
  
  Copyright 2007-2017 Wakaba <wakaba@suikawiki.org>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  This library derived from a JSON file, which contains data extracted
  from HTML Standard.  "Written by Ian Hickson (Google, ian@hixie.ch) -
  Parts  Copyright 2004-2014 Apple Inc., Mozilla Foundation, and Opera
  Software ASA; You are granted a license to use, reproduce and create
  derivative works of this document."
  
  =cut
  
    
WEB_HTML_PARSER

$fatpacked{"Web/HTML/ParserData.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WEB_HTML_PARSERDATA';
  package Web::HTML::ParserData;
  use strict;
  use warnings;
  our $VERSION = '5.0';
  use Web::HTML::_SyntaxDefs;
  use Web::HTML::_NamedEntityList;
  
  ## ------ Namespace URLs ------
  
  sub HTML_NS () { q<http://www.w3.org/1999/xhtml> }
  sub MML_NS () { q<http://www.w3.org/1998/Math/MathML> }
  sub SVG_NS () { q<http://www.w3.org/2000/svg> }
  sub XLINK_NS () { q<http://www.w3.org/1999/xlink> }
  sub XML_NS () { q<http://www.w3.org/XML/1998/namespace> }
  sub XMLNS_NS () { q<http://www.w3.org/2000/xmlns/> }
  
  ## ------ Element categories ------
  
  our $AllVoidElements = $Web::HTML::_SyntaxDefs->{void}->{+HTML_NS};
  
  ## ------ Foreign element integration points ------
  
  our $MathMLTextIntegrationPoints = $Web::HTML::_SyntaxDefs->{is_mathml_text_integration_point};
  our $MathMLTextIntegrationPointMathMLElements = $Web::HTML::_SyntaxDefs->{is_mathml_text_integration_point_mathml};
  our $SVGHTMLIntegrationPoints = $Web::HTML::_SyntaxDefs->{is_svg_html_integration_point};
  our $MathMLHTMLIntegrationPoints = $Web::HTML::_SyntaxDefs->{is_mathml_html_integration_point};
  our $ForeignContentBreakers = $Web::HTML::_SyntaxDefs->{foreign_content_breakers};
  
  ## ------ Attribute name mappings ------
  
  our $MathMLAttrNameFixup = $Web::HTML::_SyntaxDefs->{adjusted_mathml_attr_names};
  our $SVGAttrNameFixup = $Web::HTML::_SyntaxDefs->{adjusted_svg_attr_names};
  our $ForeignAttrNamespaceFixup = $Web::HTML::_SyntaxDefs->{adjusted_ns_attr_names};
  our $SVGElementNameFixup = $Web::HTML::_SyntaxDefs->{adjusted_svg_element_names};
  
  our $ForeignAttrNameToArgs = {};
  for (keys %$ForeignAttrNamespaceFixup) {
    $ForeignAttrNameToArgs->{(SVG_NS)}->{$_} = $ForeignAttrNamespaceFixup->{$_};
    $ForeignAttrNameToArgs->{(MML_NS)}->{$_} = $ForeignAttrNamespaceFixup->{$_};
  }
  for (keys %$SVGAttrNameFixup) {
    $ForeignAttrNameToArgs->{(SVG_NS)}->{$_} = [undef, [undef, $SVGAttrNameFixup->{$_}]];
  }
  for (keys %$MathMLAttrNameFixup) {
    $ForeignAttrNameToArgs->{(MML_NS)}->{$_} = [undef, [undef, $MathMLAttrNameFixup->{$_}]];
  }
  
  ## ------ Character references ------
  
  our $NamedCharRefs = $Web::HTML::EntityChar;
  our $InvalidCharRefs = $Web::HTML::_SyntaxDefs->{charref_invalid};
  our $CharRefReplacements = $Web::HTML::_SyntaxDefs->{charref_replacements};
  our $NoncharacterCodePoints = $Web::HTML::_SyntaxDefs->{nonchars};
  
  ## ------ DEPRECATED ------
  
  # XXX Variables in this section will be removed.
  
  our $ObsoletePermittedDoctypes = {
    '-//W3C//DTD HTML 4.0//EN'
        => 'http://www.w3.org/TR/REC-html40/strict.dtd', # or missing
    '-//W3C//DTD HTML 4.01//EN'
        => 'http://www.w3.org/TR/html4/strict.dtd', # or missing
    '-//W3C//DTD XHTML 1.0 Strict//EN'
        => 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd', # required
    '-//W3C//DTD XHTML 1.1//EN'
        => 'http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd', # required
  };
  our $QuirkyPublicIDPrefixes = [
    "+//SILMARIL//DTD HTML PRO V0R11 19970101//",
    "-//ADVASOFT LTD//DTD HTML 3.0 ASWEDIT + EXTENSIONS//",
    "-//AS//DTD HTML 3.0 ASWEDIT + EXTENSIONS//",
    "-//IETF//DTD HTML 2.0 LEVEL 1//",
    "-//IETF//DTD HTML 2.0 LEVEL 2//",
    "-//IETF//DTD HTML 2.0 STRICT LEVEL 1//",
    "-//IETF//DTD HTML 2.0 STRICT LEVEL 2//",
    "-//IETF//DTD HTML 2.0 STRICT//",
    "-//IETF//DTD HTML 2.0//",
    "-//IETF//DTD HTML 2.1E//",
    "-//IETF//DTD HTML 3.0//",
    "-//IETF//DTD HTML 3.2 FINAL//",
    "-//IETF//DTD HTML 3.2//",
    "-//IETF//DTD HTML 3//",
    "-//IETF//DTD HTML LEVEL 0//",
    "-//IETF//DTD HTML LEVEL 1//",
    "-//IETF//DTD HTML LEVEL 2//",
    "-//IETF//DTD HTML LEVEL 3//",
    "-//IETF//DTD HTML STRICT LEVEL 0//",
    "-//IETF//DTD HTML STRICT LEVEL 1//",
    "-//IETF//DTD HTML STRICT LEVEL 2//",
    "-//IETF//DTD HTML STRICT LEVEL 3//",
    "-//IETF//DTD HTML STRICT//",
    "-//IETF//DTD HTML//",
    "-//METRIUS//DTD METRIUS PRESENTATIONAL//",
    "-//MICROSOFT//DTD INTERNET EXPLORER 2.0 HTML STRICT//",
    "-//MICROSOFT//DTD INTERNET EXPLORER 2.0 HTML//",
    "-//MICROSOFT//DTD INTERNET EXPLORER 2.0 TABLES//",
    "-//MICROSOFT//DTD INTERNET EXPLORER 3.0 HTML STRICT//",
    "-//MICROSOFT//DTD INTERNET EXPLORER 3.0 HTML//",
    "-//MICROSOFT//DTD INTERNET EXPLORER 3.0 TABLES//",
    "-//NETSCAPE COMM. CORP.//DTD HTML//",
    "-//NETSCAPE COMM. CORP.//DTD STRICT HTML//",
    "-//O'REILLY AND ASSOCIATES//DTD HTML 2.0//",
    "-//O'REILLY AND ASSOCIATES//DTD HTML EXTENDED 1.0//",
    "-//O'REILLY AND ASSOCIATES//DTD HTML EXTENDED RELAXED 1.0//",
    "-//SOFTQUAD SOFTWARE//DTD HOTMETAL PRO 6.0::19990601::EXTENSIONS TO HTML 4.0//",
    "-//SOFTQUAD//DTD HOTMETAL PRO 4.0::19971010::EXTENSIONS TO HTML 4.0//",
    "-//SPYGLASS//DTD HTML 2.0 EXTENDED//",
    "-//SQ//DTD HTML 2.0 HOTMETAL + EXTENSIONS//",
    "-//SUN MICROSYSTEMS CORP.//DTD HOTJAVA HTML//",
    "-//SUN MICROSYSTEMS CORP.//DTD HOTJAVA STRICT HTML//",
    "-//W3C//DTD HTML 3 1995-03-24//",
    "-//W3C//DTD HTML 3.2 DRAFT//",
    "-//W3C//DTD HTML 3.2 FINAL//",
    "-//W3C//DTD HTML 3.2//",
    "-//W3C//DTD HTML 3.2S DRAFT//",
    "-//W3C//DTD HTML 4.0 FRAMESET//",
    "-//W3C//DTD HTML 4.0 TRANSITIONAL//",
    "-//W3C//DTD HTML EXPERIMETNAL 19960712//",
    "-//W3C//DTD HTML EXPERIMENTAL 970421//",
    "-//W3C//DTD W3 HTML//",
    "-//W3O//DTD W3 HTML 3.0//",
    "-//WEBTECHS//DTD MOZILLA HTML 2.0//",
    "-//WEBTECHS//DTD MOZILLA HTML//",
  ]; # $QuirkyPublicIDPrefixes
  our $QuirkyPublicIDs = {
    "-//W3O//DTD W3 HTML STRICT 3.0//EN//" => 1,
    "-/W3C/DTD HTML 4.0 TRANSITIONAL/EN" => 1,
    "HTML" => 1,
  }; # $QuirkyPublicIDs
  
  ## ------ End of deprecated ------
  
  1;
  
  =head1 NAME
  
  Web::HTML::ParserData - Data for HTML parser
  
  =head1 DESCRIPTION
  
  The C<Web::HTML::ParserData> module contains data for HTML and XML
  parsers, extracted from the HTML Standard.
  
  =head1 CONSTANTS
  
  Following constants returning namespace URLs are defined (but not
  exported): C<HTML_NS> (HTML namespace), C<SVG_NS> (SVG namespace),
  C<MML_NS> (MathML namespace), C<XML_NS> (XML namespace), C<XMLNS_NS>
  (XML Namespaces namespace), and C<XLINK_NS> (XLink namespace).
  
  =head1 VARIABLES
  
  There are following data from the HTML Standard:
  
  =over 4
  
  =item $AllVoidElements
  
  A hash reference, whose keys are HTML void element names (conforming
  or non-conforming) and values are true.  This list is equal to the
  list of HTML elements whose "syntax_category" is "void" or "obsolete
  void" in the JSON data file
  <https://github.com/manakai/data-web-defs/blob/master/doc/elements.txt>.
  
  =item $MathMLTextIntegrationPoints
  
  The local names of the MathML text integration point elements
  <http://www.whatwg.org/specs/web-apps/current-work/#mathml-text-integration-point>.
  Keys are local names and values are true values.
  
  =item $MathMLTextIntegrationPointMathMLElements
  
  The tag names of the start tags that are interpreted as MathML
  elements in MathML text integration point
  <http://www.whatwg.org/specs/web-apps/current-work/#tree-construction>.
  Keys are tag names (in lowercase) and values are true values.
  
  =item $SVGHTMLIntegrationPoints
  
  The local names of the HTML integration point SVG elements
  <http://www.whatwg.org/specs/web-apps/current-work/#html-integration-point>.
  Keys are local names and values are true values.
  
  =item $MathMLHTMLIntegrationPoints
  
  The local names of the HTML integration point MathML elements
  <http://www.whatwg.org/specs/web-apps/current-work/#html-integration-point>.
  Keys are local names and values are true values.
  
  Note that the C<annotation-xml> element is B<NOT> in this list (but
  sometimes it is an HTML integration point).
  
  =item $ForeignContentBreakers
  
  The tag names of the start tags that will close foreign elements if
  they appear in foreign content parsing mode
  <http://www.whatwg.org/specs/web-apps/current-work/#parsing-main-inforeign>.
  Keys are tag names (in lowercase) and values are true values.
  
  Note that the C<font> tag name is B<NOT> in this list (but it
  sometimes closes foreign elements).
  
  =item $MathMLAttrNameFixup
  
  Table in adjust MathML attributes
  <http://www.whatwg.org/specs/web-apps/current-work/#adjust-mathml-attributes>.
  
  =item $SVGAttrNameFixup
  
  Table in adjust SVG attributes
  <http://www.whatwg.org/specs/web-apps/current-work/#adjust-svg-attributes>.
  
  =item $ForeignAttrNamespaceFixup
  
  Table in adjust foreign attributes
  <http://www.whatwg.org/specs/web-apps/current-work/#adjust-foreign-attributes>.
  
  =item $SVGElementNameFixup
  
  Table in the rules for parsing tokens in foreign content, any other
  start tag, an element in the SVG namespace
  <http://www.whatwg.org/specs/web-apps/current-work/#parsing-main-inforeign>.
  
  =item $NamedCharRefs
  
  HTML named character references.
  
  =item $CharRefReplacements
  
  The code point replacement table for HTML character references, as
  specified in HTML Standard
  <http://www.whatwg.org/specs/web-apps/current-work/#tokenizing-character-references>.
  Keys are original code points (as specified in character references),
  represented as strings in shortest decimal form, and values are
  corresponding replaced code points, represented as integers.
  
  Note that surrogate code points are not included in this list (but
  replaced by U+FFFD).  Note also that some code points are replaced by
  the same code point.
  
  =item $NoncharacterCodePoints
  
  The Unicode noncharacter code points.  Keys are code points,
  represented as strings in shortest decimal form, and values are some
  true values.
  
  =back
  
  Note that variables not mentioned in this section should not be used.
  They might be removed in later revision of this module.
  
  =head1 SPECIFICATION
  
  =over 4
  
  =item HTML
  
  HTML Standard <http://www.whatwg.org/specs/web-apps/current-work/>.
  
  =back
  
  =head1 SOURCES
  
  data-web-defs <https://github.com/manakai/data-web-defs/>.
  
  data-chars <https://github.com/manakai/data-chars/>.
  
  =head1 LICENSE
  
  You are granted a license to use, reproduce and create derivative
  works of this file.
  
  The JSON file contains data extracted from HTML Standard.  "Written by
  Ian Hickson (Google, ian@hixie.ch) - Parts  Copyright 2004-2014 Apple
  Inc., Mozilla Foundation, and Opera Software ASA; You are granted a
  license to use, reproduce and create derivative works of this
  document."
  
  =cut
WEB_HTML_PARSERDATA

$fatpacked{"Web/HTML/Serializer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WEB_HTML_SERIALIZER';
  package Web::HTML::Serializer;
  use strict;
  use warnings;
  no warnings 'utf8';
  our $VERSION = '13.0';
  use Web::HTML::_SyntaxDefs;
  
  sub new ($) {
    return bless {}, $_[0];
  } # new
  
  sub scripting ($;$) {
    if (@_ > 1) {
      $_[0]->{scripting} = $_[1];
    }
    return $_[0]->{scripting};
  } # scripting
  
  sub _in_cdata ($$) {
    my ($self, $node) = @_;
    
    my $ns = $node->namespace_uri;
    return 0 if not defined $ns; # in no namespace, or not an Element
    return 0 unless $ns eq q<http://www.w3.org/1999/xhtml>;
    
    my $ln = $node->manakai_local_name;
    return 1 if {
      style => 1,
      script => 1,
      xmp => 1,
      iframe => 1,
      noembed => 1,
      noframes => 1,
      plaintext => 1,
      noscript => $self->scripting,
    }->{$ln};
  
    return 0;
  } # _in_cdata
  
  sub get_inner_html ($$) {
    my ($self, $node) = @_;
  
    return \'' if not ref $node eq 'ARRAY' and
        $Web::HTML::_SyntaxDefs->{void}->{$node->namespace_uri // ''}->{$node->local_name // ''};
    
    my $s = '';
    
    ## Step 2
    my $node_in_cdata = ref $node eq 'ARRAY' ? 0 : $self->_in_cdata ($node);
    my @node = map { [$_, $node_in_cdata] }
        ref $node eq 'ARRAY' ? @$node :
        ($node->node_type == 1 and $node->manakai_element_type_match ('http://www.w3.org/1999/xhtml', 'template'))
            ? $node->content->child_nodes->to_list
            : $node->child_nodes->to_list;
    C: while (@node) {
      ## Step 2.1
      my $c = shift @node;
      my $child = $c->[0];
  
      ## End tag
      if (not ref $child) {
        $s .= $child;
        next;
      }
  
      ## Step 2.2
      my $nt = $child->node_type;
      if ($nt == 1) { # Element
        my $tag_name;
        my $child_ns = $child->namespace_uri || '';
        if ($child_ns eq q<http://www.w3.org/1999/xhtml> or
            $child_ns eq q<http://www.w3.org/2000/svg> or
            $child_ns eq q<http://www.w3.org/1998/Math/MathML>) {
          $tag_name = $child->manakai_local_name;
        } else {
          $tag_name = $child->manakai_tag_name;
        }
        $s .= '<' . $tag_name;
  
        my @attrs = @{$child->attributes}; # sort order MUST be stable
        for my $attr (@attrs) { # order is implementation dependent
          my $attr_name;
          my $attr_ns = $attr->namespace_uri;
          if (not defined $attr_ns) {
            $attr_name = $attr->manakai_local_name;
          } elsif ($attr_ns eq q<http://www.w3.org/XML/1998/namespace>) {
            $attr_name = 'xml:' . $attr->manakai_local_name;
          } elsif ($attr_ns eq q<http://www.w3.org/2000/xmlns/>) {
            $attr_name = 'xmlns:' . $attr->manakai_local_name;
            $attr_name = 'xmlns' if $attr_name eq 'xmlns:xmlns';
          } elsif ($attr_ns eq q<http://www.w3.org/1999/xlink>) {
            $attr_name = 'xlink:' . $attr->manakai_local_name;
          } else {
            $attr_name = $attr->manakai_name;
          }
          $s .= ' ' . $attr_name . '="';
          my $attr_value = $attr->value;
          ## escape
          $attr_value =~ s/&/&amp;/g;
          $attr_value =~ s/\xA0/&nbsp;/g;
          $attr_value =~ s/"/&quot;/g;
          #$attr_value =~ s/</&lt;/g;
          #$attr_value =~ s/>/&gt;/g;
          $s .= $attr_value . '"';
        }
        $s .= '>';
        
        next C if $Web::HTML::_SyntaxDefs->{void}->{$child_ns}->{$tag_name};
  
        my $child_in_cdata = $self->_in_cdata ($child);
        unshift @node,
            (map { [$_, $child_in_cdata] } ($child->node_type == 1 and $child->manakai_element_type_match ('http://www.w3.org/1999/xhtml', 'template')) ? $child->content->child_nodes->to_list : $child->child_nodes->to_list),
            (['</' . $tag_name . '>', 0]);
      } elsif ($nt == 3) { # Text
        if ($c->[1]) { # in CDATA or PLAINTEXT element
          $s .= $child->data;
        } else {
          my $value = $child->data;
          $value =~ s/&/&amp;/g;
          $value =~ s/\xA0/&nbsp;/g;
          $value =~ s/</&lt;/g;
          $value =~ s/>/&gt;/g;
          #$value =~ s/"/&quot;/g;
          $s .= $value;
        }
      } elsif ($nt == 8) { # Comment
        $s .= '<!--' . $child->data . '-->';
      } elsif ($nt == 10) { # DocumentType
        my $pubid = $child->public_id;
        my $sysid = $child->system_id;
        if (length $pubid) {
          $s .= '<!DOCTYPE ' . $child->name . ' PUBLIC "' . $pubid . '" "' . $sysid . '">';
        } elsif (length $sysid) {
          $s .= '<!DOCTYPE ' . $child->name . ' SYSTEM "' . $sysid . '">';
        } else {
          $s .= '<!DOCTYPE ' . $child->name . '>';
        }
      } elsif ($nt == 7) { # ProcessingInstruction
        $s .= '<?' . $child->target . ' ' . $child->data . '>';
      } elsif ($nt == 9 or $nt == 11) { # Document / DocumentFragment
        unshift @node, map { [$_, $c->[1]] } $child->child_nodes->to_list;
      } else {
        die "Node type not supported: $nt";
      }
    } # C
    
    ## Step 3
    return \$s;
  } # get_inner_html
  
  1;
  
  =head1 LICENSE
  
  Copyright 2007-2019 Wakaba <wakaba@suikawiki.org>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
WEB_HTML_SERIALIZER

$fatpacked{"Web/HTML/SourceMap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WEB_HTML_SOURCEMAP';
  package Web::HTML::SourceMap;
  use strict;
  use warnings;
  no warnings 'utf8';
  our $VERSION = '3.0';
  use Carp qw(croak);
  
  our @EXPORT;
  
  sub import ($;@) {
    my $from_class = shift;
    my ($to_class, $file, $line) = caller;
    no strict 'refs';
    for (@_ ? @_ : @{$from_class . '::EXPORT'}) {
      my $code = $from_class->can ($_)
          or croak qq{"$_" is not exported by the $from_class module at $file line $line};
      *{$to_class . '::' . $_} = $code;
    }
  } # import
  
  ## See SuikaWiki:manakai index data structure
  ## <http://wiki.suikawiki.org/n/manakai%20index%20data%20structures>.
  
  ## XXX As these functions are still in development, they are not
  ## documented yet.
  
  push @EXPORT, qw(resolve_index_pair);
  sub resolve_index_pair ($$$) {
    my ($di_data_set, $di, $index) = @_;
    for (1..50) {
      return ($di, $index) if $di < 0;
  
      my $map = ($di_data_set->[$di] || {})->{map};
      return ($di, $index) if not defined $map;
  
      my $entry = [0, -1, 0];
      for (@$map) {
        last if $index < $_->[0];
        $entry = $_;
      }
      $di = $entry->[1];
      $index = $entry->[2] + $index - $entry->[0];
    }
    return ($di, $index);
  } # resolve_index_pair
  
  push @EXPORT, qw(indexed_string_to_mapping);
  sub indexed_string_to_mapping ($) {
    my $is = $_[0];
    my $map = [];
    my $offset = 0;
    for (@$is) { # IndexedString
      push @$map, [$offset, $_->[1], $_->[2]];
      $offset += length $_->[0];
    }
    return $map;
  } # indexed_string_to_mapping
  
  push @EXPORT, qw(index_pair_to_lc_pair);
  sub index_pair_to_lc_pair ($$$) {
    my ($di_data_set, $di, $index) = @_;
    return (undef, undef) if $di < 0;
  
    my $map = ($di_data_set->[$di] || {})->{lc_map};
    return (undef, undef) if not defined $map;
  
    my $entry = undef;
    for (@$map) {
      last if $index < $_->[0];
      $entry = $_;
    }
  
    if (defined $entry) {
      return ($entry->[1], $entry->[2] + $index - $entry->[0]);
    } else {
      return (undef, undef);
    }
  } # index_pair_to_lc_pair
  
  push @EXPORT, qw(create_index_lc_mapping);
  sub create_index_lc_mapping ($) {
    my @map = ([0, 1, 1]);
    my $pos = 0;
    my $l = 1;
    my $c = 1;
    my $prev_length = 0;
    for (split /(\x0D\x0A?|\x0A)/, $_[0], -1) {
      if ($_ eq "\x0A" or $_ eq "\x0D") {
        $l++;
        push @map, [$pos+1, $l, 1];
        $c = 1;
        $pos += length $_;
        $prev_length = 0;
      } elsif ($_ eq "\x0D\x0A") {
        push @map, [$pos+1, $l, $prev_length || 1], [$pos+2, $l+1, 1];
        $l++;
        $c = 1;
        $pos += length $_;
        $prev_length = 0;
      } else {
        my $length = $prev_length = length $_;
        $c += $length;
        $pos += $length;
      }
    }
    return \@map;
  } # create_index_lc_mapping
  
  ## ------ "sps" data structure ------
  
  ## DON'T USE THESE FUNCTIONS!  They are to be removed once the XML
  ## parser is replaced by a new one.
  
  ## See |Web::HTML::Tokenizer| (search for |"sps"|) for description of
  ## data structures.
  
  ## Tests are included in |t/modules/Web-HTML-Parser-textpos.t|,
  ## |t/modules/Web-XML-Parser-textpos.t|, and other test scripts.
  
  push @EXPORT, qw(create_pos_lc_map);
  sub create_pos_lc_map ($) {
    my @map;
    my $pos = 0;
    my $l = 1;
    my $c = 1;
    for (split /(\x0D\x0A?|\x0A)/, $_[0], -1) {
      if (/[\x0D\x0A]/) {
        $l++;
        push @map, [$pos, length $_, $l, 0];
        $c = 1;
        $pos += length $_;
      } else {
        my $length = length $_;
        push @map, [$pos, $length, $l, $c];
        $c += $length;
        $pos += $length;
      }
    }
    unless (@map) {
      unshift @map, [0, 0, 1, 1];
    }
    return \@map;
  } # create_pos_lc_map
  
  push @EXPORT, qw(sps_set_di);
  sub sps_set_di ($$) {
    for (@{$_[0]}) {
      $_->[4] = $_[1] if not defined $_->[5];
    }
  } # sps_set_di
  
  push @EXPORT, qw(sps_with_offset);
  sub sps_with_offset ($$);
  sub sps_with_offset ($$) {
    my $delta = $_[1];
    return [map { my $v = [@$_]; $v->[0] += $delta; $v } @{$_[0]}];
  } # sps_add_offset
  
  push @EXPORT, qw(sps_is_empty);
  sub sps_is_empty ($) {
    return not @{$_[0] or []};
  } # sps_is_empty
  
  push @EXPORT, qw(lc_lc_mapper);
  sub lc_lc_mapper ($$$);
  sub lc_lc_mapper ($$$) {
    my ($from_map => $to_map, $args) = @_;
    return if defined $args->{di}; # absolute
  
    my $line;
    my $column;
    if (defined $args->{column}) {
      $line = $args->{line};
      $column = $args->{column};
    } elsif (defined $args->{token}) {
      $line = $args->{token}->{line};
      $column = $args->{token}->{column};
      return if defined $args->{token}->{di};
    }
    return unless defined $column;
  
    $args->{di} = -1;
    my $p;
    for (@$from_map) {
      if ($_->[2] < $line or
          $_->[2] == $line and $_->[3] <= $column) {
        $p = $_;
      } else {
        last;
      }
    }
    return unless defined $p;
  
    my $pos = $p->[0] + ($column - $p->[3]);
    my $q;
    for (@$to_map) {
      last if $pos < $_->[0];
      $q = $_;
    }
    if (defined $q and $pos <= $q->[0] + $q->[1]) {
      #print STDERR "$line.$column is index $pos (@{[join ' ', map { $_ // '' } @$p]}) is ";
      $args->{line} = $q->[2];
      $args->{column} = $q->[3] + $pos - $q->[0];
      $args->{di} = $q->[4];
      #print STDERR "$args->{line}.$args->{column}#@{[$args->{di} // -1]} (@{[join ' ', map { $_ // '' } @$q]})\n";
      lc_lc_mapper $q->[5] => $q->[6], $args if defined $q->[5]
    }
  } # lc_lc_mapper
  
  push @EXPORT, qw(combined_sps);
  sub combined_sps ($$$) {
    my ($sps, $from_map, $to_map) = @_;
    return [map {
      my $v = [@$_];
      $v->[5] = $from_map, $v->[6] = $to_map unless defined $v->[4];
      $v;
    } @$sps];
  } # combined_sps
  
  push @EXPORT, qw(pos_to_lc);
  sub pos_to_lc ($$) {
    my ($map, $pos) = @_;
    my $p;
    for (@$map) {
      last if $pos < $_->[0];
      $p = $_;
    }
    my %sp;
    if (defined $p and $pos <= $p->[0] + $p->[1]) {
      $sp{line} = $p->[2];
      $sp{column} = $p->[3] + $pos - $p->[0];
      $sp{di} = $p->[4];
      lc_lc_mapper $map => $p->[5], \%sp if defined $p->[5];
    }
    return \%sp;
  } # pos_to_lc
  
  push @EXPORT, qw(node_to_text_and_tc_and_sps);
  sub node_to_text_and_tc_and_sps ($) {
    my $node = $_[0];
    my @text;
    my @text_sps;
    my $text_delta = 0;
    my @tc;
    my @tc_sps;
    my $tc_delta = 0;
    for my $node (@{$node->child_nodes}) {
      my $nt = $node->node_type;
      if ($nt == 1) { # ELEMENT_NODE
        my @node = @{$node->child_nodes};
        while (@node) {
          my $node = shift @node;
          my $nt = $node->node_type;
          if ($nt == 1) { # ELEMENT_NODE
            unshift @node, @{$node->child_nodes};
          } elsif ($nt == 3) { # TEXT_NODE
            push @tc_sps, @{sps_with_offset $node->get_user_data ('manakai_sps') || [], $tc_delta};
            for ($node->data) {
              push @tc, $_;
              $tc_delta += length $_;
            }
          }
        }
      } elsif ($nt == 3) { # TEXT_NODE
        push @text_sps, @{sps_with_offset $node->get_user_data ('manakai_sps') || [], $text_delta};
        push @tc_sps, @{sps_with_offset $node->get_user_data ('manakai_sps') || [], $tc_delta};
        for ($node->data) {
          push @text, $_;
          push @tc, $_;
          $tc_delta += $_, $text_delta += $_ for length $_;
        }
      }
    }
    return ((join '', @text), (join '', @tc), \@text_sps, \@tc_sps);
  } # node_to_text_and_tc_and_sps
  
  1;
  
  =head1 LICENSE
  
  Copyright 2014 Wakaba <wakaba@suikawiki.org>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
WEB_HTML_SOURCEMAP

$fatpacked{"Web/HTML/_NamedEntityList.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WEB_HTML__NAMEDENTITYLIST';
  $Web::HTML::EntityChar = {
            "AElig" => "\x{c6}",
            "AElig;" => "\x{c6}",
            "AMP" => "&",
            "AMP;" => "&",
            "Aacute" => "\x{c1}",
            "Aacute;" => "\x{c1}",
            "Abreve;" => "\x{102}",
            "Acirc" => "\x{c2}",
            "Acirc;" => "\x{c2}",
            "Acy;" => "\x{410}",
            "Afr;" => "\x{1d504}",
            "Agrave" => "\x{c0}",
            "Agrave;" => "\x{c0}",
            "Alpha;" => "\x{391}",
            "Amacr;" => "\x{100}",
            "And;" => "\x{2a53}",
            "Aogon;" => "\x{104}",
            "Aopf;" => "\x{1d538}",
            "ApplyFunction;" => "\x{2061}",
            "Aring" => "\x{c5}",
            "Aring;" => "\x{c5}",
            "Ascr;" => "\x{1d49c}",
            "Assign;" => "\x{2254}",
            "Atilde" => "\x{c3}",
            "Atilde;" => "\x{c3}",
            "Auml" => "\x{c4}",
            "Auml;" => "\x{c4}",
            "Backslash;" => "\x{2216}",
            "Barv;" => "\x{2ae7}",
            "Barwed;" => "\x{2306}",
            "Bcy;" => "\x{411}",
            "Because;" => "\x{2235}",
            "Bernoullis;" => "\x{212c}",
            "Beta;" => "\x{392}",
            "Bfr;" => "\x{1d505}",
            "Bopf;" => "\x{1d539}",
            "Breve;" => "\x{2d8}",
            "Bscr;" => "\x{212c}",
            "Bumpeq;" => "\x{224e}",
            "CHcy;" => "\x{427}",
            "COPY" => "\x{a9}",
            "COPY;" => "\x{a9}",
            "Cacute;" => "\x{106}",
            "Cap;" => "\x{22d2}",
            "CapitalDifferentialD;" => "\x{2145}",
            "Cayleys;" => "\x{212d}",
            "Ccaron;" => "\x{10c}",
            "Ccedil" => "\x{c7}",
            "Ccedil;" => "\x{c7}",
            "Ccirc;" => "\x{108}",
            "Cconint;" => "\x{2230}",
            "Cdot;" => "\x{10a}",
            "Cedilla;" => "\x{b8}",
            "CenterDot;" => "\x{b7}",
            "Cfr;" => "\x{212d}",
            "Chi;" => "\x{3a7}",
            "CircleDot;" => "\x{2299}",
            "CircleMinus;" => "\x{2296}",
            "CirclePlus;" => "\x{2295}",
            "CircleTimes;" => "\x{2297}",
            "ClockwiseContourIntegral;" => "\x{2232}",
            "CloseCurlyDoubleQuote;" => "\x{201d}",
            "CloseCurlyQuote;" => "\x{2019}",
            "Colon;" => "\x{2237}",
            "Colone;" => "\x{2a74}",
            "Congruent;" => "\x{2261}",
            "Conint;" => "\x{222f}",
            "ContourIntegral;" => "\x{222e}",
            "Copf;" => "\x{2102}",
            "Coproduct;" => "\x{2210}",
            "CounterClockwiseContourIntegral;" => "\x{2233}",
            "Cross;" => "\x{2a2f}",
            "Cscr;" => "\x{1d49e}",
            "Cup;" => "\x{22d3}",
            "CupCap;" => "\x{224d}",
            "DD;" => "\x{2145}",
            "DDotrahd;" => "\x{2911}",
            "DJcy;" => "\x{402}",
            "DScy;" => "\x{405}",
            "DZcy;" => "\x{40f}",
            "Dagger;" => "\x{2021}",
            "Darr;" => "\x{21a1}",
            "Dashv;" => "\x{2ae4}",
            "Dcaron;" => "\x{10e}",
            "Dcy;" => "\x{414}",
            "Del;" => "\x{2207}",
            "Delta;" => "\x{394}",
            "Dfr;" => "\x{1d507}",
            "DiacriticalAcute;" => "\x{b4}",
            "DiacriticalDot;" => "\x{2d9}",
            "DiacriticalDoubleAcute;" => "\x{2dd}",
            "DiacriticalGrave;" => "`",
            "DiacriticalTilde;" => "\x{2dc}",
            "Diamond;" => "\x{22c4}",
            "DifferentialD;" => "\x{2146}",
            "Dopf;" => "\x{1d53b}",
            "Dot;" => "\x{a8}",
            "DotDot;" => "\x{20dc}",
            "DotEqual;" => "\x{2250}",
            "DoubleContourIntegral;" => "\x{222f}",
            "DoubleDot;" => "\x{a8}",
            "DoubleDownArrow;" => "\x{21d3}",
            "DoubleLeftArrow;" => "\x{21d0}",
            "DoubleLeftRightArrow;" => "\x{21d4}",
            "DoubleLeftTee;" => "\x{2ae4}",
            "DoubleLongLeftArrow;" => "\x{27f8}",
            "DoubleLongLeftRightArrow;" => "\x{27fa}",
            "DoubleLongRightArrow;" => "\x{27f9}",
            "DoubleRightArrow;" => "\x{21d2}",
            "DoubleRightTee;" => "\x{22a8}",
            "DoubleUpArrow;" => "\x{21d1}",
            "DoubleUpDownArrow;" => "\x{21d5}",
            "DoubleVerticalBar;" => "\x{2225}",
            "DownArrow;" => "\x{2193}",
            "DownArrowBar;" => "\x{2913}",
            "DownArrowUpArrow;" => "\x{21f5}",
            "DownBreve;" => "\x{311}",
            "DownLeftRightVector;" => "\x{2950}",
            "DownLeftTeeVector;" => "\x{295e}",
            "DownLeftVector;" => "\x{21bd}",
            "DownLeftVectorBar;" => "\x{2956}",
            "DownRightTeeVector;" => "\x{295f}",
            "DownRightVector;" => "\x{21c1}",
            "DownRightVectorBar;" => "\x{2957}",
            "DownTee;" => "\x{22a4}",
            "DownTeeArrow;" => "\x{21a7}",
            "Downarrow;" => "\x{21d3}",
            "Dscr;" => "\x{1d49f}",
            "Dstrok;" => "\x{110}",
            "ENG;" => "\x{14a}",
            "ETH" => "\x{d0}",
            "ETH;" => "\x{d0}",
            "Eacute" => "\x{c9}",
            "Eacute;" => "\x{c9}",
            "Ecaron;" => "\x{11a}",
            "Ecirc" => "\x{ca}",
            "Ecirc;" => "\x{ca}",
            "Ecy;" => "\x{42d}",
            "Edot;" => "\x{116}",
            "Efr;" => "\x{1d508}",
            "Egrave" => "\x{c8}",
            "Egrave;" => "\x{c8}",
            "Element;" => "\x{2208}",
            "Emacr;" => "\x{112}",
            "EmptySmallSquare;" => "\x{25fb}",
            "EmptyVerySmallSquare;" => "\x{25ab}",
            "Eogon;" => "\x{118}",
            "Eopf;" => "\x{1d53c}",
            "Epsilon;" => "\x{395}",
            "Equal;" => "\x{2a75}",
            "EqualTilde;" => "\x{2242}",
            "Equilibrium;" => "\x{21cc}",
            "Escr;" => "\x{2130}",
            "Esim;" => "\x{2a73}",
            "Eta;" => "\x{397}",
            "Euml" => "\x{cb}",
            "Euml;" => "\x{cb}",
            "Exists;" => "\x{2203}",
            "ExponentialE;" => "\x{2147}",
            "Fcy;" => "\x{424}",
            "Ffr;" => "\x{1d509}",
            "FilledSmallSquare;" => "\x{25fc}",
            "FilledVerySmallSquare;" => "\x{25aa}",
            "Fopf;" => "\x{1d53d}",
            "ForAll;" => "\x{2200}",
            "Fouriertrf;" => "\x{2131}",
            "Fscr;" => "\x{2131}",
            "GJcy;" => "\x{403}",
            "GT" => ">",
            "GT;" => ">",
            "Gamma;" => "\x{393}",
            "Gammad;" => "\x{3dc}",
            "Gbreve;" => "\x{11e}",
            "Gcedil;" => "\x{122}",
            "Gcirc;" => "\x{11c}",
            "Gcy;" => "\x{413}",
            "Gdot;" => "\x{120}",
            "Gfr;" => "\x{1d50a}",
            "Gg;" => "\x{22d9}",
            "Gopf;" => "\x{1d53e}",
            "GreaterEqual;" => "\x{2265}",
            "GreaterEqualLess;" => "\x{22db}",
            "GreaterFullEqual;" => "\x{2267}",
            "GreaterGreater;" => "\x{2aa2}",
            "GreaterLess;" => "\x{2277}",
            "GreaterSlantEqual;" => "\x{2a7e}",
            "GreaterTilde;" => "\x{2273}",
            "Gscr;" => "\x{1d4a2}",
            "Gt;" => "\x{226b}",
            "HARDcy;" => "\x{42a}",
            "Hacek;" => "\x{2c7}",
            "Hat;" => "^",
            "Hcirc;" => "\x{124}",
            "Hfr;" => "\x{210c}",
            "HilbertSpace;" => "\x{210b}",
            "Hopf;" => "\x{210d}",
            "HorizontalLine;" => "\x{2500}",
            "Hscr;" => "\x{210b}",
            "Hstrok;" => "\x{126}",
            "HumpDownHump;" => "\x{224e}",
            "HumpEqual;" => "\x{224f}",
            "IEcy;" => "\x{415}",
            "IJlig;" => "\x{132}",
            "IOcy;" => "\x{401}",
            "Iacute" => "\x{cd}",
            "Iacute;" => "\x{cd}",
            "Icirc" => "\x{ce}",
            "Icirc;" => "\x{ce}",
            "Icy;" => "\x{418}",
            "Idot;" => "\x{130}",
            "Ifr;" => "\x{2111}",
            "Igrave" => "\x{cc}",
            "Igrave;" => "\x{cc}",
            "Im;" => "\x{2111}",
            "Imacr;" => "\x{12a}",
            "ImaginaryI;" => "\x{2148}",
            "Implies;" => "\x{21d2}",
            "Int;" => "\x{222c}",
            "Integral;" => "\x{222b}",
            "Intersection;" => "\x{22c2}",
            "InvisibleComma;" => "\x{2063}",
            "InvisibleTimes;" => "\x{2062}",
            "Iogon;" => "\x{12e}",
            "Iopf;" => "\x{1d540}",
            "Iota;" => "\x{399}",
            "Iscr;" => "\x{2110}",
            "Itilde;" => "\x{128}",
            "Iukcy;" => "\x{406}",
            "Iuml" => "\x{cf}",
            "Iuml;" => "\x{cf}",
            "Jcirc;" => "\x{134}",
            "Jcy;" => "\x{419}",
            "Jfr;" => "\x{1d50d}",
            "Jopf;" => "\x{1d541}",
            "Jscr;" => "\x{1d4a5}",
            "Jsercy;" => "\x{408}",
            "Jukcy;" => "\x{404}",
            "KHcy;" => "\x{425}",
            "KJcy;" => "\x{40c}",
            "Kappa;" => "\x{39a}",
            "Kcedil;" => "\x{136}",
            "Kcy;" => "\x{41a}",
            "Kfr;" => "\x{1d50e}",
            "Kopf;" => "\x{1d542}",
            "Kscr;" => "\x{1d4a6}",
            "LJcy;" => "\x{409}",
            "LT" => "<",
            "LT;" => "<",
            "Lacute;" => "\x{139}",
            "Lambda;" => "\x{39b}",
            "Lang;" => "\x{27ea}",
            "Laplacetrf;" => "\x{2112}",
            "Larr;" => "\x{219e}",
            "Lcaron;" => "\x{13d}",
            "Lcedil;" => "\x{13b}",
            "Lcy;" => "\x{41b}",
            "LeftAngleBracket;" => "\x{27e8}",
            "LeftArrow;" => "\x{2190}",
            "LeftArrowBar;" => "\x{21e4}",
            "LeftArrowRightArrow;" => "\x{21c6}",
            "LeftCeiling;" => "\x{2308}",
            "LeftDoubleBracket;" => "\x{27e6}",
            "LeftDownTeeVector;" => "\x{2961}",
            "LeftDownVector;" => "\x{21c3}",
            "LeftDownVectorBar;" => "\x{2959}",
            "LeftFloor;" => "\x{230a}",
            "LeftRightArrow;" => "\x{2194}",
            "LeftRightVector;" => "\x{294e}",
            "LeftTee;" => "\x{22a3}",
            "LeftTeeArrow;" => "\x{21a4}",
            "LeftTeeVector;" => "\x{295a}",
            "LeftTriangle;" => "\x{22b2}",
            "LeftTriangleBar;" => "\x{29cf}",
            "LeftTriangleEqual;" => "\x{22b4}",
            "LeftUpDownVector;" => "\x{2951}",
            "LeftUpTeeVector;" => "\x{2960}",
            "LeftUpVector;" => "\x{21bf}",
            "LeftUpVectorBar;" => "\x{2958}",
            "LeftVector;" => "\x{21bc}",
            "LeftVectorBar;" => "\x{2952}",
            "Leftarrow;" => "\x{21d0}",
            "Leftrightarrow;" => "\x{21d4}",
            "LessEqualGreater;" => "\x{22da}",
            "LessFullEqual;" => "\x{2266}",
            "LessGreater;" => "\x{2276}",
            "LessLess;" => "\x{2aa1}",
            "LessSlantEqual;" => "\x{2a7d}",
            "LessTilde;" => "\x{2272}",
            "Lfr;" => "\x{1d50f}",
            "Ll;" => "\x{22d8}",
            "Lleftarrow;" => "\x{21da}",
            "Lmidot;" => "\x{13f}",
            "LongLeftArrow;" => "\x{27f5}",
            "LongLeftRightArrow;" => "\x{27f7}",
            "LongRightArrow;" => "\x{27f6}",
            "Longleftarrow;" => "\x{27f8}",
            "Longleftrightarrow;" => "\x{27fa}",
            "Longrightarrow;" => "\x{27f9}",
            "Lopf;" => "\x{1d543}",
            "LowerLeftArrow;" => "\x{2199}",
            "LowerRightArrow;" => "\x{2198}",
            "Lscr;" => "\x{2112}",
            "Lsh;" => "\x{21b0}",
            "Lstrok;" => "\x{141}",
            "Lt;" => "\x{226a}",
            "Map;" => "\x{2905}",
            "Mcy;" => "\x{41c}",
            "MediumSpace;" => "\x{205f}",
            "Mellintrf;" => "\x{2133}",
            "Mfr;" => "\x{1d510}",
            "MinusPlus;" => "\x{2213}",
            "Mopf;" => "\x{1d544}",
            "Mscr;" => "\x{2133}",
            "Mu;" => "\x{39c}",
            "NJcy;" => "\x{40a}",
            "Nacute;" => "\x{143}",
            "Ncaron;" => "\x{147}",
            "Ncedil;" => "\x{145}",
            "Ncy;" => "\x{41d}",
            "NegativeMediumSpace;" => "\x{200b}",
            "NegativeThickSpace;" => "\x{200b}",
            "NegativeThinSpace;" => "\x{200b}",
            "NegativeVeryThinSpace;" => "\x{200b}",
            "NestedGreaterGreater;" => "\x{226b}",
            "NestedLessLess;" => "\x{226a}",
            "NewLine;" => "\n",
            "Nfr;" => "\x{1d511}",
            "NoBreak;" => "\x{2060}",
            "NonBreakingSpace;" => "\x{a0}",
            "Nopf;" => "\x{2115}",
            "Not;" => "\x{2aec}",
            "NotCongruent;" => "\x{2262}",
            "NotCupCap;" => "\x{226d}",
            "NotDoubleVerticalBar;" => "\x{2226}",
            "NotElement;" => "\x{2209}",
            "NotEqual;" => "\x{2260}",
            "NotEqualTilde;" => "\x{2242}\x{338}",
            "NotExists;" => "\x{2204}",
            "NotGreater;" => "\x{226f}",
            "NotGreaterEqual;" => "\x{2271}",
            "NotGreaterFullEqual;" => "\x{2267}\x{338}",
            "NotGreaterGreater;" => "\x{226b}\x{338}",
            "NotGreaterLess;" => "\x{2279}",
            "NotGreaterSlantEqual;" => "\x{2a7e}\x{338}",
            "NotGreaterTilde;" => "\x{2275}",
            "NotHumpDownHump;" => "\x{224e}\x{338}",
            "NotHumpEqual;" => "\x{224f}\x{338}",
            "NotLeftTriangle;" => "\x{22ea}",
            "NotLeftTriangleBar;" => "\x{29cf}\x{338}",
            "NotLeftTriangleEqual;" => "\x{22ec}",
            "NotLess;" => "\x{226e}",
            "NotLessEqual;" => "\x{2270}",
            "NotLessGreater;" => "\x{2278}",
            "NotLessLess;" => "\x{226a}\x{338}",
            "NotLessSlantEqual;" => "\x{2a7d}\x{338}",
            "NotLessTilde;" => "\x{2274}",
            "NotNestedGreaterGreater;" => "\x{2aa2}\x{338}",
            "NotNestedLessLess;" => "\x{2aa1}\x{338}",
            "NotPrecedes;" => "\x{2280}",
            "NotPrecedesEqual;" => "\x{2aaf}\x{338}",
            "NotPrecedesSlantEqual;" => "\x{22e0}",
            "NotReverseElement;" => "\x{220c}",
            "NotRightTriangle;" => "\x{22eb}",
            "NotRightTriangleBar;" => "\x{29d0}\x{338}",
            "NotRightTriangleEqual;" => "\x{22ed}",
            "NotSquareSubset;" => "\x{228f}\x{338}",
            "NotSquareSubsetEqual;" => "\x{22e2}",
            "NotSquareSuperset;" => "\x{2290}\x{338}",
            "NotSquareSupersetEqual;" => "\x{22e3}",
            "NotSubset;" => "\x{2282}\x{20d2}",
            "NotSubsetEqual;" => "\x{2288}",
            "NotSucceeds;" => "\x{2281}",
            "NotSucceedsEqual;" => "\x{2ab0}\x{338}",
            "NotSucceedsSlantEqual;" => "\x{22e1}",
            "NotSucceedsTilde;" => "\x{227f}\x{338}",
            "NotSuperset;" => "\x{2283}\x{20d2}",
            "NotSupersetEqual;" => "\x{2289}",
            "NotTilde;" => "\x{2241}",
            "NotTildeEqual;" => "\x{2244}",
            "NotTildeFullEqual;" => "\x{2247}",
            "NotTildeTilde;" => "\x{2249}",
            "NotVerticalBar;" => "\x{2224}",
            "Nscr;" => "\x{1d4a9}",
            "Ntilde" => "\x{d1}",
            "Ntilde;" => "\x{d1}",
            "Nu;" => "\x{39d}",
            "OElig;" => "\x{152}",
            "Oacute" => "\x{d3}",
            "Oacute;" => "\x{d3}",
            "Ocirc" => "\x{d4}",
            "Ocirc;" => "\x{d4}",
            "Ocy;" => "\x{41e}",
            "Odblac;" => "\x{150}",
            "Ofr;" => "\x{1d512}",
            "Ograve" => "\x{d2}",
            "Ograve;" => "\x{d2}",
            "Omacr;" => "\x{14c}",
            "Omega;" => "\x{3a9}",
            "Omicron;" => "\x{39f}",
            "Oopf;" => "\x{1d546}",
            "OpenCurlyDoubleQuote;" => "\x{201c}",
            "OpenCurlyQuote;" => "\x{2018}",
            "Or;" => "\x{2a54}",
            "Oscr;" => "\x{1d4aa}",
            "Oslash" => "\x{d8}",
            "Oslash;" => "\x{d8}",
            "Otilde" => "\x{d5}",
            "Otilde;" => "\x{d5}",
            "Otimes;" => "\x{2a37}",
            "Ouml" => "\x{d6}",
            "Ouml;" => "\x{d6}",
            "OverBar;" => "\x{203e}",
            "OverBrace;" => "\x{23de}",
            "OverBracket;" => "\x{23b4}",
            "OverParenthesis;" => "\x{23dc}",
            "PartialD;" => "\x{2202}",
            "Pcy;" => "\x{41f}",
            "Pfr;" => "\x{1d513}",
            "Phi;" => "\x{3a6}",
            "Pi;" => "\x{3a0}",
            "PlusMinus;" => "\x{b1}",
            "Poincareplane;" => "\x{210c}",
            "Popf;" => "\x{2119}",
            "Pr;" => "\x{2abb}",
            "Precedes;" => "\x{227a}",
            "PrecedesEqual;" => "\x{2aaf}",
            "PrecedesSlantEqual;" => "\x{227c}",
            "PrecedesTilde;" => "\x{227e}",
            "Prime;" => "\x{2033}",
            "Product;" => "\x{220f}",
            "Proportion;" => "\x{2237}",
            "Proportional;" => "\x{221d}",
            "Pscr;" => "\x{1d4ab}",
            "Psi;" => "\x{3a8}",
            "QUOT" => "\"",
            "QUOT;" => "\"",
            "Qfr;" => "\x{1d514}",
            "Qopf;" => "\x{211a}",
            "Qscr;" => "\x{1d4ac}",
            "RBarr;" => "\x{2910}",
            "REG" => "\x{ae}",
            "REG;" => "\x{ae}",
            "Racute;" => "\x{154}",
            "Rang;" => "\x{27eb}",
            "Rarr;" => "\x{21a0}",
            "Rarrtl;" => "\x{2916}",
            "Rcaron;" => "\x{158}",
            "Rcedil;" => "\x{156}",
            "Rcy;" => "\x{420}",
            "Re;" => "\x{211c}",
            "ReverseElement;" => "\x{220b}",
            "ReverseEquilibrium;" => "\x{21cb}",
            "ReverseUpEquilibrium;" => "\x{296f}",
            "Rfr;" => "\x{211c}",
            "Rho;" => "\x{3a1}",
            "RightAngleBracket;" => "\x{27e9}",
            "RightArrow;" => "\x{2192}",
            "RightArrowBar;" => "\x{21e5}",
            "RightArrowLeftArrow;" => "\x{21c4}",
            "RightCeiling;" => "\x{2309}",
            "RightDoubleBracket;" => "\x{27e7}",
            "RightDownTeeVector;" => "\x{295d}",
            "RightDownVector;" => "\x{21c2}",
            "RightDownVectorBar;" => "\x{2955}",
            "RightFloor;" => "\x{230b}",
            "RightTee;" => "\x{22a2}",
            "RightTeeArrow;" => "\x{21a6}",
            "RightTeeVector;" => "\x{295b}",
            "RightTriangle;" => "\x{22b3}",
            "RightTriangleBar;" => "\x{29d0}",
            "RightTriangleEqual;" => "\x{22b5}",
            "RightUpDownVector;" => "\x{294f}",
            "RightUpTeeVector;" => "\x{295c}",
            "RightUpVector;" => "\x{21be}",
            "RightUpVectorBar;" => "\x{2954}",
            "RightVector;" => "\x{21c0}",
            "RightVectorBar;" => "\x{2953}",
            "Rightarrow;" => "\x{21d2}",
            "Ropf;" => "\x{211d}",
            "RoundImplies;" => "\x{2970}",
            "Rrightarrow;" => "\x{21db}",
            "Rscr;" => "\x{211b}",
            "Rsh;" => "\x{21b1}",
            "RuleDelayed;" => "\x{29f4}",
            "SHCHcy;" => "\x{429}",
            "SHcy;" => "\x{428}",
            "SOFTcy;" => "\x{42c}",
            "Sacute;" => "\x{15a}",
            "Sc;" => "\x{2abc}",
            "Scaron;" => "\x{160}",
            "Scedil;" => "\x{15e}",
            "Scirc;" => "\x{15c}",
            "Scy;" => "\x{421}",
            "Sfr;" => "\x{1d516}",
            "ShortDownArrow;" => "\x{2193}",
            "ShortLeftArrow;" => "\x{2190}",
            "ShortRightArrow;" => "\x{2192}",
            "ShortUpArrow;" => "\x{2191}",
            "Sigma;" => "\x{3a3}",
            "SmallCircle;" => "\x{2218}",
            "Sopf;" => "\x{1d54a}",
            "Sqrt;" => "\x{221a}",
            "Square;" => "\x{25a1}",
            "SquareIntersection;" => "\x{2293}",
            "SquareSubset;" => "\x{228f}",
            "SquareSubsetEqual;" => "\x{2291}",
            "SquareSuperset;" => "\x{2290}",
            "SquareSupersetEqual;" => "\x{2292}",
            "SquareUnion;" => "\x{2294}",
            "Sscr;" => "\x{1d4ae}",
            "Star;" => "\x{22c6}",
            "Sub;" => "\x{22d0}",
            "Subset;" => "\x{22d0}",
            "SubsetEqual;" => "\x{2286}",
            "Succeeds;" => "\x{227b}",
            "SucceedsEqual;" => "\x{2ab0}",
            "SucceedsSlantEqual;" => "\x{227d}",
            "SucceedsTilde;" => "\x{227f}",
            "SuchThat;" => "\x{220b}",
            "Sum;" => "\x{2211}",
            "Sup;" => "\x{22d1}",
            "Superset;" => "\x{2283}",
            "SupersetEqual;" => "\x{2287}",
            "Supset;" => "\x{22d1}",
            "THORN" => "\x{de}",
            "THORN;" => "\x{de}",
            "TRADE;" => "\x{2122}",
            "TSHcy;" => "\x{40b}",
            "TScy;" => "\x{426}",
            "Tab;" => "\t",
            "Tau;" => "\x{3a4}",
            "Tcaron;" => "\x{164}",
            "Tcedil;" => "\x{162}",
            "Tcy;" => "\x{422}",
            "Tfr;" => "\x{1d517}",
            "Therefore;" => "\x{2234}",
            "Theta;" => "\x{398}",
            "ThickSpace;" => "\x{205f}\x{200a}",
            "ThinSpace;" => "\x{2009}",
            "Tilde;" => "\x{223c}",
            "TildeEqual;" => "\x{2243}",
            "TildeFullEqual;" => "\x{2245}",
            "TildeTilde;" => "\x{2248}",
            "Topf;" => "\x{1d54b}",
            "TripleDot;" => "\x{20db}",
            "Tscr;" => "\x{1d4af}",
            "Tstrok;" => "\x{166}",
            "Uacute" => "\x{da}",
            "Uacute;" => "\x{da}",
            "Uarr;" => "\x{219f}",
            "Uarrocir;" => "\x{2949}",
            "Ubrcy;" => "\x{40e}",
            "Ubreve;" => "\x{16c}",
            "Ucirc" => "\x{db}",
            "Ucirc;" => "\x{db}",
            "Ucy;" => "\x{423}",
            "Udblac;" => "\x{170}",
            "Ufr;" => "\x{1d518}",
            "Ugrave" => "\x{d9}",
            "Ugrave;" => "\x{d9}",
            "Umacr;" => "\x{16a}",
            "UnderBar;" => "_",
            "UnderBrace;" => "\x{23df}",
            "UnderBracket;" => "\x{23b5}",
            "UnderParenthesis;" => "\x{23dd}",
            "Union;" => "\x{22c3}",
            "UnionPlus;" => "\x{228e}",
            "Uogon;" => "\x{172}",
            "Uopf;" => "\x{1d54c}",
            "UpArrow;" => "\x{2191}",
            "UpArrowBar;" => "\x{2912}",
            "UpArrowDownArrow;" => "\x{21c5}",
            "UpDownArrow;" => "\x{2195}",
            "UpEquilibrium;" => "\x{296e}",
            "UpTee;" => "\x{22a5}",
            "UpTeeArrow;" => "\x{21a5}",
            "Uparrow;" => "\x{21d1}",
            "Updownarrow;" => "\x{21d5}",
            "UpperLeftArrow;" => "\x{2196}",
            "UpperRightArrow;" => "\x{2197}",
            "Upsi;" => "\x{3d2}",
            "Upsilon;" => "\x{3a5}",
            "Uring;" => "\x{16e}",
            "Uscr;" => "\x{1d4b0}",
            "Utilde;" => "\x{168}",
            "Uuml" => "\x{dc}",
            "Uuml;" => "\x{dc}",
            "VDash;" => "\x{22ab}",
            "Vbar;" => "\x{2aeb}",
            "Vcy;" => "\x{412}",
            "Vdash;" => "\x{22a9}",
            "Vdashl;" => "\x{2ae6}",
            "Vee;" => "\x{22c1}",
            "Verbar;" => "\x{2016}",
            "Vert;" => "\x{2016}",
            "VerticalBar;" => "\x{2223}",
            "VerticalLine;" => "|",
            "VerticalSeparator;" => "\x{2758}",
            "VerticalTilde;" => "\x{2240}",
            "VeryThinSpace;" => "\x{200a}",
            "Vfr;" => "\x{1d519}",
            "Vopf;" => "\x{1d54d}",
            "Vscr;" => "\x{1d4b1}",
            "Vvdash;" => "\x{22aa}",
            "Wcirc;" => "\x{174}",
            "Wedge;" => "\x{22c0}",
            "Wfr;" => "\x{1d51a}",
            "Wopf;" => "\x{1d54e}",
            "Wscr;" => "\x{1d4b2}",
            "Xfr;" => "\x{1d51b}",
            "Xi;" => "\x{39e}",
            "Xopf;" => "\x{1d54f}",
            "Xscr;" => "\x{1d4b3}",
            "YAcy;" => "\x{42f}",
            "YIcy;" => "\x{407}",
            "YUcy;" => "\x{42e}",
            "Yacute" => "\x{dd}",
            "Yacute;" => "\x{dd}",
            "Ycirc;" => "\x{176}",
            "Ycy;" => "\x{42b}",
            "Yfr;" => "\x{1d51c}",
            "Yopf;" => "\x{1d550}",
            "Yscr;" => "\x{1d4b4}",
            "Yuml;" => "\x{178}",
            "ZHcy;" => "\x{416}",
            "Zacute;" => "\x{179}",
            "Zcaron;" => "\x{17d}",
            "Zcy;" => "\x{417}",
            "Zdot;" => "\x{17b}",
            "ZeroWidthSpace;" => "\x{200b}",
            "Zeta;" => "\x{396}",
            "Zfr;" => "\x{2128}",
            "Zopf;" => "\x{2124}",
            "Zscr;" => "\x{1d4b5}",
            "aacute" => "\x{e1}",
            "aacute;" => "\x{e1}",
            "abreve;" => "\x{103}",
            "ac;" => "\x{223e}",
            "acE;" => "\x{223e}\x{333}",
            "acd;" => "\x{223f}",
            "acirc" => "\x{e2}",
            "acirc;" => "\x{e2}",
            "acute" => "\x{b4}",
            "acute;" => "\x{b4}",
            "acy;" => "\x{430}",
            "aelig" => "\x{e6}",
            "aelig;" => "\x{e6}",
            "af;" => "\x{2061}",
            "afr;" => "\x{1d51e}",
            "agrave" => "\x{e0}",
            "agrave;" => "\x{e0}",
            "alefsym;" => "\x{2135}",
            "aleph;" => "\x{2135}",
            "alpha;" => "\x{3b1}",
            "amacr;" => "\x{101}",
            "amalg;" => "\x{2a3f}",
            "amp" => "&",
            "amp;" => "&",
            "and;" => "\x{2227}",
            "andand;" => "\x{2a55}",
            "andd;" => "\x{2a5c}",
            "andslope;" => "\x{2a58}",
            "andv;" => "\x{2a5a}",
            "ang;" => "\x{2220}",
            "ange;" => "\x{29a4}",
            "angle;" => "\x{2220}",
            "angmsd;" => "\x{2221}",
            "angmsdaa;" => "\x{29a8}",
            "angmsdab;" => "\x{29a9}",
            "angmsdac;" => "\x{29aa}",
            "angmsdad;" => "\x{29ab}",
            "angmsdae;" => "\x{29ac}",
            "angmsdaf;" => "\x{29ad}",
            "angmsdag;" => "\x{29ae}",
            "angmsdah;" => "\x{29af}",
            "angrt;" => "\x{221f}",
            "angrtvb;" => "\x{22be}",
            "angrtvbd;" => "\x{299d}",
            "angsph;" => "\x{2222}",
            "angst;" => "\x{c5}",
            "angzarr;" => "\x{237c}",
            "aogon;" => "\x{105}",
            "aopf;" => "\x{1d552}",
            "ap;" => "\x{2248}",
            "apE;" => "\x{2a70}",
            "apacir;" => "\x{2a6f}",
            "ape;" => "\x{224a}",
            "apid;" => "\x{224b}",
            "apos;" => "'",
            "approx;" => "\x{2248}",
            "approxeq;" => "\x{224a}",
            "aring" => "\x{e5}",
            "aring;" => "\x{e5}",
            "ascr;" => "\x{1d4b6}",
            "ast;" => "*",
            "asymp;" => "\x{2248}",
            "asympeq;" => "\x{224d}",
            "atilde" => "\x{e3}",
            "atilde;" => "\x{e3}",
            "auml" => "\x{e4}",
            "auml;" => "\x{e4}",
            "awconint;" => "\x{2233}",
            "awint;" => "\x{2a11}",
            "bNot;" => "\x{2aed}",
            "backcong;" => "\x{224c}",
            "backepsilon;" => "\x{3f6}",
            "backprime;" => "\x{2035}",
            "backsim;" => "\x{223d}",
            "backsimeq;" => "\x{22cd}",
            "barvee;" => "\x{22bd}",
            "barwed;" => "\x{2305}",
            "barwedge;" => "\x{2305}",
            "bbrk;" => "\x{23b5}",
            "bbrktbrk;" => "\x{23b6}",
            "bcong;" => "\x{224c}",
            "bcy;" => "\x{431}",
            "bdquo;" => "\x{201e}",
            "becaus;" => "\x{2235}",
            "because;" => "\x{2235}",
            "bemptyv;" => "\x{29b0}",
            "bepsi;" => "\x{3f6}",
            "bernou;" => "\x{212c}",
            "beta;" => "\x{3b2}",
            "beth;" => "\x{2136}",
            "between;" => "\x{226c}",
            "bfr;" => "\x{1d51f}",
            "bigcap;" => "\x{22c2}",
            "bigcirc;" => "\x{25ef}",
            "bigcup;" => "\x{22c3}",
            "bigodot;" => "\x{2a00}",
            "bigoplus;" => "\x{2a01}",
            "bigotimes;" => "\x{2a02}",
            "bigsqcup;" => "\x{2a06}",
            "bigstar;" => "\x{2605}",
            "bigtriangledown;" => "\x{25bd}",
            "bigtriangleup;" => "\x{25b3}",
            "biguplus;" => "\x{2a04}",
            "bigvee;" => "\x{22c1}",
            "bigwedge;" => "\x{22c0}",
            "bkarow;" => "\x{290d}",
            "blacklozenge;" => "\x{29eb}",
            "blacksquare;" => "\x{25aa}",
            "blacktriangle;" => "\x{25b4}",
            "blacktriangledown;" => "\x{25be}",
            "blacktriangleleft;" => "\x{25c2}",
            "blacktriangleright;" => "\x{25b8}",
            "blank;" => "\x{2423}",
            "blk12;" => "\x{2592}",
            "blk14;" => "\x{2591}",
            "blk34;" => "\x{2593}",
            "block;" => "\x{2588}",
            "bne;" => "=\x{20e5}",
            "bnequiv;" => "\x{2261}\x{20e5}",
            "bnot;" => "\x{2310}",
            "bopf;" => "\x{1d553}",
            "bot;" => "\x{22a5}",
            "bottom;" => "\x{22a5}",
            "bowtie;" => "\x{22c8}",
            "boxDL;" => "\x{2557}",
            "boxDR;" => "\x{2554}",
            "boxDl;" => "\x{2556}",
            "boxDr;" => "\x{2553}",
            "boxH;" => "\x{2550}",
            "boxHD;" => "\x{2566}",
            "boxHU;" => "\x{2569}",
            "boxHd;" => "\x{2564}",
            "boxHu;" => "\x{2567}",
            "boxUL;" => "\x{255d}",
            "boxUR;" => "\x{255a}",
            "boxUl;" => "\x{255c}",
            "boxUr;" => "\x{2559}",
            "boxV;" => "\x{2551}",
            "boxVH;" => "\x{256c}",
            "boxVL;" => "\x{2563}",
            "boxVR;" => "\x{2560}",
            "boxVh;" => "\x{256b}",
            "boxVl;" => "\x{2562}",
            "boxVr;" => "\x{255f}",
            "boxbox;" => "\x{29c9}",
            "boxdL;" => "\x{2555}",
            "boxdR;" => "\x{2552}",
            "boxdl;" => "\x{2510}",
            "boxdr;" => "\x{250c}",
            "boxh;" => "\x{2500}",
            "boxhD;" => "\x{2565}",
            "boxhU;" => "\x{2568}",
            "boxhd;" => "\x{252c}",
            "boxhu;" => "\x{2534}",
            "boxminus;" => "\x{229f}",
            "boxplus;" => "\x{229e}",
            "boxtimes;" => "\x{22a0}",
            "boxuL;" => "\x{255b}",
            "boxuR;" => "\x{2558}",
            "boxul;" => "\x{2518}",
            "boxur;" => "\x{2514}",
            "boxv;" => "\x{2502}",
            "boxvH;" => "\x{256a}",
            "boxvL;" => "\x{2561}",
            "boxvR;" => "\x{255e}",
            "boxvh;" => "\x{253c}",
            "boxvl;" => "\x{2524}",
            "boxvr;" => "\x{251c}",
            "bprime;" => "\x{2035}",
            "breve;" => "\x{2d8}",
            "brvbar" => "\x{a6}",
            "brvbar;" => "\x{a6}",
            "bscr;" => "\x{1d4b7}",
            "bsemi;" => "\x{204f}",
            "bsim;" => "\x{223d}",
            "bsime;" => "\x{22cd}",
            "bsol;" => "\\",
            "bsolb;" => "\x{29c5}",
            "bsolhsub;" => "\x{27c8}",
            "bull;" => "\x{2022}",
            "bullet;" => "\x{2022}",
            "bump;" => "\x{224e}",
            "bumpE;" => "\x{2aae}",
            "bumpe;" => "\x{224f}",
            "bumpeq;" => "\x{224f}",
            "cacute;" => "\x{107}",
            "cap;" => "\x{2229}",
            "capand;" => "\x{2a44}",
            "capbrcup;" => "\x{2a49}",
            "capcap;" => "\x{2a4b}",
            "capcup;" => "\x{2a47}",
            "capdot;" => "\x{2a40}",
            "caps;" => "\x{2229}\x{fe00}",
            "caret;" => "\x{2041}",
            "caron;" => "\x{2c7}",
            "ccaps;" => "\x{2a4d}",
            "ccaron;" => "\x{10d}",
            "ccedil" => "\x{e7}",
            "ccedil;" => "\x{e7}",
            "ccirc;" => "\x{109}",
            "ccups;" => "\x{2a4c}",
            "ccupssm;" => "\x{2a50}",
            "cdot;" => "\x{10b}",
            "cedil" => "\x{b8}",
            "cedil;" => "\x{b8}",
            "cemptyv;" => "\x{29b2}",
            "cent" => "\x{a2}",
            "cent;" => "\x{a2}",
            "centerdot;" => "\x{b7}",
            "cfr;" => "\x{1d520}",
            "chcy;" => "\x{447}",
            "check;" => "\x{2713}",
            "checkmark;" => "\x{2713}",
            "chi;" => "\x{3c7}",
            "cir;" => "\x{25cb}",
            "cirE;" => "\x{29c3}",
            "circ;" => "\x{2c6}",
            "circeq;" => "\x{2257}",
            "circlearrowleft;" => "\x{21ba}",
            "circlearrowright;" => "\x{21bb}",
            "circledR;" => "\x{ae}",
            "circledS;" => "\x{24c8}",
            "circledast;" => "\x{229b}",
            "circledcirc;" => "\x{229a}",
            "circleddash;" => "\x{229d}",
            "cire;" => "\x{2257}",
            "cirfnint;" => "\x{2a10}",
            "cirmid;" => "\x{2aef}",
            "cirscir;" => "\x{29c2}",
            "clubs;" => "\x{2663}",
            "clubsuit;" => "\x{2663}",
            "colon;" => ":",
            "colone;" => "\x{2254}",
            "coloneq;" => "\x{2254}",
            "comma;" => ",",
            "commat;" => "\@",
            "comp;" => "\x{2201}",
            "compfn;" => "\x{2218}",
            "complement;" => "\x{2201}",
            "complexes;" => "\x{2102}",
            "cong;" => "\x{2245}",
            "congdot;" => "\x{2a6d}",
            "conint;" => "\x{222e}",
            "copf;" => "\x{1d554}",
            "coprod;" => "\x{2210}",
            "copy" => "\x{a9}",
            "copy;" => "\x{a9}",
            "copysr;" => "\x{2117}",
            "crarr;" => "\x{21b5}",
            "cross;" => "\x{2717}",
            "cscr;" => "\x{1d4b8}",
            "csub;" => "\x{2acf}",
            "csube;" => "\x{2ad1}",
            "csup;" => "\x{2ad0}",
            "csupe;" => "\x{2ad2}",
            "ctdot;" => "\x{22ef}",
            "cudarrl;" => "\x{2938}",
            "cudarrr;" => "\x{2935}",
            "cuepr;" => "\x{22de}",
            "cuesc;" => "\x{22df}",
            "cularr;" => "\x{21b6}",
            "cularrp;" => "\x{293d}",
            "cup;" => "\x{222a}",
            "cupbrcap;" => "\x{2a48}",
            "cupcap;" => "\x{2a46}",
            "cupcup;" => "\x{2a4a}",
            "cupdot;" => "\x{228d}",
            "cupor;" => "\x{2a45}",
            "cups;" => "\x{222a}\x{fe00}",
            "curarr;" => "\x{21b7}",
            "curarrm;" => "\x{293c}",
            "curlyeqprec;" => "\x{22de}",
            "curlyeqsucc;" => "\x{22df}",
            "curlyvee;" => "\x{22ce}",
            "curlywedge;" => "\x{22cf}",
            "curren" => "\x{a4}",
            "curren;" => "\x{a4}",
            "curvearrowleft;" => "\x{21b6}",
            "curvearrowright;" => "\x{21b7}",
            "cuvee;" => "\x{22ce}",
            "cuwed;" => "\x{22cf}",
            "cwconint;" => "\x{2232}",
            "cwint;" => "\x{2231}",
            "cylcty;" => "\x{232d}",
            "dArr;" => "\x{21d3}",
            "dHar;" => "\x{2965}",
            "dagger;" => "\x{2020}",
            "daleth;" => "\x{2138}",
            "darr;" => "\x{2193}",
            "dash;" => "\x{2010}",
            "dashv;" => "\x{22a3}",
            "dbkarow;" => "\x{290f}",
            "dblac;" => "\x{2dd}",
            "dcaron;" => "\x{10f}",
            "dcy;" => "\x{434}",
            "dd;" => "\x{2146}",
            "ddagger;" => "\x{2021}",
            "ddarr;" => "\x{21ca}",
            "ddotseq;" => "\x{2a77}",
            "deg" => "\x{b0}",
            "deg;" => "\x{b0}",
            "delta;" => "\x{3b4}",
            "demptyv;" => "\x{29b1}",
            "dfisht;" => "\x{297f}",
            "dfr;" => "\x{1d521}",
            "dharl;" => "\x{21c3}",
            "dharr;" => "\x{21c2}",
            "diam;" => "\x{22c4}",
            "diamond;" => "\x{22c4}",
            "diamondsuit;" => "\x{2666}",
            "diams;" => "\x{2666}",
            "die;" => "\x{a8}",
            "digamma;" => "\x{3dd}",
            "disin;" => "\x{22f2}",
            "div;" => "\x{f7}",
            "divide" => "\x{f7}",
            "divide;" => "\x{f7}",
            "divideontimes;" => "\x{22c7}",
            "divonx;" => "\x{22c7}",
            "djcy;" => "\x{452}",
            "dlcorn;" => "\x{231e}",
            "dlcrop;" => "\x{230d}",
            "dollar;" => "\$",
            "dopf;" => "\x{1d555}",
            "dot;" => "\x{2d9}",
            "doteq;" => "\x{2250}",
            "doteqdot;" => "\x{2251}",
            "dotminus;" => "\x{2238}",
            "dotplus;" => "\x{2214}",
            "dotsquare;" => "\x{22a1}",
            "doublebarwedge;" => "\x{2306}",
            "downarrow;" => "\x{2193}",
            "downdownarrows;" => "\x{21ca}",
            "downharpoonleft;" => "\x{21c3}",
            "downharpoonright;" => "\x{21c2}",
            "drbkarow;" => "\x{2910}",
            "drcorn;" => "\x{231f}",
            "drcrop;" => "\x{230c}",
            "dscr;" => "\x{1d4b9}",
            "dscy;" => "\x{455}",
            "dsol;" => "\x{29f6}",
            "dstrok;" => "\x{111}",
            "dtdot;" => "\x{22f1}",
            "dtri;" => "\x{25bf}",
            "dtrif;" => "\x{25be}",
            "duarr;" => "\x{21f5}",
            "duhar;" => "\x{296f}",
            "dwangle;" => "\x{29a6}",
            "dzcy;" => "\x{45f}",
            "dzigrarr;" => "\x{27ff}",
            "eDDot;" => "\x{2a77}",
            "eDot;" => "\x{2251}",
            "eacute" => "\x{e9}",
            "eacute;" => "\x{e9}",
            "easter;" => "\x{2a6e}",
            "ecaron;" => "\x{11b}",
            "ecir;" => "\x{2256}",
            "ecirc" => "\x{ea}",
            "ecirc;" => "\x{ea}",
            "ecolon;" => "\x{2255}",
            "ecy;" => "\x{44d}",
            "edot;" => "\x{117}",
            "ee;" => "\x{2147}",
            "efDot;" => "\x{2252}",
            "efr;" => "\x{1d522}",
            "eg;" => "\x{2a9a}",
            "egrave" => "\x{e8}",
            "egrave;" => "\x{e8}",
            "egs;" => "\x{2a96}",
            "egsdot;" => "\x{2a98}",
            "el;" => "\x{2a99}",
            "elinters;" => "\x{23e7}",
            "ell;" => "\x{2113}",
            "els;" => "\x{2a95}",
            "elsdot;" => "\x{2a97}",
            "emacr;" => "\x{113}",
            "empty;" => "\x{2205}",
            "emptyset;" => "\x{2205}",
            "emptyv;" => "\x{2205}",
            "emsp13;" => "\x{2004}",
            "emsp14;" => "\x{2005}",
            "emsp;" => "\x{2003}",
            "eng;" => "\x{14b}",
            "ensp;" => "\x{2002}",
            "eogon;" => "\x{119}",
            "eopf;" => "\x{1d556}",
            "epar;" => "\x{22d5}",
            "eparsl;" => "\x{29e3}",
            "eplus;" => "\x{2a71}",
            "epsi;" => "\x{3b5}",
            "epsilon;" => "\x{3b5}",
            "epsiv;" => "\x{3f5}",
            "eqcirc;" => "\x{2256}",
            "eqcolon;" => "\x{2255}",
            "eqsim;" => "\x{2242}",
            "eqslantgtr;" => "\x{2a96}",
            "eqslantless;" => "\x{2a95}",
            "equals;" => "=",
            "equest;" => "\x{225f}",
            "equiv;" => "\x{2261}",
            "equivDD;" => "\x{2a78}",
            "eqvparsl;" => "\x{29e5}",
            "erDot;" => "\x{2253}",
            "erarr;" => "\x{2971}",
            "escr;" => "\x{212f}",
            "esdot;" => "\x{2250}",
            "esim;" => "\x{2242}",
            "eta;" => "\x{3b7}",
            "eth" => "\x{f0}",
            "eth;" => "\x{f0}",
            "euml" => "\x{eb}",
            "euml;" => "\x{eb}",
            "euro;" => "\x{20ac}",
            "excl;" => "!",
            "exist;" => "\x{2203}",
            "expectation;" => "\x{2130}",
            "exponentiale;" => "\x{2147}",
            "fallingdotseq;" => "\x{2252}",
            "fcy;" => "\x{444}",
            "female;" => "\x{2640}",
            "ffilig;" => "\x{fb03}",
            "fflig;" => "\x{fb00}",
            "ffllig;" => "\x{fb04}",
            "ffr;" => "\x{1d523}",
            "filig;" => "\x{fb01}",
            "fjlig;" => "fj",
            "flat;" => "\x{266d}",
            "fllig;" => "\x{fb02}",
            "fltns;" => "\x{25b1}",
            "fnof;" => "\x{192}",
            "fopf;" => "\x{1d557}",
            "forall;" => "\x{2200}",
            "fork;" => "\x{22d4}",
            "forkv;" => "\x{2ad9}",
            "fpartint;" => "\x{2a0d}",
            "frac12" => "\x{bd}",
            "frac12;" => "\x{bd}",
            "frac13;" => "\x{2153}",
            "frac14" => "\x{bc}",
            "frac14;" => "\x{bc}",
            "frac15;" => "\x{2155}",
            "frac16;" => "\x{2159}",
            "frac18;" => "\x{215b}",
            "frac23;" => "\x{2154}",
            "frac25;" => "\x{2156}",
            "frac34" => "\x{be}",
            "frac34;" => "\x{be}",
            "frac35;" => "\x{2157}",
            "frac38;" => "\x{215c}",
            "frac45;" => "\x{2158}",
            "frac56;" => "\x{215a}",
            "frac58;" => "\x{215d}",
            "frac78;" => "\x{215e}",
            "frasl;" => "\x{2044}",
            "frown;" => "\x{2322}",
            "fscr;" => "\x{1d4bb}",
            "gE;" => "\x{2267}",
            "gEl;" => "\x{2a8c}",
            "gacute;" => "\x{1f5}",
            "gamma;" => "\x{3b3}",
            "gammad;" => "\x{3dd}",
            "gap;" => "\x{2a86}",
            "gbreve;" => "\x{11f}",
            "gcirc;" => "\x{11d}",
            "gcy;" => "\x{433}",
            "gdot;" => "\x{121}",
            "ge;" => "\x{2265}",
            "gel;" => "\x{22db}",
            "geq;" => "\x{2265}",
            "geqq;" => "\x{2267}",
            "geqslant;" => "\x{2a7e}",
            "ges;" => "\x{2a7e}",
            "gescc;" => "\x{2aa9}",
            "gesdot;" => "\x{2a80}",
            "gesdoto;" => "\x{2a82}",
            "gesdotol;" => "\x{2a84}",
            "gesl;" => "\x{22db}\x{fe00}",
            "gesles;" => "\x{2a94}",
            "gfr;" => "\x{1d524}",
            "gg;" => "\x{226b}",
            "ggg;" => "\x{22d9}",
            "gimel;" => "\x{2137}",
            "gjcy;" => "\x{453}",
            "gl;" => "\x{2277}",
            "glE;" => "\x{2a92}",
            "gla;" => "\x{2aa5}",
            "glj;" => "\x{2aa4}",
            "gnE;" => "\x{2269}",
            "gnap;" => "\x{2a8a}",
            "gnapprox;" => "\x{2a8a}",
            "gne;" => "\x{2a88}",
            "gneq;" => "\x{2a88}",
            "gneqq;" => "\x{2269}",
            "gnsim;" => "\x{22e7}",
            "gopf;" => "\x{1d558}",
            "grave;" => "`",
            "gscr;" => "\x{210a}",
            "gsim;" => "\x{2273}",
            "gsime;" => "\x{2a8e}",
            "gsiml;" => "\x{2a90}",
            "gt" => ">",
            "gt;" => ">",
            "gtcc;" => "\x{2aa7}",
            "gtcir;" => "\x{2a7a}",
            "gtdot;" => "\x{22d7}",
            "gtlPar;" => "\x{2995}",
            "gtquest;" => "\x{2a7c}",
            "gtrapprox;" => "\x{2a86}",
            "gtrarr;" => "\x{2978}",
            "gtrdot;" => "\x{22d7}",
            "gtreqless;" => "\x{22db}",
            "gtreqqless;" => "\x{2a8c}",
            "gtrless;" => "\x{2277}",
            "gtrsim;" => "\x{2273}",
            "gvertneqq;" => "\x{2269}\x{fe00}",
            "gvnE;" => "\x{2269}\x{fe00}",
            "hArr;" => "\x{21d4}",
            "hairsp;" => "\x{200a}",
            "half;" => "\x{bd}",
            "hamilt;" => "\x{210b}",
            "hardcy;" => "\x{44a}",
            "harr;" => "\x{2194}",
            "harrcir;" => "\x{2948}",
            "harrw;" => "\x{21ad}",
            "hbar;" => "\x{210f}",
            "hcirc;" => "\x{125}",
            "hearts;" => "\x{2665}",
            "heartsuit;" => "\x{2665}",
            "hellip;" => "\x{2026}",
            "hercon;" => "\x{22b9}",
            "hfr;" => "\x{1d525}",
            "hksearow;" => "\x{2925}",
            "hkswarow;" => "\x{2926}",
            "hoarr;" => "\x{21ff}",
            "homtht;" => "\x{223b}",
            "hookleftarrow;" => "\x{21a9}",
            "hookrightarrow;" => "\x{21aa}",
            "hopf;" => "\x{1d559}",
            "horbar;" => "\x{2015}",
            "hscr;" => "\x{1d4bd}",
            "hslash;" => "\x{210f}",
            "hstrok;" => "\x{127}",
            "hybull;" => "\x{2043}",
            "hyphen;" => "\x{2010}",
            "iacute" => "\x{ed}",
            "iacute;" => "\x{ed}",
            "ic;" => "\x{2063}",
            "icirc" => "\x{ee}",
            "icirc;" => "\x{ee}",
            "icy;" => "\x{438}",
            "iecy;" => "\x{435}",
            "iexcl" => "\x{a1}",
            "iexcl;" => "\x{a1}",
            "iff;" => "\x{21d4}",
            "ifr;" => "\x{1d526}",
            "igrave" => "\x{ec}",
            "igrave;" => "\x{ec}",
            "ii;" => "\x{2148}",
            "iiiint;" => "\x{2a0c}",
            "iiint;" => "\x{222d}",
            "iinfin;" => "\x{29dc}",
            "iiota;" => "\x{2129}",
            "ijlig;" => "\x{133}",
            "imacr;" => "\x{12b}",
            "image;" => "\x{2111}",
            "imagline;" => "\x{2110}",
            "imagpart;" => "\x{2111}",
            "imath;" => "\x{131}",
            "imof;" => "\x{22b7}",
            "imped;" => "\x{1b5}",
            "in;" => "\x{2208}",
            "incare;" => "\x{2105}",
            "infin;" => "\x{221e}",
            "infintie;" => "\x{29dd}",
            "inodot;" => "\x{131}",
            "int;" => "\x{222b}",
            "intcal;" => "\x{22ba}",
            "integers;" => "\x{2124}",
            "intercal;" => "\x{22ba}",
            "intlarhk;" => "\x{2a17}",
            "intprod;" => "\x{2a3c}",
            "iocy;" => "\x{451}",
            "iogon;" => "\x{12f}",
            "iopf;" => "\x{1d55a}",
            "iota;" => "\x{3b9}",
            "iprod;" => "\x{2a3c}",
            "iquest" => "\x{bf}",
            "iquest;" => "\x{bf}",
            "iscr;" => "\x{1d4be}",
            "isin;" => "\x{2208}",
            "isinE;" => "\x{22f9}",
            "isindot;" => "\x{22f5}",
            "isins;" => "\x{22f4}",
            "isinsv;" => "\x{22f3}",
            "isinv;" => "\x{2208}",
            "it;" => "\x{2062}",
            "itilde;" => "\x{129}",
            "iukcy;" => "\x{456}",
            "iuml" => "\x{ef}",
            "iuml;" => "\x{ef}",
            "jcirc;" => "\x{135}",
            "jcy;" => "\x{439}",
            "jfr;" => "\x{1d527}",
            "jmath;" => "\x{237}",
            "jopf;" => "\x{1d55b}",
            "jscr;" => "\x{1d4bf}",
            "jsercy;" => "\x{458}",
            "jukcy;" => "\x{454}",
            "kappa;" => "\x{3ba}",
            "kappav;" => "\x{3f0}",
            "kcedil;" => "\x{137}",
            "kcy;" => "\x{43a}",
            "kfr;" => "\x{1d528}",
            "kgreen;" => "\x{138}",
            "khcy;" => "\x{445}",
            "kjcy;" => "\x{45c}",
            "kopf;" => "\x{1d55c}",
            "kscr;" => "\x{1d4c0}",
            "lAarr;" => "\x{21da}",
            "lArr;" => "\x{21d0}",
            "lAtail;" => "\x{291b}",
            "lBarr;" => "\x{290e}",
            "lE;" => "\x{2266}",
            "lEg;" => "\x{2a8b}",
            "lHar;" => "\x{2962}",
            "lacute;" => "\x{13a}",
            "laemptyv;" => "\x{29b4}",
            "lagran;" => "\x{2112}",
            "lambda;" => "\x{3bb}",
            "lang;" => "\x{27e8}",
            "langd;" => "\x{2991}",
            "langle;" => "\x{27e8}",
            "lap;" => "\x{2a85}",
            "laquo" => "\x{ab}",
            "laquo;" => "\x{ab}",
            "larr;" => "\x{2190}",
            "larrb;" => "\x{21e4}",
            "larrbfs;" => "\x{291f}",
            "larrfs;" => "\x{291d}",
            "larrhk;" => "\x{21a9}",
            "larrlp;" => "\x{21ab}",
            "larrpl;" => "\x{2939}",
            "larrsim;" => "\x{2973}",
            "larrtl;" => "\x{21a2}",
            "lat;" => "\x{2aab}",
            "latail;" => "\x{2919}",
            "late;" => "\x{2aad}",
            "lates;" => "\x{2aad}\x{fe00}",
            "lbarr;" => "\x{290c}",
            "lbbrk;" => "\x{2772}",
            "lbrace;" => "{",
            "lbrack;" => "[",
            "lbrke;" => "\x{298b}",
            "lbrksld;" => "\x{298f}",
            "lbrkslu;" => "\x{298d}",
            "lcaron;" => "\x{13e}",
            "lcedil;" => "\x{13c}",
            "lceil;" => "\x{2308}",
            "lcub;" => "{",
            "lcy;" => "\x{43b}",
            "ldca;" => "\x{2936}",
            "ldquo;" => "\x{201c}",
            "ldquor;" => "\x{201e}",
            "ldrdhar;" => "\x{2967}",
            "ldrushar;" => "\x{294b}",
            "ldsh;" => "\x{21b2}",
            "le;" => "\x{2264}",
            "leftarrow;" => "\x{2190}",
            "leftarrowtail;" => "\x{21a2}",
            "leftharpoondown;" => "\x{21bd}",
            "leftharpoonup;" => "\x{21bc}",
            "leftleftarrows;" => "\x{21c7}",
            "leftrightarrow;" => "\x{2194}",
            "leftrightarrows;" => "\x{21c6}",
            "leftrightharpoons;" => "\x{21cb}",
            "leftrightsquigarrow;" => "\x{21ad}",
            "leftthreetimes;" => "\x{22cb}",
            "leg;" => "\x{22da}",
            "leq;" => "\x{2264}",
            "leqq;" => "\x{2266}",
            "leqslant;" => "\x{2a7d}",
            "les;" => "\x{2a7d}",
            "lescc;" => "\x{2aa8}",
            "lesdot;" => "\x{2a7f}",
            "lesdoto;" => "\x{2a81}",
            "lesdotor;" => "\x{2a83}",
            "lesg;" => "\x{22da}\x{fe00}",
            "lesges;" => "\x{2a93}",
            "lessapprox;" => "\x{2a85}",
            "lessdot;" => "\x{22d6}",
            "lesseqgtr;" => "\x{22da}",
            "lesseqqgtr;" => "\x{2a8b}",
            "lessgtr;" => "\x{2276}",
            "lesssim;" => "\x{2272}",
            "lfisht;" => "\x{297c}",
            "lfloor;" => "\x{230a}",
            "lfr;" => "\x{1d529}",
            "lg;" => "\x{2276}",
            "lgE;" => "\x{2a91}",
            "lhard;" => "\x{21bd}",
            "lharu;" => "\x{21bc}",
            "lharul;" => "\x{296a}",
            "lhblk;" => "\x{2584}",
            "ljcy;" => "\x{459}",
            "ll;" => "\x{226a}",
            "llarr;" => "\x{21c7}",
            "llcorner;" => "\x{231e}",
            "llhard;" => "\x{296b}",
            "lltri;" => "\x{25fa}",
            "lmidot;" => "\x{140}",
            "lmoust;" => "\x{23b0}",
            "lmoustache;" => "\x{23b0}",
            "lnE;" => "\x{2268}",
            "lnap;" => "\x{2a89}",
            "lnapprox;" => "\x{2a89}",
            "lne;" => "\x{2a87}",
            "lneq;" => "\x{2a87}",
            "lneqq;" => "\x{2268}",
            "lnsim;" => "\x{22e6}",
            "loang;" => "\x{27ec}",
            "loarr;" => "\x{21fd}",
            "lobrk;" => "\x{27e6}",
            "longleftarrow;" => "\x{27f5}",
            "longleftrightarrow;" => "\x{27f7}",
            "longmapsto;" => "\x{27fc}",
            "longrightarrow;" => "\x{27f6}",
            "looparrowleft;" => "\x{21ab}",
            "looparrowright;" => "\x{21ac}",
            "lopar;" => "\x{2985}",
            "lopf;" => "\x{1d55d}",
            "loplus;" => "\x{2a2d}",
            "lotimes;" => "\x{2a34}",
            "lowast;" => "\x{2217}",
            "lowbar;" => "_",
            "loz;" => "\x{25ca}",
            "lozenge;" => "\x{25ca}",
            "lozf;" => "\x{29eb}",
            "lpar;" => "(",
            "lparlt;" => "\x{2993}",
            "lrarr;" => "\x{21c6}",
            "lrcorner;" => "\x{231f}",
            "lrhar;" => "\x{21cb}",
            "lrhard;" => "\x{296d}",
            "lrm;" => "\x{200e}",
            "lrtri;" => "\x{22bf}",
            "lsaquo;" => "\x{2039}",
            "lscr;" => "\x{1d4c1}",
            "lsh;" => "\x{21b0}",
            "lsim;" => "\x{2272}",
            "lsime;" => "\x{2a8d}",
            "lsimg;" => "\x{2a8f}",
            "lsqb;" => "[",
            "lsquo;" => "\x{2018}",
            "lsquor;" => "\x{201a}",
            "lstrok;" => "\x{142}",
            "lt" => "<",
            "lt;" => "<",
            "ltcc;" => "\x{2aa6}",
            "ltcir;" => "\x{2a79}",
            "ltdot;" => "\x{22d6}",
            "lthree;" => "\x{22cb}",
            "ltimes;" => "\x{22c9}",
            "ltlarr;" => "\x{2976}",
            "ltquest;" => "\x{2a7b}",
            "ltrPar;" => "\x{2996}",
            "ltri;" => "\x{25c3}",
            "ltrie;" => "\x{22b4}",
            "ltrif;" => "\x{25c2}",
            "lurdshar;" => "\x{294a}",
            "luruhar;" => "\x{2966}",
            "lvertneqq;" => "\x{2268}\x{fe00}",
            "lvnE;" => "\x{2268}\x{fe00}",
            "mDDot;" => "\x{223a}",
            "macr" => "\x{af}",
            "macr;" => "\x{af}",
            "male;" => "\x{2642}",
            "malt;" => "\x{2720}",
            "maltese;" => "\x{2720}",
            "map;" => "\x{21a6}",
            "mapsto;" => "\x{21a6}",
            "mapstodown;" => "\x{21a7}",
            "mapstoleft;" => "\x{21a4}",
            "mapstoup;" => "\x{21a5}",
            "marker;" => "\x{25ae}",
            "mcomma;" => "\x{2a29}",
            "mcy;" => "\x{43c}",
            "mdash;" => "\x{2014}",
            "measuredangle;" => "\x{2221}",
            "mfr;" => "\x{1d52a}",
            "mho;" => "\x{2127}",
            "micro" => "\x{b5}",
            "micro;" => "\x{b5}",
            "mid;" => "\x{2223}",
            "midast;" => "*",
            "midcir;" => "\x{2af0}",
            "middot" => "\x{b7}",
            "middot;" => "\x{b7}",
            "minus;" => "\x{2212}",
            "minusb;" => "\x{229f}",
            "minusd;" => "\x{2238}",
            "minusdu;" => "\x{2a2a}",
            "mlcp;" => "\x{2adb}",
            "mldr;" => "\x{2026}",
            "mnplus;" => "\x{2213}",
            "models;" => "\x{22a7}",
            "mopf;" => "\x{1d55e}",
            "mp;" => "\x{2213}",
            "mscr;" => "\x{1d4c2}",
            "mstpos;" => "\x{223e}",
            "mu;" => "\x{3bc}",
            "multimap;" => "\x{22b8}",
            "mumap;" => "\x{22b8}",
            "nGg;" => "\x{22d9}\x{338}",
            "nGt;" => "\x{226b}\x{20d2}",
            "nGtv;" => "\x{226b}\x{338}",
            "nLeftarrow;" => "\x{21cd}",
            "nLeftrightarrow;" => "\x{21ce}",
            "nLl;" => "\x{22d8}\x{338}",
            "nLt;" => "\x{226a}\x{20d2}",
            "nLtv;" => "\x{226a}\x{338}",
            "nRightarrow;" => "\x{21cf}",
            "nVDash;" => "\x{22af}",
            "nVdash;" => "\x{22ae}",
            "nabla;" => "\x{2207}",
            "nacute;" => "\x{144}",
            "nang;" => "\x{2220}\x{20d2}",
            "nap;" => "\x{2249}",
            "napE;" => "\x{2a70}\x{338}",
            "napid;" => "\x{224b}\x{338}",
            "napos;" => "\x{149}",
            "napprox;" => "\x{2249}",
            "natur;" => "\x{266e}",
            "natural;" => "\x{266e}",
            "naturals;" => "\x{2115}",
            "nbsp" => "\x{a0}",
            "nbsp;" => "\x{a0}",
            "nbump;" => "\x{224e}\x{338}",
            "nbumpe;" => "\x{224f}\x{338}",
            "ncap;" => "\x{2a43}",
            "ncaron;" => "\x{148}",
            "ncedil;" => "\x{146}",
            "ncong;" => "\x{2247}",
            "ncongdot;" => "\x{2a6d}\x{338}",
            "ncup;" => "\x{2a42}",
            "ncy;" => "\x{43d}",
            "ndash;" => "\x{2013}",
            "ne;" => "\x{2260}",
            "neArr;" => "\x{21d7}",
            "nearhk;" => "\x{2924}",
            "nearr;" => "\x{2197}",
            "nearrow;" => "\x{2197}",
            "nedot;" => "\x{2250}\x{338}",
            "nequiv;" => "\x{2262}",
            "nesear;" => "\x{2928}",
            "nesim;" => "\x{2242}\x{338}",
            "nexist;" => "\x{2204}",
            "nexists;" => "\x{2204}",
            "nfr;" => "\x{1d52b}",
            "ngE;" => "\x{2267}\x{338}",
            "nge;" => "\x{2271}",
            "ngeq;" => "\x{2271}",
            "ngeqq;" => "\x{2267}\x{338}",
            "ngeqslant;" => "\x{2a7e}\x{338}",
            "nges;" => "\x{2a7e}\x{338}",
            "ngsim;" => "\x{2275}",
            "ngt;" => "\x{226f}",
            "ngtr;" => "\x{226f}",
            "nhArr;" => "\x{21ce}",
            "nharr;" => "\x{21ae}",
            "nhpar;" => "\x{2af2}",
            "ni;" => "\x{220b}",
            "nis;" => "\x{22fc}",
            "nisd;" => "\x{22fa}",
            "niv;" => "\x{220b}",
            "njcy;" => "\x{45a}",
            "nlArr;" => "\x{21cd}",
            "nlE;" => "\x{2266}\x{338}",
            "nlarr;" => "\x{219a}",
            "nldr;" => "\x{2025}",
            "nle;" => "\x{2270}",
            "nleftarrow;" => "\x{219a}",
            "nleftrightarrow;" => "\x{21ae}",
            "nleq;" => "\x{2270}",
            "nleqq;" => "\x{2266}\x{338}",
            "nleqslant;" => "\x{2a7d}\x{338}",
            "nles;" => "\x{2a7d}\x{338}",
            "nless;" => "\x{226e}",
            "nlsim;" => "\x{2274}",
            "nlt;" => "\x{226e}",
            "nltri;" => "\x{22ea}",
            "nltrie;" => "\x{22ec}",
            "nmid;" => "\x{2224}",
            "nopf;" => "\x{1d55f}",
            "not" => "\x{ac}",
            "not;" => "\x{ac}",
            "notin;" => "\x{2209}",
            "notinE;" => "\x{22f9}\x{338}",
            "notindot;" => "\x{22f5}\x{338}",
            "notinva;" => "\x{2209}",
            "notinvb;" => "\x{22f7}",
            "notinvc;" => "\x{22f6}",
            "notni;" => "\x{220c}",
            "notniva;" => "\x{220c}",
            "notnivb;" => "\x{22fe}",
            "notnivc;" => "\x{22fd}",
            "npar;" => "\x{2226}",
            "nparallel;" => "\x{2226}",
            "nparsl;" => "\x{2afd}\x{20e5}",
            "npart;" => "\x{2202}\x{338}",
            "npolint;" => "\x{2a14}",
            "npr;" => "\x{2280}",
            "nprcue;" => "\x{22e0}",
            "npre;" => "\x{2aaf}\x{338}",
            "nprec;" => "\x{2280}",
            "npreceq;" => "\x{2aaf}\x{338}",
            "nrArr;" => "\x{21cf}",
            "nrarr;" => "\x{219b}",
            "nrarrc;" => "\x{2933}\x{338}",
            "nrarrw;" => "\x{219d}\x{338}",
            "nrightarrow;" => "\x{219b}",
            "nrtri;" => "\x{22eb}",
            "nrtrie;" => "\x{22ed}",
            "nsc;" => "\x{2281}",
            "nsccue;" => "\x{22e1}",
            "nsce;" => "\x{2ab0}\x{338}",
            "nscr;" => "\x{1d4c3}",
            "nshortmid;" => "\x{2224}",
            "nshortparallel;" => "\x{2226}",
            "nsim;" => "\x{2241}",
            "nsime;" => "\x{2244}",
            "nsimeq;" => "\x{2244}",
            "nsmid;" => "\x{2224}",
            "nspar;" => "\x{2226}",
            "nsqsube;" => "\x{22e2}",
            "nsqsupe;" => "\x{22e3}",
            "nsub;" => "\x{2284}",
            "nsubE;" => "\x{2ac5}\x{338}",
            "nsube;" => "\x{2288}",
            "nsubset;" => "\x{2282}\x{20d2}",
            "nsubseteq;" => "\x{2288}",
            "nsubseteqq;" => "\x{2ac5}\x{338}",
            "nsucc;" => "\x{2281}",
            "nsucceq;" => "\x{2ab0}\x{338}",
            "nsup;" => "\x{2285}",
            "nsupE;" => "\x{2ac6}\x{338}",
            "nsupe;" => "\x{2289}",
            "nsupset;" => "\x{2283}\x{20d2}",
            "nsupseteq;" => "\x{2289}",
            "nsupseteqq;" => "\x{2ac6}\x{338}",
            "ntgl;" => "\x{2279}",
            "ntilde" => "\x{f1}",
            "ntilde;" => "\x{f1}",
            "ntlg;" => "\x{2278}",
            "ntriangleleft;" => "\x{22ea}",
            "ntrianglelefteq;" => "\x{22ec}",
            "ntriangleright;" => "\x{22eb}",
            "ntrianglerighteq;" => "\x{22ed}",
            "nu;" => "\x{3bd}",
            "num;" => "#",
            "numero;" => "\x{2116}",
            "numsp;" => "\x{2007}",
            "nvDash;" => "\x{22ad}",
            "nvHarr;" => "\x{2904}",
            "nvap;" => "\x{224d}\x{20d2}",
            "nvdash;" => "\x{22ac}",
            "nvge;" => "\x{2265}\x{20d2}",
            "nvgt;" => ">\x{20d2}",
            "nvinfin;" => "\x{29de}",
            "nvlArr;" => "\x{2902}",
            "nvle;" => "\x{2264}\x{20d2}",
            "nvlt;" => "<\x{20d2}",
            "nvltrie;" => "\x{22b4}\x{20d2}",
            "nvrArr;" => "\x{2903}",
            "nvrtrie;" => "\x{22b5}\x{20d2}",
            "nvsim;" => "\x{223c}\x{20d2}",
            "nwArr;" => "\x{21d6}",
            "nwarhk;" => "\x{2923}",
            "nwarr;" => "\x{2196}",
            "nwarrow;" => "\x{2196}",
            "nwnear;" => "\x{2927}",
            "oS;" => "\x{24c8}",
            "oacute" => "\x{f3}",
            "oacute;" => "\x{f3}",
            "oast;" => "\x{229b}",
            "ocir;" => "\x{229a}",
            "ocirc" => "\x{f4}",
            "ocirc;" => "\x{f4}",
            "ocy;" => "\x{43e}",
            "odash;" => "\x{229d}",
            "odblac;" => "\x{151}",
            "odiv;" => "\x{2a38}",
            "odot;" => "\x{2299}",
            "odsold;" => "\x{29bc}",
            "oelig;" => "\x{153}",
            "ofcir;" => "\x{29bf}",
            "ofr;" => "\x{1d52c}",
            "ogon;" => "\x{2db}",
            "ograve" => "\x{f2}",
            "ograve;" => "\x{f2}",
            "ogt;" => "\x{29c1}",
            "ohbar;" => "\x{29b5}",
            "ohm;" => "\x{3a9}",
            "oint;" => "\x{222e}",
            "olarr;" => "\x{21ba}",
            "olcir;" => "\x{29be}",
            "olcross;" => "\x{29bb}",
            "oline;" => "\x{203e}",
            "olt;" => "\x{29c0}",
            "omacr;" => "\x{14d}",
            "omega;" => "\x{3c9}",
            "omicron;" => "\x{3bf}",
            "omid;" => "\x{29b6}",
            "ominus;" => "\x{2296}",
            "oopf;" => "\x{1d560}",
            "opar;" => "\x{29b7}",
            "operp;" => "\x{29b9}",
            "oplus;" => "\x{2295}",
            "or;" => "\x{2228}",
            "orarr;" => "\x{21bb}",
            "ord;" => "\x{2a5d}",
            "order;" => "\x{2134}",
            "orderof;" => "\x{2134}",
            "ordf" => "\x{aa}",
            "ordf;" => "\x{aa}",
            "ordm" => "\x{ba}",
            "ordm;" => "\x{ba}",
            "origof;" => "\x{22b6}",
            "oror;" => "\x{2a56}",
            "orslope;" => "\x{2a57}",
            "orv;" => "\x{2a5b}",
            "oscr;" => "\x{2134}",
            "oslash" => "\x{f8}",
            "oslash;" => "\x{f8}",
            "osol;" => "\x{2298}",
            "otilde" => "\x{f5}",
            "otilde;" => "\x{f5}",
            "otimes;" => "\x{2297}",
            "otimesas;" => "\x{2a36}",
            "ouml" => "\x{f6}",
            "ouml;" => "\x{f6}",
            "ovbar;" => "\x{233d}",
            "par;" => "\x{2225}",
            "para" => "\x{b6}",
            "para;" => "\x{b6}",
            "parallel;" => "\x{2225}",
            "parsim;" => "\x{2af3}",
            "parsl;" => "\x{2afd}",
            "part;" => "\x{2202}",
            "pcy;" => "\x{43f}",
            "percnt;" => "%",
            "period;" => ".",
            "permil;" => "\x{2030}",
            "perp;" => "\x{22a5}",
            "pertenk;" => "\x{2031}",
            "pfr;" => "\x{1d52d}",
            "phi;" => "\x{3c6}",
            "phiv;" => "\x{3d5}",
            "phmmat;" => "\x{2133}",
            "phone;" => "\x{260e}",
            "pi;" => "\x{3c0}",
            "pitchfork;" => "\x{22d4}",
            "piv;" => "\x{3d6}",
            "planck;" => "\x{210f}",
            "planckh;" => "\x{210e}",
            "plankv;" => "\x{210f}",
            "plus;" => "+",
            "plusacir;" => "\x{2a23}",
            "plusb;" => "\x{229e}",
            "pluscir;" => "\x{2a22}",
            "plusdo;" => "\x{2214}",
            "plusdu;" => "\x{2a25}",
            "pluse;" => "\x{2a72}",
            "plusmn" => "\x{b1}",
            "plusmn;" => "\x{b1}",
            "plussim;" => "\x{2a26}",
            "plustwo;" => "\x{2a27}",
            "pm;" => "\x{b1}",
            "pointint;" => "\x{2a15}",
            "popf;" => "\x{1d561}",
            "pound" => "\x{a3}",
            "pound;" => "\x{a3}",
            "pr;" => "\x{227a}",
            "prE;" => "\x{2ab3}",
            "prap;" => "\x{2ab7}",
            "prcue;" => "\x{227c}",
            "pre;" => "\x{2aaf}",
            "prec;" => "\x{227a}",
            "precapprox;" => "\x{2ab7}",
            "preccurlyeq;" => "\x{227c}",
            "preceq;" => "\x{2aaf}",
            "precnapprox;" => "\x{2ab9}",
            "precneqq;" => "\x{2ab5}",
            "precnsim;" => "\x{22e8}",
            "precsim;" => "\x{227e}",
            "prime;" => "\x{2032}",
            "primes;" => "\x{2119}",
            "prnE;" => "\x{2ab5}",
            "prnap;" => "\x{2ab9}",
            "prnsim;" => "\x{22e8}",
            "prod;" => "\x{220f}",
            "profalar;" => "\x{232e}",
            "profline;" => "\x{2312}",
            "profsurf;" => "\x{2313}",
            "prop;" => "\x{221d}",
            "propto;" => "\x{221d}",
            "prsim;" => "\x{227e}",
            "prurel;" => "\x{22b0}",
            "pscr;" => "\x{1d4c5}",
            "psi;" => "\x{3c8}",
            "puncsp;" => "\x{2008}",
            "qfr;" => "\x{1d52e}",
            "qint;" => "\x{2a0c}",
            "qopf;" => "\x{1d562}",
            "qprime;" => "\x{2057}",
            "qscr;" => "\x{1d4c6}",
            "quaternions;" => "\x{210d}",
            "quatint;" => "\x{2a16}",
            "quest;" => "?",
            "questeq;" => "\x{225f}",
            "quot" => "\"",
            "quot;" => "\"",
            "rAarr;" => "\x{21db}",
            "rArr;" => "\x{21d2}",
            "rAtail;" => "\x{291c}",
            "rBarr;" => "\x{290f}",
            "rHar;" => "\x{2964}",
            "race;" => "\x{223d}\x{331}",
            "racute;" => "\x{155}",
            "radic;" => "\x{221a}",
            "raemptyv;" => "\x{29b3}",
            "rang;" => "\x{27e9}",
            "rangd;" => "\x{2992}",
            "range;" => "\x{29a5}",
            "rangle;" => "\x{27e9}",
            "raquo" => "\x{bb}",
            "raquo;" => "\x{bb}",
            "rarr;" => "\x{2192}",
            "rarrap;" => "\x{2975}",
            "rarrb;" => "\x{21e5}",
            "rarrbfs;" => "\x{2920}",
            "rarrc;" => "\x{2933}",
            "rarrfs;" => "\x{291e}",
            "rarrhk;" => "\x{21aa}",
            "rarrlp;" => "\x{21ac}",
            "rarrpl;" => "\x{2945}",
            "rarrsim;" => "\x{2974}",
            "rarrtl;" => "\x{21a3}",
            "rarrw;" => "\x{219d}",
            "ratail;" => "\x{291a}",
            "ratio;" => "\x{2236}",
            "rationals;" => "\x{211a}",
            "rbarr;" => "\x{290d}",
            "rbbrk;" => "\x{2773}",
            "rbrace;" => "}",
            "rbrack;" => "]",
            "rbrke;" => "\x{298c}",
            "rbrksld;" => "\x{298e}",
            "rbrkslu;" => "\x{2990}",
            "rcaron;" => "\x{159}",
            "rcedil;" => "\x{157}",
            "rceil;" => "\x{2309}",
            "rcub;" => "}",
            "rcy;" => "\x{440}",
            "rdca;" => "\x{2937}",
            "rdldhar;" => "\x{2969}",
            "rdquo;" => "\x{201d}",
            "rdquor;" => "\x{201d}",
            "rdsh;" => "\x{21b3}",
            "real;" => "\x{211c}",
            "realine;" => "\x{211b}",
            "realpart;" => "\x{211c}",
            "reals;" => "\x{211d}",
            "rect;" => "\x{25ad}",
            "reg" => "\x{ae}",
            "reg;" => "\x{ae}",
            "rfisht;" => "\x{297d}",
            "rfloor;" => "\x{230b}",
            "rfr;" => "\x{1d52f}",
            "rhard;" => "\x{21c1}",
            "rharu;" => "\x{21c0}",
            "rharul;" => "\x{296c}",
            "rho;" => "\x{3c1}",
            "rhov;" => "\x{3f1}",
            "rightarrow;" => "\x{2192}",
            "rightarrowtail;" => "\x{21a3}",
            "rightharpoondown;" => "\x{21c1}",
            "rightharpoonup;" => "\x{21c0}",
            "rightleftarrows;" => "\x{21c4}",
            "rightleftharpoons;" => "\x{21cc}",
            "rightrightarrows;" => "\x{21c9}",
            "rightsquigarrow;" => "\x{219d}",
            "rightthreetimes;" => "\x{22cc}",
            "ring;" => "\x{2da}",
            "risingdotseq;" => "\x{2253}",
            "rlarr;" => "\x{21c4}",
            "rlhar;" => "\x{21cc}",
            "rlm;" => "\x{200f}",
            "rmoust;" => "\x{23b1}",
            "rmoustache;" => "\x{23b1}",
            "rnmid;" => "\x{2aee}",
            "roang;" => "\x{27ed}",
            "roarr;" => "\x{21fe}",
            "robrk;" => "\x{27e7}",
            "ropar;" => "\x{2986}",
            "ropf;" => "\x{1d563}",
            "roplus;" => "\x{2a2e}",
            "rotimes;" => "\x{2a35}",
            "rpar;" => ")",
            "rpargt;" => "\x{2994}",
            "rppolint;" => "\x{2a12}",
            "rrarr;" => "\x{21c9}",
            "rsaquo;" => "\x{203a}",
            "rscr;" => "\x{1d4c7}",
            "rsh;" => "\x{21b1}",
            "rsqb;" => "]",
            "rsquo;" => "\x{2019}",
            "rsquor;" => "\x{2019}",
            "rthree;" => "\x{22cc}",
            "rtimes;" => "\x{22ca}",
            "rtri;" => "\x{25b9}",
            "rtrie;" => "\x{22b5}",
            "rtrif;" => "\x{25b8}",
            "rtriltri;" => "\x{29ce}",
            "ruluhar;" => "\x{2968}",
            "rx;" => "\x{211e}",
            "sacute;" => "\x{15b}",
            "sbquo;" => "\x{201a}",
            "sc;" => "\x{227b}",
            "scE;" => "\x{2ab4}",
            "scap;" => "\x{2ab8}",
            "scaron;" => "\x{161}",
            "sccue;" => "\x{227d}",
            "sce;" => "\x{2ab0}",
            "scedil;" => "\x{15f}",
            "scirc;" => "\x{15d}",
            "scnE;" => "\x{2ab6}",
            "scnap;" => "\x{2aba}",
            "scnsim;" => "\x{22e9}",
            "scpolint;" => "\x{2a13}",
            "scsim;" => "\x{227f}",
            "scy;" => "\x{441}",
            "sdot;" => "\x{22c5}",
            "sdotb;" => "\x{22a1}",
            "sdote;" => "\x{2a66}",
            "seArr;" => "\x{21d8}",
            "searhk;" => "\x{2925}",
            "searr;" => "\x{2198}",
            "searrow;" => "\x{2198}",
            "sect" => "\x{a7}",
            "sect;" => "\x{a7}",
            "semi;" => ";",
            "seswar;" => "\x{2929}",
            "setminus;" => "\x{2216}",
            "setmn;" => "\x{2216}",
            "sext;" => "\x{2736}",
            "sfr;" => "\x{1d530}",
            "sfrown;" => "\x{2322}",
            "sharp;" => "\x{266f}",
            "shchcy;" => "\x{449}",
            "shcy;" => "\x{448}",
            "shortmid;" => "\x{2223}",
            "shortparallel;" => "\x{2225}",
            "shy" => "\x{ad}",
            "shy;" => "\x{ad}",
            "sigma;" => "\x{3c3}",
            "sigmaf;" => "\x{3c2}",
            "sigmav;" => "\x{3c2}",
            "sim;" => "\x{223c}",
            "simdot;" => "\x{2a6a}",
            "sime;" => "\x{2243}",
            "simeq;" => "\x{2243}",
            "simg;" => "\x{2a9e}",
            "simgE;" => "\x{2aa0}",
            "siml;" => "\x{2a9d}",
            "simlE;" => "\x{2a9f}",
            "simne;" => "\x{2246}",
            "simplus;" => "\x{2a24}",
            "simrarr;" => "\x{2972}",
            "slarr;" => "\x{2190}",
            "smallsetminus;" => "\x{2216}",
            "smashp;" => "\x{2a33}",
            "smeparsl;" => "\x{29e4}",
            "smid;" => "\x{2223}",
            "smile;" => "\x{2323}",
            "smt;" => "\x{2aaa}",
            "smte;" => "\x{2aac}",
            "smtes;" => "\x{2aac}\x{fe00}",
            "softcy;" => "\x{44c}",
            "sol;" => "/",
            "solb;" => "\x{29c4}",
            "solbar;" => "\x{233f}",
            "sopf;" => "\x{1d564}",
            "spades;" => "\x{2660}",
            "spadesuit;" => "\x{2660}",
            "spar;" => "\x{2225}",
            "sqcap;" => "\x{2293}",
            "sqcaps;" => "\x{2293}\x{fe00}",
            "sqcup;" => "\x{2294}",
            "sqcups;" => "\x{2294}\x{fe00}",
            "sqsub;" => "\x{228f}",
            "sqsube;" => "\x{2291}",
            "sqsubset;" => "\x{228f}",
            "sqsubseteq;" => "\x{2291}",
            "sqsup;" => "\x{2290}",
            "sqsupe;" => "\x{2292}",
            "sqsupset;" => "\x{2290}",
            "sqsupseteq;" => "\x{2292}",
            "squ;" => "\x{25a1}",
            "square;" => "\x{25a1}",
            "squarf;" => "\x{25aa}",
            "squf;" => "\x{25aa}",
            "srarr;" => "\x{2192}",
            "sscr;" => "\x{1d4c8}",
            "ssetmn;" => "\x{2216}",
            "ssmile;" => "\x{2323}",
            "sstarf;" => "\x{22c6}",
            "star;" => "\x{2606}",
            "starf;" => "\x{2605}",
            "straightepsilon;" => "\x{3f5}",
            "straightphi;" => "\x{3d5}",
            "strns;" => "\x{af}",
            "sub;" => "\x{2282}",
            "subE;" => "\x{2ac5}",
            "subdot;" => "\x{2abd}",
            "sube;" => "\x{2286}",
            "subedot;" => "\x{2ac3}",
            "submult;" => "\x{2ac1}",
            "subnE;" => "\x{2acb}",
            "subne;" => "\x{228a}",
            "subplus;" => "\x{2abf}",
            "subrarr;" => "\x{2979}",
            "subset;" => "\x{2282}",
            "subseteq;" => "\x{2286}",
            "subseteqq;" => "\x{2ac5}",
            "subsetneq;" => "\x{228a}",
            "subsetneqq;" => "\x{2acb}",
            "subsim;" => "\x{2ac7}",
            "subsub;" => "\x{2ad5}",
            "subsup;" => "\x{2ad3}",
            "succ;" => "\x{227b}",
            "succapprox;" => "\x{2ab8}",
            "succcurlyeq;" => "\x{227d}",
            "succeq;" => "\x{2ab0}",
            "succnapprox;" => "\x{2aba}",
            "succneqq;" => "\x{2ab6}",
            "succnsim;" => "\x{22e9}",
            "succsim;" => "\x{227f}",
            "sum;" => "\x{2211}",
            "sung;" => "\x{266a}",
            "sup1" => "\x{b9}",
            "sup1;" => "\x{b9}",
            "sup2" => "\x{b2}",
            "sup2;" => "\x{b2}",
            "sup3" => "\x{b3}",
            "sup3;" => "\x{b3}",
            "sup;" => "\x{2283}",
            "supE;" => "\x{2ac6}",
            "supdot;" => "\x{2abe}",
            "supdsub;" => "\x{2ad8}",
            "supe;" => "\x{2287}",
            "supedot;" => "\x{2ac4}",
            "suphsol;" => "\x{27c9}",
            "suphsub;" => "\x{2ad7}",
            "suplarr;" => "\x{297b}",
            "supmult;" => "\x{2ac2}",
            "supnE;" => "\x{2acc}",
            "supne;" => "\x{228b}",
            "supplus;" => "\x{2ac0}",
            "supset;" => "\x{2283}",
            "supseteq;" => "\x{2287}",
            "supseteqq;" => "\x{2ac6}",
            "supsetneq;" => "\x{228b}",
            "supsetneqq;" => "\x{2acc}",
            "supsim;" => "\x{2ac8}",
            "supsub;" => "\x{2ad4}",
            "supsup;" => "\x{2ad6}",
            "swArr;" => "\x{21d9}",
            "swarhk;" => "\x{2926}",
            "swarr;" => "\x{2199}",
            "swarrow;" => "\x{2199}",
            "swnwar;" => "\x{292a}",
            "szlig" => "\x{df}",
            "szlig;" => "\x{df}",
            "target;" => "\x{2316}",
            "tau;" => "\x{3c4}",
            "tbrk;" => "\x{23b4}",
            "tcaron;" => "\x{165}",
            "tcedil;" => "\x{163}",
            "tcy;" => "\x{442}",
            "tdot;" => "\x{20db}",
            "telrec;" => "\x{2315}",
            "tfr;" => "\x{1d531}",
            "there4;" => "\x{2234}",
            "therefore;" => "\x{2234}",
            "theta;" => "\x{3b8}",
            "thetasym;" => "\x{3d1}",
            "thetav;" => "\x{3d1}",
            "thickapprox;" => "\x{2248}",
            "thicksim;" => "\x{223c}",
            "thinsp;" => "\x{2009}",
            "thkap;" => "\x{2248}",
            "thksim;" => "\x{223c}",
            "thorn" => "\x{fe}",
            "thorn;" => "\x{fe}",
            "tilde;" => "\x{2dc}",
            "times" => "\x{d7}",
            "times;" => "\x{d7}",
            "timesb;" => "\x{22a0}",
            "timesbar;" => "\x{2a31}",
            "timesd;" => "\x{2a30}",
            "tint;" => "\x{222d}",
            "toea;" => "\x{2928}",
            "top;" => "\x{22a4}",
            "topbot;" => "\x{2336}",
            "topcir;" => "\x{2af1}",
            "topf;" => "\x{1d565}",
            "topfork;" => "\x{2ada}",
            "tosa;" => "\x{2929}",
            "tprime;" => "\x{2034}",
            "trade;" => "\x{2122}",
            "triangle;" => "\x{25b5}",
            "triangledown;" => "\x{25bf}",
            "triangleleft;" => "\x{25c3}",
            "trianglelefteq;" => "\x{22b4}",
            "triangleq;" => "\x{225c}",
            "triangleright;" => "\x{25b9}",
            "trianglerighteq;" => "\x{22b5}",
            "tridot;" => "\x{25ec}",
            "trie;" => "\x{225c}",
            "triminus;" => "\x{2a3a}",
            "triplus;" => "\x{2a39}",
            "trisb;" => "\x{29cd}",
            "tritime;" => "\x{2a3b}",
            "trpezium;" => "\x{23e2}",
            "tscr;" => "\x{1d4c9}",
            "tscy;" => "\x{446}",
            "tshcy;" => "\x{45b}",
            "tstrok;" => "\x{167}",
            "twixt;" => "\x{226c}",
            "twoheadleftarrow;" => "\x{219e}",
            "twoheadrightarrow;" => "\x{21a0}",
            "uArr;" => "\x{21d1}",
            "uHar;" => "\x{2963}",
            "uacute" => "\x{fa}",
            "uacute;" => "\x{fa}",
            "uarr;" => "\x{2191}",
            "ubrcy;" => "\x{45e}",
            "ubreve;" => "\x{16d}",
            "ucirc" => "\x{fb}",
            "ucirc;" => "\x{fb}",
            "ucy;" => "\x{443}",
            "udarr;" => "\x{21c5}",
            "udblac;" => "\x{171}",
            "udhar;" => "\x{296e}",
            "ufisht;" => "\x{297e}",
            "ufr;" => "\x{1d532}",
            "ugrave" => "\x{f9}",
            "ugrave;" => "\x{f9}",
            "uharl;" => "\x{21bf}",
            "uharr;" => "\x{21be}",
            "uhblk;" => "\x{2580}",
            "ulcorn;" => "\x{231c}",
            "ulcorner;" => "\x{231c}",
            "ulcrop;" => "\x{230f}",
            "ultri;" => "\x{25f8}",
            "umacr;" => "\x{16b}",
            "uml" => "\x{a8}",
            "uml;" => "\x{a8}",
            "uogon;" => "\x{173}",
            "uopf;" => "\x{1d566}",
            "uparrow;" => "\x{2191}",
            "updownarrow;" => "\x{2195}",
            "upharpoonleft;" => "\x{21bf}",
            "upharpoonright;" => "\x{21be}",
            "uplus;" => "\x{228e}",
            "upsi;" => "\x{3c5}",
            "upsih;" => "\x{3d2}",
            "upsilon;" => "\x{3c5}",
            "upuparrows;" => "\x{21c8}",
            "urcorn;" => "\x{231d}",
            "urcorner;" => "\x{231d}",
            "urcrop;" => "\x{230e}",
            "uring;" => "\x{16f}",
            "urtri;" => "\x{25f9}",
            "uscr;" => "\x{1d4ca}",
            "utdot;" => "\x{22f0}",
            "utilde;" => "\x{169}",
            "utri;" => "\x{25b5}",
            "utrif;" => "\x{25b4}",
            "uuarr;" => "\x{21c8}",
            "uuml" => "\x{fc}",
            "uuml;" => "\x{fc}",
            "uwangle;" => "\x{29a7}",
            "vArr;" => "\x{21d5}",
            "vBar;" => "\x{2ae8}",
            "vBarv;" => "\x{2ae9}",
            "vDash;" => "\x{22a8}",
            "vangrt;" => "\x{299c}",
            "varepsilon;" => "\x{3f5}",
            "varkappa;" => "\x{3f0}",
            "varnothing;" => "\x{2205}",
            "varphi;" => "\x{3d5}",
            "varpi;" => "\x{3d6}",
            "varpropto;" => "\x{221d}",
            "varr;" => "\x{2195}",
            "varrho;" => "\x{3f1}",
            "varsigma;" => "\x{3c2}",
            "varsubsetneq;" => "\x{228a}\x{fe00}",
            "varsubsetneqq;" => "\x{2acb}\x{fe00}",
            "varsupsetneq;" => "\x{228b}\x{fe00}",
            "varsupsetneqq;" => "\x{2acc}\x{fe00}",
            "vartheta;" => "\x{3d1}",
            "vartriangleleft;" => "\x{22b2}",
            "vartriangleright;" => "\x{22b3}",
            "vcy;" => "\x{432}",
            "vdash;" => "\x{22a2}",
            "vee;" => "\x{2228}",
            "veebar;" => "\x{22bb}",
            "veeeq;" => "\x{225a}",
            "vellip;" => "\x{22ee}",
            "verbar;" => "|",
            "vert;" => "|",
            "vfr;" => "\x{1d533}",
            "vltri;" => "\x{22b2}",
            "vnsub;" => "\x{2282}\x{20d2}",
            "vnsup;" => "\x{2283}\x{20d2}",
            "vopf;" => "\x{1d567}",
            "vprop;" => "\x{221d}",
            "vrtri;" => "\x{22b3}",
            "vscr;" => "\x{1d4cb}",
            "vsubnE;" => "\x{2acb}\x{fe00}",
            "vsubne;" => "\x{228a}\x{fe00}",
            "vsupnE;" => "\x{2acc}\x{fe00}",
            "vsupne;" => "\x{228b}\x{fe00}",
            "vzigzag;" => "\x{299a}",
            "wcirc;" => "\x{175}",
            "wedbar;" => "\x{2a5f}",
            "wedge;" => "\x{2227}",
            "wedgeq;" => "\x{2259}",
            "weierp;" => "\x{2118}",
            "wfr;" => "\x{1d534}",
            "wopf;" => "\x{1d568}",
            "wp;" => "\x{2118}",
            "wr;" => "\x{2240}",
            "wreath;" => "\x{2240}",
            "wscr;" => "\x{1d4cc}",
            "xcap;" => "\x{22c2}",
            "xcirc;" => "\x{25ef}",
            "xcup;" => "\x{22c3}",
            "xdtri;" => "\x{25bd}",
            "xfr;" => "\x{1d535}",
            "xhArr;" => "\x{27fa}",
            "xharr;" => "\x{27f7}",
            "xi;" => "\x{3be}",
            "xlArr;" => "\x{27f8}",
            "xlarr;" => "\x{27f5}",
            "xmap;" => "\x{27fc}",
            "xnis;" => "\x{22fb}",
            "xodot;" => "\x{2a00}",
            "xopf;" => "\x{1d569}",
            "xoplus;" => "\x{2a01}",
            "xotime;" => "\x{2a02}",
            "xrArr;" => "\x{27f9}",
            "xrarr;" => "\x{27f6}",
            "xscr;" => "\x{1d4cd}",
            "xsqcup;" => "\x{2a06}",
            "xuplus;" => "\x{2a04}",
            "xutri;" => "\x{25b3}",
            "xvee;" => "\x{22c1}",
            "xwedge;" => "\x{22c0}",
            "yacute" => "\x{fd}",
            "yacute;" => "\x{fd}",
            "yacy;" => "\x{44f}",
            "ycirc;" => "\x{177}",
            "ycy;" => "\x{44b}",
            "yen" => "\x{a5}",
            "yen;" => "\x{a5}",
            "yfr;" => "\x{1d536}",
            "yicy;" => "\x{457}",
            "yopf;" => "\x{1d56a}",
            "yscr;" => "\x{1d4ce}",
            "yucy;" => "\x{44e}",
            "yuml" => "\x{ff}",
            "yuml;" => "\x{ff}",
            "zacute;" => "\x{17a}",
            "zcaron;" => "\x{17e}",
            "zcy;" => "\x{437}",
            "zdot;" => "\x{17c}",
            "zeetrf;" => "\x{2128}",
            "zeta;" => "\x{3b6}",
            "zfr;" => "\x{1d537}",
            "zhcy;" => "\x{436}",
            "zigrarr;" => "\x{21dd}",
            "zopf;" => "\x{1d56b}",
            "zscr;" => "\x{1d4cf}",
            "zwj;" => "\x{200d}",
            "zwnj;" => "\x{200c}"
          };
  
  1;
  #  Copyright 2004-2011 Apple Computer, Inc., Mozilla Foundation, and Opera Software ASA.
  # You are granted a license to use, reproduce and create derivative works of this document.
WEB_HTML__NAMEDENTITYLIST

$fatpacked{"Web/HTML/_SyntaxDefs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WEB_HTML__SYNTAXDEFS';
  $Web::HTML::_SyntaxDefs = {
            "adjusted_mathml_attr_names" => {
                                              "definitionurl" => "definitionURL"
                                            },
            "adjusted_ns_attr_names" => {
                                          "xlink:actuate" => [
                                                               "http://www.w3.org/1999/xlink",
                                                               [
                                                                 "xlink",
                                                                 "actuate"
                                                               ]
                                                             ],
                                          "xlink:arcrole" => [
                                                               "http://www.w3.org/1999/xlink",
                                                               [
                                                                 "xlink",
                                                                 "arcrole"
                                                               ]
                                                             ],
                                          "xlink:href" => [
                                                            "http://www.w3.org/1999/xlink",
                                                            [
                                                              "xlink",
                                                              "href"
                                                            ]
                                                          ],
                                          "xlink:role" => [
                                                            "http://www.w3.org/1999/xlink",
                                                            [
                                                              "xlink",
                                                              "role"
                                                            ]
                                                          ],
                                          "xlink:show" => [
                                                            "http://www.w3.org/1999/xlink",
                                                            [
                                                              "xlink",
                                                              "show"
                                                            ]
                                                          ],
                                          "xlink:title" => [
                                                             "http://www.w3.org/1999/xlink",
                                                             [
                                                               "xlink",
                                                               "title"
                                                             ]
                                                           ],
                                          "xlink:type" => [
                                                            "http://www.w3.org/1999/xlink",
                                                            [
                                                              "xlink",
                                                              "type"
                                                            ]
                                                          ],
                                          "xml:lang" => [
                                                          "http://www.w3.org/XML/1998/namespace",
                                                          [
                                                            "xml",
                                                            "lang"
                                                          ]
                                                        ],
                                          "xml:space" => [
                                                           "http://www.w3.org/XML/1998/namespace",
                                                           [
                                                             "xml",
                                                             "space"
                                                           ]
                                                         ],
                                          "xmlns" => [
                                                       "http://www.w3.org/2000/xmlns/",
                                                       [
                                                         undef,
                                                         "xmlns"
                                                       ]
                                                     ],
                                          "xmlns:xlink" => [
                                                             "http://www.w3.org/2000/xmlns/",
                                                             [
                                                               "xmlns",
                                                               "xlink"
                                                             ]
                                                           ]
                                        },
            "adjusted_svg_attr_names" => {
                                           "attributename" => "attributeName",
                                           "attributetype" => "attributeType",
                                           "basefrequency" => "baseFrequency",
                                           "baseprofile" => "baseProfile",
                                           "calcmode" => "calcMode",
                                           "clippathunits" => "clipPathUnits",
                                           "diffuseconstant" => "diffuseConstant",
                                           "edgemode" => "edgeMode",
                                           "filterunits" => "filterUnits",
                                           "glyphref" => "glyphRef",
                                           "gradienttransform" => "gradientTransform",
                                           "gradientunits" => "gradientUnits",
                                           "kernelmatrix" => "kernelMatrix",
                                           "kernelunitlength" => "kernelUnitLength",
                                           "keypoints" => "keyPoints",
                                           "keysplines" => "keySplines",
                                           "keytimes" => "keyTimes",
                                           "lengthadjust" => "lengthAdjust",
                                           "limitingconeangle" => "limitingConeAngle",
                                           "markerheight" => "markerHeight",
                                           "markerunits" => "markerUnits",
                                           "markerwidth" => "markerWidth",
                                           "maskcontentunits" => "maskContentUnits",
                                           "maskunits" => "maskUnits",
                                           "numoctaves" => "numOctaves",
                                           "pathlength" => "pathLength",
                                           "patterncontentunits" => "patternContentUnits",
                                           "patterntransform" => "patternTransform",
                                           "patternunits" => "patternUnits",
                                           "pointsatx" => "pointsAtX",
                                           "pointsaty" => "pointsAtY",
                                           "pointsatz" => "pointsAtZ",
                                           "preservealpha" => "preserveAlpha",
                                           "preserveaspectratio" => "preserveAspectRatio",
                                           "primitiveunits" => "primitiveUnits",
                                           "refx" => "refX",
                                           "refy" => "refY",
                                           "repeatcount" => "repeatCount",
                                           "repeatdur" => "repeatDur",
                                           "requiredextensions" => "requiredExtensions",
                                           "requiredfeatures" => "requiredFeatures",
                                           "specularconstant" => "specularConstant",
                                           "specularexponent" => "specularExponent",
                                           "spreadmethod" => "spreadMethod",
                                           "startoffset" => "startOffset",
                                           "stddeviation" => "stdDeviation",
                                           "stitchtiles" => "stitchTiles",
                                           "surfacescale" => "surfaceScale",
                                           "systemlanguage" => "systemLanguage",
                                           "tablevalues" => "tableValues",
                                           "targetx" => "targetX",
                                           "targety" => "targetY",
                                           "textlength" => "textLength",
                                           "viewbox" => "viewBox",
                                           "viewtarget" => "viewTarget",
                                           "xchannelselector" => "xChannelSelector",
                                           "ychannelselector" => "yChannelSelector",
                                           "zoomandpan" => "zoomAndPan"
                                         },
            "adjusted_svg_element_names" => {
                                              "altglyph" => "altGlyph",
                                              "altglyphdef" => "altGlyphDef",
                                              "altglyphitem" => "altGlyphItem",
                                              "animatecolor" => "animateColor",
                                              "animatemotion" => "animateMotion",
                                              "animatetransform" => "animateTransform",
                                              "clippath" => "clipPath",
                                              "feblend" => "feBlend",
                                              "fecolormatrix" => "feColorMatrix",
                                              "fecomponenttransfer" => "feComponentTransfer",
                                              "fecomposite" => "feComposite",
                                              "feconvolvematrix" => "feConvolveMatrix",
                                              "fediffuselighting" => "feDiffuseLighting",
                                              "fedisplacementmap" => "feDisplacementMap",
                                              "fedistantlight" => "feDistantLight",
                                              "fedropshadow" => "feDropShadow",
                                              "feflood" => "feFlood",
                                              "fefunca" => "feFuncA",
                                              "fefuncb" => "feFuncB",
                                              "fefuncg" => "feFuncG",
                                              "fefuncr" => "feFuncR",
                                              "fegaussianblur" => "feGaussianBlur",
                                              "feimage" => "feImage",
                                              "femerge" => "feMerge",
                                              "femergenode" => "feMergeNode",
                                              "femorphology" => "feMorphology",
                                              "feoffset" => "feOffset",
                                              "fepointlight" => "fePointLight",
                                              "fespecularlighting" => "feSpecularLighting",
                                              "fespotlight" => "feSpotLight",
                                              "fetile" => "feTile",
                                              "feturbulence" => "feTurbulence",
                                              "foreignobject" => "foreignObject",
                                              "glyphref" => "glyphRef",
                                              "lineargradient" => "linearGradient",
                                              "radialgradient" => "radialGradient",
                                              "textpath" => "textPath"
                                            },
            "charref_invalid" => {
                                   "0" => 65533,
                                   "1" => 1,
                                   "1048574" => 1048574,
                                   "1048575" => 1048575,
                                   "11" => 11,
                                   "1114110" => 1114110,
                                   "1114111" => 1114111,
                                   "127" => 127,
                                   "128" => 8364,
                                   "129" => 129,
                                   "13" => 13,
                                   "130" => 8218,
                                   "131" => 402,
                                   "131070" => 131070,
                                   "131071" => 131071,
                                   "132" => 8222,
                                   "133" => 8230,
                                   "134" => 8224,
                                   "135" => 8225,
                                   "136" => 710,
                                   "137" => 8240,
                                   "138" => 352,
                                   "139" => 8249,
                                   "14" => 14,
                                   "140" => 338,
                                   "141" => 141,
                                   "142" => 381,
                                   "143" => 143,
                                   "144" => 144,
                                   "145" => 8216,
                                   "146" => 8217,
                                   "147" => 8220,
                                   "148" => 8221,
                                   "149" => 8226,
                                   "15" => 15,
                                   "150" => 8211,
                                   "151" => 8212,
                                   "152" => 732,
                                   "153" => 8482,
                                   "154" => 353,
                                   "155" => 8250,
                                   "156" => 339,
                                   "157" => 157,
                                   "158" => 382,
                                   "159" => 376,
                                   "16" => 16,
                                   "17" => 17,
                                   "18" => 18,
                                   "19" => 19,
                                   "196606" => 196606,
                                   "196607" => 196607,
                                   "2" => 2,
                                   "20" => 20,
                                   "21" => 21,
                                   "22" => 22,
                                   "23" => 23,
                                   "24" => 24,
                                   "25" => 25,
                                   "26" => 26,
                                   "262142" => 262142,
                                   "262143" => 262143,
                                   "27" => 27,
                                   "28" => 28,
                                   "29" => 29,
                                   "3" => 3,
                                   "30" => 30,
                                   "31" => 31,
                                   "327678" => 327678,
                                   "327679" => 327679,
                                   "393214" => 393214,
                                   "393215" => 393215,
                                   "4" => 4,
                                   "458750" => 458750,
                                   "458751" => 458751,
                                   "5" => 5,
                                   "524286" => 524286,
                                   "524287" => 524287,
                                   "55296" => 65533,
                                   "55297" => 65533,
                                   "55298" => 65533,
                                   "55299" => 65533,
                                   "55300" => 65533,
                                   "55301" => 65533,
                                   "55302" => 65533,
                                   "55303" => 65533,
                                   "55304" => 65533,
                                   "55305" => 65533,
                                   "55306" => 65533,
                                   "55307" => 65533,
                                   "55308" => 65533,
                                   "55309" => 65533,
                                   "55310" => 65533,
                                   "55311" => 65533,
                                   "55312" => 65533,
                                   "55313" => 65533,
                                   "55314" => 65533,
                                   "55315" => 65533,
                                   "55316" => 65533,
                                   "55317" => 65533,
                                   "55318" => 65533,
                                   "55319" => 65533,
                                   "55320" => 65533,
                                   "55321" => 65533,
                                   "55322" => 65533,
                                   "55323" => 65533,
                                   "55324" => 65533,
                                   "55325" => 65533,
                                   "55326" => 65533,
                                   "55327" => 65533,
                                   "55328" => 65533,
                                   "55329" => 65533,
                                   "55330" => 65533,
                                   "55331" => 65533,
                                   "55332" => 65533,
                                   "55333" => 65533,
                                   "55334" => 65533,
                                   "55335" => 65533,
                                   "55336" => 65533,
                                   "55337" => 65533,
                                   "55338" => 65533,
                                   "55339" => 65533,
                                   "55340" => 65533,
                                   "55341" => 65533,
                                   "55342" => 65533,
                                   "55343" => 65533,
                                   "55344" => 65533,
                                   "55345" => 65533,
                                   "55346" => 65533,
                                   "55347" => 65533,
                                   "55348" => 65533,
                                   "55349" => 65533,
                                   "55350" => 65533,
                                   "55351" => 65533,
                                   "55352" => 65533,
                                   "55353" => 65533,
                                   "55354" => 65533,
                                   "55355" => 65533,
                                   "55356" => 65533,
                                   "55357" => 65533,
                                   "55358" => 65533,
                                   "55359" => 65533,
                                   "55360" => 65533,
                                   "55361" => 65533,
                                   "55362" => 65533,
                                   "55363" => 65533,
                                   "55364" => 65533,
                                   "55365" => 65533,
                                   "55366" => 65533,
                                   "55367" => 65533,
                                   "55368" => 65533,
                                   "55369" => 65533,
                                   "55370" => 65533,
                                   "55371" => 65533,
                                   "55372" => 65533,
                                   "55373" => 65533,
                                   "55374" => 65533,
                                   "55375" => 65533,
                                   "55376" => 65533,
                                   "55377" => 65533,
                                   "55378" => 65533,
                                   "55379" => 65533,
                                   "55380" => 65533,
                                   "55381" => 65533,
                                   "55382" => 65533,
                                   "55383" => 65533,
                                   "55384" => 65533,
                                   "55385" => 65533,
                                   "55386" => 65533,
                                   "55387" => 65533,
                                   "55388" => 65533,
                                   "55389" => 65533,
                                   "55390" => 65533,
                                   "55391" => 65533,
                                   "55392" => 65533,
                                   "55393" => 65533,
                                   "55394" => 65533,
                                   "55395" => 65533,
                                   "55396" => 65533,
                                   "55397" => 65533,
                                   "55398" => 65533,
                                   "55399" => 65533,
                                   "55400" => 65533,
                                   "55401" => 65533,
                                   "55402" => 65533,
                                   "55403" => 65533,
                                   "55404" => 65533,
                                   "55405" => 65533,
                                   "55406" => 65533,
                                   "55407" => 65533,
                                   "55408" => 65533,
                                   "55409" => 65533,
                                   "55410" => 65533,
                                   "55411" => 65533,
                                   "55412" => 65533,
                                   "55413" => 65533,
                                   "55414" => 65533,
                                   "55415" => 65533,
                                   "55416" => 65533,
                                   "55417" => 65533,
                                   "55418" => 65533,
                                   "55419" => 65533,
                                   "55420" => 65533,
                                   "55421" => 65533,
                                   "55422" => 65533,
                                   "55423" => 65533,
                                   "55424" => 65533,
                                   "55425" => 65533,
                                   "55426" => 65533,
                                   "55427" => 65533,
                                   "55428" => 65533,
                                   "55429" => 65533,
                                   "55430" => 65533,
                                   "55431" => 65533,
                                   "55432" => 65533,
                                   "55433" => 65533,
                                   "55434" => 65533,
                                   "55435" => 65533,
                                   "55436" => 65533,
                                   "55437" => 65533,
                                   "55438" => 65533,
                                   "55439" => 65533,
                                   "55440" => 65533,
                                   "55441" => 65533,
                                   "55442" => 65533,
                                   "55443" => 65533,
                                   "55444" => 65533,
                                   "55445" => 65533,
                                   "55446" => 65533,
                                   "55447" => 65533,
                                   "55448" => 65533,
                                   "55449" => 65533,
                                   "55450" => 65533,
                                   "55451" => 65533,
                                   "55452" => 65533,
                                   "55453" => 65533,
                                   "55454" => 65533,
                                   "55455" => 65533,
                                   "55456" => 65533,
                                   "55457" => 65533,
                                   "55458" => 65533,
                                   "55459" => 65533,
                                   "55460" => 65533,
                                   "55461" => 65533,
                                   "55462" => 65533,
                                   "55463" => 65533,
                                   "55464" => 65533,
                                   "55465" => 65533,
                                   "55466" => 65533,
                                   "55467" => 65533,
                                   "55468" => 65533,
                                   "55469" => 65533,
                                   "55470" => 65533,
                                   "55471" => 65533,
                                   "55472" => 65533,
                                   "55473" => 65533,
                                   "55474" => 65533,
                                   "55475" => 65533,
                                   "55476" => 65533,
                                   "55477" => 65533,
                                   "55478" => 65533,
                                   "55479" => 65533,
                                   "55480" => 65533,
                                   "55481" => 65533,
                                   "55482" => 65533,
                                   "55483" => 65533,
                                   "55484" => 65533,
                                   "55485" => 65533,
                                   "55486" => 65533,
                                   "55487" => 65533,
                                   "55488" => 65533,
                                   "55489" => 65533,
                                   "55490" => 65533,
                                   "55491" => 65533,
                                   "55492" => 65533,
                                   "55493" => 65533,
                                   "55494" => 65533,
                                   "55495" => 65533,
                                   "55496" => 65533,
                                   "55497" => 65533,
                                   "55498" => 65533,
                                   "55499" => 65533,
                                   "55500" => 65533,
                                   "55501" => 65533,
                                   "55502" => 65533,
                                   "55503" => 65533,
                                   "55504" => 65533,
                                   "55505" => 65533,
                                   "55506" => 65533,
                                   "55507" => 65533,
                                   "55508" => 65533,
                                   "55509" => 65533,
                                   "55510" => 65533,
                                   "55511" => 65533,
                                   "55512" => 65533,
                                   "55513" => 65533,
                                   "55514" => 65533,
                                   "55515" => 65533,
                                   "55516" => 65533,
                                   "55517" => 65533,
                                   "55518" => 65533,
                                   "55519" => 65533,
                                   "55520" => 65533,
                                   "55521" => 65533,
                                   "55522" => 65533,
                                   "55523" => 65533,
                                   "55524" => 65533,
                                   "55525" => 65533,
                                   "55526" => 65533,
                                   "55527" => 65533,
                                   "55528" => 65533,
                                   "55529" => 65533,
                                   "55530" => 65533,
                                   "55531" => 65533,
                                   "55532" => 65533,
                                   "55533" => 65533,
                                   "55534" => 65533,
                                   "55535" => 65533,
                                   "55536" => 65533,
                                   "55537" => 65533,
                                   "55538" => 65533,
                                   "55539" => 65533,
                                   "55540" => 65533,
                                   "55541" => 65533,
                                   "55542" => 65533,
                                   "55543" => 65533,
                                   "55544" => 65533,
                                   "55545" => 65533,
                                   "55546" => 65533,
                                   "55547" => 65533,
                                   "55548" => 65533,
                                   "55549" => 65533,
                                   "55550" => 65533,
                                   "55551" => 65533,
                                   "55552" => 65533,
                                   "55553" => 65533,
                                   "55554" => 65533,
                                   "55555" => 65533,
                                   "55556" => 65533,
                                   "55557" => 65533,
                                   "55558" => 65533,
                                   "55559" => 65533,
                                   "55560" => 65533,
                                   "55561" => 65533,
                                   "55562" => 65533,
                                   "55563" => 65533,
                                   "55564" => 65533,
                                   "55565" => 65533,
                                   "55566" => 65533,
                                   "55567" => 65533,
                                   "55568" => 65533,
                                   "55569" => 65533,
                                   "55570" => 65533,
                                   "55571" => 65533,
                                   "55572" => 65533,
                                   "55573" => 65533,
                                   "55574" => 65533,
                                   "55575" => 65533,
                                   "55576" => 65533,
                                   "55577" => 65533,
                                   "55578" => 65533,
                                   "55579" => 65533,
                                   "55580" => 65533,
                                   "55581" => 65533,
                                   "55582" => 65533,
                                   "55583" => 65533,
                                   "55584" => 65533,
                                   "55585" => 65533,
                                   "55586" => 65533,
                                   "55587" => 65533,
                                   "55588" => 65533,
                                   "55589" => 65533,
                                   "55590" => 65533,
                                   "55591" => 65533,
                                   "55592" => 65533,
                                   "55593" => 65533,
                                   "55594" => 65533,
                                   "55595" => 65533,
                                   "55596" => 65533,
                                   "55597" => 65533,
                                   "55598" => 65533,
                                   "55599" => 65533,
                                   "55600" => 65533,
                                   "55601" => 65533,
                                   "55602" => 65533,
                                   "55603" => 65533,
                                   "55604" => 65533,
                                   "55605" => 65533,
                                   "55606" => 65533,
                                   "55607" => 65533,
                                   "55608" => 65533,
                                   "55609" => 65533,
                                   "55610" => 65533,
                                   "55611" => 65533,
                                   "55612" => 65533,
                                   "55613" => 65533,
                                   "55614" => 65533,
                                   "55615" => 65533,
                                   "55616" => 65533,
                                   "55617" => 65533,
                                   "55618" => 65533,
                                   "55619" => 65533,
                                   "55620" => 65533,
                                   "55621" => 65533,
                                   "55622" => 65533,
                                   "55623" => 65533,
                                   "55624" => 65533,
                                   "55625" => 65533,
                                   "55626" => 65533,
                                   "55627" => 65533,
                                   "55628" => 65533,
                                   "55629" => 65533,
                                   "55630" => 65533,
                                   "55631" => 65533,
                                   "55632" => 65533,
                                   "55633" => 65533,
                                   "55634" => 65533,
                                   "55635" => 65533,
                                   "55636" => 65533,
                                   "55637" => 65533,
                                   "55638" => 65533,
                                   "55639" => 65533,
                                   "55640" => 65533,
                                   "55641" => 65533,
                                   "55642" => 65533,
                                   "55643" => 65533,
                                   "55644" => 65533,
                                   "55645" => 65533,
                                   "55646" => 65533,
                                   "55647" => 65533,
                                   "55648" => 65533,
                                   "55649" => 65533,
                                   "55650" => 65533,
                                   "55651" => 65533,
                                   "55652" => 65533,
                                   "55653" => 65533,
                                   "55654" => 65533,
                                   "55655" => 65533,
                                   "55656" => 65533,
                                   "55657" => 65533,
                                   "55658" => 65533,
                                   "55659" => 65533,
                                   "55660" => 65533,
                                   "55661" => 65533,
                                   "55662" => 65533,
                                   "55663" => 65533,
                                   "55664" => 65533,
                                   "55665" => 65533,
                                   "55666" => 65533,
                                   "55667" => 65533,
                                   "55668" => 65533,
                                   "55669" => 65533,
                                   "55670" => 65533,
                                   "55671" => 65533,
                                   "55672" => 65533,
                                   "55673" => 65533,
                                   "55674" => 65533,
                                   "55675" => 65533,
                                   "55676" => 65533,
                                   "55677" => 65533,
                                   "55678" => 65533,
                                   "55679" => 65533,
                                   "55680" => 65533,
                                   "55681" => 65533,
                                   "55682" => 65533,
                                   "55683" => 65533,
                                   "55684" => 65533,
                                   "55685" => 65533,
                                   "55686" => 65533,
                                   "55687" => 65533,
                                   "55688" => 65533,
                                   "55689" => 65533,
                                   "55690" => 65533,
                                   "55691" => 65533,
                                   "55692" => 65533,
                                   "55693" => 65533,
                                   "55694" => 65533,
                                   "55695" => 65533,
                                   "55696" => 65533,
                                   "55697" => 65533,
                                   "55698" => 65533,
                                   "55699" => 65533,
                                   "55700" => 65533,
                                   "55701" => 65533,
                                   "55702" => 65533,
                                   "55703" => 65533,
                                   "55704" => 65533,
                                   "55705" => 65533,
                                   "55706" => 65533,
                                   "55707" => 65533,
                                   "55708" => 65533,
                                   "55709" => 65533,
                                   "55710" => 65533,
                                   "55711" => 65533,
                                   "55712" => 65533,
                                   "55713" => 65533,
                                   "55714" => 65533,
                                   "55715" => 65533,
                                   "55716" => 65533,
                                   "55717" => 65533,
                                   "55718" => 65533,
                                   "55719" => 65533,
                                   "55720" => 65533,
                                   "55721" => 65533,
                                   "55722" => 65533,
                                   "55723" => 65533,
                                   "55724" => 65533,
                                   "55725" => 65533,
                                   "55726" => 65533,
                                   "55727" => 65533,
                                   "55728" => 65533,
                                   "55729" => 65533,
                                   "55730" => 65533,
                                   "55731" => 65533,
                                   "55732" => 65533,
                                   "55733" => 65533,
                                   "55734" => 65533,
                                   "55735" => 65533,
                                   "55736" => 65533,
                                   "55737" => 65533,
                                   "55738" => 65533,
                                   "55739" => 65533,
                                   "55740" => 65533,
                                   "55741" => 65533,
                                   "55742" => 65533,
                                   "55743" => 65533,
                                   "55744" => 65533,
                                   "55745" => 65533,
                                   "55746" => 65533,
                                   "55747" => 65533,
                                   "55748" => 65533,
                                   "55749" => 65533,
                                   "55750" => 65533,
                                   "55751" => 65533,
                                   "55752" => 65533,
                                   "55753" => 65533,
                                   "55754" => 65533,
                                   "55755" => 65533,
                                   "55756" => 65533,
                                   "55757" => 65533,
                                   "55758" => 65533,
                                   "55759" => 65533,
                                   "55760" => 65533,
                                   "55761" => 65533,
                                   "55762" => 65533,
                                   "55763" => 65533,
                                   "55764" => 65533,
                                   "55765" => 65533,
                                   "55766" => 65533,
                                   "55767" => 65533,
                                   "55768" => 65533,
                                   "55769" => 65533,
                                   "55770" => 65533,
                                   "55771" => 65533,
                                   "55772" => 65533,
                                   "55773" => 65533,
                                   "55774" => 65533,
                                   "55775" => 65533,
                                   "55776" => 65533,
                                   "55777" => 65533,
                                   "55778" => 65533,
                                   "55779" => 65533,
                                   "55780" => 65533,
                                   "55781" => 65533,
                                   "55782" => 65533,
                                   "55783" => 65533,
                                   "55784" => 65533,
                                   "55785" => 65533,
                                   "55786" => 65533,
                                   "55787" => 65533,
                                   "55788" => 65533,
                                   "55789" => 65533,
                                   "55790" => 65533,
                                   "55791" => 65533,
                                   "55792" => 65533,
                                   "55793" => 65533,
                                   "55794" => 65533,
                                   "55795" => 65533,
                                   "55796" => 65533,
                                   "55797" => 65533,
                                   "55798" => 65533,
                                   "55799" => 65533,
                                   "55800" => 65533,
                                   "55801" => 65533,
                                   "55802" => 65533,
                                   "55803" => 65533,
                                   "55804" => 65533,
                                   "55805" => 65533,
                                   "55806" => 65533,
                                   "55807" => 65533,
                                   "55808" => 65533,
                                   "55809" => 65533,
                                   "55810" => 65533,
                                   "55811" => 65533,
                                   "55812" => 65533,
                                   "55813" => 65533,
                                   "55814" => 65533,
                                   "55815" => 65533,
                                   "55816" => 65533,
                                   "55817" => 65533,
                                   "55818" => 65533,
                                   "55819" => 65533,
                                   "55820" => 65533,
                                   "55821" => 65533,
                                   "55822" => 65533,
                                   "55823" => 65533,
                                   "55824" => 65533,
                                   "55825" => 65533,
                                   "55826" => 65533,
                                   "55827" => 65533,
                                   "55828" => 65533,
                                   "55829" => 65533,
                                   "55830" => 65533,
                                   "55831" => 65533,
                                   "55832" => 65533,
                                   "55833" => 65533,
                                   "55834" => 65533,
                                   "55835" => 65533,
                                   "55836" => 65533,
                                   "55837" => 65533,
                                   "55838" => 65533,
                                   "55839" => 65533,
                                   "55840" => 65533,
                                   "55841" => 65533,
                                   "55842" => 65533,
                                   "55843" => 65533,
                                   "55844" => 65533,
                                   "55845" => 65533,
                                   "55846" => 65533,
                                   "55847" => 65533,
                                   "55848" => 65533,
                                   "55849" => 65533,
                                   "55850" => 65533,
                                   "55851" => 65533,
                                   "55852" => 65533,
                                   "55853" => 65533,
                                   "55854" => 65533,
                                   "55855" => 65533,
                                   "55856" => 65533,
                                   "55857" => 65533,
                                   "55858" => 65533,
                                   "55859" => 65533,
                                   "55860" => 65533,
                                   "55861" => 65533,
                                   "55862" => 65533,
                                   "55863" => 65533,
                                   "55864" => 65533,
                                   "55865" => 65533,
                                   "55866" => 65533,
                                   "55867" => 65533,
                                   "55868" => 65533,
                                   "55869" => 65533,
                                   "55870" => 65533,
                                   "55871" => 65533,
                                   "55872" => 65533,
                                   "55873" => 65533,
                                   "55874" => 65533,
                                   "55875" => 65533,
                                   "55876" => 65533,
                                   "55877" => 65533,
                                   "55878" => 65533,
                                   "55879" => 65533,
                                   "55880" => 65533,
                                   "55881" => 65533,
                                   "55882" => 65533,
                                   "55883" => 65533,
                                   "55884" => 65533,
                                   "55885" => 65533,
                                   "55886" => 65533,
                                   "55887" => 65533,
                                   "55888" => 65533,
                                   "55889" => 65533,
                                   "55890" => 65533,
                                   "55891" => 65533,
                                   "55892" => 65533,
                                   "55893" => 65533,
                                   "55894" => 65533,
                                   "55895" => 65533,
                                   "55896" => 65533,
                                   "55897" => 65533,
                                   "55898" => 65533,
                                   "55899" => 65533,
                                   "55900" => 65533,
                                   "55901" => 65533,
                                   "55902" => 65533,
                                   "55903" => 65533,
                                   "55904" => 65533,
                                   "55905" => 65533,
                                   "55906" => 65533,
                                   "55907" => 65533,
                                   "55908" => 65533,
                                   "55909" => 65533,
                                   "55910" => 65533,
                                   "55911" => 65533,
                                   "55912" => 65533,
                                   "55913" => 65533,
                                   "55914" => 65533,
                                   "55915" => 65533,
                                   "55916" => 65533,
                                   "55917" => 65533,
                                   "55918" => 65533,
                                   "55919" => 65533,
                                   "55920" => 65533,
                                   "55921" => 65533,
                                   "55922" => 65533,
                                   "55923" => 65533,
                                   "55924" => 65533,
                                   "55925" => 65533,
                                   "55926" => 65533,
                                   "55927" => 65533,
                                   "55928" => 65533,
                                   "55929" => 65533,
                                   "55930" => 65533,
                                   "55931" => 65533,
                                   "55932" => 65533,
                                   "55933" => 65533,
                                   "55934" => 65533,
                                   "55935" => 65533,
                                   "55936" => 65533,
                                   "55937" => 65533,
                                   "55938" => 65533,
                                   "55939" => 65533,
                                   "55940" => 65533,
                                   "55941" => 65533,
                                   "55942" => 65533,
                                   "55943" => 65533,
                                   "55944" => 65533,
                                   "55945" => 65533,
                                   "55946" => 65533,
                                   "55947" => 65533,
                                   "55948" => 65533,
                                   "55949" => 65533,
                                   "55950" => 65533,
                                   "55951" => 65533,
                                   "55952" => 65533,
                                   "55953" => 65533,
                                   "55954" => 65533,
                                   "55955" => 65533,
                                   "55956" => 65533,
                                   "55957" => 65533,
                                   "55958" => 65533,
                                   "55959" => 65533,
                                   "55960" => 65533,
                                   "55961" => 65533,
                                   "55962" => 65533,
                                   "55963" => 65533,
                                   "55964" => 65533,
                                   "55965" => 65533,
                                   "55966" => 65533,
                                   "55967" => 65533,
                                   "55968" => 65533,
                                   "55969" => 65533,
                                   "55970" => 65533,
                                   "55971" => 65533,
                                   "55972" => 65533,
                                   "55973" => 65533,
                                   "55974" => 65533,
                                   "55975" => 65533,
                                   "55976" => 65533,
                                   "55977" => 65533,
                                   "55978" => 65533,
                                   "55979" => 65533,
                                   "55980" => 65533,
                                   "55981" => 65533,
                                   "55982" => 65533,
                                   "55983" => 65533,
                                   "55984" => 65533,
                                   "55985" => 65533,
                                   "55986" => 65533,
                                   "55987" => 65533,
                                   "55988" => 65533,
                                   "55989" => 65533,
                                   "55990" => 65533,
                                   "55991" => 65533,
                                   "55992" => 65533,
                                   "55993" => 65533,
                                   "55994" => 65533,
                                   "55995" => 65533,
                                   "55996" => 65533,
                                   "55997" => 65533,
                                   "55998" => 65533,
                                   "55999" => 65533,
                                   "56000" => 65533,
                                   "56001" => 65533,
                                   "56002" => 65533,
                                   "56003" => 65533,
                                   "56004" => 65533,
                                   "56005" => 65533,
                                   "56006" => 65533,
                                   "56007" => 65533,
                                   "56008" => 65533,
                                   "56009" => 65533,
                                   "56010" => 65533,
                                   "56011" => 65533,
                                   "56012" => 65533,
                                   "56013" => 65533,
                                   "56014" => 65533,
                                   "56015" => 65533,
                                   "56016" => 65533,
                                   "56017" => 65533,
                                   "56018" => 65533,
                                   "56019" => 65533,
                                   "56020" => 65533,
                                   "56021" => 65533,
                                   "56022" => 65533,
                                   "56023" => 65533,
                                   "56024" => 65533,
                                   "56025" => 65533,
                                   "56026" => 65533,
                                   "56027" => 65533,
                                   "56028" => 65533,
                                   "56029" => 65533,
                                   "56030" => 65533,
                                   "56031" => 65533,
                                   "56032" => 65533,
                                   "56033" => 65533,
                                   "56034" => 65533,
                                   "56035" => 65533,
                                   "56036" => 65533,
                                   "56037" => 65533,
                                   "56038" => 65533,
                                   "56039" => 65533,
                                   "56040" => 65533,
                                   "56041" => 65533,
                                   "56042" => 65533,
                                   "56043" => 65533,
                                   "56044" => 65533,
                                   "56045" => 65533,
                                   "56046" => 65533,
                                   "56047" => 65533,
                                   "56048" => 65533,
                                   "56049" => 65533,
                                   "56050" => 65533,
                                   "56051" => 65533,
                                   "56052" => 65533,
                                   "56053" => 65533,
                                   "56054" => 65533,
                                   "56055" => 65533,
                                   "56056" => 65533,
                                   "56057" => 65533,
                                   "56058" => 65533,
                                   "56059" => 65533,
                                   "56060" => 65533,
                                   "56061" => 65533,
                                   "56062" => 65533,
                                   "56063" => 65533,
                                   "56064" => 65533,
                                   "56065" => 65533,
                                   "56066" => 65533,
                                   "56067" => 65533,
                                   "56068" => 65533,
                                   "56069" => 65533,
                                   "56070" => 65533,
                                   "56071" => 65533,
                                   "56072" => 65533,
                                   "56073" => 65533,
                                   "56074" => 65533,
                                   "56075" => 65533,
                                   "56076" => 65533,
                                   "56077" => 65533,
                                   "56078" => 65533,
                                   "56079" => 65533,
                                   "56080" => 65533,
                                   "56081" => 65533,
                                   "56082" => 65533,
                                   "56083" => 65533,
                                   "56084" => 65533,
                                   "56085" => 65533,
                                   "56086" => 65533,
                                   "56087" => 65533,
                                   "56088" => 65533,
                                   "56089" => 65533,
                                   "56090" => 65533,
                                   "56091" => 65533,
                                   "56092" => 65533,
                                   "56093" => 65533,
                                   "56094" => 65533,
                                   "56095" => 65533,
                                   "56096" => 65533,
                                   "56097" => 65533,
                                   "56098" => 65533,
                                   "56099" => 65533,
                                   "56100" => 65533,
                                   "56101" => 65533,
                                   "56102" => 65533,
                                   "56103" => 65533,
                                   "56104" => 65533,
                                   "56105" => 65533,
                                   "56106" => 65533,
                                   "56107" => 65533,
                                   "56108" => 65533,
                                   "56109" => 65533,
                                   "56110" => 65533,
                                   "56111" => 65533,
                                   "56112" => 65533,
                                   "56113" => 65533,
                                   "56114" => 65533,
                                   "56115" => 65533,
                                   "56116" => 65533,
                                   "56117" => 65533,
                                   "56118" => 65533,
                                   "56119" => 65533,
                                   "56120" => 65533,
                                   "56121" => 65533,
                                   "56122" => 65533,
                                   "56123" => 65533,
                                   "56124" => 65533,
                                   "56125" => 65533,
                                   "56126" => 65533,
                                   "56127" => 65533,
                                   "56128" => 65533,
                                   "56129" => 65533,
                                   "56130" => 65533,
                                   "56131" => 65533,
                                   "56132" => 65533,
                                   "56133" => 65533,
                                   "56134" => 65533,
                                   "56135" => 65533,
                                   "56136" => 65533,
                                   "56137" => 65533,
                                   "56138" => 65533,
                                   "56139" => 65533,
                                   "56140" => 65533,
                                   "56141" => 65533,
                                   "56142" => 65533,
                                   "56143" => 65533,
                                   "56144" => 65533,
                                   "56145" => 65533,
                                   "56146" => 65533,
                                   "56147" => 65533,
                                   "56148" => 65533,
                                   "56149" => 65533,
                                   "56150" => 65533,
                                   "56151" => 65533,
                                   "56152" => 65533,
                                   "56153" => 65533,
                                   "56154" => 65533,
                                   "56155" => 65533,
                                   "56156" => 65533,
                                   "56157" => 65533,
                                   "56158" => 65533,
                                   "56159" => 65533,
                                   "56160" => 65533,
                                   "56161" => 65533,
                                   "56162" => 65533,
                                   "56163" => 65533,
                                   "56164" => 65533,
                                   "56165" => 65533,
                                   "56166" => 65533,
                                   "56167" => 65533,
                                   "56168" => 65533,
                                   "56169" => 65533,
                                   "56170" => 65533,
                                   "56171" => 65533,
                                   "56172" => 65533,
                                   "56173" => 65533,
                                   "56174" => 65533,
                                   "56175" => 65533,
                                   "56176" => 65533,
                                   "56177" => 65533,
                                   "56178" => 65533,
                                   "56179" => 65533,
                                   "56180" => 65533,
                                   "56181" => 65533,
                                   "56182" => 65533,
                                   "56183" => 65533,
                                   "56184" => 65533,
                                   "56185" => 65533,
                                   "56186" => 65533,
                                   "56187" => 65533,
                                   "56188" => 65533,
                                   "56189" => 65533,
                                   "56190" => 65533,
                                   "56191" => 65533,
                                   "56192" => 65533,
                                   "56193" => 65533,
                                   "56194" => 65533,
                                   "56195" => 65533,
                                   "56196" => 65533,
                                   "56197" => 65533,
                                   "56198" => 65533,
                                   "56199" => 65533,
                                   "56200" => 65533,
                                   "56201" => 65533,
                                   "56202" => 65533,
                                   "56203" => 65533,
                                   "56204" => 65533,
                                   "56205" => 65533,
                                   "56206" => 65533,
                                   "56207" => 65533,
                                   "56208" => 65533,
                                   "56209" => 65533,
                                   "56210" => 65533,
                                   "56211" => 65533,
                                   "56212" => 65533,
                                   "56213" => 65533,
                                   "56214" => 65533,
                                   "56215" => 65533,
                                   "56216" => 65533,
                                   "56217" => 65533,
                                   "56218" => 65533,
                                   "56219" => 65533,
                                   "56220" => 65533,
                                   "56221" => 65533,
                                   "56222" => 65533,
                                   "56223" => 65533,
                                   "56224" => 65533,
                                   "56225" => 65533,
                                   "56226" => 65533,
                                   "56227" => 65533,
                                   "56228" => 65533,
                                   "56229" => 65533,
                                   "56230" => 65533,
                                   "56231" => 65533,
                                   "56232" => 65533,
                                   "56233" => 65533,
                                   "56234" => 65533,
                                   "56235" => 65533,
                                   "56236" => 65533,
                                   "56237" => 65533,
                                   "56238" => 65533,
                                   "56239" => 65533,
                                   "56240" => 65533,
                                   "56241" => 65533,
                                   "56242" => 65533,
                                   "56243" => 65533,
                                   "56244" => 65533,
                                   "56245" => 65533,
                                   "56246" => 65533,
                                   "56247" => 65533,
                                   "56248" => 65533,
                                   "56249" => 65533,
                                   "56250" => 65533,
                                   "56251" => 65533,
                                   "56252" => 65533,
                                   "56253" => 65533,
                                   "56254" => 65533,
                                   "56255" => 65533,
                                   "56256" => 65533,
                                   "56257" => 65533,
                                   "56258" => 65533,
                                   "56259" => 65533,
                                   "56260" => 65533,
                                   "56261" => 65533,
                                   "56262" => 65533,
                                   "56263" => 65533,
                                   "56264" => 65533,
                                   "56265" => 65533,
                                   "56266" => 65533,
                                   "56267" => 65533,
                                   "56268" => 65533,
                                   "56269" => 65533,
                                   "56270" => 65533,
                                   "56271" => 65533,
                                   "56272" => 65533,
                                   "56273" => 65533,
                                   "56274" => 65533,
                                   "56275" => 65533,
                                   "56276" => 65533,
                                   "56277" => 65533,
                                   "56278" => 65533,
                                   "56279" => 65533,
                                   "56280" => 65533,
                                   "56281" => 65533,
                                   "56282" => 65533,
                                   "56283" => 65533,
                                   "56284" => 65533,
                                   "56285" => 65533,
                                   "56286" => 65533,
                                   "56287" => 65533,
                                   "56288" => 65533,
                                   "56289" => 65533,
                                   "56290" => 65533,
                                   "56291" => 65533,
                                   "56292" => 65533,
                                   "56293" => 65533,
                                   "56294" => 65533,
                                   "56295" => 65533,
                                   "56296" => 65533,
                                   "56297" => 65533,
                                   "56298" => 65533,
                                   "56299" => 65533,
                                   "56300" => 65533,
                                   "56301" => 65533,
                                   "56302" => 65533,
                                   "56303" => 65533,
                                   "56304" => 65533,
                                   "56305" => 65533,
                                   "56306" => 65533,
                                   "56307" => 65533,
                                   "56308" => 65533,
                                   "56309" => 65533,
                                   "56310" => 65533,
                                   "56311" => 65533,
                                   "56312" => 65533,
                                   "56313" => 65533,
                                   "56314" => 65533,
                                   "56315" => 65533,
                                   "56316" => 65533,
                                   "56317" => 65533,
                                   "56318" => 65533,
                                   "56319" => 65533,
                                   "56320" => 65533,
                                   "56321" => 65533,
                                   "56322" => 65533,
                                   "56323" => 65533,
                                   "56324" => 65533,
                                   "56325" => 65533,
                                   "56326" => 65533,
                                   "56327" => 65533,
                                   "56328" => 65533,
                                   "56329" => 65533,
                                   "56330" => 65533,
                                   "56331" => 65533,
                                   "56332" => 65533,
                                   "56333" => 65533,
                                   "56334" => 65533,
                                   "56335" => 65533,
                                   "56336" => 65533,
                                   "56337" => 65533,
                                   "56338" => 65533,
                                   "56339" => 65533,
                                   "56340" => 65533,
                                   "56341" => 65533,
                                   "56342" => 65533,
                                   "56343" => 65533,
                                   "56344" => 65533,
                                   "56345" => 65533,
                                   "56346" => 65533,
                                   "56347" => 65533,
                                   "56348" => 65533,
                                   "56349" => 65533,
                                   "56350" => 65533,
                                   "56351" => 65533,
                                   "56352" => 65533,
                                   "56353" => 65533,
                                   "56354" => 65533,
                                   "56355" => 65533,
                                   "56356" => 65533,
                                   "56357" => 65533,
                                   "56358" => 65533,
                                   "56359" => 65533,
                                   "56360" => 65533,
                                   "56361" => 65533,
                                   "56362" => 65533,
                                   "56363" => 65533,
                                   "56364" => 65533,
                                   "56365" => 65533,
                                   "56366" => 65533,
                                   "56367" => 65533,
                                   "56368" => 65533,
                                   "56369" => 65533,
                                   "56370" => 65533,
                                   "56371" => 65533,
                                   "56372" => 65533,
                                   "56373" => 65533,
                                   "56374" => 65533,
                                   "56375" => 65533,
                                   "56376" => 65533,
                                   "56377" => 65533,
                                   "56378" => 65533,
                                   "56379" => 65533,
                                   "56380" => 65533,
                                   "56381" => 65533,
                                   "56382" => 65533,
                                   "56383" => 65533,
                                   "56384" => 65533,
                                   "56385" => 65533,
                                   "56386" => 65533,
                                   "56387" => 65533,
                                   "56388" => 65533,
                                   "56389" => 65533,
                                   "56390" => 65533,
                                   "56391" => 65533,
                                   "56392" => 65533,
                                   "56393" => 65533,
                                   "56394" => 65533,
                                   "56395" => 65533,
                                   "56396" => 65533,
                                   "56397" => 65533,
                                   "56398" => 65533,
                                   "56399" => 65533,
                                   "56400" => 65533,
                                   "56401" => 65533,
                                   "56402" => 65533,
                                   "56403" => 65533,
                                   "56404" => 65533,
                                   "56405" => 65533,
                                   "56406" => 65533,
                                   "56407" => 65533,
                                   "56408" => 65533,
                                   "56409" => 65533,
                                   "56410" => 65533,
                                   "56411" => 65533,
                                   "56412" => 65533,
                                   "56413" => 65533,
                                   "56414" => 65533,
                                   "56415" => 65533,
                                   "56416" => 65533,
                                   "56417" => 65533,
                                   "56418" => 65533,
                                   "56419" => 65533,
                                   "56420" => 65533,
                                   "56421" => 65533,
                                   "56422" => 65533,
                                   "56423" => 65533,
                                   "56424" => 65533,
                                   "56425" => 65533,
                                   "56426" => 65533,
                                   "56427" => 65533,
                                   "56428" => 65533,
                                   "56429" => 65533,
                                   "56430" => 65533,
                                   "56431" => 65533,
                                   "56432" => 65533,
                                   "56433" => 65533,
                                   "56434" => 65533,
                                   "56435" => 65533,
                                   "56436" => 65533,
                                   "56437" => 65533,
                                   "56438" => 65533,
                                   "56439" => 65533,
                                   "56440" => 65533,
                                   "56441" => 65533,
                                   "56442" => 65533,
                                   "56443" => 65533,
                                   "56444" => 65533,
                                   "56445" => 65533,
                                   "56446" => 65533,
                                   "56447" => 65533,
                                   "56448" => 65533,
                                   "56449" => 65533,
                                   "56450" => 65533,
                                   "56451" => 65533,
                                   "56452" => 65533,
                                   "56453" => 65533,
                                   "56454" => 65533,
                                   "56455" => 65533,
                                   "56456" => 65533,
                                   "56457" => 65533,
                                   "56458" => 65533,
                                   "56459" => 65533,
                                   "56460" => 65533,
                                   "56461" => 65533,
                                   "56462" => 65533,
                                   "56463" => 65533,
                                   "56464" => 65533,
                                   "56465" => 65533,
                                   "56466" => 65533,
                                   "56467" => 65533,
                                   "56468" => 65533,
                                   "56469" => 65533,
                                   "56470" => 65533,
                                   "56471" => 65533,
                                   "56472" => 65533,
                                   "56473" => 65533,
                                   "56474" => 65533,
                                   "56475" => 65533,
                                   "56476" => 65533,
                                   "56477" => 65533,
                                   "56478" => 65533,
                                   "56479" => 65533,
                                   "56480" => 65533,
                                   "56481" => 65533,
                                   "56482" => 65533,
                                   "56483" => 65533,
                                   "56484" => 65533,
                                   "56485" => 65533,
                                   "56486" => 65533,
                                   "56487" => 65533,
                                   "56488" => 65533,
                                   "56489" => 65533,
                                   "56490" => 65533,
                                   "56491" => 65533,
                                   "56492" => 65533,
                                   "56493" => 65533,
                                   "56494" => 65533,
                                   "56495" => 65533,
                                   "56496" => 65533,
                                   "56497" => 65533,
                                   "56498" => 65533,
                                   "56499" => 65533,
                                   "56500" => 65533,
                                   "56501" => 65533,
                                   "56502" => 65533,
                                   "56503" => 65533,
                                   "56504" => 65533,
                                   "56505" => 65533,
                                   "56506" => 65533,
                                   "56507" => 65533,
                                   "56508" => 65533,
                                   "56509" => 65533,
                                   "56510" => 65533,
                                   "56511" => 65533,
                                   "56512" => 65533,
                                   "56513" => 65533,
                                   "56514" => 65533,
                                   "56515" => 65533,
                                   "56516" => 65533,
                                   "56517" => 65533,
                                   "56518" => 65533,
                                   "56519" => 65533,
                                   "56520" => 65533,
                                   "56521" => 65533,
                                   "56522" => 65533,
                                   "56523" => 65533,
                                   "56524" => 65533,
                                   "56525" => 65533,
                                   "56526" => 65533,
                                   "56527" => 65533,
                                   "56528" => 65533,
                                   "56529" => 65533,
                                   "56530" => 65533,
                                   "56531" => 65533,
                                   "56532" => 65533,
                                   "56533" => 65533,
                                   "56534" => 65533,
                                   "56535" => 65533,
                                   "56536" => 65533,
                                   "56537" => 65533,
                                   "56538" => 65533,
                                   "56539" => 65533,
                                   "56540" => 65533,
                                   "56541" => 65533,
                                   "56542" => 65533,
                                   "56543" => 65533,
                                   "56544" => 65533,
                                   "56545" => 65533,
                                   "56546" => 65533,
                                   "56547" => 65533,
                                   "56548" => 65533,
                                   "56549" => 65533,
                                   "56550" => 65533,
                                   "56551" => 65533,
                                   "56552" => 65533,
                                   "56553" => 65533,
                                   "56554" => 65533,
                                   "56555" => 65533,
                                   "56556" => 65533,
                                   "56557" => 65533,
                                   "56558" => 65533,
                                   "56559" => 65533,
                                   "56560" => 65533,
                                   "56561" => 65533,
                                   "56562" => 65533,
                                   "56563" => 65533,
                                   "56564" => 65533,
                                   "56565" => 65533,
                                   "56566" => 65533,
                                   "56567" => 65533,
                                   "56568" => 65533,
                                   "56569" => 65533,
                                   "56570" => 65533,
                                   "56571" => 65533,
                                   "56572" => 65533,
                                   "56573" => 65533,
                                   "56574" => 65533,
                                   "56575" => 65533,
                                   "56576" => 65533,
                                   "56577" => 65533,
                                   "56578" => 65533,
                                   "56579" => 65533,
                                   "56580" => 65533,
                                   "56581" => 65533,
                                   "56582" => 65533,
                                   "56583" => 65533,
                                   "56584" => 65533,
                                   "56585" => 65533,
                                   "56586" => 65533,
                                   "56587" => 65533,
                                   "56588" => 65533,
                                   "56589" => 65533,
                                   "56590" => 65533,
                                   "56591" => 65533,
                                   "56592" => 65533,
                                   "56593" => 65533,
                                   "56594" => 65533,
                                   "56595" => 65533,
                                   "56596" => 65533,
                                   "56597" => 65533,
                                   "56598" => 65533,
                                   "56599" => 65533,
                                   "56600" => 65533,
                                   "56601" => 65533,
                                   "56602" => 65533,
                                   "56603" => 65533,
                                   "56604" => 65533,
                                   "56605" => 65533,
                                   "56606" => 65533,
                                   "56607" => 65533,
                                   "56608" => 65533,
                                   "56609" => 65533,
                                   "56610" => 65533,
                                   "56611" => 65533,
                                   "56612" => 65533,
                                   "56613" => 65533,
                                   "56614" => 65533,
                                   "56615" => 65533,
                                   "56616" => 65533,
                                   "56617" => 65533,
                                   "56618" => 65533,
                                   "56619" => 65533,
                                   "56620" => 65533,
                                   "56621" => 65533,
                                   "56622" => 65533,
                                   "56623" => 65533,
                                   "56624" => 65533,
                                   "56625" => 65533,
                                   "56626" => 65533,
                                   "56627" => 65533,
                                   "56628" => 65533,
                                   "56629" => 65533,
                                   "56630" => 65533,
                                   "56631" => 65533,
                                   "56632" => 65533,
                                   "56633" => 65533,
                                   "56634" => 65533,
                                   "56635" => 65533,
                                   "56636" => 65533,
                                   "56637" => 65533,
                                   "56638" => 65533,
                                   "56639" => 65533,
                                   "56640" => 65533,
                                   "56641" => 65533,
                                   "56642" => 65533,
                                   "56643" => 65533,
                                   "56644" => 65533,
                                   "56645" => 65533,
                                   "56646" => 65533,
                                   "56647" => 65533,
                                   "56648" => 65533,
                                   "56649" => 65533,
                                   "56650" => 65533,
                                   "56651" => 65533,
                                   "56652" => 65533,
                                   "56653" => 65533,
                                   "56654" => 65533,
                                   "56655" => 65533,
                                   "56656" => 65533,
                                   "56657" => 65533,
                                   "56658" => 65533,
                                   "56659" => 65533,
                                   "56660" => 65533,
                                   "56661" => 65533,
                                   "56662" => 65533,
                                   "56663" => 65533,
                                   "56664" => 65533,
                                   "56665" => 65533,
                                   "56666" => 65533,
                                   "56667" => 65533,
                                   "56668" => 65533,
                                   "56669" => 65533,
                                   "56670" => 65533,
                                   "56671" => 65533,
                                   "56672" => 65533,
                                   "56673" => 65533,
                                   "56674" => 65533,
                                   "56675" => 65533,
                                   "56676" => 65533,
                                   "56677" => 65533,
                                   "56678" => 65533,
                                   "56679" => 65533,
                                   "56680" => 65533,
                                   "56681" => 65533,
                                   "56682" => 65533,
                                   "56683" => 65533,
                                   "56684" => 65533,
                                   "56685" => 65533,
                                   "56686" => 65533,
                                   "56687" => 65533,
                                   "56688" => 65533,
                                   "56689" => 65533,
                                   "56690" => 65533,
                                   "56691" => 65533,
                                   "56692" => 65533,
                                   "56693" => 65533,
                                   "56694" => 65533,
                                   "56695" => 65533,
                                   "56696" => 65533,
                                   "56697" => 65533,
                                   "56698" => 65533,
                                   "56699" => 65533,
                                   "56700" => 65533,
                                   "56701" => 65533,
                                   "56702" => 65533,
                                   "56703" => 65533,
                                   "56704" => 65533,
                                   "56705" => 65533,
                                   "56706" => 65533,
                                   "56707" => 65533,
                                   "56708" => 65533,
                                   "56709" => 65533,
                                   "56710" => 65533,
                                   "56711" => 65533,
                                   "56712" => 65533,
                                   "56713" => 65533,
                                   "56714" => 65533,
                                   "56715" => 65533,
                                   "56716" => 65533,
                                   "56717" => 65533,
                                   "56718" => 65533,
                                   "56719" => 65533,
                                   "56720" => 65533,
                                   "56721" => 65533,
                                   "56722" => 65533,
                                   "56723" => 65533,
                                   "56724" => 65533,
                                   "56725" => 65533,
                                   "56726" => 65533,
                                   "56727" => 65533,
                                   "56728" => 65533,
                                   "56729" => 65533,
                                   "56730" => 65533,
                                   "56731" => 65533,
                                   "56732" => 65533,
                                   "56733" => 65533,
                                   "56734" => 65533,
                                   "56735" => 65533,
                                   "56736" => 65533,
                                   "56737" => 65533,
                                   "56738" => 65533,
                                   "56739" => 65533,
                                   "56740" => 65533,
                                   "56741" => 65533,
                                   "56742" => 65533,
                                   "56743" => 65533,
                                   "56744" => 65533,
                                   "56745" => 65533,
                                   "56746" => 65533,
                                   "56747" => 65533,
                                   "56748" => 65533,
                                   "56749" => 65533,
                                   "56750" => 65533,
                                   "56751" => 65533,
                                   "56752" => 65533,
                                   "56753" => 65533,
                                   "56754" => 65533,
                                   "56755" => 65533,
                                   "56756" => 65533,
                                   "56757" => 65533,
                                   "56758" => 65533,
                                   "56759" => 65533,
                                   "56760" => 65533,
                                   "56761" => 65533,
                                   "56762" => 65533,
                                   "56763" => 65533,
                                   "56764" => 65533,
                                   "56765" => 65533,
                                   "56766" => 65533,
                                   "56767" => 65533,
                                   "56768" => 65533,
                                   "56769" => 65533,
                                   "56770" => 65533,
                                   "56771" => 65533,
                                   "56772" => 65533,
                                   "56773" => 65533,
                                   "56774" => 65533,
                                   "56775" => 65533,
                                   "56776" => 65533,
                                   "56777" => 65533,
                                   "56778" => 65533,
                                   "56779" => 65533,
                                   "56780" => 65533,
                                   "56781" => 65533,
                                   "56782" => 65533,
                                   "56783" => 65533,
                                   "56784" => 65533,
                                   "56785" => 65533,
                                   "56786" => 65533,
                                   "56787" => 65533,
                                   "56788" => 65533,
                                   "56789" => 65533,
                                   "56790" => 65533,
                                   "56791" => 65533,
                                   "56792" => 65533,
                                   "56793" => 65533,
                                   "56794" => 65533,
                                   "56795" => 65533,
                                   "56796" => 65533,
                                   "56797" => 65533,
                                   "56798" => 65533,
                                   "56799" => 65533,
                                   "56800" => 65533,
                                   "56801" => 65533,
                                   "56802" => 65533,
                                   "56803" => 65533,
                                   "56804" => 65533,
                                   "56805" => 65533,
                                   "56806" => 65533,
                                   "56807" => 65533,
                                   "56808" => 65533,
                                   "56809" => 65533,
                                   "56810" => 65533,
                                   "56811" => 65533,
                                   "56812" => 65533,
                                   "56813" => 65533,
                                   "56814" => 65533,
                                   "56815" => 65533,
                                   "56816" => 65533,
                                   "56817" => 65533,
                                   "56818" => 65533,
                                   "56819" => 65533,
                                   "56820" => 65533,
                                   "56821" => 65533,
                                   "56822" => 65533,
                                   "56823" => 65533,
                                   "56824" => 65533,
                                   "56825" => 65533,
                                   "56826" => 65533,
                                   "56827" => 65533,
                                   "56828" => 65533,
                                   "56829" => 65533,
                                   "56830" => 65533,
                                   "56831" => 65533,
                                   "56832" => 65533,
                                   "56833" => 65533,
                                   "56834" => 65533,
                                   "56835" => 65533,
                                   "56836" => 65533,
                                   "56837" => 65533,
                                   "56838" => 65533,
                                   "56839" => 65533,
                                   "56840" => 65533,
                                   "56841" => 65533,
                                   "56842" => 65533,
                                   "56843" => 65533,
                                   "56844" => 65533,
                                   "56845" => 65533,
                                   "56846" => 65533,
                                   "56847" => 65533,
                                   "56848" => 65533,
                                   "56849" => 65533,
                                   "56850" => 65533,
                                   "56851" => 65533,
                                   "56852" => 65533,
                                   "56853" => 65533,
                                   "56854" => 65533,
                                   "56855" => 65533,
                                   "56856" => 65533,
                                   "56857" => 65533,
                                   "56858" => 65533,
                                   "56859" => 65533,
                                   "56860" => 65533,
                                   "56861" => 65533,
                                   "56862" => 65533,
                                   "56863" => 65533,
                                   "56864" => 65533,
                                   "56865" => 65533,
                                   "56866" => 65533,
                                   "56867" => 65533,
                                   "56868" => 65533,
                                   "56869" => 65533,
                                   "56870" => 65533,
                                   "56871" => 65533,
                                   "56872" => 65533,
                                   "56873" => 65533,
                                   "56874" => 65533,
                                   "56875" => 65533,
                                   "56876" => 65533,
                                   "56877" => 65533,
                                   "56878" => 65533,
                                   "56879" => 65533,
                                   "56880" => 65533,
                                   "56881" => 65533,
                                   "56882" => 65533,
                                   "56883" => 65533,
                                   "56884" => 65533,
                                   "56885" => 65533,
                                   "56886" => 65533,
                                   "56887" => 65533,
                                   "56888" => 65533,
                                   "56889" => 65533,
                                   "56890" => 65533,
                                   "56891" => 65533,
                                   "56892" => 65533,
                                   "56893" => 65533,
                                   "56894" => 65533,
                                   "56895" => 65533,
                                   "56896" => 65533,
                                   "56897" => 65533,
                                   "56898" => 65533,
                                   "56899" => 65533,
                                   "56900" => 65533,
                                   "56901" => 65533,
                                   "56902" => 65533,
                                   "56903" => 65533,
                                   "56904" => 65533,
                                   "56905" => 65533,
                                   "56906" => 65533,
                                   "56907" => 65533,
                                   "56908" => 65533,
                                   "56909" => 65533,
                                   "56910" => 65533,
                                   "56911" => 65533,
                                   "56912" => 65533,
                                   "56913" => 65533,
                                   "56914" => 65533,
                                   "56915" => 65533,
                                   "56916" => 65533,
                                   "56917" => 65533,
                                   "56918" => 65533,
                                   "56919" => 65533,
                                   "56920" => 65533,
                                   "56921" => 65533,
                                   "56922" => 65533,
                                   "56923" => 65533,
                                   "56924" => 65533,
                                   "56925" => 65533,
                                   "56926" => 65533,
                                   "56927" => 65533,
                                   "56928" => 65533,
                                   "56929" => 65533,
                                   "56930" => 65533,
                                   "56931" => 65533,
                                   "56932" => 65533,
                                   "56933" => 65533,
                                   "56934" => 65533,
                                   "56935" => 65533,
                                   "56936" => 65533,
                                   "56937" => 65533,
                                   "56938" => 65533,
                                   "56939" => 65533,
                                   "56940" => 65533,
                                   "56941" => 65533,
                                   "56942" => 65533,
                                   "56943" => 65533,
                                   "56944" => 65533,
                                   "56945" => 65533,
                                   "56946" => 65533,
                                   "56947" => 65533,
                                   "56948" => 65533,
                                   "56949" => 65533,
                                   "56950" => 65533,
                                   "56951" => 65533,
                                   "56952" => 65533,
                                   "56953" => 65533,
                                   "56954" => 65533,
                                   "56955" => 65533,
                                   "56956" => 65533,
                                   "56957" => 65533,
                                   "56958" => 65533,
                                   "56959" => 65533,
                                   "56960" => 65533,
                                   "56961" => 65533,
                                   "56962" => 65533,
                                   "56963" => 65533,
                                   "56964" => 65533,
                                   "56965" => 65533,
                                   "56966" => 65533,
                                   "56967" => 65533,
                                   "56968" => 65533,
                                   "56969" => 65533,
                                   "56970" => 65533,
                                   "56971" => 65533,
                                   "56972" => 65533,
                                   "56973" => 65533,
                                   "56974" => 65533,
                                   "56975" => 65533,
                                   "56976" => 65533,
                                   "56977" => 65533,
                                   "56978" => 65533,
                                   "56979" => 65533,
                                   "56980" => 65533,
                                   "56981" => 65533,
                                   "56982" => 65533,
                                   "56983" => 65533,
                                   "56984" => 65533,
                                   "56985" => 65533,
                                   "56986" => 65533,
                                   "56987" => 65533,
                                   "56988" => 65533,
                                   "56989" => 65533,
                                   "56990" => 65533,
                                   "56991" => 65533,
                                   "56992" => 65533,
                                   "56993" => 65533,
                                   "56994" => 65533,
                                   "56995" => 65533,
                                   "56996" => 65533,
                                   "56997" => 65533,
                                   "56998" => 65533,
                                   "56999" => 65533,
                                   "57000" => 65533,
                                   "57001" => 65533,
                                   "57002" => 65533,
                                   "57003" => 65533,
                                   "57004" => 65533,
                                   "57005" => 65533,
                                   "57006" => 65533,
                                   "57007" => 65533,
                                   "57008" => 65533,
                                   "57009" => 65533,
                                   "57010" => 65533,
                                   "57011" => 65533,
                                   "57012" => 65533,
                                   "57013" => 65533,
                                   "57014" => 65533,
                                   "57015" => 65533,
                                   "57016" => 65533,
                                   "57017" => 65533,
                                   "57018" => 65533,
                                   "57019" => 65533,
                                   "57020" => 65533,
                                   "57021" => 65533,
                                   "57022" => 65533,
                                   "57023" => 65533,
                                   "57024" => 65533,
                                   "57025" => 65533,
                                   "57026" => 65533,
                                   "57027" => 65533,
                                   "57028" => 65533,
                                   "57029" => 65533,
                                   "57030" => 65533,
                                   "57031" => 65533,
                                   "57032" => 65533,
                                   "57033" => 65533,
                                   "57034" => 65533,
                                   "57035" => 65533,
                                   "57036" => 65533,
                                   "57037" => 65533,
                                   "57038" => 65533,
                                   "57039" => 65533,
                                   "57040" => 65533,
                                   "57041" => 65533,
                                   "57042" => 65533,
                                   "57043" => 65533,
                                   "57044" => 65533,
                                   "57045" => 65533,
                                   "57046" => 65533,
                                   "57047" => 65533,
                                   "57048" => 65533,
                                   "57049" => 65533,
                                   "57050" => 65533,
                                   "57051" => 65533,
                                   "57052" => 65533,
                                   "57053" => 65533,
                                   "57054" => 65533,
                                   "57055" => 65533,
                                   "57056" => 65533,
                                   "57057" => 65533,
                                   "57058" => 65533,
                                   "57059" => 65533,
                                   "57060" => 65533,
                                   "57061" => 65533,
                                   "57062" => 65533,
                                   "57063" => 65533,
                                   "57064" => 65533,
                                   "57065" => 65533,
                                   "57066" => 65533,
                                   "57067" => 65533,
                                   "57068" => 65533,
                                   "57069" => 65533,
                                   "57070" => 65533,
                                   "57071" => 65533,
                                   "57072" => 65533,
                                   "57073" => 65533,
                                   "57074" => 65533,
                                   "57075" => 65533,
                                   "57076" => 65533,
                                   "57077" => 65533,
                                   "57078" => 65533,
                                   "57079" => 65533,
                                   "57080" => 65533,
                                   "57081" => 65533,
                                   "57082" => 65533,
                                   "57083" => 65533,
                                   "57084" => 65533,
                                   "57085" => 65533,
                                   "57086" => 65533,
                                   "57087" => 65533,
                                   "57088" => 65533,
                                   "57089" => 65533,
                                   "57090" => 65533,
                                   "57091" => 65533,
                                   "57092" => 65533,
                                   "57093" => 65533,
                                   "57094" => 65533,
                                   "57095" => 65533,
                                   "57096" => 65533,
                                   "57097" => 65533,
                                   "57098" => 65533,
                                   "57099" => 65533,
                                   "57100" => 65533,
                                   "57101" => 65533,
                                   "57102" => 65533,
                                   "57103" => 65533,
                                   "57104" => 65533,
                                   "57105" => 65533,
                                   "57106" => 65533,
                                   "57107" => 65533,
                                   "57108" => 65533,
                                   "57109" => 65533,
                                   "57110" => 65533,
                                   "57111" => 65533,
                                   "57112" => 65533,
                                   "57113" => 65533,
                                   "57114" => 65533,
                                   "57115" => 65533,
                                   "57116" => 65533,
                                   "57117" => 65533,
                                   "57118" => 65533,
                                   "57119" => 65533,
                                   "57120" => 65533,
                                   "57121" => 65533,
                                   "57122" => 65533,
                                   "57123" => 65533,
                                   "57124" => 65533,
                                   "57125" => 65533,
                                   "57126" => 65533,
                                   "57127" => 65533,
                                   "57128" => 65533,
                                   "57129" => 65533,
                                   "57130" => 65533,
                                   "57131" => 65533,
                                   "57132" => 65533,
                                   "57133" => 65533,
                                   "57134" => 65533,
                                   "57135" => 65533,
                                   "57136" => 65533,
                                   "57137" => 65533,
                                   "57138" => 65533,
                                   "57139" => 65533,
                                   "57140" => 65533,
                                   "57141" => 65533,
                                   "57142" => 65533,
                                   "57143" => 65533,
                                   "57144" => 65533,
                                   "57145" => 65533,
                                   "57146" => 65533,
                                   "57147" => 65533,
                                   "57148" => 65533,
                                   "57149" => 65533,
                                   "57150" => 65533,
                                   "57151" => 65533,
                                   "57152" => 65533,
                                   "57153" => 65533,
                                   "57154" => 65533,
                                   "57155" => 65533,
                                   "57156" => 65533,
                                   "57157" => 65533,
                                   "57158" => 65533,
                                   "57159" => 65533,
                                   "57160" => 65533,
                                   "57161" => 65533,
                                   "57162" => 65533,
                                   "57163" => 65533,
                                   "57164" => 65533,
                                   "57165" => 65533,
                                   "57166" => 65533,
                                   "57167" => 65533,
                                   "57168" => 65533,
                                   "57169" => 65533,
                                   "57170" => 65533,
                                   "57171" => 65533,
                                   "57172" => 65533,
                                   "57173" => 65533,
                                   "57174" => 65533,
                                   "57175" => 65533,
                                   "57176" => 65533,
                                   "57177" => 65533,
                                   "57178" => 65533,
                                   "57179" => 65533,
                                   "57180" => 65533,
                                   "57181" => 65533,
                                   "57182" => 65533,
                                   "57183" => 65533,
                                   "57184" => 65533,
                                   "57185" => 65533,
                                   "57186" => 65533,
                                   "57187" => 65533,
                                   "57188" => 65533,
                                   "57189" => 65533,
                                   "57190" => 65533,
                                   "57191" => 65533,
                                   "57192" => 65533,
                                   "57193" => 65533,
                                   "57194" => 65533,
                                   "57195" => 65533,
                                   "57196" => 65533,
                                   "57197" => 65533,
                                   "57198" => 65533,
                                   "57199" => 65533,
                                   "57200" => 65533,
                                   "57201" => 65533,
                                   "57202" => 65533,
                                   "57203" => 65533,
                                   "57204" => 65533,
                                   "57205" => 65533,
                                   "57206" => 65533,
                                   "57207" => 65533,
                                   "57208" => 65533,
                                   "57209" => 65533,
                                   "57210" => 65533,
                                   "57211" => 65533,
                                   "57212" => 65533,
                                   "57213" => 65533,
                                   "57214" => 65533,
                                   "57215" => 65533,
                                   "57216" => 65533,
                                   "57217" => 65533,
                                   "57218" => 65533,
                                   "57219" => 65533,
                                   "57220" => 65533,
                                   "57221" => 65533,
                                   "57222" => 65533,
                                   "57223" => 65533,
                                   "57224" => 65533,
                                   "57225" => 65533,
                                   "57226" => 65533,
                                   "57227" => 65533,
                                   "57228" => 65533,
                                   "57229" => 65533,
                                   "57230" => 65533,
                                   "57231" => 65533,
                                   "57232" => 65533,
                                   "57233" => 65533,
                                   "57234" => 65533,
                                   "57235" => 65533,
                                   "57236" => 65533,
                                   "57237" => 65533,
                                   "57238" => 65533,
                                   "57239" => 65533,
                                   "57240" => 65533,
                                   "57241" => 65533,
                                   "57242" => 65533,
                                   "57243" => 65533,
                                   "57244" => 65533,
                                   "57245" => 65533,
                                   "57246" => 65533,
                                   "57247" => 65533,
                                   "57248" => 65533,
                                   "57249" => 65533,
                                   "57250" => 65533,
                                   "57251" => 65533,
                                   "57252" => 65533,
                                   "57253" => 65533,
                                   "57254" => 65533,
                                   "57255" => 65533,
                                   "57256" => 65533,
                                   "57257" => 65533,
                                   "57258" => 65533,
                                   "57259" => 65533,
                                   "57260" => 65533,
                                   "57261" => 65533,
                                   "57262" => 65533,
                                   "57263" => 65533,
                                   "57264" => 65533,
                                   "57265" => 65533,
                                   "57266" => 65533,
                                   "57267" => 65533,
                                   "57268" => 65533,
                                   "57269" => 65533,
                                   "57270" => 65533,
                                   "57271" => 65533,
                                   "57272" => 65533,
                                   "57273" => 65533,
                                   "57274" => 65533,
                                   "57275" => 65533,
                                   "57276" => 65533,
                                   "57277" => 65533,
                                   "57278" => 65533,
                                   "57279" => 65533,
                                   "57280" => 65533,
                                   "57281" => 65533,
                                   "57282" => 65533,
                                   "57283" => 65533,
                                   "57284" => 65533,
                                   "57285" => 65533,
                                   "57286" => 65533,
                                   "57287" => 65533,
                                   "57288" => 65533,
                                   "57289" => 65533,
                                   "57290" => 65533,
                                   "57291" => 65533,
                                   "57292" => 65533,
                                   "57293" => 65533,
                                   "57294" => 65533,
                                   "57295" => 65533,
                                   "57296" => 65533,
                                   "57297" => 65533,
                                   "57298" => 65533,
                                   "57299" => 65533,
                                   "57300" => 65533,
                                   "57301" => 65533,
                                   "57302" => 65533,
                                   "57303" => 65533,
                                   "57304" => 65533,
                                   "57305" => 65533,
                                   "57306" => 65533,
                                   "57307" => 65533,
                                   "57308" => 65533,
                                   "57309" => 65533,
                                   "57310" => 65533,
                                   "57311" => 65533,
                                   "57312" => 65533,
                                   "57313" => 65533,
                                   "57314" => 65533,
                                   "57315" => 65533,
                                   "57316" => 65533,
                                   "57317" => 65533,
                                   "57318" => 65533,
                                   "57319" => 65533,
                                   "57320" => 65533,
                                   "57321" => 65533,
                                   "57322" => 65533,
                                   "57323" => 65533,
                                   "57324" => 65533,
                                   "57325" => 65533,
                                   "57326" => 65533,
                                   "57327" => 65533,
                                   "57328" => 65533,
                                   "57329" => 65533,
                                   "57330" => 65533,
                                   "57331" => 65533,
                                   "57332" => 65533,
                                   "57333" => 65533,
                                   "57334" => 65533,
                                   "57335" => 65533,
                                   "57336" => 65533,
                                   "57337" => 65533,
                                   "57338" => 65533,
                                   "57339" => 65533,
                                   "57340" => 65533,
                                   "57341" => 65533,
                                   "57342" => 65533,
                                   "57343" => 65533,
                                   "589822" => 589822,
                                   "589823" => 589823,
                                   "6" => 6,
                                   "64976" => 64976,
                                   "64977" => 64977,
                                   "64978" => 64978,
                                   "64979" => 64979,
                                   "64980" => 64980,
                                   "64981" => 64981,
                                   "64982" => 64982,
                                   "64983" => 64983,
                                   "64984" => 64984,
                                   "64985" => 64985,
                                   "64986" => 64986,
                                   "64987" => 64987,
                                   "64988" => 64988,
                                   "64989" => 64989,
                                   "64990" => 64990,
                                   "64991" => 64991,
                                   "64992" => 64992,
                                   "64993" => 64993,
                                   "64994" => 64994,
                                   "64995" => 64995,
                                   "64996" => 64996,
                                   "64997" => 64997,
                                   "64998" => 64998,
                                   "64999" => 64999,
                                   "65000" => 65000,
                                   "65001" => 65001,
                                   "65002" => 65002,
                                   "65003" => 65003,
                                   "65004" => 65004,
                                   "65005" => 65005,
                                   "65006" => 65006,
                                   "65007" => 65007,
                                   "65534" => 65534,
                                   "65535" => 65535,
                                   "655358" => 655358,
                                   "655359" => 655359,
                                   "7" => 7,
                                   "720894" => 720894,
                                   "720895" => 720895,
                                   "786430" => 786430,
                                   "786431" => 786431,
                                   "8" => 8,
                                   "851966" => 851966,
                                   "851967" => 851967,
                                   "917502" => 917502,
                                   "917503" => 917503,
                                   "983038" => 983038,
                                   "983039" => 983039
                                 },
            "charref_replacements" => {
                                        "0" => 65533,
                                        "128" => 8364,
                                        "129" => 129,
                                        "130" => 8218,
                                        "131" => 402,
                                        "132" => 8222,
                                        "133" => 8230,
                                        "134" => 8224,
                                        "135" => 8225,
                                        "136" => 710,
                                        "137" => 8240,
                                        "138" => 352,
                                        "139" => 8249,
                                        "140" => 338,
                                        "141" => 141,
                                        "142" => 381,
                                        "143" => 143,
                                        "144" => 144,
                                        "145" => 8216,
                                        "146" => 8217,
                                        "147" => 8220,
                                        "148" => 8221,
                                        "149" => 8226,
                                        "150" => 8211,
                                        "151" => 8212,
                                        "152" => 732,
                                        "153" => 8482,
                                        "154" => 353,
                                        "155" => 8250,
                                        "156" => 339,
                                        "157" => 157,
                                        "158" => 382,
                                        "159" => 376
                                      },
            "charrefs_pubids" => {
                                   "-//W3C//DTD MathML 2.0//EN" => 1,
                                   "-//W3C//DTD XHTML 1.0 Frameset//EN" => 1,
                                   "-//W3C//DTD XHTML 1.0 Strict//EN" => 1,
                                   "-//W3C//DTD XHTML 1.0 Transitional//EN" => 1,
                                   "-//W3C//DTD XHTML 1.1 plus MathML 2.0 plus SVG 1.1//EN" => 1,
                                   "-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN" => 1,
                                   "-//W3C//DTD XHTML 1.1//EN" => 1,
                                   "-//W3C//DTD XHTML Basic 1.0//EN" => 1,
                                   "-//WAPFORUM//DTD XHTML Mobile 1.0//EN" => 1
                                 },
            "foreign_content_breakers" => {
                                            "b" => 1,
                                            "big" => 1,
                                            "blockquote" => 1,
                                            "body" => 1,
                                            "br" => 1,
                                            "center" => 1,
                                            "code" => 1,
                                            "dd" => 1,
                                            "div" => 1,
                                            "dl" => 1,
                                            "dt" => 1,
                                            "em" => 1,
                                            "embed" => 1,
                                            "h1" => 1,
                                            "h2" => 1,
                                            "h3" => 1,
                                            "h4" => 1,
                                            "h5" => 1,
                                            "h6" => 1,
                                            "head" => 1,
                                            "hr" => 1,
                                            "i" => 1,
                                            "img" => 1,
                                            "li" => 1,
                                            "listing" => 1,
                                            "menu" => 1,
                                            "meta" => 1,
                                            "nobr" => 1,
                                            "ol" => 1,
                                            "p" => 1,
                                            "pre" => 1,
                                            "ruby" => 1,
                                            "s" => 1,
                                            "small" => 1,
                                            "span" => 1,
                                            "strike" => 1,
                                            "strong" => 1,
                                            "sub" => 1,
                                            "sup" => 1,
                                            "table" => 1,
                                            "tt" => 1,
                                            "u" => 1,
                                            "ul" => 1,
                                            "var" => 1
                                          },
            "is_mathml_text_integration_point" => {
                                                    "mi" => 1,
                                                    "mn" => 1,
                                                    "mo" => 1,
                                                    "ms" => 1,
                                                    "mtext" => 1
                                                  },
            "is_mathml_text_integration_point_mathml" => {
                                                           "malignmark" => 1,
                                                           "mglyph" => 1
                                                         },
            "is_svg_html_integration_point" => {
                                                 "desc" => 1,
                                                 "foreignObject" => 1,
                                                 "title" => 1
                                               },
            "nonchars" => {
                            "1048574" => 1,
                            "1048575" => 1,
                            "1114110" => 1,
                            "1114111" => 1,
                            "131070" => 1,
                            "131071" => 1,
                            "196606" => 1,
                            "196607" => 1,
                            "262142" => 1,
                            "262143" => 1,
                            "327678" => 1,
                            "327679" => 1,
                            "393214" => 1,
                            "393215" => 1,
                            "458750" => 1,
                            "458751" => 1,
                            "524286" => 1,
                            "524287" => 1,
                            "589822" => 1,
                            "589823" => 1,
                            "64976" => 1,
                            "64977" => 1,
                            "64978" => 1,
                            "64979" => 1,
                            "64980" => 1,
                            "64981" => 1,
                            "64982" => 1,
                            "64983" => 1,
                            "64984" => 1,
                            "64985" => 1,
                            "64986" => 1,
                            "64987" => 1,
                            "64988" => 1,
                            "64989" => 1,
                            "64990" => 1,
                            "64991" => 1,
                            "64992" => 1,
                            "64993" => 1,
                            "64994" => 1,
                            "64995" => 1,
                            "64996" => 1,
                            "64997" => 1,
                            "64998" => 1,
                            "64999" => 1,
                            "65000" => 1,
                            "65001" => 1,
                            "65002" => 1,
                            "65003" => 1,
                            "65004" => 1,
                            "65005" => 1,
                            "65006" => 1,
                            "65007" => 1,
                            "65534" => 1,
                            "65535" => 1,
                            "655358" => 1,
                            "655359" => 1,
                            "720894" => 1,
                            "720895" => 1,
                            "786430" => 1,
                            "786431" => 1,
                            "851966" => 1,
                            "851967" => 1,
                            "917502" => 1,
                            "917503" => 1,
                            "983038" => 1,
                            "983039" => 1
                          },
            "prompt" => {
                          "ach" => "Man en aye obedo namba ma yenye. Ket yeny lok mapire tek: ",
                          "af" => "Hierdie is 'n soekbare indeks. Tik soeksleutelwoorde in: ",
                          "ak" => "Wo tumi hwehw\x{25b} ind\x{25b}ks yi mu. Kyer\x{25b}w wo nkasafua-titiriw: ",
                          "am" => "\x{12ed}\x{1205} \x{120a}\x{1348}\x{1208}\x{130d} \x{12e8}\x{121a}\x{127d}\x{120d} \x{1218}\x{1228}\x{1303} \x{1320}\x{124b}\x{121a} \x{1290}\x{12cd}\x{1362} \x{12e8}\x{134d}\x{1208}\x{130b} \x{1241}\x{120d}\x{134d} \x{1243}\x{120b}\x{1275} \x{12a0}\x{1235}\x{1308}\x{1263}\x{1366}",
                          "ar" => "\x{64a}\x{645}\x{643}\x{646} \x{627}\x{644}\x{628}\x{62d}\x{62b} \x{641}\x{64a} \x{647}\x{630}\x{627} \x{627}\x{644}\x{641}\x{647}\x{631}\x{633} \x{628}\x{625}\x{62f}\x{62e}\x{627}\x{644} \x{643}\x{644}\x{645}\x{627}\x{62a} \x{645}\x{641}\x{62a}\x{627}\x{62d}\x{64a}\x{629}: ",
                          "as" => "\x{98f}\x{987}\x{99f}\x{9cb} \x{98f}\x{99f}\x{9be} \x{9ac}\x{9bf}\x{99a}\x{9be}\x{9f0}\x{9bf}\x{9ac} \x{9aa}\x{9f0}\x{9be} \x{9b8}\x{9c2}\x{99a}\x{9c0}\x{964} \x{9ac}\x{9bf}\x{99a}\x{9f0}\x{9be}\x{9f0} \x{9ae}\x{9c2}\x{9b2} \x{9b6}\x{9ac}\x{9cd}\x{9a6} \x{9a6}\x{9bf}\x{9df}\x{995}: ",
                          "ast" => "Esto ye un \x{ed}ndiz de gueta. Introduz los t\x{e9}rminos de gueta: ",
                          "be" => "\x{413}\x{44d}\x{442}\x{430} \x{43f}\x{43e}\x{448}\x{443}\x{43a}\x{430}\x{432}\x{44b} \x{43f}\x{430}\x{43a}\x{430}\x{437}\x{430}\x{43b}\x{44c}\x{43d}\x{456}\x{43a}. \x{423}\x{432}\x{44f}\x{434}\x{437}\x{456}\x{446}\x{435} \x{43a}\x{43b}\x{44e}\x{447}\x{430}\x{432}\x{44b}\x{44f} \x{441}\x{43b}\x{43e}\x{432}\x{44b} \x{434}\x{43b}\x{44f} \x{43f}\x{43e}\x{448}\x{443}\x{43a}\x{443}: ",
                          "bg" => "\x{412} \x{442}\x{43e}\x{437}\x{438} \x{438}\x{43d}\x{434}\x{435}\x{43a}\x{441} \x{43c}\x{43e}\x{436}\x{435} \x{434}\x{430} \x{441}\x{435} \x{442}\x{44a}\x{440}\x{441}\x{438}. \x{412}\x{44a}\x{432}\x{435}\x{434}\x{435}\x{442}\x{435} \x{43a}\x{43b}\x{44e}\x{447}\x{43e}\x{432}\x{438} \x{434}\x{443}\x{43c}\x{438} \x{437}\x{430} \x{442}\x{44a}\x{440}\x{441}\x{435}\x{43d}\x{435}: ",
                          "bn" => "\x{98f}\x{99f}\x{9bf} \x{985}\x{9a8}\x{9c1}\x{9b8}\x{9a8}\x{9cd}\x{9a7}\x{9be}\x{9a8}\x{9af}\x{9cb}\x{997}\x{9cd}\x{9af} \x{9b8}\x{9c2}\x{99a}\x{9bf}\x{9f7} \x{985}\x{9a8}\x{9c1}\x{9b8}\x{9a8}\x{9cd}\x{9a7}\x{9be}\x{9a8}\x{9c7}\x{9b0} \x{9ae}\x{9c2}\x{9b2}\x{9b6}\x{9ac}\x{9cd}\x{9a6} \x{9aa}\x{9cd}\x{9b0}\x{9ac}\x{9c7}\x{9b6} \x{995}\x{9b0}\x{9be}\x{9a8}: ",
                          "bn-bd" => "\x{98f}\x{99f}\x{9bf} \x{98f}\x{995}\x{99f}\x{9bf} \x{985}\x{9a8}\x{9c1}\x{9b8}\x{9a8}\x{9cd}\x{9a7}\x{9be}\x{9a8}\x{9af}\x{9cb}\x{997}\x{9cd}\x{9af} \x{987}\x{9a8}\x{9a1}\x{9c7}\x{995}\x{9cd}\x{9b8}\x{964} \x{985}\x{9a8}\x{9c1}\x{9b8}\x{9a8}\x{9cd}\x{9a7}\x{9be}\x{9a8} \x{995}\x{9c0}\x{993}\x{9df}\x{9be}\x{9b0}\x{9cd}\x{9a1} \x{9a6}\x{9bf}\x{9a8}: ",
                          "bn-in" => "\x{98f}\x{987} \x{9b8}\x{9c2}\x{99a}\x{9bf}\x{9aa}\x{9a4}\x{9cd}\x{9b0}\x{99f}\x{9bf} \x{985}\x{9a8}\x{9c1}\x{9b8}\x{9a8}\x{9cd}\x{9a7}\x{9be}\x{9a8}\x{9c7}\x{9b0} \x{9af}\x{9cb}\x{997}\x{9cd}\x{9af}\x{964} \x{985}\x{9a8}\x{9c1}\x{9b8}\x{9a8}\x{9cd}\x{9a7}\x{9be}\x{9a8} \x{995}\x{9b0}\x{9be} \x{99c}\x{9a8}\x{9cd}\x{9af} \x{985}\x{9ad}\x{9bf}\x{9ac}\x{9cd}\x{9af}\x{995}\x{9cd}\x{9a4}\x{9bf} \x{9b2}\x{9bf}\x{996}\x{9c1}\x{9a8}: ",
                          "br" => "Setu un ibil klask. Roit ho kerio\x{f9}-alc'hwez evit ar c'hlask : ",
                          "bs" => "Ovaj indeks se mo\x{17e}e pretra\x{17e}ivati. Unesite klju\x{10d}ne rije\x{10d}i za pretragu: ",
                          "ca" => "\x{c9}s un \x{ed}ndex on es poden realitzar cerques. Introdueix els termes de cerca: ",
                          "cs" => "Toto je prohled\x{e1}vateln\x{fd} index. Zadejte hledan\x{e1} kl\x{ed}\x{10d}ov\x{e1} slova: ",
                          "cy" => "Mae hwn yn fynegai chwiliadwy. Rhowch allweddeiriau chwilio: ",
                          "da" => "Der kan s\x{f8}ges i dette indeks. Indtast s\x{f8}ge-n\x{f8}gleord: ",
                          "de" => "Dieser Index kann durchsucht werden. Geben Sie Suchbegriffe ein: ",
                          "el" => "\x{3a0}\x{3c1}\x{3cc}\x{3ba}\x{3b5}\x{3b9}\x{3c4}\x{3b1}\x{3b9} \x{3b3}\x{3b9}\x{3b1} \x{3b5}\x{3c5}\x{3c1}\x{3b5}\x{3c4}\x{3ae}\x{3c1}\x{3b9}\x{3bf} \x{3bc}\x{3b5} \x{3b4}\x{3c5}\x{3bd}\x{3b1}\x{3c4}\x{3cc}\x{3c4}\x{3b7}\x{3c4}\x{3b1} \x{3b1}\x{3bd}\x{3b1}\x{3b6}\x{3ae}\x{3c4}\x{3b7}\x{3c3}\x{3b7}\x{3c2}. \x{3a0}\x{3bb}\x{3b7}\x{3ba}\x{3c4}\x{3c1}\x{3bf}\x{3bb}\x{3bf}\x{3b3}\x{3ae}\x{3c3}\x{3c4}\x{3b5} \x{3bb}\x{3ad}\x{3be}\x{3b5}\x{3b9}\x{3c2}-\x{3ba}\x{3bb}\x{3b5}\x{3b9}\x{3b4}\x{3b9}\x{3ac} \x{3b1}\x{3bd}\x{3b1}\x{3b6}\x{3ae}\x{3c4}\x{3b7}\x{3c3}\x{3b7}\x{3c2}: ",
                          "en" => "This is a searchable index. Enter search keywords: ",
                          "en-gb" => "This is a searchable index. Enter search keywords: ",
                          "en-za" => "This is a searchable index. Enter search keywords: ",
                          "eo" => "Tiu \x{109}i estas ser\x{109}ebla indekso.  Tajpu la ser\x{109}otajn vortojn: ",
                          "es" => "Se trata de un \x{ed}ndice que admite b\x{fa}squedas. Introduce las palabras clave de b\x{fa}squeda: ",
                          "es-419" => "Se trata de un \x{ed}ndice que admite b\x{fa}squedas. Escribe las palabras clave de b\x{fa}squeda: ",
                          "es-ar" => "Este es un \x{ed}ndice en el que se pueden ejecutar b\x{fa}squedas. Ingrese t\x{e9}rminos a buscar: ",
                          "es-cl" => "Este es un \x{ed}ndice en el que se pueden ejecutar b\x{fa}squedas. Ingrese t\x{e9}rminos a buscar: ",
                          "es-es" => "Esto es un \x{ed}ndice de b\x{fa}squeda. Introduzca los t\x{e9}rminos de b\x{fa}squeda: ",
                          "es-mx" => "Este es un \x{ed}ndice de b\x{fa}squeda. Introduce las palabras clave de b\x{fa}squeda: ",
                          "et" => "See on otsitav indeks. Sisestage otsingu jaoks m\x{e4}rks\x{f5}nad: ",
                          "eu" => "Indize bilagarria da hau. Sartu bilatu beharreko gako-hitzak: ",
                          "fa" => "\x{627}\x{6cc}\x{646} \x{646}\x{645}\x{627}\x{6cc}\x{647} \x{642}\x{627}\x{628}\x{644} \x{62c}\x{633}\x{62a}\x{62c}\x{648} \x{627}\x{633}\x{62a}. \x{6a9}\x{644}\x{645}\x{627}\x{62a} \x{6a9}\x{644}\x{6cc}\x{62f}\x{6cc} \x{62c}\x{633}\x{62a}\x{62c}\x{648} \x{631}\x{627} \x{648}\x{627}\x{631}\x{62f} \x{6a9}\x{646}\x{6cc}\x{62f}: ",
                          "fi" => "T\x{e4}m\x{e4} on haettavissa oleva hakemisto. Anna hakusanat: ",
                          "fil" => "Isa itong paghahanap ng index. Ipasok ang paghahanap sa mga keyword: ",
                          "fr" => "Vous pouvez lancer des recherches dans cet index. Pour cela, entrez des mots cl\x{e9}s de recherche\x{a0}: ",
                          "fy-nl" => "Dit is in trochsykbere yndeks. Fier sykwurden yn: ",
                          "ga-ie" => "Is inn\x{e9}acs inchuardaithe \x{e9} seo. Cl\x{f3}scr\x{ed}obh lorgfhocail: ",
                          "gd" => "Seo cl\x{e0}r-innse as urrainn dhut rannsachadh. Cuir a-steach faclan-luirg: ",
                          "gl" => "Isto \x{e9} un \x{ed}ndice de busca. Introduza as palabras chave da busca: ",
                          "gu" => "\x{a86} \x{a8f}\x{a95} \x{ab6}\x{acb}\x{aa7}\x{ab8}\x{a95}\x{acd}\x{ab7}\x{aae} \x{a85}\x{aa8}\x{ac1}\x{a95}\x{acd}\x{ab0}\x{aae}\x{aa3}\x{abf}\x{a95}\x{abe} \x{a9b}\x{ac7}. \x{ab6}\x{acb}\x{aa7} \x{a95}\x{ac0}\x{ab5}\x{ab0}\x{acd}\x{aa1}\x{acd}\x{ab8} \x{aa6}\x{abe}\x{a96}\x{ab2} \x{a95}\x{ab0}\x{acb}: ",
                          "gu-in" => "\x{a86} \x{ab6}\x{acb}\x{aa7} \x{a95}\x{ab0}\x{ac0} \x{ab6}\x{a95}\x{abe}\x{aaf} \x{aa4}\x{ac7}\x{ab5}\x{ac0} \x{a85}\x{aa8}\x{ac1}\x{a95}\x{acd}\x{ab0}\x{aae}\x{aa3}\x{abf}\x{a95}\x{abe} \x{a9b}\x{ac7}. \x{ab6}\x{acb}\x{aa7} \x{a95}\x{abf}\x{ab5}\x{ab0}\x{acd}\x{aa1}\x{acb}\x{aa8}\x{ac7} \x{aa6}\x{abe}\x{a96}\x{ab2} \x{a95}\x{ab0}\x{acb}: ",
                          "he" => "\x{5d6}\x{5d4}\x{5d5} \x{5d0}\x{5d9}\x{5e0}\x{5d3}\x{5e7}\x{5e1} \x{5d4}\x{5e0}\x{5d9}\x{5ea}\x{5df} \x{5dc}\x{5d7}\x{5d9}\x{5e4}\x{5d5}\x{5e9}. \x{5d4}\x{5db}\x{5e0}\x{5e1} \x{5de}\x{5d9}\x{5dc}\x{5d5}\x{5ea} \x{5de}\x{5e4}\x{5ea}\x{5d7} \x{5dc}\x{5d7}\x{5d9}\x{5e4}\x{5d5}\x{5e9}: ",
                          "hi" => "\x{907}\x{938} \x{905}\x{928}\x{941}\x{915}\x{94d}\x{930}\x{92e}\x{923}\x{93f}\x{915}\x{93e} \x{915}\x{94b} \x{916}\x{94b}\x{91c}\x{93e} \x{91c}\x{93e} \x{938}\x{915}\x{924}\x{93e} \x{939}\x{948}. \x{916}\x{94b}\x{91c} \x{915}\x{941}\x{902}\x{91c}\x{940}\x{936}\x{92c}\x{94d}\x{926} \x{92a}\x{94d}\x{930}\x{935}\x{93f}\x{937}\x{94d}\x{91f} \x{915}\x{930}\x{947}\x{902}: ",
                          "hr" => "Ovaj je indeks mogu\x{107}e pretra\x{17e}ivati. Unesite klju\x{10d}ne rije\x{10d}i za pretra\x{17e}ivanje: ",
                          "hu" => "Ez egy kereshet\x{151} index. \x{cd}rjon be keres\x{e9}si kulcsszavakat: ",
                          "hy-am" => "\x{553}\x{576}\x{57f}\x{580}\x{565}\x{56c}\x{578}\x{582} \x{570}\x{561}\x{574}\x{561}\x{580} \x{563}\x{580}\x{565}\x{584} \x{57f}\x{565}\x{584}\x{57d}\x{57f}.",
                          "id" => "Terdapat indeks yang dapat dicari. Masukkan kata kunci penelusuran: ",
                          "is" => "\x{de}etta er leitarv\x{e9}l. Sl\x{e1}\x{f0}u inn leitaror\x{f0}: ",
                          "it" => "Questo \x{e8} un indice di ricerca. Inserisci le parole chiave di ricerca: ",
                          "iw" => "\x{5d6}\x{5d4}\x{5d5} \x{5d0}\x{5d9}\x{5e0}\x{5d3}\x{5e7}\x{5e1} \x{5e9}\x{5e0}\x{5d9}\x{5ea}\x{5df} \x{5dc}\x{5d1}\x{5e6}\x{5e2} \x{5d1}\x{5d5} \x{5d7}\x{5d9}\x{5e4}\x{5d5}\x{5e9}. \x{5d4}\x{5d6}\x{5df} \x{5de}\x{5d9}\x{5dc}\x{5d5}\x{5ea} \x{5de}\x{5e4}\x{5ea}\x{5d7} \x{5dc}\x{5d7}\x{5d9}\x{5e4}\x{5d5}\x{5e9}: ",
                          "ja" => "\x{3053}\x{306e}\x{30a4}\x{30f3}\x{30c7}\x{30c3}\x{30af}\x{30b9}\x{306f}\x{691c}\x{7d22}\x{3067}\x{304d}\x{307e}\x{3059}\x{3002}\x{30ad}\x{30fc}\x{30ef}\x{30fc}\x{30c9}\x{3092}\x{5165}\x{529b}\x{3057}\x{3066}\x{304f}\x{3060}\x{3055}\x{3044}: ",
                          "ja-jp-mac" => "\x{3053}\x{308c}\x{306f}\x{691c}\x{7d22}\x{53ef}\x{80fd}\x{306a}\x{30a4}\x{30f3}\x{30c7}\x{30c3}\x{30af}\x{30b9}\x{3067}\x{3059}\x{3002}\x{691c}\x{7d22}\x{30ad}\x{30fc}\x{30ef}\x{30fc}\x{30c9}\x{3092}\x{5165}\x{529b}\x{3057}\x{3066}\x{304f}\x{3060}\x{3055}\x{3044}: ",
                          "ka" => "\x{10d4}\x{10e1} \x{10eb}\x{10d8}\x{10d4}\x{10d1}\x{10d8}\x{10e1} \x{10d8}\x{10dc}\x{10d3}\x{10d4}\x{10e5}\x{10e1}\x{10d8}\x{10d0}. \x{10db}\x{10d8}\x{10e3}\x{10d7}\x{10d8}\x{10d7}\x{10d4}\x{10d7} \x{10e1}\x{10d0}\x{10d9}\x{10d5}\x{10d0}\x{10dc}\x{10eb}\x{10dd} \x{10e1}\x{10d8}\x{10e2}\x{10e7}\x{10d5}\x{10d4}\x{10d1}\x{10d8}: ",
                          "kk" => "\x{411}\x{4b1}\x{43b} \x{43c}\x{430}\x{437}\x{43c}\x{4b1}\x{43d}\x{43d}\x{44b}\x{4a3} \x{456}\x{448}\x{456}\x{43d}\x{434}\x{435} \x{456}\x{437}\x{434}\x{435}\x{443}\x{433}\x{435} \x{431}\x{43e}\x{43b}\x{430}\x{434}\x{44b}. \x{406}\x{437}\x{434}\x{435}\x{443} \x{441}\x{4e9}\x{437}\x{434}\x{435}\x{440}\x{456}\x{43d} \x{435}\x{43d}\x{433}\x{456}\x{437}\x{456}\x{4a3}\x{456}\x{437}: ",
                          "km" => "\x{179c}\x{17b6}\x{200b}\x{1787}\x{17b6}\x{200b}\x{179b}\x{17b7}\x{1794}\x{17b7}\x{1780}\x{17d2}\x{179a}\x{1798}\x{200b}\x{178a}\x{17c2}\x{179b}\x{200b}\x{17a2}\x{17b6}\x{1785}\x{200b}\x{179f}\x{17d2}\x{179c}\x{17c2}\x{1784}\x{179a}\x{1780}\x{200b}\x{1794}\x{17b6}\x{1793}\x{a0}\x{17d4} \x{1794}\x{1789}\x{17d2}\x{1785}\x{17bc}\x{179b}\x{200b}\x{1796}\x{17b6}\x{1780}\x{17d2}\x{1799}\x{200b}\x{1782}\x{1793}\x{17d2}\x{179b}\x{17b9}\x{17c7}\x{200b}\x{179f}\x{17d2}\x{179c}\x{17c2}\x{1784}\x{179a}\x{1780}\x{a0}\x{17d6}",
                          "kn" => "\x{c87}\x{ca6}\x{cc1} \x{cb9}\x{cc1}\x{ca1}\x{cc1}\x{c95}\x{cbe}\x{ca1}\x{cac}\x{cb9}\x{cc1}\x{ca6}\x{cbe}\x{ca6} \x{cb8}\x{cc2}\x{c9a}\x{cbf}\x{c95}\x{cc6} \x{cb9}\x{cc1}\x{ca1}\x{cc1}\x{c95}\x{cbe}\x{c9f} \x{c95}\x{cc0}\x{cb5}\x{cb0}\x{ccd}\x{ca1}\x{ccd}\x{200c}\x{c97}\x{cb3}\x{ca8}\x{ccd}\x{ca8}\x{cc1} \x{ca8}\x{cae}\x{cc2}\x{ca6}\x{cbf}\x{cb8}\x{cbf}: ",
                          "ko" => "\x{c774}\x{ac83}\x{c740} \x{ac80}\x{c0c9} \x{c0c9}\x{c778}\x{d569}\x{b2c8}\x{b2e4}. \x{ac80}\x{c0c9} \x{d0a4}\x{c6cc}\x{b4dc} \x{c785}\x{b825}: ",
                          "ku" => "Ev \x{ee}ndekseke l\x{ea} t\x{ea} ger\x{ee}n. Peyv\x{ea}n l\x{ea}ger\x{ee}n\x{ea} biniv\x{ee}se: ",
                          "lg" => "Eno noonyeso. Yingizaamu ebigambo byo noonya: ",
                          "lt" => "Tai yra ie\x{161}kotinas indeksas. \x{12e}veskite paie\x{161}kos raktini\x{173} \x{17e}od\x{17e}i\x{173}: ",
                          "lv" => "\x{160}is ir indekss ar mekl\x{113}\x{161}anas iesp\x{113}j\x{101}m. Ievad\x{12b}t mekl\x{113}\x{161}anas atsl\x{113}gv\x{101}rdus: ",
                          "mk" => "\x{41e}\x{432}\x{430}\x{430} \x{441}\x{43e}\x{434}\x{440}\x{436}\x{438}\x{43d}\x{430} \x{43c}\x{43e}\x{436}\x{435} \x{434}\x{430} \x{441}\x{435} \x{43f}\x{440}\x{435}\x{431}\x{430}\x{440}\x{443}\x{432}\x{430}. \x{412}\x{43d}\x{435}\x{441}\x{435}\x{442}\x{435} \x{437}\x{431}\x{43e}\x{440} \x{437}\x{430} \x{43f}\x{440}\x{435}\x{431}\x{430}\x{440}\x{443}\x{432}\x{430}\x{45a}\x{435}: ",
                          "ml" => "\x{d07}\x{d24}\x{d4d} \x{d24}\x{d3f}\x{d30}\x{d2f}\x{d3e}\x{d35}\x{d41}\x{d28}\x{d4d}\x{d28} \x{d38}\x{d42}\x{d1a}\x{d3f}\x{d15}\x{d2f}\x{d3e}\x{d23}\x{d4d}. \x{d24}\x{d3f}\x{d30}\x{d2f}\x{d32}\x{d4d}\x{200d} \x{d15}\x{d40}\x{d35}\x{d47}\x{d21}\x{d41}\x{d15}\x{d33}\x{d4d}\x{200d} \x{d28}\x{d32}\x{d4d}\x{200d}\x{d15}\x{d41}\x{d15}: ",
                          "mr" => "\x{939}\x{940} \x{936}\x{94b}\x{927} \x{918}\x{947}\x{923}\x{94d}\x{92f}\x{93e}\x{92f}\x{94b}\x{917}\x{94d}\x{92f} \x{905}\x{928}\x{941}\x{915}\x{94d}\x{930}\x{92e}\x{923}\x{93f}\x{915}\x{93e} \x{906}\x{939}\x{947}. \x{936}\x{94b}\x{927} \x{915}\x{940}\x{935}\x{930}\x{94d}\x{921} \x{92a}\x{94d}\x{930}\x{935}\x{93f}\x{937}\x{94d}\x{91f} \x{915}\x{930}\x{93e}: ",
                          "ms" => "Ini adalah indeks boleh dicari. Masukkan kata kunci carian: ",
                          "my" => "\x{101b}\x{103e}\x{102c}\x{1016}\x{103d}\x{1031}\x{1014}\x{102d}\x{102f}\x{1004}\x{103a}\x{101e}\x{1031}\x{102c}\x{1014}\x{1031}\x{101b}\x{102c}\x{1010}\x{1005}\x{103a}\x{1001}\x{102f}\x{1016}\x{103c}\x{1005}\x{103a}\x{101e}\x{100a}\x{103a}\x{1011}\x{102d}\x{102f}\x{1037}\x{1000}\x{103c}\x{1031}\x{102c}\x{1004}\x{1037}\x{103a}\x{1005}\x{102c}\x{101c}\x{102d}\x{102f}\x{101e}\x{1031}\x{102c}\x{1005}\x{102c}\x{101c}\x{102f}\x{1036}\x{1038}\x{1011}\x{100a}\x{1037}\x{103a}\x{1000}\x{102c}\x{101b}\x{103e}\x{102c}\x{1015}\x{102b}: ",
                          "nb" => "Dette er en s\x{f8}kbar indeks. Skriv s\x{f8}keord: ",
                          "nb-no" => "Dette er en s\x{f8}kbar indeks. Skriv s\x{f8}keord: ",
                          "nl" => "Dit is een doorzoekbare index. Geef zoekwoorden op: ",
                          "nn" => "Denne indeksen kan det s\x{f8}kjast i. Skriv inn s\x{f8}keord: ",
                          "nn-no" => "Denne indeksen kan det s\x{f8}kjast i. Skriv inn s\x{f8}keord: ",
                          "no" => "Dette er en s\x{f8}kbar indeks. Angi s\x{f8}keordene: ",
                          "nso" => "Ye ke t\x{161}hupaditeng yeo go ka nyakwago go yona. Lokela mant\x{161}u a motheo a go nyaka: ",
                          "oc" => "Aqu\x{f2} es un ind\x{e8}x de rec\x{e8}rca. Picatz de mots claus per la rec\x{e8}rca\x{a0}: ",
                          "or" => "\x{b0f}\x{b39}\x{b3e} \x{b17}\x{b4b}\x{b1f}\x{b3f}\x{b0f} \x{b38}\x{b28}\x{b4d}\x{b27}\x{b3e}\x{b28}\x{b2f}\x{b4b}\x{b17}\x{b4d}\x{b5f} \x{b05}\x{b28}\x{b41}\x{b15}\x{b4d}\x{b30}\x{b2e}\x{b23}\x{b3f}\x{b15}\x{b3e}\x{964} \x{b16}\x{b4b}\x{b1c}\x{b3e} \x{b38}\x{b42}\x{b1a}\x{b15} \x{b36}\x{b2c}\x{b4d}\x{b26} \x{b2d}\x{b30}\x{b23} \x{b15}\x{b30}\x{b28}\x{b4d}\x{b24}\x{b41}: ",
                          "pa-in" => "\x{a07}\x{a39} \x{a16}\x{a4b}\x{a1c}\x{a2f}\x{a4b}\x{a17} \x{a07}\x{a70}\x{a21}\x{a48}\x{a15}\x{a38} \x{a39}\x{a48}\x{964} \x{a16}\x{a4b}\x{a1c} \x{a38}\x{a3c}\x{a2c}\x{a26} \x{a26}\x{a3f}\x{a13}: ",
                          "pl" => "Ten indeks mo\x{17c}na przeszukiwa\x{107}. Wprowad\x{17a} wyszukiwane s\x{142}owa kluczowe: ",
                          "pt" => "Este \x{ed}ndice \x{e9} pesquis\x{e1}vel. Introduza palavras-chave de pesquisa: ",
                          "pt-br" => "Este \x{e9} um \x{ed}ndice pesquis\x{e1}vel. Insira palavras-chave de pesquisa: ",
                          "pt-pt" => "Este \x{ed}ndice \x{e9} pesquis\x{e1}vel. Introduza palavras-chave de pesquisa: ",
                          "rm" => "En quest index pos ti tschertgar. Endatescha pleds magics per la tschertga: ",
                          "ro" => "Acesta este un index \x{ee}n care se poate c\x{103}uta. Introduce\x{21b}i cuvintele cheie pentru c\x{103}utare: ",
                          "ru" => "\x{42d}\x{442}\x{43e} \x{438}\x{43d}\x{434}\x{435}\x{43a}\x{441} \x{441} \x{432}\x{43e}\x{437}\x{43c}\x{43e}\x{436}\x{43d}\x{43e}\x{441}\x{442}\x{44c}\x{44e} \x{43f}\x{43e}\x{438}\x{441}\x{43a}\x{430}. \x{412}\x{432}\x{435}\x{434}\x{438}\x{442}\x{435} \x{43a}\x{43b}\x{44e}\x{447}\x{435}\x{432}\x{44b}\x{435} \x{441}\x{43b}\x{43e}\x{432}\x{430} \x{434}\x{43b}\x{44f} \x{43f}\x{43e}\x{438}\x{441}\x{43a}\x{430}: ",
                          "sk" => "Tento index sa d\x{e1} preh\x{13e}ad\x{e1}va\x{165}. Zadajte k\x{13e}\x{fa}\x{10d}ov\x{e9} slov\x{e1} na vyh\x{13e}adanie: ",
                          "sl" => "To je kazalo, ki omogo\x{10d}a iskanje. Vnesite klju\x{10d}ne besede za iskanje: ",
                          "son" => "Woo ti ceeci-se maabo\x{14b}. Ceeci kalimawey dam: ",
                          "sq" => "Ky \x{eb}sht\x{eb} nj\x{eb} tregues i k\x{eb}rkuesh\x{eb}m. Jepni nj\x{eb} fjal\x{eb}ky\x{e7} k\x{eb}rkimi: ",
                          "sr" => "\x{41e}\x{432}\x{43e} \x{458}\x{435} \x{438}\x{43d}\x{434}\x{435}\x{43a}\x{441} \x{43a}\x{43e}\x{458}\x{438} \x{43c}\x{43e}\x{436}\x{435} \x{434}\x{430} \x{441}\x{435} \x{43f}\x{440}\x{435}\x{442}\x{440}\x{430}\x{436}\x{443}\x{458}\x{435}. \x{423}\x{43d}\x{435}\x{441}\x{438}\x{442}\x{435} \x{43a}\x{459}\x{443}\x{447}\x{43d}\x{435} \x{440}\x{435}\x{447}\x{438} \x{437}\x{430} \x{43f}\x{440}\x{435}\x{442}\x{440}\x{430}\x{433}\x{443}: ",
                          "sv" => "Det h\x{e4}r \x{e4}r ett s\x{f6}kbart index. Skriv s\x{f6}kord: ",
                          "sv-se" => "Detta \x{e4}r ett s\x{f6}kbart index. Skriv in s\x{f6}kord: ",
                          "sw" => "Hii ni fahirisi inayoweza kutafutwa. Weka maneno muhimu ya utafutaji.",
                          "ta" => "\x{b87}\x{ba4}\x{bc1} \x{ba4}\x{bc7}\x{b9f}\x{b95}\x{bcd}\x{b95}\x{bc2}\x{b9f}\x{bbf}\x{baf} \x{baa}\x{bca}\x{bb0}\x{bc1}\x{bb3}\x{b9f}\x{b95}\x{bcd}\x{b95}\x{bae}\x{bcd}. \x{ba4}\x{bc7}\x{b9f}\x{bb2}\x{bcd} \x{b9a}\x{bca}\x{bb1}\x{bcd}\x{b95}\x{bb3}\x{bc8} \x{b89}\x{bb3}\x{bcd}\x{bb3}\x{bbf}\x{b9f}\x{bc1}\x{b95}: ",
                          "te" => "\x{c07}\x{c26}\x{c3f} \x{c12}\x{c15} \x{c36}\x{c4b}\x{c27}\x{c3f}\x{c02}\x{c1a}\x{c17}\x{c32} \x{c38}\x{c42}\x{c1a}\x{c3f}\x{c15}. \x{c36}\x{c4b}\x{c27}\x{c28} \x{c15}\x{c40}\x{c35}\x{c30}\x{c4d}\x{c21}\x{c4d}\x{200c}\x{c32}\x{c28}\x{c41} \x{c0e}\x{c02}\x{c1f}\x{c30}\x{c4d} \x{c1a}\x{c46}\x{c2f}\x{c4d}\x{c2f}\x{c02}\x{c21}\x{c3f}: ",
                          "th" => "\x{e19}\x{e35}\x{e48}\x{e04}\x{e37}\x{e2d}\x{e14}\x{e31}\x{e0a}\x{e19}\x{e35}\x{e17}\x{e35}\x{e48}\x{e2a}\x{e32}\x{e21}\x{e32}\x{e23}\x{e16}\x{e04}\x{e49}\x{e19}\x{e2b}\x{e32}\x{e44}\x{e14}\x{e49} \x{e1b}\x{e49}\x{e2d}\x{e19}\x{e04}\x{e33}\x{e2b}\x{e25}\x{e31}\x{e01}\x{e43}\x{e19}\x{e01}\x{e32}\x{e23}\x{e04}\x{e49}\x{e19}\x{e2b}\x{e32}: ",
                          "tr" => "Bu dizinde arama yap\x{131}labilir. Arama anahtar kelimeleri girin: ",
                          "uk" => "\x{426}\x{435}\x{439} \x{434}\x{43e}\x{441}\x{442}\x{443}\x{43f}\x{43d}\x{438}\x{439} \x{434}\x{43b}\x{44f} \x{43f}\x{43e}\x{448}\x{443}\x{43a}\x{443} \x{456}\x{43d}\x{434}\x{435}\x{43a}\x{441}. \x{412}\x{432}\x{435}\x{434}\x{456}\x{442}\x{44c} \x{43a}\x{43b}\x{44e}\x{447}\x{43e}\x{432}\x{456} \x{441}\x{43b}\x{43e}\x{432}\x{430} \x{43f}\x{43e}\x{448}\x{443}\x{43a}\x{443}: ",
                          "vi" => "\x{110}\x{e2}y l\x{e0} ch\x{1ec9} m\x{1ee5}c c\x{f3} th\x{1ec3} t\x{ec}m ki\x{1ebf}m. Nh\x{1ead}p t\x{1eeb} kh\x{f3}a t\x{ec}m ki\x{1ebf}m v\x{e0}o: ",
                          "xh" => "Esi sisalathisi esikhangelekayo. Ngenisa amagama aphambili okukhangelwa: ",
                          "zh-cn" => "\x{8fd9}\x{662f}\x{4e00}\x{4e2a}\x{53ef}\x{641c}\x{7d22}\x{7684}\x{7d22}\x{5f15}\x{3002}\x{8bf7}\x{8f93}\x{5165}\x{641c}\x{7d22}\x{5173}\x{952e}\x{5b57}\x{ff1a}",
                          "zh-tw" => "\x{9019}\x{662f}\x{53ef}\x{641c}\x{5c0b}\x{7684}\x{7d22}\x{5f15}\x{ff0c}\x{8f38}\x{5165}\x{641c}\x{5c0b}\x{95dc}\x{9375}\x{5b57}\x{ff1a}",
                          "zu" => "Lolu uhlu lwezihloko okwazi ukucinga kulo. Faka amagama ayinhloko okucinga: "
                        },
            "void" => {
                        "http://www.w3.org/1999/xhtml" => {
                                                            "area" => 1,
                                                            "base" => 1,
                                                            "basefont" => 1,
                                                            "bgsound" => 1,
                                                            "br" => 1,
                                                            "col" => 1,
                                                            "embed" => 1,
                                                            "frame" => 1,
                                                            "hr" => 1,
                                                            "img" => 1,
                                                            "input" => 1,
                                                            "keygen" => 1,
                                                            "link" => 1,
                                                            "meta" => 1,
                                                            "param" => 1,
                                                            "source" => 1,
                                                            "track" => 1,
                                                            "wbr" => 1
                                                          }
                      },
            "xml_char_discouraged" => {
                                        "1048574" => 1048574,
                                        "1048575" => 1048575,
                                        "1114110" => 1114110,
                                        "1114111" => 1114111,
                                        "127" => 127,
                                        "128" => 128,
                                        "129" => 129,
                                        "130" => 130,
                                        "131" => 131,
                                        "131070" => 131070,
                                        "131071" => 131071,
                                        "132" => 132,
                                        "133" => 133,
                                        "134" => 134,
                                        "135" => 135,
                                        "136" => 136,
                                        "137" => 137,
                                        "138" => 138,
                                        "139" => 139,
                                        "140" => 140,
                                        "141" => 141,
                                        "142" => 142,
                                        "143" => 143,
                                        "144" => 144,
                                        "145" => 145,
                                        "146" => 146,
                                        "147" => 147,
                                        "148" => 148,
                                        "149" => 149,
                                        "150" => 150,
                                        "151" => 151,
                                        "152" => 152,
                                        "153" => 153,
                                        "154" => 154,
                                        "155" => 155,
                                        "156" => 156,
                                        "157" => 157,
                                        "158" => 158,
                                        "159" => 159,
                                        "196606" => 196606,
                                        "196607" => 196607,
                                        "262142" => 262142,
                                        "262143" => 262143,
                                        "327678" => 327678,
                                        "327679" => 327679,
                                        "393214" => 393214,
                                        "393215" => 393215,
                                        "458750" => 458750,
                                        "458751" => 458751,
                                        "524286" => 524286,
                                        "524287" => 524287,
                                        "589822" => 589822,
                                        "589823" => 589823,
                                        "64976" => 64976,
                                        "64977" => 64977,
                                        "64978" => 64978,
                                        "64979" => 64979,
                                        "64980" => 64980,
                                        "64981" => 64981,
                                        "64982" => 64982,
                                        "64983" => 64983,
                                        "64984" => 64984,
                                        "64985" => 64985,
                                        "64986" => 64986,
                                        "64987" => 64987,
                                        "64988" => 64988,
                                        "64989" => 64989,
                                        "64990" => 64990,
                                        "64991" => 64991,
                                        "64992" => 64992,
                                        "64993" => 64993,
                                        "64994" => 64994,
                                        "64995" => 64995,
                                        "64996" => 64996,
                                        "64997" => 64997,
                                        "64998" => 64998,
                                        "64999" => 64999,
                                        "65000" => 65000,
                                        "65001" => 65001,
                                        "65002" => 65002,
                                        "65003" => 65003,
                                        "65004" => 65004,
                                        "65005" => 65005,
                                        "65006" => 65006,
                                        "65007" => 65007,
                                        "655358" => 655358,
                                        "655359" => 655359,
                                        "720894" => 720894,
                                        "720895" => 720895,
                                        "786430" => 786430,
                                        "786431" => 786431,
                                        "8232" => 8232,
                                        "851966" => 851966,
                                        "851967" => 851967,
                                        "917502" => 917502,
                                        "917503" => 917503,
                                        "983038" => 983038,
                                        "983039" => 983039
                                      },
            "xml_charref_invalid" => {
                                       "0" => 65533,
                                       "1" => 1,
                                       "11" => 11,
                                       "12" => 12,
                                       "14" => 14,
                                       "15" => 15,
                                       "16" => 16,
                                       "17" => 17,
                                       "18" => 18,
                                       "19" => 19,
                                       "2" => 2,
                                       "20" => 20,
                                       "21" => 21,
                                       "22" => 22,
                                       "23" => 23,
                                       "24" => 24,
                                       "25" => 25,
                                       "26" => 26,
                                       "27" => 27,
                                       "28" => 28,
                                       "29" => 29,
                                       "3" => 3,
                                       "30" => 30,
                                       "31" => 31,
                                       "4" => 4,
                                       "5" => 5,
                                       "55296" => 65533,
                                       "55297" => 65533,
                                       "55298" => 65533,
                                       "55299" => 65533,
                                       "55300" => 65533,
                                       "55301" => 65533,
                                       "55302" => 65533,
                                       "55303" => 65533,
                                       "55304" => 65533,
                                       "55305" => 65533,
                                       "55306" => 65533,
                                       "55307" => 65533,
                                       "55308" => 65533,
                                       "55309" => 65533,
                                       "55310" => 65533,
                                       "55311" => 65533,
                                       "55312" => 65533,
                                       "55313" => 65533,
                                       "55314" => 65533,
                                       "55315" => 65533,
                                       "55316" => 65533,
                                       "55317" => 65533,
                                       "55318" => 65533,
                                       "55319" => 65533,
                                       "55320" => 65533,
                                       "55321" => 65533,
                                       "55322" => 65533,
                                       "55323" => 65533,
                                       "55324" => 65533,
                                       "55325" => 65533,
                                       "55326" => 65533,
                                       "55327" => 65533,
                                       "55328" => 65533,
                                       "55329" => 65533,
                                       "55330" => 65533,
                                       "55331" => 65533,
                                       "55332" => 65533,
                                       "55333" => 65533,
                                       "55334" => 65533,
                                       "55335" => 65533,
                                       "55336" => 65533,
                                       "55337" => 65533,
                                       "55338" => 65533,
                                       "55339" => 65533,
                                       "55340" => 65533,
                                       "55341" => 65533,
                                       "55342" => 65533,
                                       "55343" => 65533,
                                       "55344" => 65533,
                                       "55345" => 65533,
                                       "55346" => 65533,
                                       "55347" => 65533,
                                       "55348" => 65533,
                                       "55349" => 65533,
                                       "55350" => 65533,
                                       "55351" => 65533,
                                       "55352" => 65533,
                                       "55353" => 65533,
                                       "55354" => 65533,
                                       "55355" => 65533,
                                       "55356" => 65533,
                                       "55357" => 65533,
                                       "55358" => 65533,
                                       "55359" => 65533,
                                       "55360" => 65533,
                                       "55361" => 65533,
                                       "55362" => 65533,
                                       "55363" => 65533,
                                       "55364" => 65533,
                                       "55365" => 65533,
                                       "55366" => 65533,
                                       "55367" => 65533,
                                       "55368" => 65533,
                                       "55369" => 65533,
                                       "55370" => 65533,
                                       "55371" => 65533,
                                       "55372" => 65533,
                                       "55373" => 65533,
                                       "55374" => 65533,
                                       "55375" => 65533,
                                       "55376" => 65533,
                                       "55377" => 65533,
                                       "55378" => 65533,
                                       "55379" => 65533,
                                       "55380" => 65533,
                                       "55381" => 65533,
                                       "55382" => 65533,
                                       "55383" => 65533,
                                       "55384" => 65533,
                                       "55385" => 65533,
                                       "55386" => 65533,
                                       "55387" => 65533,
                                       "55388" => 65533,
                                       "55389" => 65533,
                                       "55390" => 65533,
                                       "55391" => 65533,
                                       "55392" => 65533,
                                       "55393" => 65533,
                                       "55394" => 65533,
                                       "55395" => 65533,
                                       "55396" => 65533,
                                       "55397" => 65533,
                                       "55398" => 65533,
                                       "55399" => 65533,
                                       "55400" => 65533,
                                       "55401" => 65533,
                                       "55402" => 65533,
                                       "55403" => 65533,
                                       "55404" => 65533,
                                       "55405" => 65533,
                                       "55406" => 65533,
                                       "55407" => 65533,
                                       "55408" => 65533,
                                       "55409" => 65533,
                                       "55410" => 65533,
                                       "55411" => 65533,
                                       "55412" => 65533,
                                       "55413" => 65533,
                                       "55414" => 65533,
                                       "55415" => 65533,
                                       "55416" => 65533,
                                       "55417" => 65533,
                                       "55418" => 65533,
                                       "55419" => 65533,
                                       "55420" => 65533,
                                       "55421" => 65533,
                                       "55422" => 65533,
                                       "55423" => 65533,
                                       "55424" => 65533,
                                       "55425" => 65533,
                                       "55426" => 65533,
                                       "55427" => 65533,
                                       "55428" => 65533,
                                       "55429" => 65533,
                                       "55430" => 65533,
                                       "55431" => 65533,
                                       "55432" => 65533,
                                       "55433" => 65533,
                                       "55434" => 65533,
                                       "55435" => 65533,
                                       "55436" => 65533,
                                       "55437" => 65533,
                                       "55438" => 65533,
                                       "55439" => 65533,
                                       "55440" => 65533,
                                       "55441" => 65533,
                                       "55442" => 65533,
                                       "55443" => 65533,
                                       "55444" => 65533,
                                       "55445" => 65533,
                                       "55446" => 65533,
                                       "55447" => 65533,
                                       "55448" => 65533,
                                       "55449" => 65533,
                                       "55450" => 65533,
                                       "55451" => 65533,
                                       "55452" => 65533,
                                       "55453" => 65533,
                                       "55454" => 65533,
                                       "55455" => 65533,
                                       "55456" => 65533,
                                       "55457" => 65533,
                                       "55458" => 65533,
                                       "55459" => 65533,
                                       "55460" => 65533,
                                       "55461" => 65533,
                                       "55462" => 65533,
                                       "55463" => 65533,
                                       "55464" => 65533,
                                       "55465" => 65533,
                                       "55466" => 65533,
                                       "55467" => 65533,
                                       "55468" => 65533,
                                       "55469" => 65533,
                                       "55470" => 65533,
                                       "55471" => 65533,
                                       "55472" => 65533,
                                       "55473" => 65533,
                                       "55474" => 65533,
                                       "55475" => 65533,
                                       "55476" => 65533,
                                       "55477" => 65533,
                                       "55478" => 65533,
                                       "55479" => 65533,
                                       "55480" => 65533,
                                       "55481" => 65533,
                                       "55482" => 65533,
                                       "55483" => 65533,
                                       "55484" => 65533,
                                       "55485" => 65533,
                                       "55486" => 65533,
                                       "55487" => 65533,
                                       "55488" => 65533,
                                       "55489" => 65533,
                                       "55490" => 65533,
                                       "55491" => 65533,
                                       "55492" => 65533,
                                       "55493" => 65533,
                                       "55494" => 65533,
                                       "55495" => 65533,
                                       "55496" => 65533,
                                       "55497" => 65533,
                                       "55498" => 65533,
                                       "55499" => 65533,
                                       "55500" => 65533,
                                       "55501" => 65533,
                                       "55502" => 65533,
                                       "55503" => 65533,
                                       "55504" => 65533,
                                       "55505" => 65533,
                                       "55506" => 65533,
                                       "55507" => 65533,
                                       "55508" => 65533,
                                       "55509" => 65533,
                                       "55510" => 65533,
                                       "55511" => 65533,
                                       "55512" => 65533,
                                       "55513" => 65533,
                                       "55514" => 65533,
                                       "55515" => 65533,
                                       "55516" => 65533,
                                       "55517" => 65533,
                                       "55518" => 65533,
                                       "55519" => 65533,
                                       "55520" => 65533,
                                       "55521" => 65533,
                                       "55522" => 65533,
                                       "55523" => 65533,
                                       "55524" => 65533,
                                       "55525" => 65533,
                                       "55526" => 65533,
                                       "55527" => 65533,
                                       "55528" => 65533,
                                       "55529" => 65533,
                                       "55530" => 65533,
                                       "55531" => 65533,
                                       "55532" => 65533,
                                       "55533" => 65533,
                                       "55534" => 65533,
                                       "55535" => 65533,
                                       "55536" => 65533,
                                       "55537" => 65533,
                                       "55538" => 65533,
                                       "55539" => 65533,
                                       "55540" => 65533,
                                       "55541" => 65533,
                                       "55542" => 65533,
                                       "55543" => 65533,
                                       "55544" => 65533,
                                       "55545" => 65533,
                                       "55546" => 65533,
                                       "55547" => 65533,
                                       "55548" => 65533,
                                       "55549" => 65533,
                                       "55550" => 65533,
                                       "55551" => 65533,
                                       "55552" => 65533,
                                       "55553" => 65533,
                                       "55554" => 65533,
                                       "55555" => 65533,
                                       "55556" => 65533,
                                       "55557" => 65533,
                                       "55558" => 65533,
                                       "55559" => 65533,
                                       "55560" => 65533,
                                       "55561" => 65533,
                                       "55562" => 65533,
                                       "55563" => 65533,
                                       "55564" => 65533,
                                       "55565" => 65533,
                                       "55566" => 65533,
                                       "55567" => 65533,
                                       "55568" => 65533,
                                       "55569" => 65533,
                                       "55570" => 65533,
                                       "55571" => 65533,
                                       "55572" => 65533,
                                       "55573" => 65533,
                                       "55574" => 65533,
                                       "55575" => 65533,
                                       "55576" => 65533,
                                       "55577" => 65533,
                                       "55578" => 65533,
                                       "55579" => 65533,
                                       "55580" => 65533,
                                       "55581" => 65533,
                                       "55582" => 65533,
                                       "55583" => 65533,
                                       "55584" => 65533,
                                       "55585" => 65533,
                                       "55586" => 65533,
                                       "55587" => 65533,
                                       "55588" => 65533,
                                       "55589" => 65533,
                                       "55590" => 65533,
                                       "55591" => 65533,
                                       "55592" => 65533,
                                       "55593" => 65533,
                                       "55594" => 65533,
                                       "55595" => 65533,
                                       "55596" => 65533,
                                       "55597" => 65533,
                                       "55598" => 65533,
                                       "55599" => 65533,
                                       "55600" => 65533,
                                       "55601" => 65533,
                                       "55602" => 65533,
                                       "55603" => 65533,
                                       "55604" => 65533,
                                       "55605" => 65533,
                                       "55606" => 65533,
                                       "55607" => 65533,
                                       "55608" => 65533,
                                       "55609" => 65533,
                                       "55610" => 65533,
                                       "55611" => 65533,
                                       "55612" => 65533,
                                       "55613" => 65533,
                                       "55614" => 65533,
                                       "55615" => 65533,
                                       "55616" => 65533,
                                       "55617" => 65533,
                                       "55618" => 65533,
                                       "55619" => 65533,
                                       "55620" => 65533,
                                       "55621" => 65533,
                                       "55622" => 65533,
                                       "55623" => 65533,
                                       "55624" => 65533,
                                       "55625" => 65533,
                                       "55626" => 65533,
                                       "55627" => 65533,
                                       "55628" => 65533,
                                       "55629" => 65533,
                                       "55630" => 65533,
                                       "55631" => 65533,
                                       "55632" => 65533,
                                       "55633" => 65533,
                                       "55634" => 65533,
                                       "55635" => 65533,
                                       "55636" => 65533,
                                       "55637" => 65533,
                                       "55638" => 65533,
                                       "55639" => 65533,
                                       "55640" => 65533,
                                       "55641" => 65533,
                                       "55642" => 65533,
                                       "55643" => 65533,
                                       "55644" => 65533,
                                       "55645" => 65533,
                                       "55646" => 65533,
                                       "55647" => 65533,
                                       "55648" => 65533,
                                       "55649" => 65533,
                                       "55650" => 65533,
                                       "55651" => 65533,
                                       "55652" => 65533,
                                       "55653" => 65533,
                                       "55654" => 65533,
                                       "55655" => 65533,
                                       "55656" => 65533,
                                       "55657" => 65533,
                                       "55658" => 65533,
                                       "55659" => 65533,
                                       "55660" => 65533,
                                       "55661" => 65533,
                                       "55662" => 65533,
                                       "55663" => 65533,
                                       "55664" => 65533,
                                       "55665" => 65533,
                                       "55666" => 65533,
                                       "55667" => 65533,
                                       "55668" => 65533,
                                       "55669" => 65533,
                                       "55670" => 65533,
                                       "55671" => 65533,
                                       "55672" => 65533,
                                       "55673" => 65533,
                                       "55674" => 65533,
                                       "55675" => 65533,
                                       "55676" => 65533,
                                       "55677" => 65533,
                                       "55678" => 65533,
                                       "55679" => 65533,
                                       "55680" => 65533,
                                       "55681" => 65533,
                                       "55682" => 65533,
                                       "55683" => 65533,
                                       "55684" => 65533,
                                       "55685" => 65533,
                                       "55686" => 65533,
                                       "55687" => 65533,
                                       "55688" => 65533,
                                       "55689" => 65533,
                                       "55690" => 65533,
                                       "55691" => 65533,
                                       "55692" => 65533,
                                       "55693" => 65533,
                                       "55694" => 65533,
                                       "55695" => 65533,
                                       "55696" => 65533,
                                       "55697" => 65533,
                                       "55698" => 65533,
                                       "55699" => 65533,
                                       "55700" => 65533,
                                       "55701" => 65533,
                                       "55702" => 65533,
                                       "55703" => 65533,
                                       "55704" => 65533,
                                       "55705" => 65533,
                                       "55706" => 65533,
                                       "55707" => 65533,
                                       "55708" => 65533,
                                       "55709" => 65533,
                                       "55710" => 65533,
                                       "55711" => 65533,
                                       "55712" => 65533,
                                       "55713" => 65533,
                                       "55714" => 65533,
                                       "55715" => 65533,
                                       "55716" => 65533,
                                       "55717" => 65533,
                                       "55718" => 65533,
                                       "55719" => 65533,
                                       "55720" => 65533,
                                       "55721" => 65533,
                                       "55722" => 65533,
                                       "55723" => 65533,
                                       "55724" => 65533,
                                       "55725" => 65533,
                                       "55726" => 65533,
                                       "55727" => 65533,
                                       "55728" => 65533,
                                       "55729" => 65533,
                                       "55730" => 65533,
                                       "55731" => 65533,
                                       "55732" => 65533,
                                       "55733" => 65533,
                                       "55734" => 65533,
                                       "55735" => 65533,
                                       "55736" => 65533,
                                       "55737" => 65533,
                                       "55738" => 65533,
                                       "55739" => 65533,
                                       "55740" => 65533,
                                       "55741" => 65533,
                                       "55742" => 65533,
                                       "55743" => 65533,
                                       "55744" => 65533,
                                       "55745" => 65533,
                                       "55746" => 65533,
                                       "55747" => 65533,
                                       "55748" => 65533,
                                       "55749" => 65533,
                                       "55750" => 65533,
                                       "55751" => 65533,
                                       "55752" => 65533,
                                       "55753" => 65533,
                                       "55754" => 65533,
                                       "55755" => 65533,
                                       "55756" => 65533,
                                       "55757" => 65533,
                                       "55758" => 65533,
                                       "55759" => 65533,
                                       "55760" => 65533,
                                       "55761" => 65533,
                                       "55762" => 65533,
                                       "55763" => 65533,
                                       "55764" => 65533,
                                       "55765" => 65533,
                                       "55766" => 65533,
                                       "55767" => 65533,
                                       "55768" => 65533,
                                       "55769" => 65533,
                                       "55770" => 65533,
                                       "55771" => 65533,
                                       "55772" => 65533,
                                       "55773" => 65533,
                                       "55774" => 65533,
                                       "55775" => 65533,
                                       "55776" => 65533,
                                       "55777" => 65533,
                                       "55778" => 65533,
                                       "55779" => 65533,
                                       "55780" => 65533,
                                       "55781" => 65533,
                                       "55782" => 65533,
                                       "55783" => 65533,
                                       "55784" => 65533,
                                       "55785" => 65533,
                                       "55786" => 65533,
                                       "55787" => 65533,
                                       "55788" => 65533,
                                       "55789" => 65533,
                                       "55790" => 65533,
                                       "55791" => 65533,
                                       "55792" => 65533,
                                       "55793" => 65533,
                                       "55794" => 65533,
                                       "55795" => 65533,
                                       "55796" => 65533,
                                       "55797" => 65533,
                                       "55798" => 65533,
                                       "55799" => 65533,
                                       "55800" => 65533,
                                       "55801" => 65533,
                                       "55802" => 65533,
                                       "55803" => 65533,
                                       "55804" => 65533,
                                       "55805" => 65533,
                                       "55806" => 65533,
                                       "55807" => 65533,
                                       "55808" => 65533,
                                       "55809" => 65533,
                                       "55810" => 65533,
                                       "55811" => 65533,
                                       "55812" => 65533,
                                       "55813" => 65533,
                                       "55814" => 65533,
                                       "55815" => 65533,
                                       "55816" => 65533,
                                       "55817" => 65533,
                                       "55818" => 65533,
                                       "55819" => 65533,
                                       "55820" => 65533,
                                       "55821" => 65533,
                                       "55822" => 65533,
                                       "55823" => 65533,
                                       "55824" => 65533,
                                       "55825" => 65533,
                                       "55826" => 65533,
                                       "55827" => 65533,
                                       "55828" => 65533,
                                       "55829" => 65533,
                                       "55830" => 65533,
                                       "55831" => 65533,
                                       "55832" => 65533,
                                       "55833" => 65533,
                                       "55834" => 65533,
                                       "55835" => 65533,
                                       "55836" => 65533,
                                       "55837" => 65533,
                                       "55838" => 65533,
                                       "55839" => 65533,
                                       "55840" => 65533,
                                       "55841" => 65533,
                                       "55842" => 65533,
                                       "55843" => 65533,
                                       "55844" => 65533,
                                       "55845" => 65533,
                                       "55846" => 65533,
                                       "55847" => 65533,
                                       "55848" => 65533,
                                       "55849" => 65533,
                                       "55850" => 65533,
                                       "55851" => 65533,
                                       "55852" => 65533,
                                       "55853" => 65533,
                                       "55854" => 65533,
                                       "55855" => 65533,
                                       "55856" => 65533,
                                       "55857" => 65533,
                                       "55858" => 65533,
                                       "55859" => 65533,
                                       "55860" => 65533,
                                       "55861" => 65533,
                                       "55862" => 65533,
                                       "55863" => 65533,
                                       "55864" => 65533,
                                       "55865" => 65533,
                                       "55866" => 65533,
                                       "55867" => 65533,
                                       "55868" => 65533,
                                       "55869" => 65533,
                                       "55870" => 65533,
                                       "55871" => 65533,
                                       "55872" => 65533,
                                       "55873" => 65533,
                                       "55874" => 65533,
                                       "55875" => 65533,
                                       "55876" => 65533,
                                       "55877" => 65533,
                                       "55878" => 65533,
                                       "55879" => 65533,
                                       "55880" => 65533,
                                       "55881" => 65533,
                                       "55882" => 65533,
                                       "55883" => 65533,
                                       "55884" => 65533,
                                       "55885" => 65533,
                                       "55886" => 65533,
                                       "55887" => 65533,
                                       "55888" => 65533,
                                       "55889" => 65533,
                                       "55890" => 65533,
                                       "55891" => 65533,
                                       "55892" => 65533,
                                       "55893" => 65533,
                                       "55894" => 65533,
                                       "55895" => 65533,
                                       "55896" => 65533,
                                       "55897" => 65533,
                                       "55898" => 65533,
                                       "55899" => 65533,
                                       "55900" => 65533,
                                       "55901" => 65533,
                                       "55902" => 65533,
                                       "55903" => 65533,
                                       "55904" => 65533,
                                       "55905" => 65533,
                                       "55906" => 65533,
                                       "55907" => 65533,
                                       "55908" => 65533,
                                       "55909" => 65533,
                                       "55910" => 65533,
                                       "55911" => 65533,
                                       "55912" => 65533,
                                       "55913" => 65533,
                                       "55914" => 65533,
                                       "55915" => 65533,
                                       "55916" => 65533,
                                       "55917" => 65533,
                                       "55918" => 65533,
                                       "55919" => 65533,
                                       "55920" => 65533,
                                       "55921" => 65533,
                                       "55922" => 65533,
                                       "55923" => 65533,
                                       "55924" => 65533,
                                       "55925" => 65533,
                                       "55926" => 65533,
                                       "55927" => 65533,
                                       "55928" => 65533,
                                       "55929" => 65533,
                                       "55930" => 65533,
                                       "55931" => 65533,
                                       "55932" => 65533,
                                       "55933" => 65533,
                                       "55934" => 65533,
                                       "55935" => 65533,
                                       "55936" => 65533,
                                       "55937" => 65533,
                                       "55938" => 65533,
                                       "55939" => 65533,
                                       "55940" => 65533,
                                       "55941" => 65533,
                                       "55942" => 65533,
                                       "55943" => 65533,
                                       "55944" => 65533,
                                       "55945" => 65533,
                                       "55946" => 65533,
                                       "55947" => 65533,
                                       "55948" => 65533,
                                       "55949" => 65533,
                                       "55950" => 65533,
                                       "55951" => 65533,
                                       "55952" => 65533,
                                       "55953" => 65533,
                                       "55954" => 65533,
                                       "55955" => 65533,
                                       "55956" => 65533,
                                       "55957" => 65533,
                                       "55958" => 65533,
                                       "55959" => 65533,
                                       "55960" => 65533,
                                       "55961" => 65533,
                                       "55962" => 65533,
                                       "55963" => 65533,
                                       "55964" => 65533,
                                       "55965" => 65533,
                                       "55966" => 65533,
                                       "55967" => 65533,
                                       "55968" => 65533,
                                       "55969" => 65533,
                                       "55970" => 65533,
                                       "55971" => 65533,
                                       "55972" => 65533,
                                       "55973" => 65533,
                                       "55974" => 65533,
                                       "55975" => 65533,
                                       "55976" => 65533,
                                       "55977" => 65533,
                                       "55978" => 65533,
                                       "55979" => 65533,
                                       "55980" => 65533,
                                       "55981" => 65533,
                                       "55982" => 65533,
                                       "55983" => 65533,
                                       "55984" => 65533,
                                       "55985" => 65533,
                                       "55986" => 65533,
                                       "55987" => 65533,
                                       "55988" => 65533,
                                       "55989" => 65533,
                                       "55990" => 65533,
                                       "55991" => 65533,
                                       "55992" => 65533,
                                       "55993" => 65533,
                                       "55994" => 65533,
                                       "55995" => 65533,
                                       "55996" => 65533,
                                       "55997" => 65533,
                                       "55998" => 65533,
                                       "55999" => 65533,
                                       "56000" => 65533,
                                       "56001" => 65533,
                                       "56002" => 65533,
                                       "56003" => 65533,
                                       "56004" => 65533,
                                       "56005" => 65533,
                                       "56006" => 65533,
                                       "56007" => 65533,
                                       "56008" => 65533,
                                       "56009" => 65533,
                                       "56010" => 65533,
                                       "56011" => 65533,
                                       "56012" => 65533,
                                       "56013" => 65533,
                                       "56014" => 65533,
                                       "56015" => 65533,
                                       "56016" => 65533,
                                       "56017" => 65533,
                                       "56018" => 65533,
                                       "56019" => 65533,
                                       "56020" => 65533,
                                       "56021" => 65533,
                                       "56022" => 65533,
                                       "56023" => 65533,
                                       "56024" => 65533,
                                       "56025" => 65533,
                                       "56026" => 65533,
                                       "56027" => 65533,
                                       "56028" => 65533,
                                       "56029" => 65533,
                                       "56030" => 65533,
                                       "56031" => 65533,
                                       "56032" => 65533,
                                       "56033" => 65533,
                                       "56034" => 65533,
                                       "56035" => 65533,
                                       "56036" => 65533,
                                       "56037" => 65533,
                                       "56038" => 65533,
                                       "56039" => 65533,
                                       "56040" => 65533,
                                       "56041" => 65533,
                                       "56042" => 65533,
                                       "56043" => 65533,
                                       "56044" => 65533,
                                       "56045" => 65533,
                                       "56046" => 65533,
                                       "56047" => 65533,
                                       "56048" => 65533,
                                       "56049" => 65533,
                                       "56050" => 65533,
                                       "56051" => 65533,
                                       "56052" => 65533,
                                       "56053" => 65533,
                                       "56054" => 65533,
                                       "56055" => 65533,
                                       "56056" => 65533,
                                       "56057" => 65533,
                                       "56058" => 65533,
                                       "56059" => 65533,
                                       "56060" => 65533,
                                       "56061" => 65533,
                                       "56062" => 65533,
                                       "56063" => 65533,
                                       "56064" => 65533,
                                       "56065" => 65533,
                                       "56066" => 65533,
                                       "56067" => 65533,
                                       "56068" => 65533,
                                       "56069" => 65533,
                                       "56070" => 65533,
                                       "56071" => 65533,
                                       "56072" => 65533,
                                       "56073" => 65533,
                                       "56074" => 65533,
                                       "56075" => 65533,
                                       "56076" => 65533,
                                       "56077" => 65533,
                                       "56078" => 65533,
                                       "56079" => 65533,
                                       "56080" => 65533,
                                       "56081" => 65533,
                                       "56082" => 65533,
                                       "56083" => 65533,
                                       "56084" => 65533,
                                       "56085" => 65533,
                                       "56086" => 65533,
                                       "56087" => 65533,
                                       "56088" => 65533,
                                       "56089" => 65533,
                                       "56090" => 65533,
                                       "56091" => 65533,
                                       "56092" => 65533,
                                       "56093" => 65533,
                                       "56094" => 65533,
                                       "56095" => 65533,
                                       "56096" => 65533,
                                       "56097" => 65533,
                                       "56098" => 65533,
                                       "56099" => 65533,
                                       "56100" => 65533,
                                       "56101" => 65533,
                                       "56102" => 65533,
                                       "56103" => 65533,
                                       "56104" => 65533,
                                       "56105" => 65533,
                                       "56106" => 65533,
                                       "56107" => 65533,
                                       "56108" => 65533,
                                       "56109" => 65533,
                                       "56110" => 65533,
                                       "56111" => 65533,
                                       "56112" => 65533,
                                       "56113" => 65533,
                                       "56114" => 65533,
                                       "56115" => 65533,
                                       "56116" => 65533,
                                       "56117" => 65533,
                                       "56118" => 65533,
                                       "56119" => 65533,
                                       "56120" => 65533,
                                       "56121" => 65533,
                                       "56122" => 65533,
                                       "56123" => 65533,
                                       "56124" => 65533,
                                       "56125" => 65533,
                                       "56126" => 65533,
                                       "56127" => 65533,
                                       "56128" => 65533,
                                       "56129" => 65533,
                                       "56130" => 65533,
                                       "56131" => 65533,
                                       "56132" => 65533,
                                       "56133" => 65533,
                                       "56134" => 65533,
                                       "56135" => 65533,
                                       "56136" => 65533,
                                       "56137" => 65533,
                                       "56138" => 65533,
                                       "56139" => 65533,
                                       "56140" => 65533,
                                       "56141" => 65533,
                                       "56142" => 65533,
                                       "56143" => 65533,
                                       "56144" => 65533,
                                       "56145" => 65533,
                                       "56146" => 65533,
                                       "56147" => 65533,
                                       "56148" => 65533,
                                       "56149" => 65533,
                                       "56150" => 65533,
                                       "56151" => 65533,
                                       "56152" => 65533,
                                       "56153" => 65533,
                                       "56154" => 65533,
                                       "56155" => 65533,
                                       "56156" => 65533,
                                       "56157" => 65533,
                                       "56158" => 65533,
                                       "56159" => 65533,
                                       "56160" => 65533,
                                       "56161" => 65533,
                                       "56162" => 65533,
                                       "56163" => 65533,
                                       "56164" => 65533,
                                       "56165" => 65533,
                                       "56166" => 65533,
                                       "56167" => 65533,
                                       "56168" => 65533,
                                       "56169" => 65533,
                                       "56170" => 65533,
                                       "56171" => 65533,
                                       "56172" => 65533,
                                       "56173" => 65533,
                                       "56174" => 65533,
                                       "56175" => 65533,
                                       "56176" => 65533,
                                       "56177" => 65533,
                                       "56178" => 65533,
                                       "56179" => 65533,
                                       "56180" => 65533,
                                       "56181" => 65533,
                                       "56182" => 65533,
                                       "56183" => 65533,
                                       "56184" => 65533,
                                       "56185" => 65533,
                                       "56186" => 65533,
                                       "56187" => 65533,
                                       "56188" => 65533,
                                       "56189" => 65533,
                                       "56190" => 65533,
                                       "56191" => 65533,
                                       "56192" => 65533,
                                       "56193" => 65533,
                                       "56194" => 65533,
                                       "56195" => 65533,
                                       "56196" => 65533,
                                       "56197" => 65533,
                                       "56198" => 65533,
                                       "56199" => 65533,
                                       "56200" => 65533,
                                       "56201" => 65533,
                                       "56202" => 65533,
                                       "56203" => 65533,
                                       "56204" => 65533,
                                       "56205" => 65533,
                                       "56206" => 65533,
                                       "56207" => 65533,
                                       "56208" => 65533,
                                       "56209" => 65533,
                                       "56210" => 65533,
                                       "56211" => 65533,
                                       "56212" => 65533,
                                       "56213" => 65533,
                                       "56214" => 65533,
                                       "56215" => 65533,
                                       "56216" => 65533,
                                       "56217" => 65533,
                                       "56218" => 65533,
                                       "56219" => 65533,
                                       "56220" => 65533,
                                       "56221" => 65533,
                                       "56222" => 65533,
                                       "56223" => 65533,
                                       "56224" => 65533,
                                       "56225" => 65533,
                                       "56226" => 65533,
                                       "56227" => 65533,
                                       "56228" => 65533,
                                       "56229" => 65533,
                                       "56230" => 65533,
                                       "56231" => 65533,
                                       "56232" => 65533,
                                       "56233" => 65533,
                                       "56234" => 65533,
                                       "56235" => 65533,
                                       "56236" => 65533,
                                       "56237" => 65533,
                                       "56238" => 65533,
                                       "56239" => 65533,
                                       "56240" => 65533,
                                       "56241" => 65533,
                                       "56242" => 65533,
                                       "56243" => 65533,
                                       "56244" => 65533,
                                       "56245" => 65533,
                                       "56246" => 65533,
                                       "56247" => 65533,
                                       "56248" => 65533,
                                       "56249" => 65533,
                                       "56250" => 65533,
                                       "56251" => 65533,
                                       "56252" => 65533,
                                       "56253" => 65533,
                                       "56254" => 65533,
                                       "56255" => 65533,
                                       "56256" => 65533,
                                       "56257" => 65533,
                                       "56258" => 65533,
                                       "56259" => 65533,
                                       "56260" => 65533,
                                       "56261" => 65533,
                                       "56262" => 65533,
                                       "56263" => 65533,
                                       "56264" => 65533,
                                       "56265" => 65533,
                                       "56266" => 65533,
                                       "56267" => 65533,
                                       "56268" => 65533,
                                       "56269" => 65533,
                                       "56270" => 65533,
                                       "56271" => 65533,
                                       "56272" => 65533,
                                       "56273" => 65533,
                                       "56274" => 65533,
                                       "56275" => 65533,
                                       "56276" => 65533,
                                       "56277" => 65533,
                                       "56278" => 65533,
                                       "56279" => 65533,
                                       "56280" => 65533,
                                       "56281" => 65533,
                                       "56282" => 65533,
                                       "56283" => 65533,
                                       "56284" => 65533,
                                       "56285" => 65533,
                                       "56286" => 65533,
                                       "56287" => 65533,
                                       "56288" => 65533,
                                       "56289" => 65533,
                                       "56290" => 65533,
                                       "56291" => 65533,
                                       "56292" => 65533,
                                       "56293" => 65533,
                                       "56294" => 65533,
                                       "56295" => 65533,
                                       "56296" => 65533,
                                       "56297" => 65533,
                                       "56298" => 65533,
                                       "56299" => 65533,
                                       "56300" => 65533,
                                       "56301" => 65533,
                                       "56302" => 65533,
                                       "56303" => 65533,
                                       "56304" => 65533,
                                       "56305" => 65533,
                                       "56306" => 65533,
                                       "56307" => 65533,
                                       "56308" => 65533,
                                       "56309" => 65533,
                                       "56310" => 65533,
                                       "56311" => 65533,
                                       "56312" => 65533,
                                       "56313" => 65533,
                                       "56314" => 65533,
                                       "56315" => 65533,
                                       "56316" => 65533,
                                       "56317" => 65533,
                                       "56318" => 65533,
                                       "56319" => 65533,
                                       "56320" => 65533,
                                       "56321" => 65533,
                                       "56322" => 65533,
                                       "56323" => 65533,
                                       "56324" => 65533,
                                       "56325" => 65533,
                                       "56326" => 65533,
                                       "56327" => 65533,
                                       "56328" => 65533,
                                       "56329" => 65533,
                                       "56330" => 65533,
                                       "56331" => 65533,
                                       "56332" => 65533,
                                       "56333" => 65533,
                                       "56334" => 65533,
                                       "56335" => 65533,
                                       "56336" => 65533,
                                       "56337" => 65533,
                                       "56338" => 65533,
                                       "56339" => 65533,
                                       "56340" => 65533,
                                       "56341" => 65533,
                                       "56342" => 65533,
                                       "56343" => 65533,
                                       "56344" => 65533,
                                       "56345" => 65533,
                                       "56346" => 65533,
                                       "56347" => 65533,
                                       "56348" => 65533,
                                       "56349" => 65533,
                                       "56350" => 65533,
                                       "56351" => 65533,
                                       "56352" => 65533,
                                       "56353" => 65533,
                                       "56354" => 65533,
                                       "56355" => 65533,
                                       "56356" => 65533,
                                       "56357" => 65533,
                                       "56358" => 65533,
                                       "56359" => 65533,
                                       "56360" => 65533,
                                       "56361" => 65533,
                                       "56362" => 65533,
                                       "56363" => 65533,
                                       "56364" => 65533,
                                       "56365" => 65533,
                                       "56366" => 65533,
                                       "56367" => 65533,
                                       "56368" => 65533,
                                       "56369" => 65533,
                                       "56370" => 65533,
                                       "56371" => 65533,
                                       "56372" => 65533,
                                       "56373" => 65533,
                                       "56374" => 65533,
                                       "56375" => 65533,
                                       "56376" => 65533,
                                       "56377" => 65533,
                                       "56378" => 65533,
                                       "56379" => 65533,
                                       "56380" => 65533,
                                       "56381" => 65533,
                                       "56382" => 65533,
                                       "56383" => 65533,
                                       "56384" => 65533,
                                       "56385" => 65533,
                                       "56386" => 65533,
                                       "56387" => 65533,
                                       "56388" => 65533,
                                       "56389" => 65533,
                                       "56390" => 65533,
                                       "56391" => 65533,
                                       "56392" => 65533,
                                       "56393" => 65533,
                                       "56394" => 65533,
                                       "56395" => 65533,
                                       "56396" => 65533,
                                       "56397" => 65533,
                                       "56398" => 65533,
                                       "56399" => 65533,
                                       "56400" => 65533,
                                       "56401" => 65533,
                                       "56402" => 65533,
                                       "56403" => 65533,
                                       "56404" => 65533,
                                       "56405" => 65533,
                                       "56406" => 65533,
                                       "56407" => 65533,
                                       "56408" => 65533,
                                       "56409" => 65533,
                                       "56410" => 65533,
                                       "56411" => 65533,
                                       "56412" => 65533,
                                       "56413" => 65533,
                                       "56414" => 65533,
                                       "56415" => 65533,
                                       "56416" => 65533,
                                       "56417" => 65533,
                                       "56418" => 65533,
                                       "56419" => 65533,
                                       "56420" => 65533,
                                       "56421" => 65533,
                                       "56422" => 65533,
                                       "56423" => 65533,
                                       "56424" => 65533,
                                       "56425" => 65533,
                                       "56426" => 65533,
                                       "56427" => 65533,
                                       "56428" => 65533,
                                       "56429" => 65533,
                                       "56430" => 65533,
                                       "56431" => 65533,
                                       "56432" => 65533,
                                       "56433" => 65533,
                                       "56434" => 65533,
                                       "56435" => 65533,
                                       "56436" => 65533,
                                       "56437" => 65533,
                                       "56438" => 65533,
                                       "56439" => 65533,
                                       "56440" => 65533,
                                       "56441" => 65533,
                                       "56442" => 65533,
                                       "56443" => 65533,
                                       "56444" => 65533,
                                       "56445" => 65533,
                                       "56446" => 65533,
                                       "56447" => 65533,
                                       "56448" => 65533,
                                       "56449" => 65533,
                                       "56450" => 65533,
                                       "56451" => 65533,
                                       "56452" => 65533,
                                       "56453" => 65533,
                                       "56454" => 65533,
                                       "56455" => 65533,
                                       "56456" => 65533,
                                       "56457" => 65533,
                                       "56458" => 65533,
                                       "56459" => 65533,
                                       "56460" => 65533,
                                       "56461" => 65533,
                                       "56462" => 65533,
                                       "56463" => 65533,
                                       "56464" => 65533,
                                       "56465" => 65533,
                                       "56466" => 65533,
                                       "56467" => 65533,
                                       "56468" => 65533,
                                       "56469" => 65533,
                                       "56470" => 65533,
                                       "56471" => 65533,
                                       "56472" => 65533,
                                       "56473" => 65533,
                                       "56474" => 65533,
                                       "56475" => 65533,
                                       "56476" => 65533,
                                       "56477" => 65533,
                                       "56478" => 65533,
                                       "56479" => 65533,
                                       "56480" => 65533,
                                       "56481" => 65533,
                                       "56482" => 65533,
                                       "56483" => 65533,
                                       "56484" => 65533,
                                       "56485" => 65533,
                                       "56486" => 65533,
                                       "56487" => 65533,
                                       "56488" => 65533,
                                       "56489" => 65533,
                                       "56490" => 65533,
                                       "56491" => 65533,
                                       "56492" => 65533,
                                       "56493" => 65533,
                                       "56494" => 65533,
                                       "56495" => 65533,
                                       "56496" => 65533,
                                       "56497" => 65533,
                                       "56498" => 65533,
                                       "56499" => 65533,
                                       "56500" => 65533,
                                       "56501" => 65533,
                                       "56502" => 65533,
                                       "56503" => 65533,
                                       "56504" => 65533,
                                       "56505" => 65533,
                                       "56506" => 65533,
                                       "56507" => 65533,
                                       "56508" => 65533,
                                       "56509" => 65533,
                                       "56510" => 65533,
                                       "56511" => 65533,
                                       "56512" => 65533,
                                       "56513" => 65533,
                                       "56514" => 65533,
                                       "56515" => 65533,
                                       "56516" => 65533,
                                       "56517" => 65533,
                                       "56518" => 65533,
                                       "56519" => 65533,
                                       "56520" => 65533,
                                       "56521" => 65533,
                                       "56522" => 65533,
                                       "56523" => 65533,
                                       "56524" => 65533,
                                       "56525" => 65533,
                                       "56526" => 65533,
                                       "56527" => 65533,
                                       "56528" => 65533,
                                       "56529" => 65533,
                                       "56530" => 65533,
                                       "56531" => 65533,
                                       "56532" => 65533,
                                       "56533" => 65533,
                                       "56534" => 65533,
                                       "56535" => 65533,
                                       "56536" => 65533,
                                       "56537" => 65533,
                                       "56538" => 65533,
                                       "56539" => 65533,
                                       "56540" => 65533,
                                       "56541" => 65533,
                                       "56542" => 65533,
                                       "56543" => 65533,
                                       "56544" => 65533,
                                       "56545" => 65533,
                                       "56546" => 65533,
                                       "56547" => 65533,
                                       "56548" => 65533,
                                       "56549" => 65533,
                                       "56550" => 65533,
                                       "56551" => 65533,
                                       "56552" => 65533,
                                       "56553" => 65533,
                                       "56554" => 65533,
                                       "56555" => 65533,
                                       "56556" => 65533,
                                       "56557" => 65533,
                                       "56558" => 65533,
                                       "56559" => 65533,
                                       "56560" => 65533,
                                       "56561" => 65533,
                                       "56562" => 65533,
                                       "56563" => 65533,
                                       "56564" => 65533,
                                       "56565" => 65533,
                                       "56566" => 65533,
                                       "56567" => 65533,
                                       "56568" => 65533,
                                       "56569" => 65533,
                                       "56570" => 65533,
                                       "56571" => 65533,
                                       "56572" => 65533,
                                       "56573" => 65533,
                                       "56574" => 65533,
                                       "56575" => 65533,
                                       "56576" => 65533,
                                       "56577" => 65533,
                                       "56578" => 65533,
                                       "56579" => 65533,
                                       "56580" => 65533,
                                       "56581" => 65533,
                                       "56582" => 65533,
                                       "56583" => 65533,
                                       "56584" => 65533,
                                       "56585" => 65533,
                                       "56586" => 65533,
                                       "56587" => 65533,
                                       "56588" => 65533,
                                       "56589" => 65533,
                                       "56590" => 65533,
                                       "56591" => 65533,
                                       "56592" => 65533,
                                       "56593" => 65533,
                                       "56594" => 65533,
                                       "56595" => 65533,
                                       "56596" => 65533,
                                       "56597" => 65533,
                                       "56598" => 65533,
                                       "56599" => 65533,
                                       "56600" => 65533,
                                       "56601" => 65533,
                                       "56602" => 65533,
                                       "56603" => 65533,
                                       "56604" => 65533,
                                       "56605" => 65533,
                                       "56606" => 65533,
                                       "56607" => 65533,
                                       "56608" => 65533,
                                       "56609" => 65533,
                                       "56610" => 65533,
                                       "56611" => 65533,
                                       "56612" => 65533,
                                       "56613" => 65533,
                                       "56614" => 65533,
                                       "56615" => 65533,
                                       "56616" => 65533,
                                       "56617" => 65533,
                                       "56618" => 65533,
                                       "56619" => 65533,
                                       "56620" => 65533,
                                       "56621" => 65533,
                                       "56622" => 65533,
                                       "56623" => 65533,
                                       "56624" => 65533,
                                       "56625" => 65533,
                                       "56626" => 65533,
                                       "56627" => 65533,
                                       "56628" => 65533,
                                       "56629" => 65533,
                                       "56630" => 65533,
                                       "56631" => 65533,
                                       "56632" => 65533,
                                       "56633" => 65533,
                                       "56634" => 65533,
                                       "56635" => 65533,
                                       "56636" => 65533,
                                       "56637" => 65533,
                                       "56638" => 65533,
                                       "56639" => 65533,
                                       "56640" => 65533,
                                       "56641" => 65533,
                                       "56642" => 65533,
                                       "56643" => 65533,
                                       "56644" => 65533,
                                       "56645" => 65533,
                                       "56646" => 65533,
                                       "56647" => 65533,
                                       "56648" => 65533,
                                       "56649" => 65533,
                                       "56650" => 65533,
                                       "56651" => 65533,
                                       "56652" => 65533,
                                       "56653" => 65533,
                                       "56654" => 65533,
                                       "56655" => 65533,
                                       "56656" => 65533,
                                       "56657" => 65533,
                                       "56658" => 65533,
                                       "56659" => 65533,
                                       "56660" => 65533,
                                       "56661" => 65533,
                                       "56662" => 65533,
                                       "56663" => 65533,
                                       "56664" => 65533,
                                       "56665" => 65533,
                                       "56666" => 65533,
                                       "56667" => 65533,
                                       "56668" => 65533,
                                       "56669" => 65533,
                                       "56670" => 65533,
                                       "56671" => 65533,
                                       "56672" => 65533,
                                       "56673" => 65533,
                                       "56674" => 65533,
                                       "56675" => 65533,
                                       "56676" => 65533,
                                       "56677" => 65533,
                                       "56678" => 65533,
                                       "56679" => 65533,
                                       "56680" => 65533,
                                       "56681" => 65533,
                                       "56682" => 65533,
                                       "56683" => 65533,
                                       "56684" => 65533,
                                       "56685" => 65533,
                                       "56686" => 65533,
                                       "56687" => 65533,
                                       "56688" => 65533,
                                       "56689" => 65533,
                                       "56690" => 65533,
                                       "56691" => 65533,
                                       "56692" => 65533,
                                       "56693" => 65533,
                                       "56694" => 65533,
                                       "56695" => 65533,
                                       "56696" => 65533,
                                       "56697" => 65533,
                                       "56698" => 65533,
                                       "56699" => 65533,
                                       "56700" => 65533,
                                       "56701" => 65533,
                                       "56702" => 65533,
                                       "56703" => 65533,
                                       "56704" => 65533,
                                       "56705" => 65533,
                                       "56706" => 65533,
                                       "56707" => 65533,
                                       "56708" => 65533,
                                       "56709" => 65533,
                                       "56710" => 65533,
                                       "56711" => 65533,
                                       "56712" => 65533,
                                       "56713" => 65533,
                                       "56714" => 65533,
                                       "56715" => 65533,
                                       "56716" => 65533,
                                       "56717" => 65533,
                                       "56718" => 65533,
                                       "56719" => 65533,
                                       "56720" => 65533,
                                       "56721" => 65533,
                                       "56722" => 65533,
                                       "56723" => 65533,
                                       "56724" => 65533,
                                       "56725" => 65533,
                                       "56726" => 65533,
                                       "56727" => 65533,
                                       "56728" => 65533,
                                       "56729" => 65533,
                                       "56730" => 65533,
                                       "56731" => 65533,
                                       "56732" => 65533,
                                       "56733" => 65533,
                                       "56734" => 65533,
                                       "56735" => 65533,
                                       "56736" => 65533,
                                       "56737" => 65533,
                                       "56738" => 65533,
                                       "56739" => 65533,
                                       "56740" => 65533,
                                       "56741" => 65533,
                                       "56742" => 65533,
                                       "56743" => 65533,
                                       "56744" => 65533,
                                       "56745" => 65533,
                                       "56746" => 65533,
                                       "56747" => 65533,
                                       "56748" => 65533,
                                       "56749" => 65533,
                                       "56750" => 65533,
                                       "56751" => 65533,
                                       "56752" => 65533,
                                       "56753" => 65533,
                                       "56754" => 65533,
                                       "56755" => 65533,
                                       "56756" => 65533,
                                       "56757" => 65533,
                                       "56758" => 65533,
                                       "56759" => 65533,
                                       "56760" => 65533,
                                       "56761" => 65533,
                                       "56762" => 65533,
                                       "56763" => 65533,
                                       "56764" => 65533,
                                       "56765" => 65533,
                                       "56766" => 65533,
                                       "56767" => 65533,
                                       "56768" => 65533,
                                       "56769" => 65533,
                                       "56770" => 65533,
                                       "56771" => 65533,
                                       "56772" => 65533,
                                       "56773" => 65533,
                                       "56774" => 65533,
                                       "56775" => 65533,
                                       "56776" => 65533,
                                       "56777" => 65533,
                                       "56778" => 65533,
                                       "56779" => 65533,
                                       "56780" => 65533,
                                       "56781" => 65533,
                                       "56782" => 65533,
                                       "56783" => 65533,
                                       "56784" => 65533,
                                       "56785" => 65533,
                                       "56786" => 65533,
                                       "56787" => 65533,
                                       "56788" => 65533,
                                       "56789" => 65533,
                                       "56790" => 65533,
                                       "56791" => 65533,
                                       "56792" => 65533,
                                       "56793" => 65533,
                                       "56794" => 65533,
                                       "56795" => 65533,
                                       "56796" => 65533,
                                       "56797" => 65533,
                                       "56798" => 65533,
                                       "56799" => 65533,
                                       "56800" => 65533,
                                       "56801" => 65533,
                                       "56802" => 65533,
                                       "56803" => 65533,
                                       "56804" => 65533,
                                       "56805" => 65533,
                                       "56806" => 65533,
                                       "56807" => 65533,
                                       "56808" => 65533,
                                       "56809" => 65533,
                                       "56810" => 65533,
                                       "56811" => 65533,
                                       "56812" => 65533,
                                       "56813" => 65533,
                                       "56814" => 65533,
                                       "56815" => 65533,
                                       "56816" => 65533,
                                       "56817" => 65533,
                                       "56818" => 65533,
                                       "56819" => 65533,
                                       "56820" => 65533,
                                       "56821" => 65533,
                                       "56822" => 65533,
                                       "56823" => 65533,
                                       "56824" => 65533,
                                       "56825" => 65533,
                                       "56826" => 65533,
                                       "56827" => 65533,
                                       "56828" => 65533,
                                       "56829" => 65533,
                                       "56830" => 65533,
                                       "56831" => 65533,
                                       "56832" => 65533,
                                       "56833" => 65533,
                                       "56834" => 65533,
                                       "56835" => 65533,
                                       "56836" => 65533,
                                       "56837" => 65533,
                                       "56838" => 65533,
                                       "56839" => 65533,
                                       "56840" => 65533,
                                       "56841" => 65533,
                                       "56842" => 65533,
                                       "56843" => 65533,
                                       "56844" => 65533,
                                       "56845" => 65533,
                                       "56846" => 65533,
                                       "56847" => 65533,
                                       "56848" => 65533,
                                       "56849" => 65533,
                                       "56850" => 65533,
                                       "56851" => 65533,
                                       "56852" => 65533,
                                       "56853" => 65533,
                                       "56854" => 65533,
                                       "56855" => 65533,
                                       "56856" => 65533,
                                       "56857" => 65533,
                                       "56858" => 65533,
                                       "56859" => 65533,
                                       "56860" => 65533,
                                       "56861" => 65533,
                                       "56862" => 65533,
                                       "56863" => 65533,
                                       "56864" => 65533,
                                       "56865" => 65533,
                                       "56866" => 65533,
                                       "56867" => 65533,
                                       "56868" => 65533,
                                       "56869" => 65533,
                                       "56870" => 65533,
                                       "56871" => 65533,
                                       "56872" => 65533,
                                       "56873" => 65533,
                                       "56874" => 65533,
                                       "56875" => 65533,
                                       "56876" => 65533,
                                       "56877" => 65533,
                                       "56878" => 65533,
                                       "56879" => 65533,
                                       "56880" => 65533,
                                       "56881" => 65533,
                                       "56882" => 65533,
                                       "56883" => 65533,
                                       "56884" => 65533,
                                       "56885" => 65533,
                                       "56886" => 65533,
                                       "56887" => 65533,
                                       "56888" => 65533,
                                       "56889" => 65533,
                                       "56890" => 65533,
                                       "56891" => 65533,
                                       "56892" => 65533,
                                       "56893" => 65533,
                                       "56894" => 65533,
                                       "56895" => 65533,
                                       "56896" => 65533,
                                       "56897" => 65533,
                                       "56898" => 65533,
                                       "56899" => 65533,
                                       "56900" => 65533,
                                       "56901" => 65533,
                                       "56902" => 65533,
                                       "56903" => 65533,
                                       "56904" => 65533,
                                       "56905" => 65533,
                                       "56906" => 65533,
                                       "56907" => 65533,
                                       "56908" => 65533,
                                       "56909" => 65533,
                                       "56910" => 65533,
                                       "56911" => 65533,
                                       "56912" => 65533,
                                       "56913" => 65533,
                                       "56914" => 65533,
                                       "56915" => 65533,
                                       "56916" => 65533,
                                       "56917" => 65533,
                                       "56918" => 65533,
                                       "56919" => 65533,
                                       "56920" => 65533,
                                       "56921" => 65533,
                                       "56922" => 65533,
                                       "56923" => 65533,
                                       "56924" => 65533,
                                       "56925" => 65533,
                                       "56926" => 65533,
                                       "56927" => 65533,
                                       "56928" => 65533,
                                       "56929" => 65533,
                                       "56930" => 65533,
                                       "56931" => 65533,
                                       "56932" => 65533,
                                       "56933" => 65533,
                                       "56934" => 65533,
                                       "56935" => 65533,
                                       "56936" => 65533,
                                       "56937" => 65533,
                                       "56938" => 65533,
                                       "56939" => 65533,
                                       "56940" => 65533,
                                       "56941" => 65533,
                                       "56942" => 65533,
                                       "56943" => 65533,
                                       "56944" => 65533,
                                       "56945" => 65533,
                                       "56946" => 65533,
                                       "56947" => 65533,
                                       "56948" => 65533,
                                       "56949" => 65533,
                                       "56950" => 65533,
                                       "56951" => 65533,
                                       "56952" => 65533,
                                       "56953" => 65533,
                                       "56954" => 65533,
                                       "56955" => 65533,
                                       "56956" => 65533,
                                       "56957" => 65533,
                                       "56958" => 65533,
                                       "56959" => 65533,
                                       "56960" => 65533,
                                       "56961" => 65533,
                                       "56962" => 65533,
                                       "56963" => 65533,
                                       "56964" => 65533,
                                       "56965" => 65533,
                                       "56966" => 65533,
                                       "56967" => 65533,
                                       "56968" => 65533,
                                       "56969" => 65533,
                                       "56970" => 65533,
                                       "56971" => 65533,
                                       "56972" => 65533,
                                       "56973" => 65533,
                                       "56974" => 65533,
                                       "56975" => 65533,
                                       "56976" => 65533,
                                       "56977" => 65533,
                                       "56978" => 65533,
                                       "56979" => 65533,
                                       "56980" => 65533,
                                       "56981" => 65533,
                                       "56982" => 65533,
                                       "56983" => 65533,
                                       "56984" => 65533,
                                       "56985" => 65533,
                                       "56986" => 65533,
                                       "56987" => 65533,
                                       "56988" => 65533,
                                       "56989" => 65533,
                                       "56990" => 65533,
                                       "56991" => 65533,
                                       "56992" => 65533,
                                       "56993" => 65533,
                                       "56994" => 65533,
                                       "56995" => 65533,
                                       "56996" => 65533,
                                       "56997" => 65533,
                                       "56998" => 65533,
                                       "56999" => 65533,
                                       "57000" => 65533,
                                       "57001" => 65533,
                                       "57002" => 65533,
                                       "57003" => 65533,
                                       "57004" => 65533,
                                       "57005" => 65533,
                                       "57006" => 65533,
                                       "57007" => 65533,
                                       "57008" => 65533,
                                       "57009" => 65533,
                                       "57010" => 65533,
                                       "57011" => 65533,
                                       "57012" => 65533,
                                       "57013" => 65533,
                                       "57014" => 65533,
                                       "57015" => 65533,
                                       "57016" => 65533,
                                       "57017" => 65533,
                                       "57018" => 65533,
                                       "57019" => 65533,
                                       "57020" => 65533,
                                       "57021" => 65533,
                                       "57022" => 65533,
                                       "57023" => 65533,
                                       "57024" => 65533,
                                       "57025" => 65533,
                                       "57026" => 65533,
                                       "57027" => 65533,
                                       "57028" => 65533,
                                       "57029" => 65533,
                                       "57030" => 65533,
                                       "57031" => 65533,
                                       "57032" => 65533,
                                       "57033" => 65533,
                                       "57034" => 65533,
                                       "57035" => 65533,
                                       "57036" => 65533,
                                       "57037" => 65533,
                                       "57038" => 65533,
                                       "57039" => 65533,
                                       "57040" => 65533,
                                       "57041" => 65533,
                                       "57042" => 65533,
                                       "57043" => 65533,
                                       "57044" => 65533,
                                       "57045" => 65533,
                                       "57046" => 65533,
                                       "57047" => 65533,
                                       "57048" => 65533,
                                       "57049" => 65533,
                                       "57050" => 65533,
                                       "57051" => 65533,
                                       "57052" => 65533,
                                       "57053" => 65533,
                                       "57054" => 65533,
                                       "57055" => 65533,
                                       "57056" => 65533,
                                       "57057" => 65533,
                                       "57058" => 65533,
                                       "57059" => 65533,
                                       "57060" => 65533,
                                       "57061" => 65533,
                                       "57062" => 65533,
                                       "57063" => 65533,
                                       "57064" => 65533,
                                       "57065" => 65533,
                                       "57066" => 65533,
                                       "57067" => 65533,
                                       "57068" => 65533,
                                       "57069" => 65533,
                                       "57070" => 65533,
                                       "57071" => 65533,
                                       "57072" => 65533,
                                       "57073" => 65533,
                                       "57074" => 65533,
                                       "57075" => 65533,
                                       "57076" => 65533,
                                       "57077" => 65533,
                                       "57078" => 65533,
                                       "57079" => 65533,
                                       "57080" => 65533,
                                       "57081" => 65533,
                                       "57082" => 65533,
                                       "57083" => 65533,
                                       "57084" => 65533,
                                       "57085" => 65533,
                                       "57086" => 65533,
                                       "57087" => 65533,
                                       "57088" => 65533,
                                       "57089" => 65533,
                                       "57090" => 65533,
                                       "57091" => 65533,
                                       "57092" => 65533,
                                       "57093" => 65533,
                                       "57094" => 65533,
                                       "57095" => 65533,
                                       "57096" => 65533,
                                       "57097" => 65533,
                                       "57098" => 65533,
                                       "57099" => 65533,
                                       "57100" => 65533,
                                       "57101" => 65533,
                                       "57102" => 65533,
                                       "57103" => 65533,
                                       "57104" => 65533,
                                       "57105" => 65533,
                                       "57106" => 65533,
                                       "57107" => 65533,
                                       "57108" => 65533,
                                       "57109" => 65533,
                                       "57110" => 65533,
                                       "57111" => 65533,
                                       "57112" => 65533,
                                       "57113" => 65533,
                                       "57114" => 65533,
                                       "57115" => 65533,
                                       "57116" => 65533,
                                       "57117" => 65533,
                                       "57118" => 65533,
                                       "57119" => 65533,
                                       "57120" => 65533,
                                       "57121" => 65533,
                                       "57122" => 65533,
                                       "57123" => 65533,
                                       "57124" => 65533,
                                       "57125" => 65533,
                                       "57126" => 65533,
                                       "57127" => 65533,
                                       "57128" => 65533,
                                       "57129" => 65533,
                                       "57130" => 65533,
                                       "57131" => 65533,
                                       "57132" => 65533,
                                       "57133" => 65533,
                                       "57134" => 65533,
                                       "57135" => 65533,
                                       "57136" => 65533,
                                       "57137" => 65533,
                                       "57138" => 65533,
                                       "57139" => 65533,
                                       "57140" => 65533,
                                       "57141" => 65533,
                                       "57142" => 65533,
                                       "57143" => 65533,
                                       "57144" => 65533,
                                       "57145" => 65533,
                                       "57146" => 65533,
                                       "57147" => 65533,
                                       "57148" => 65533,
                                       "57149" => 65533,
                                       "57150" => 65533,
                                       "57151" => 65533,
                                       "57152" => 65533,
                                       "57153" => 65533,
                                       "57154" => 65533,
                                       "57155" => 65533,
                                       "57156" => 65533,
                                       "57157" => 65533,
                                       "57158" => 65533,
                                       "57159" => 65533,
                                       "57160" => 65533,
                                       "57161" => 65533,
                                       "57162" => 65533,
                                       "57163" => 65533,
                                       "57164" => 65533,
                                       "57165" => 65533,
                                       "57166" => 65533,
                                       "57167" => 65533,
                                       "57168" => 65533,
                                       "57169" => 65533,
                                       "57170" => 65533,
                                       "57171" => 65533,
                                       "57172" => 65533,
                                       "57173" => 65533,
                                       "57174" => 65533,
                                       "57175" => 65533,
                                       "57176" => 65533,
                                       "57177" => 65533,
                                       "57178" => 65533,
                                       "57179" => 65533,
                                       "57180" => 65533,
                                       "57181" => 65533,
                                       "57182" => 65533,
                                       "57183" => 65533,
                                       "57184" => 65533,
                                       "57185" => 65533,
                                       "57186" => 65533,
                                       "57187" => 65533,
                                       "57188" => 65533,
                                       "57189" => 65533,
                                       "57190" => 65533,
                                       "57191" => 65533,
                                       "57192" => 65533,
                                       "57193" => 65533,
                                       "57194" => 65533,
                                       "57195" => 65533,
                                       "57196" => 65533,
                                       "57197" => 65533,
                                       "57198" => 65533,
                                       "57199" => 65533,
                                       "57200" => 65533,
                                       "57201" => 65533,
                                       "57202" => 65533,
                                       "57203" => 65533,
                                       "57204" => 65533,
                                       "57205" => 65533,
                                       "57206" => 65533,
                                       "57207" => 65533,
                                       "57208" => 65533,
                                       "57209" => 65533,
                                       "57210" => 65533,
                                       "57211" => 65533,
                                       "57212" => 65533,
                                       "57213" => 65533,
                                       "57214" => 65533,
                                       "57215" => 65533,
                                       "57216" => 65533,
                                       "57217" => 65533,
                                       "57218" => 65533,
                                       "57219" => 65533,
                                       "57220" => 65533,
                                       "57221" => 65533,
                                       "57222" => 65533,
                                       "57223" => 65533,
                                       "57224" => 65533,
                                       "57225" => 65533,
                                       "57226" => 65533,
                                       "57227" => 65533,
                                       "57228" => 65533,
                                       "57229" => 65533,
                                       "57230" => 65533,
                                       "57231" => 65533,
                                       "57232" => 65533,
                                       "57233" => 65533,
                                       "57234" => 65533,
                                       "57235" => 65533,
                                       "57236" => 65533,
                                       "57237" => 65533,
                                       "57238" => 65533,
                                       "57239" => 65533,
                                       "57240" => 65533,
                                       "57241" => 65533,
                                       "57242" => 65533,
                                       "57243" => 65533,
                                       "57244" => 65533,
                                       "57245" => 65533,
                                       "57246" => 65533,
                                       "57247" => 65533,
                                       "57248" => 65533,
                                       "57249" => 65533,
                                       "57250" => 65533,
                                       "57251" => 65533,
                                       "57252" => 65533,
                                       "57253" => 65533,
                                       "57254" => 65533,
                                       "57255" => 65533,
                                       "57256" => 65533,
                                       "57257" => 65533,
                                       "57258" => 65533,
                                       "57259" => 65533,
                                       "57260" => 65533,
                                       "57261" => 65533,
                                       "57262" => 65533,
                                       "57263" => 65533,
                                       "57264" => 65533,
                                       "57265" => 65533,
                                       "57266" => 65533,
                                       "57267" => 65533,
                                       "57268" => 65533,
                                       "57269" => 65533,
                                       "57270" => 65533,
                                       "57271" => 65533,
                                       "57272" => 65533,
                                       "57273" => 65533,
                                       "57274" => 65533,
                                       "57275" => 65533,
                                       "57276" => 65533,
                                       "57277" => 65533,
                                       "57278" => 65533,
                                       "57279" => 65533,
                                       "57280" => 65533,
                                       "57281" => 65533,
                                       "57282" => 65533,
                                       "57283" => 65533,
                                       "57284" => 65533,
                                       "57285" => 65533,
                                       "57286" => 65533,
                                       "57287" => 65533,
                                       "57288" => 65533,
                                       "57289" => 65533,
                                       "57290" => 65533,
                                       "57291" => 65533,
                                       "57292" => 65533,
                                       "57293" => 65533,
                                       "57294" => 65533,
                                       "57295" => 65533,
                                       "57296" => 65533,
                                       "57297" => 65533,
                                       "57298" => 65533,
                                       "57299" => 65533,
                                       "57300" => 65533,
                                       "57301" => 65533,
                                       "57302" => 65533,
                                       "57303" => 65533,
                                       "57304" => 65533,
                                       "57305" => 65533,
                                       "57306" => 65533,
                                       "57307" => 65533,
                                       "57308" => 65533,
                                       "57309" => 65533,
                                       "57310" => 65533,
                                       "57311" => 65533,
                                       "57312" => 65533,
                                       "57313" => 65533,
                                       "57314" => 65533,
                                       "57315" => 65533,
                                       "57316" => 65533,
                                       "57317" => 65533,
                                       "57318" => 65533,
                                       "57319" => 65533,
                                       "57320" => 65533,
                                       "57321" => 65533,
                                       "57322" => 65533,
                                       "57323" => 65533,
                                       "57324" => 65533,
                                       "57325" => 65533,
                                       "57326" => 65533,
                                       "57327" => 65533,
                                       "57328" => 65533,
                                       "57329" => 65533,
                                       "57330" => 65533,
                                       "57331" => 65533,
                                       "57332" => 65533,
                                       "57333" => 65533,
                                       "57334" => 65533,
                                       "57335" => 65533,
                                       "57336" => 65533,
                                       "57337" => 65533,
                                       "57338" => 65533,
                                       "57339" => 65533,
                                       "57340" => 65533,
                                       "57341" => 65533,
                                       "57342" => 65533,
                                       "57343" => 65533,
                                       "6" => 6,
                                       "65534" => 65534,
                                       "65535" => 65535,
                                       "7" => 7,
                                       "8" => 8
                                     }
          };
  
  1;
  
  =head1 LICENSE
  
  This file contains data from the data-web-defs repository
  <https://github.com/manakai/data-web-defs/>.
  
  This file contains texts from Gecko and Chromium source codes.
  See following documents for full license terms of them:
  
  Gecko:
  
    This Source Code Form is subject to the terms of the Mozilla Public
    License, v. 2.0. If a copy of the MPL was not distributed with this
    file, You can obtain one at http://mozilla.org/MPL/2.0/.
  
  Chromium:
  
    See following documents:
    <http://src.chromium.org/viewvc/chrome/trunk/src/webkit/LICENSE>
    <http://src.chromium.org/viewvc/chrome/trunk/src/webkit/glue/resources/README.txt>
  
  =cut
WEB_HTML__SYNTAXDEFS

$fatpacked{"_pod2html_common.pl"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'_POD2HTML_COMMON';
  use strict;
  use warnings;
  use Pod::Simple::HTML;
  use Web::DOM::Document;
  use Web::HTML::Parser;
  
  sub process_inline_nodes ($$$$@) {
    my ($doc, $root_url, $to_repo_url, $to_module_url, @source) = @_;
    my @dest;
    while (@source) {
      my $source = shift @source;
      if ($source->node_type == $source->ELEMENT_NODE) {
        my $ln = $source->local_name;
        if ($ln eq 'a') {
          my $url = $source->get_attribute ('href');
          if (defined $url and
              $url =~ m{^https?://search.cpan.org/perldoc\?([^#]+)(#.*|)$}s) {
            my $module = $1;
            my $suffix = $2;
            $module =~ s/%3A%3A/::/g;
            $url = $to_module_url->($root_url, $module);
            $source->set_attribute (href => "$url$suffix");
            push @dest, $source;
          } elsif (not defined $url and $source->text_content eq '') {
            #
          } else {
            push @dest, $source;
          }
        } elsif ($ln eq 'i') {
          my $var = $doc->create_element ('var');
          $var->append_child ($_) for $source->child_nodes->to_list;
          push @dest, $var;
        } else {
          push @dest, $source;
        }
      } elsif ($source->node_type == $source->TEXT_NODE) {
        my $text = $source->data;
        my @cite;
        while ($text =~ s/\s*\[([^\[\]]+)\]\s*$//) {
          unshift @cite, $1;
        }
        for (split /(<[^<>]+>|[Tt]he\s+perl-\S+\s+package)/, $text) {
          if (m{^<((?:https?|view-source):[^<>]+)>$}) {
            my $a = $doc->create_element ('a');
            $a->href ($1);
            $a->text_content ($1);
            my $code = $doc->create_element ('code');
            $code->class_name ('url');
            $code->manakai_append_text ('<');
            $code->append_child ($a);
            $code->manakai_append_text ('>');
            push @dest, $code;
          } elsif (/([Tt]he\s+(perl-\S+)\s+package)/) {
            my $a = $doc->create_element ('a');
            $a->href ($to_repo_url->($root_url, $2));
            $a->text_content ($1);
            push @dest, $a;
          } else {
            push @dest, $doc->create_text_node ($_);
          }
        }
        for (@cite) {
          push @dest, $doc->create_text_node (' ');
          my $cite = $doc->create_element ('cite');
          $cite->class_name ('ref');
          $cite->manakai_append_text ('[');
          my $a = $doc->create_element ('a');
          $a->href ('#' . $_);
          $a->text_content ($_);
          $cite->append_child ($a);
          $cite->manakai_append_text (']');
          push @dest, $cite;
        }
      }
    }
    return @dest;
  } # process_inline_nodes
  
  sub pod2html ($$$%) {
    my ($pod_text => $html_path, $write, %args) = @_;
    my $n = 0;
    $n++ while $args{module_name} =~ /::/g;
    $n++ if $html_path =~ m{/index.html$};
    my $root_url = join '/', (('..') x (1 + $n));
  
    my $p = Pod::Simple::HTML->new;
    $p->output_string (\my $html);
    $p->parse_characters (1);
    $p->parse_string_document ($pod_text);
  
    my $source_doc = new Web::DOM::Document;
    my $parser = new Web::HTML::Parser;
    $parser->onerror (sub { });
    $parser->parse_char_string ($html => $source_doc);
  
    my $doc = new Web::DOM::Document;
    $doc->manakai_is_html (1);
  
    my $body = $doc->create_document_fragment;
    my $section1 = $body;
    my $section2 = $body;
    my $section3 = $body;
    my $section4 = $body;
    my $last_section = $body;
    my $has_section = {};
    my $has_member = {};
  
    my $source_body = $source_doc->body;
    for my $source_node (@{$source_body->child_nodes}) {
      my $nt = $source_node->node_type;
      if ($nt == $source_node->ELEMENT_NODE) {
        my $ln = $source_node->local_name;
        if ($ln eq 'h1' or $ln eq 'h2' or $ln eq 'h3' or $ln eq 'h4') {
          my $section = $doc->create_element ('section');
          my @node = $source_node->child_nodes->to_list;
          if (@node and
              $node[0]->node_type == $source_node->ELEMENT_NODE and
              $node[0]->local_name eq 'a') {
            my $name = $node[0]->name;
            $section->id ($name) if length $name;
            $has_section->{$name} = 1;
            my @child = $node[0]->child_nodes->to_list;
            shift @node;
            unshift @node, @child;
          }
          my $h1 = $doc->create_element ('h1');
          $h1->append_child ($_) for @node;
          $section->append_child ($h1);
          if ($ln eq 'h1') {
            $body->append_child ($section);
            $last_section = $section1 = $section2 = $section3 = $section4
                = $section;
          } elsif ($ln eq 'h2') {
            $section1->append_child ($section);
            $last_section = $section2 = $section3 = $section4 = $section;
          } elsif ($ln eq 'h3') {
            $section2->append_child ($section);
            $last_section = $section3 = $section4 = $section;
          } elsif ($ln eq 'h4') {
            $section3->append_child ($section);
            $last_section = $section4 = $section;
          }
        } elsif ($ln eq 'p') {
          if ($source_node->child_nodes->length == 1 and
              $source_node->first_child->node_type == $source_node->TEXT_NODE) {
            my $text = $source_node->inner_html;
            if ($text =~ s{^([A-Za-z0-9_:]+) - }{}) {
              my $p = $doc->create_element ('p');
              $p->inner_html (qq{<code>$1</code>});
              $last_section->append_child ($p);
            }
            $text =~ s{DOM\s+\|([A-Za-z0-9]+)\|\s+([Ii]nterface|[Oo]bject)}
                      {DOM <a href="https://suika.suikawiki.org/~wakaba/wiki/sw/n/$1"><code>$1</code></a> $2}g;
            $text =~ s{\|([^|]+)\|}{<code>$1</code>}g;
            $source_node->inner_html ($text);
          }
          my $p = $doc->create_element ('p');
          $p->append_child ($_)
              for process_inline_nodes
                      ($doc, $root_url, $args{to_repo_url}, $args{to_module_url},
                       $source_node->child_nodes->to_list);
          $last_section->append_child ($p);
        } elsif ($ln eq 'dl') {
          my $dl = $doc->create_element ('dl');
          my $has_dd;
          for my $src_node ($source_node->child_nodes->to_list) {
            if ($src_node->node_type == $src_node->ELEMENT_NODE) {
              my $ln = $src_node->local_name;
              if ($ln eq 'dt') {
                if ($src_node->child_nodes->length == 1 and
                    $src_node->first_child->node_type == $src_node->ELEMENT_NODE and
                    $src_node->first_child->local_name eq 'a') {
                  my $dt = $doc->create_element ('dt');
                  $dt->inner_html ('<code></code>')
                      if $src_node->text_content =~ /\$|->|=>/;
                  $dt->id ($src_node->first_child->name);
                  my $code = $dt->first_child || $dt;
                  if ($src_node->first_child->child_nodes->length == 1 and
                      $src_node->first_child->first_child->node_type == $src_node->TEXT_NODE) {
                    my $text = $src_node->first_child->text_content;
                    if ($text =~ /^(.*->)(\S+)(.*)$/s) {
                      $code->manakai_append_text ($1);
                      my $strong = $doc->create_element ('strong');
                      $strong->id ("member-$2") unless $has_member->{$2}++;
                      $strong->text_content ($2);
                      $code->append_child ($strong);
                      $code->manakai_append_text ($3);
                    } elsif ($text =~ /^(.*)\b(new\s+\S+)(.*)$/s) {
                      $code->manakai_append_text ($1);
                      my $strong = $doc->create_element ('strong');
                      $strong->id ("member-new") unless $has_member->{new}++;
                      $strong->text_content ($2);
                      $code->append_child ($strong);
                      $code->manakai_append_text ($3);
                    } else {
                      $code->text_content ($text);
                    }
                  } else {
                    $code->append_child ($_)
                        for $src_node->first_child->child_nodes->to_list;
                  }
                  $dl->append_child ($dt);
                } else {
                  my $dt = $doc->create_element ('dt');
                  $dt->append_child ($_)
                      for process_inline_nodes
                              ($doc, $root_url,
                               $args{to_repo_url}, $args{to_module_url},
                               $src_node->child_nodes->to_list);
                  $dl->append_child ($dt);
                }
              } elsif ($ln eq 'dd') {
                if ($src_node->child_nodes->length == 1 and
                    $src_node->first_child->node_type == $src_node->TEXT_NODE and
                    not $src_node->first_child->data =~ /\S/) {
                  #
                } else {
                  my $dd = $doc->create_element ('dd');
                  for ($src_node->child_nodes->to_list) {
                    if ($_->node_type == $_->ELEMENT_NODE and
                        $_->local_name eq 'p') {
                      my $p = $doc->create_element ('p');
                      $p->append_child ($_)
                          for process_inline_nodes
                                  ($doc, $root_url,
                                   $args{to_repo_url}, $args{to_module_url},
                                   $_->child_nodes->to_list);
                      $dd->append_child ($p);
                    } elsif ($_->node_type == $_->ELEMENT_NODE and
                             $_->local_name eq 'pre') {
                      my $pre = $doc->create_element ('pre');
                      my $code = $pre->append_child ($doc->create_element ('code'));
                      $code->append_child ($_) for $_->child_nodes->to_list;
                      $dd->append_child ($pre);
                    } else {
                      $dd->append_child ($_);
                    }
                  }
                  $dl->append_child ($dd);
                  $has_dd = 1;
                }
              } else {
                $dl->append_child ($src_node);
              }
            } else {
              $dl->append_child ($src_node);
            }
          }
          if ($has_dd) {
            $last_section->append_child ($dl);
          } else {
            my $ul = $doc->create_element ('ul');
            for ($dl->child_nodes->to_list) {
              if ($_->node_type == $_->ELEMENT_NODE and
                  $_->local_name eq 'dt') {
                my $li = $doc->create_element ('li');
                $li->append_child ($_) for $_->child_nodes->to_list;
                $ul->append_child ($li);
              } else {
                $ul->append_child ($_);
              }
            }
            $last_section->append_child ($ul);
          }
        } elsif ($ln eq 'pre') {
          my $pre = $doc->create_element ('pre');
          my $code = $pre->append_child ($doc->create_element ('code'));
          $code->append_child ($_) for $source_node->child_nodes->to_list;
          $last_section->append_child ($pre);
        } elsif ($ln eq 'a') {
          $last_section->append_child ($_) for $source_node->child_nodes->to_list;
        } else {
          $last_section->append_child ($source_node);
        }
      } elsif ($nt == $source_node->TEXT_NODE) {
        $last_section->append_child ($source_node);
      }
    }
  
    my $name = $body->get_elements_by_tag_name ('section')->[0];
    if (defined $name and
        $name->id eq 'NAME' and
        $name->children->length == 3 and
        $name->children->[0]->local_name eq 'h1' and
        $name->children->[1]->local_name eq 'p' and
        $name->children->[2]->local_name eq 'p') {
      my $h = $doc->create_element ('hgroup');
      $h->inner_html (q{<h1></h1><h2></h2>});
      $h->first_child->append_child ($_)
          for $name->children->[1]->child_nodes->to_list;
      $h->last_child->append_child ($_)
          for $name->children->[2]->child_nodes->to_list;
      $body->replace_child ($h, $name);
    }
  
    $write->($body, $root_url => $html_path, %args);
  } # pod2html
  
  sub text2html ($$$%) {
    my ($text => $html_path, $write, %args) = @_;
    my $n = 0;
    $n++ while $args{module_name} =~ /::/g;
    $n++ if $html_path =~ m{/index.html$};
    my $root_url = join '/', (('..') x (1 + $n));
    my $doc = new Web::DOM::Document;
    $doc->manakai_is_html (1);
    my $pre = $doc->create_element ('pre');
    $pre->text_content ($text);
    
    $write->($pre, $root_url => $html_path, %args);
  } # text2html
  
  1;
  
  =head1 LICENSE
  
  Copyright 2014-2022 Wakaba <wakaba@suikawiki.org>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
_POD2HTML_COMMON

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

use strict;
use warnings;
use Path::Tiny;
use Web::DOM::Document;
use Web::Encoding;

require "_pod2html_common.pl";
sub pod2html ($$$%);
sub text2html ($$$%);

sub main (@) {
  my ($title, $in_file_name) = @_;
  die "Usage: $0 title pod-file\n" unless defined $in_file_name;

  $title = Web::Encoding::decode_web_utf8 ($title);
  
  my $pod_path = path ($in_file_name);
  my $module_name = '';
  my $html_path = '';

  $module_name = $in_file_name;
  $module_name =~ s{/}{::}g;
  $module_name =~ s{^.*?::}{};

  my $to_repo_url = sub {
    my ($root_url, $repo) = @_;
    return "$root_url/$repo";
  };
  my $to_module_url = sub {
    my ($root_url, $module) = @_;
    $module =~ s{::}{/}g;
    return "$root_url/$module";
  };
  
  my $write = sub {
    my ($node, $root_url => $html_path, %args) = @_;

    binmode STDOUT, qw(:encoding(utf-8));
    printf q{
      <!DOCTYPE HTML>
      <html lang=en>
        <meta charset=utf-8>
        <title>%s</title>
        <link rel=stylesheet href="https://manakai.github.io/css/pod.css">
        <meta name=viewport content="width=device-width">

        <h1><a href="%s" rel=top>%s</a></h1>

        %s

        <sw-ads normal></sw-ads>
        <script src="https://manakai.github.io/js/global.js" async></script>

        <footer>
          <ul>
          <li><a href="%s" rel=top>Top</a>
          </ul>
          <sw-ads-notes></sw-ads-notes>
        </footer>
    },
        $title,
        $to_repo_url->($root_url, ""),
        $title,
        $node->inner_html,
        $to_repo_url->($root_url, "");
  };
  
  pod2html $pod_path->slurp_utf8 => $html_path, $write,
      to_repo_url => $to_repo_url,
      to_module_url => $to_module_url,
      module_name => $module_name,
      repo => undef,
      source_path => undef;
} # main

our $NoRun;
main (@ARGV) unless $NoRun;

=head1 LICENSE

Copyright 2014-2022 Wakaba <wakaba@suikawiki.org>.

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=cut
